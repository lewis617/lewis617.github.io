{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/silian.txt","path":"silian.txt","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/jquery-disqus-proxy.css","path":"css/jquery-disqus-proxy.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/jquery-disqus-proxy.js","path":"js/jquery-disqus-proxy.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/101.jpg","path":"css/images/101.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/102.jpg","path":"css/images/102.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/103.jpg","path":"css/images/103.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/104.jpg","path":"css/images/104.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/105.jpg","path":"css/images/105.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/106.jpg","path":"css/images/106.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/107.jpg","path":"css/images/107.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/108.jpg","path":"css/images/108.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/112.jpg","path":"css/images/112.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/113.jpg","path":"css/images/113.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/114.jpg","path":"css/images/114.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/115.jpg","path":"css/images/115.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/116.jpg","path":"css/images/116.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/120.jpg","path":"css/images/120.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/121.jpg","path":"css/images/121.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/122.jpg","path":"css/images/122.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/123.jpg","path":"css/images/123.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/124.jpg","path":"css/images/124.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/125.jpg","path":"css/images/125.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/126.jpg","path":"css/images/126.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/127.jpg","path":"css/images/127.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/128.jpg","path":"css/images/128.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/129.jpg","path":"css/images/129.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/130.jpg","path":"css/images/130.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/131.jpg","path":"css/images/131.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/132.jpg","path":"css/images/132.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/136.jpg","path":"css/images/136.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/135.jpg","path":"css/images/135.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/137.jpg","path":"css/images/137.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/138.jpg","path":"css/images/138.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/140.jpg","path":"css/images/140.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/141.gif","path":"css/images/141.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/148.jpg","path":"css/images/148.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/149.jpg","path":"css/images/149.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/151.gif","path":"css/images/151.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/152.jpg","path":"css/images/152.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/153.jpg","path":"css/images/153.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/157.jpg","path":"css/images/157.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/164.gif","path":"css/images/164.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/163.jpg","path":"css/images/163.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/166.jpg","path":"css/images/166.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/167.jpg","path":"css/images/167.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/169.jpg","path":"css/images/169.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/17.jpg","path":"css/images/17.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/170.jpg","path":"css/images/170.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/172.jpg","path":"css/images/172.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/173.jpg","path":"css/images/173.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/174.jpg","path":"css/images/174.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/175.jpg","path":"css/images/175.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/176.jpg","path":"css/images/176.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/177.jpg","path":"css/images/177.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/178.jpg","path":"css/images/178.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/179.jpg","path":"css/images/179.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/18.jpg","path":"css/images/18.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/180.jpg","path":"css/images/180.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/181.jpg","path":"css/images/181.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/182.jpg","path":"css/images/182.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/183.jpg","path":"css/images/183.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/184.jpg","path":"css/images/184.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/185.jpg","path":"css/images/185.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/187.jpg","path":"css/images/187.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/188.jpg","path":"css/images/188.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/189.jpg","path":"css/images/189.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/190.jpg","path":"css/images/190.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/191.jpg","path":"css/images/191.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/192.jpg","path":"css/images/192.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/193.jpg","path":"css/images/193.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/194.jpg","path":"css/images/194.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/195.jpg","path":"css/images/195.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/196.jpg","path":"css/images/196.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/197.gif","path":"css/images/197.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/199.jpg","path":"css/images/199.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/2.jpg","path":"css/images/2.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/200.jpg","path":"css/images/200.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/201.jpg","path":"css/images/201.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/202.jpg","path":"css/images/202.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/203.jpg","path":"css/images/203.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/204.jpg","path":"css/images/204.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/205.jpg","path":"css/images/205.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/206.jpg","path":"css/images/206.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/207.jpg","path":"css/images/207.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/208.jpg","path":"css/images/208.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/209.jpg","path":"css/images/209.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/21.jpg","path":"css/images/21.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/210.jpg","path":"css/images/210.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/212.jpg","path":"css/images/212.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/213.jpg","path":"css/images/213.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/214.jpg","path":"css/images/214.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/215.jpg","path":"css/images/215.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/216.jpg","path":"css/images/216.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/218.jpg","path":"css/images/218.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/219.jpg","path":"css/images/219.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/22.jpg","path":"css/images/22.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/220.jpg","path":"css/images/220.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/221.jpg","path":"css/images/221.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/223.jpg","path":"css/images/223.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/224.jpg","path":"css/images/224.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/226.jpg","path":"css/images/226.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/225.jpg","path":"css/images/225.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/227.jpg","path":"css/images/227.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/228.jpg","path":"css/images/228.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/229.jpg","path":"css/images/229.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/23.jpg","path":"css/images/23.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/230.jpg","path":"css/images/230.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/231.jpg","path":"css/images/231.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/232.jpg","path":"css/images/232.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/233.jpg","path":"css/images/233.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/235.jpg","path":"css/images/235.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/236.jpg","path":"css/images/236.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/237.jpg","path":"css/images/237.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/238.jpg","path":"css/images/238.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/239.jpg","path":"css/images/239.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/24.jpg","path":"css/images/24.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/240.jpg","path":"css/images/240.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/25.jpg","path":"css/images/25.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/27.jpg","path":"css/images/27.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/28.jpg","path":"css/images/28.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/29.jpg","path":"css/images/29.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/30.jpg","path":"css/images/30.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/34.jpg","path":"css/images/34.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/35.jpg","path":"css/images/35.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/37.jpg","path":"css/images/37.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/38.jpg","path":"css/images/38.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/4.jpg","path":"css/images/4.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/41.jpg","path":"css/images/41.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/42.jpg","path":"css/images/42.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/43.jpg","path":"css/images/43.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/47.jpg","path":"css/images/47.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/48.jpg","path":"css/images/48.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/49.jpg","path":"css/images/49.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/5.jpg","path":"css/images/5.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/51.jpg","path":"css/images/51.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/53.jpg","path":"css/images/53.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/55.jpg","path":"css/images/55.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/56.jpg","path":"css/images/56.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/57.jpg","path":"css/images/57.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/58.jpg","path":"css/images/58.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/59.jpg","path":"css/images/59.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/6.jpg","path":"css/images/6.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/60.jpg","path":"css/images/60.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/61.jpg","path":"css/images/61.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/62.jpg","path":"css/images/62.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/63.jpg","path":"css/images/63.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/66.jpg","path":"css/images/66.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/67.jpg","path":"css/images/67.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/68.jpg","path":"css/images/68.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/69.jpg","path":"css/images/69.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/7.jpg","path":"css/images/7.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/70.jpg","path":"css/images/70.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/71.jpg","path":"css/images/71.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/72.jpg","path":"css/images/72.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/73.jpg","path":"css/images/73.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/74.jpg","path":"css/images/74.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/75.jpg","path":"css/images/75.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/76.jpg","path":"css/images/76.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/77.jpg","path":"css/images/77.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/78.jpg","path":"css/images/78.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/79.jpg","path":"css/images/79.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/80.jpg","path":"css/images/80.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/81.jpg","path":"css/images/81.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/82.jpg","path":"css/images/82.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/83.jpg","path":"css/images/83.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/84.jpg","path":"css/images/84.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/85.jpg","path":"css/images/85.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/86.jpg","path":"css/images/86.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/87.jpg","path":"css/images/87.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/88.jpg","path":"css/images/88.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/89.jpg","path":"css/images/89.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/90.jpg","path":"css/images/90.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/91.jpg","path":"css/images/91.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/92.jpg","path":"css/images/92.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/93.jpg","path":"css/images/93.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/94.jpg","path":"css/images/94.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/95.jpg","path":"css/images/95.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/96.jpg","path":"css/images/96.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/98.jpg","path":"css/images/98.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/99.jpg","path":"css/images/99.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/favicon.ico","path":"css/images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/10.jpg","path":"css/images/10.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/100.jpg","path":"css/images/100.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/109.jpg","path":"css/images/109.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/11.jpg","path":"css/images/11.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/110.jpg","path":"css/images/110.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/111.jpg","path":"css/images/111.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/117.jpg","path":"css/images/117.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/118.jpg","path":"css/images/118.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/119.jpg","path":"css/images/119.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/12.jpg","path":"css/images/12.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/13.jpg","path":"css/images/13.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/133.jpg","path":"css/images/133.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/134.jpg","path":"css/images/134.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/139.jpg","path":"css/images/139.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/14.jpg","path":"css/images/14.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/142.jpg","path":"css/images/142.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/143.jpg","path":"css/images/143.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/144.jpg","path":"css/images/144.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/145.jpg","path":"css/images/145.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/147.gif","path":"css/images/147.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/15.jpg","path":"css/images/15.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/150.jpg","path":"css/images/150.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/155.jpg","path":"css/images/155.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/156.gif","path":"css/images/156.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/158.jpg","path":"css/images/158.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/159.jpg","path":"css/images/159.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/16.jpg","path":"css/images/16.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/160.jpg","path":"css/images/160.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/161.jpg","path":"css/images/161.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/162.jpg","path":"css/images/162.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/165.gif","path":"css/images/165.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/168.jpg","path":"css/images/168.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/171.jpg","path":"css/images/171.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/186.gif","path":"css/images/186.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/19.jpg","path":"css/images/19.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/198.gif","path":"css/images/198.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/20.jpg","path":"css/images/20.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/211.jpg","path":"css/images/211.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/217.jpg","path":"css/images/217.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/222.jpg","path":"css/images/222.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/234.jpg","path":"css/images/234.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/241.jpg","path":"css/images/241.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/242.jpg","path":"css/images/242.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/26.jpg","path":"css/images/26.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/31.jpg","path":"css/images/31.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/32.jpg","path":"css/images/32.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/33.jpg","path":"css/images/33.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/36.jpg","path":"css/images/36.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/39.jpg","path":"css/images/39.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/40.jpg","path":"css/images/40.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/44.jpg","path":"css/images/44.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/45.jpg","path":"css/images/45.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/46.jpg","path":"css/images/46.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/54.gif","path":"css/images/54.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/64.jpg","path":"css/images/64.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/65.jpg","path":"css/images/65.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/8.jpg","path":"css/images/8.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/9.jpg","path":"css/images/9.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/146.jpg","path":"css/images/146.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/50.jpg","path":"css/images/50.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/52.jpg","path":"css/images/52.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/154.jpg","path":"css/images/154.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/97.jpg","path":"css/images/97.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/1.gif","path":"css/images/1.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/0.gif","path":"css/images/0.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/3.gif","path":"css/images/3.gif","modified":1,"renderable":1}],"Cache":[{"_id":"source/silian.txt","hash":"0cfea00a659400bc925f2cb40b66067eaf4b803b","modified":1556697733658},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1555600714000},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1555600714000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1555600714000},{"_id":"themes/landscape/_config.yml","hash":"ba86af7c1ec6bf2a6f6335c003629ac3ccd98d68","modified":1555600714000},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1555600714000},{"_id":"source/about/index.md","hash":"45e6c7a37d2dfe420e4c1dc7298ba059c43a8164","modified":1556698230643},{"_id":"source/_posts/add-two-numbers.md","hash":"40377f19f8863ad79210088b4d923b1dcfcbedc8","modified":1556697728774},{"_id":"source/_posts/appium-android-get-started.md","hash":"7c8c335fd70e14663d9107065f6b5e69f04887ac","modified":1556697728841},{"_id":"source/_posts/assign-cookies.md","hash":"3ee446192055ff05d825f7c29c140e33bd9546ab","modified":1556697728972},{"_id":"source/_posts/appium-ios-get-started.md","hash":"7106e30ab93ea4c253b17e5b2ec1ba800ec5018d","modified":1556697728911},{"_id":"source/_posts/common-puppeteer-api-collection.md","hash":"564a2a170b94354e4e524e9b587ce83bd15212c2","modified":1556698229328},{"_id":"source/_posts/construcor-function-create-class.md","hash":"bad34f25fe413f511fa73184ad6087d54d75ad9e","modified":1556697729118},{"_id":"source/_posts/custom-jinja2-filter.md","hash":"82e1cdd377e5b0e92500b714ecde1285874df61a","modified":1556698229385},{"_id":"source/_posts/dfs-linked-list-in-json.md","hash":"9b2e99bb5723b553c6536f0efad436ff7c9827f2","modified":1556697729241},{"_id":"source/_posts/dictionary.md","hash":"bfb9ed64950c916ad3f5019a4edfd41a3c49447c","modified":1556697729314},{"_id":"source/_posts/e2e-testing-with-jest-and-puppeteer.md","hash":"aa2ed98aef30c1ae32fd3c8239ba1e76360addc8","modified":1556698229448},{"_id":"source/_posts/graph.md","hash":"0be455620d2dbdd9e54f0ac4505dcc89576a3cf9","modified":1556697729462},{"_id":"source/_posts/hash-table.md","hash":"3124e2045297774d78e534676bf596c7dedfa2a5","modified":1556697729545},{"_id":"source/_posts/house-robber.md","hash":"571cc29b0a55147bbfdd7a21e802afec57053c7c","modified":1556697729638},{"_id":"source/_posts/how-to-mock-http-in-e2e-testing.md","hash":"e3546e52bcd0f62ab6ca78cc03cc6a2997b567e0","modified":1556698229519},{"_id":"source/_posts/how-to-test-dom-manipulation.md","hash":"5cbde16789502bd3cf393a9e5a6f57cdfa103e8d","modified":1556697729792},{"_id":"source/_posts/immutable-data-structures-for-functional-js.md","hash":"6869cb624c7a2a0602869795caef51a4f15195d0","modified":1556698229609},{"_id":"source/_posts/js-infinite-loop-breaker.md","hash":"3a267812e42ef86a8b66a08ee3e095740b0f2fe8","modified":1556697729948},{"_id":"source/_posts/karma-start.md","hash":"6ab7f5f2723f1b9b0ab0b50adb2ac8c45d74d06e","modified":1556698229651},{"_id":"source/_posts/karma-test-demo.md","hash":"63ef4981a1edb900d35edc0ffedbcd991c9092a9","modified":1556698229662},{"_id":"source/_posts/linked-list.md","hash":"a133459f034ac5ddce88680ef2a3635b6e2b4001","modified":1556697730146},{"_id":"source/_posts/ml-component-recognition.md","hash":"795e69a44587129acef103db577ccea014a7fea4","modified":1556697730221},{"_id":"source/_posts/n-sum.md","hash":"d682665857087ee6ee2f2ef92ad97f81ecd8f6b3","modified":1556697730298},{"_id":"source/_posts/ng-complain-r2.md","hash":"30c9b070328d874050b019cde5005bcb4599c252","modified":1556698229724},{"_id":"source/_posts/ng-jq-toggle.md","hash":"ad9ac37d882bfcade9acb4a0219e070757b21aee","modified":1556698229739},{"_id":"source/_posts/ng-requirejs-module.md","hash":"43d7b6d5f50ee8646b3faabb368dee18ce0797ec","modified":1556698229752},{"_id":"source/_posts/ng2-attribute-directive.md","hash":"98c090201c6d6a719e7f92b3912e64275934f433","modified":1556698229765},{"_id":"source/_posts/ng2-component.md","hash":"d9c38c89d033dff5fe6fba3bf6e2dd5e10f1308d","modified":1556698229780},{"_id":"source/_posts/ng2-hello.md","hash":"72972a3d8436b699d3993b1a2a2f185cbfd315bc","modified":1556698229792},{"_id":"source/_posts/ng2-http-1.md","hash":"21b373dec00e7b34f9addaf0934135c291a13748","modified":1556698229807},{"_id":"source/_posts/ng2-http-2.md","hash":"17de6f08d7efa0e26aadf4b94671ebe48e111965","modified":1556698229825},{"_id":"source/_posts/ng2-pipe.md","hash":"4202ceffca220549365e43e3f334502ef747323e","modified":1556698229842},{"_id":"source/_posts/ng2-router-2.md","hash":"db7b929fdd18c5854cb0d3ec4fd35511408c6643","modified":1556698229882},{"_id":"source/_posts/ng2-router-1.md","hash":"d28c277414bb35a62cb0ba856daa29883adea185","modified":1556698229860},{"_id":"source/_posts/ng2-service.md","hash":"2bd6285fc1f3764c7c38782e6fcbde86da78d4fa","modified":1556698229899},{"_id":"source/_posts/ng2-structural-directive.md","hash":"4883d5a251759b3c3be725d991cb89b46bd289c3","modified":1556698229926},{"_id":"source/_posts/ng2-temlate.md","hash":"3a578d5f1b8233b0eb88c2aac048a47a6cd8df7f","modified":1556698229944},{"_id":"source/_posts/nginx-cross-domain.md","hash":"af7bb56a72bd864a650f35e328c2d9eed26c7163","modified":1556698229962},{"_id":"source/_posts/node-spider.md","hash":"53cddb3aade6b563ac5571f206dcdf8800fa980b","modified":1556697731417},{"_id":"source/_posts/preact-into-the-void-0.md","hash":"47a2a2b2bb2e73e602a2b690cec2ebd69a58ab98","modified":1556698230099},{"_id":"source/_posts/queue.md","hash":"18db6344dec9a29927f9eb1846443d3849f414be","modified":1556697731586},{"_id":"source/_posts/r2-array.md","hash":"9ba52dc91bf42217589be1eed629c1eaf5a64652","modified":1556698230135},{"_id":"source/_posts/r2-async.md","hash":"e14f55779c325e3c7ba3d74cf1aea4f059e218f8","modified":1556698230153},{"_id":"source/_posts/r2-book.md","hash":"85925cd5f4657b5b9117d8a8c917c48686acb000","modified":1556698230180},{"_id":"source/_posts/r2-counter.md","hash":"9b79824cf155c9842baeb6b5e0b844647b3ccb90","modified":1556698230197},{"_id":"source/_posts/r2-database.md","hash":"485298ce2d6415da4f9942131a1fce1e853e5abe","modified":1556698230217},{"_id":"source/_posts/r2-middleware.md","hash":"572fc677e6494f8135a8b90c10621e1dbd0b79b9","modified":1556698230237},{"_id":"source/_posts/r2-ssr.md","hash":"2b0faf7bdfb92ec13c6a4594847e85f1d03e2c45","modified":1556698230252},{"_id":"source/_posts/r2-state.md","hash":"3e2e7a99fe08c282244b17cc31b4dd7532e8d166","modified":1556698230271},{"_id":"source/_posts/r2-undo.md","hash":"c97efeff25247321f128498046d79351cda2fbb8","modified":1556698230289},{"_id":"source/_posts/react-reflux.md","hash":"e4935f8d9bc1070bcad010db13a04496f34581dd","modified":1556698230308},{"_id":"source/_posts/redux-amrc.md","hash":"13a7ebc1198275808ea968d96d17329f424e3b20","modified":1556698230321},{"_id":"source/_posts/render-react-components.md","hash":"3e8fde3db40fbff02cda82c816058b5783567ff2","modified":1556697732484},{"_id":"source/_posts/requirejs-bootstraop-modal.md","hash":"88bcc68e72b4bc6dd32658ca15fadddf84cbadaa","modified":1556698230365},{"_id":"source/_posts/requirejs-search.md","hash":"6dbf3aa5c0a911d54b635d9a0ef23e2c1b8f366f","modified":1556698230383},{"_id":"source/_posts/rjs-gulp-webpack.md","hash":"8677c6d23ed50d85fab6d0d80b50fd6a221088b7","modified":1556697732674},{"_id":"source/_posts/rxjs-redux-react-amazing-1.md","hash":"3db0b3543615534d275b445b2d20f01b8a5c21bd","modified":1556698230422},{"_id":"source/_posts/rxjs-redux-react-amazing-2.md","hash":"bcec5a55ae5ae0e9940f25d3b6a5996370d6258a","modified":1556698230454},{"_id":"source/_posts/set.md","hash":"b0e24dd22c2289a86c4d9aec4ed06369247881cb","modified":1556697732904},{"_id":"source/_posts/sort-and-search.md","hash":"a8bc1544f2c622bd605fbf8e0fe399c0e36f2b47","modified":1556697732989},{"_id":"source/_posts/stack.md","hash":"99102268b680ae8af3b4f48f4a7d3e4834ad6784","modified":1556697733088},{"_id":"source/_posts/start-jest.md","hash":"c89445dcbed7db786e58c965e923826683835e9f","modified":1556697733145},{"_id":"source/_posts/svg-path-playback.md","hash":"d47889537e4b10c1eba02f32f0d8bfc2846352de","modified":1556698230537},{"_id":"source/_posts/the-ethics-of-the-internet-of-things.md","hash":"132bb5dac0d2f6488b2ef63b7da07e6e6e8e546c","modified":1556698230575},{"_id":"source/_posts/tree.md","hash":"584b686dc939917117e459f6601b010ac2e66484","modified":1556697733414},{"_id":"source/_posts/typescript-angular2-secret-weapon.md","hash":"217a8f49a5604a58256bff879e5918bf83213614","modified":1556698230623},{"_id":"source/_posts/use-js-to-get-weibo-comments.md","hash":"889cc7f75ee35713db4d1dff485321a4b70b1b42","modified":1556698230635},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1555600714000},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1555600714000},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1555600714000},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1555600714000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1555600714000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1555600714000},{"_id":"themes/landscape/languages/pt.yml","hash":"46bd5f121f4704e2cd6c0950ec18b549f03bfe5c","modified":1555600714000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1555600714000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"e4287c156b146f49957b88a54ffe6d26bf2ebad4","modified":1555600714000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1555600714000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1555600714000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1555600714000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1555600714000},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1555600714000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1555600714000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1555600714000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1555600714000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"2f9906276334d2816da11ff13ef137b1fdce1504","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"b69e5e16b4f4ef8763411407bba98ff182ffa4b1","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/copyright.ejs","hash":"450db0657b6f5f49742fc85a7cecc748c7d659af","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/donate.ejs","hash":"31219d8497580f61d623c0497ef0baf2f7cc37b1","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"5412a6b929f30b99f880501b85669e2071893994","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"39ebd5de50693d94fb7737e28d0c020a6681ab62","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1555600714000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1555600714000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1555600714000},{"_id":"themes/landscape/layout/_widget/links.ejs","hash":"db3af389930a4b64c1223378fa94cddcfaee67a7","modified":1555600714000},{"_id":"themes/landscape/layout/_widget/notice.ejs","hash":"6a9fd44a9f25cde74a542e9f0acc29880ff55414","modified":1555600714000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1555600714000},{"_id":"themes/landscape/layout/_widget/series_posts.ejs","hash":"64d9a1c0452883121e0fa0b900d847ab9142e399","modified":1555600714000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1555600714000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1555600714000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1555600714000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"b4937264b6ac2e4ad46ff23e5f541c2e7fd3bcff","modified":1555600714000},{"_id":"themes/landscape/source/css/jquery-disqus-proxy.css","hash":"0883a52d9a7abdfdfc24548f6d0ee681508de6e0","modified":1555600714000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1555600714000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1555600714000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1555600714000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1555600714000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1555600714000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1555600714000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1555600714000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1555600714000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1555600714000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1555600714000},{"_id":"themes/landscape/source/js/jquery-disqus-proxy.js","hash":"d8675373cb2f1f6547410f9566efd4fd1b7d2510","modified":1555600714000},{"_id":"themes/landscape/source/js/script.js","hash":"16ff2f68f207ac1fc011a2eecaf3ac1c4a8d98b1","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1555600714000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1555600714000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1555600714000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"3047e728d560f1b7a31fe0997f13c566294e5b9c","modified":1555600714000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1555600714000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1555600714000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"b1da11e6fafb48d61f92507e71a97ad0a19d0cb1","modified":1555600714000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1555600714000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1555600714000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1555600714000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1555600714000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1555600714000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1555600714000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1555600714000},{"_id":"themes/landscape/source/css/images/101.jpg","hash":"3926cdf0e13237098ac2667f138a99244ad53c67","modified":1556698232373},{"_id":"themes/landscape/source/css/images/102.jpg","hash":"e446088a594ec3edd400acbc69328f0f443a3cab","modified":1556698232684},{"_id":"themes/landscape/source/css/images/103.jpg","hash":"33439779fc160084b62571330802fcb7a835d45c","modified":1556698232210},{"_id":"themes/landscape/source/css/images/104.jpg","hash":"a7f31985eced6527e11fd5314ec3964c530d9042","modified":1556698232962},{"_id":"themes/landscape/source/css/images/105.jpg","hash":"7f718fec5e8ac68caed2c8fa446cb3e3b236fce6","modified":1556698232672},{"_id":"themes/landscape/source/css/images/106.jpg","hash":"2118a2caecca3b16b0b8315d432a5b84aafc6521","modified":1556698233323},{"_id":"themes/landscape/source/css/images/107.jpg","hash":"5e31cf26d45d65b6b419603d2f3b55f5a71e1920","modified":1556698232574},{"_id":"themes/landscape/source/css/images/108.jpg","hash":"7fd2bd1300cb62b8e5f4d936562f3d3aeefe0c3a","modified":1556698233114},{"_id":"themes/landscape/source/css/images/112.jpg","hash":"b0689a28cfed02dac3d6816e3dbd2308cc5d54f7","modified":1556698233412},{"_id":"themes/landscape/source/css/images/113.jpg","hash":"b5e174c14841abcf20c20323ca3bd40cc406c492","modified":1556698233443},{"_id":"themes/landscape/source/css/images/114.jpg","hash":"7680bc89c985541de288b739d9544155299e5020","modified":1556698232295},{"_id":"themes/landscape/source/css/images/115.jpg","hash":"eab45e5efd4f2b8ae060ce86d7cf54061826b995","modified":1556698233584},{"_id":"themes/landscape/source/css/images/116.jpg","hash":"fb601fd132af7946e9d3541195110f64fa7302ca","modified":1556698232625},{"_id":"themes/landscape/source/css/images/120.jpg","hash":"f2555bbf97cefc7eefdd0654151343444c8976cc","modified":1556698233163},{"_id":"themes/landscape/source/css/images/121.jpg","hash":"1295d3bf7f1b4549c4ff2f03c9a34c0df7fb5d97","modified":1556698232989},{"_id":"themes/landscape/source/css/images/122.jpg","hash":"2acf58e96834d90e4b9205d3e9dfa7bd76ded5b4","modified":1556698233625},{"_id":"themes/landscape/source/css/images/123.jpg","hash":"80d3f4f45dceda42dc09fec11eaf688e2871854d","modified":1556698231791},{"_id":"themes/landscape/source/css/images/124.jpg","hash":"c3e4fa12b3492b39acb0b8fa129d61d1c7713de7","modified":1556698233342},{"_id":"themes/landscape/source/css/images/125.jpg","hash":"6011f5194013cd8211692df798f2f2d3216d9c3a","modified":1556698232997},{"_id":"themes/landscape/source/css/images/126.jpg","hash":"cea16f658ca424081b02e98e0514606aca871e94","modified":1556698232695},{"_id":"themes/landscape/source/css/images/127.jpg","hash":"ac0bfd52008697137b9fd2baff7d5e1745c9d215","modified":1556698233380},{"_id":"themes/landscape/source/css/images/128.jpg","hash":"8c754a4ae1e24c68834964c3eaa78723b71d3631","modified":1556698233926},{"_id":"themes/landscape/source/css/images/129.jpg","hash":"aad90649a6eaa1c25a4b98bffa143860d58b5b01","modified":1556698232397},{"_id":"themes/landscape/source/css/images/130.jpg","hash":"314900ed65a7b73761fcf0ff938c0aaa984b7d35","modified":1556698232070},{"_id":"themes/landscape/source/css/images/131.jpg","hash":"d31a115f5faf3d8e5fd830481891ebbbc9e7d7cf","modified":1556698233019},{"_id":"themes/landscape/source/css/images/132.jpg","hash":"747edb01faf864f21c39613636b776ac15f65945","modified":1556698233380},{"_id":"themes/landscape/source/css/images/136.jpg","hash":"d78b8c545634901d68a7e210b5f5f30dab27a6fa","modified":1556698232818},{"_id":"themes/landscape/source/css/images/135.jpg","hash":"a021c83484e69cce0e3f180bbb288807e95ef7c8","modified":1556698233899},{"_id":"themes/landscape/source/css/images/137.jpg","hash":"9f2f2e347341ab8c1aca43789305e0e18b13de43","modified":1556698233579},{"_id":"themes/landscape/source/css/images/138.jpg","hash":"3a56634ecbf3fcf6b05bec9a98b2cff94830c4c6","modified":1556698233528},{"_id":"themes/landscape/source/css/images/140.jpg","hash":"6a81f7759f9f20b8801d86361a2733a9d343c8a0","modified":1556698231822},{"_id":"themes/landscape/source/css/images/141.gif","hash":"a1b88de8945361d4d9185048e9c3a5c99221bd3d","modified":1556698232844},{"_id":"themes/landscape/source/css/images/148.jpg","hash":"4db72cd6839a0d88865d1d0f269ffbb54b40b881","modified":1556698233438},{"_id":"themes/landscape/source/css/images/149.jpg","hash":"9edebaeebd2d28ac6fb3cc535bc96ff1c6ff8c47","modified":1556698233970},{"_id":"themes/landscape/source/css/images/151.gif","hash":"a0dcef304f9abc85262a3cae924e5a4db8d30458","modified":1556698233163},{"_id":"themes/landscape/source/css/images/152.jpg","hash":"8cf0c9cae8bf0fefc7120bb57086d7788ee7ffce","modified":1556698233120},{"_id":"themes/landscape/source/css/images/153.jpg","hash":"d7dda98ffac7113729659fe2c158b74851d72584","modified":1556698233627},{"_id":"themes/landscape/source/css/images/157.jpg","hash":"6a81f7759f9f20b8801d86361a2733a9d343c8a0","modified":1556698232270},{"_id":"themes/landscape/source/css/images/164.gif","hash":"7c1153ae9fa45b6e48baa3b006b0773b27ea8a68","modified":1556698232645},{"_id":"themes/landscape/source/css/images/163.jpg","hash":"5792987016a6a41550660e5f5f86643478a82346","modified":1556698234346},{"_id":"themes/landscape/source/css/images/166.jpg","hash":"4dba4b3a3fb5d2350b06eda4b7d00a7e7d9b9c6d","modified":1556698232892},{"_id":"themes/landscape/source/css/images/167.jpg","hash":"719d96b1a100eeef0ecaf3a25fe3c94adb50b414","modified":1556698232647},{"_id":"themes/landscape/source/css/images/169.jpg","hash":"e9bcb67d78e0ccebf08b6c78afeb26b0faa76f62","modified":1556698233783},{"_id":"themes/landscape/source/css/images/17.jpg","hash":"a2040a4b0c68b37599742811b1efa0d4813be63c","modified":1556698231469},{"_id":"themes/landscape/source/css/images/170.jpg","hash":"98b469f0919e6ca5e4f6c1b82eb0922fe2782626","modified":1556698233956},{"_id":"themes/landscape/source/css/images/172.jpg","hash":"d22ca1ec600305c749587a6f41606e78827c6798","modified":1556698233249},{"_id":"themes/landscape/source/css/images/173.jpg","hash":"f116951f3f622b4d1d110f1e80db7ddbfac9b05e","modified":1556698234457},{"_id":"themes/landscape/source/css/images/174.jpg","hash":"51761e337cfba067fdfd663d352abbf9a9e44ef0","modified":1556698234198},{"_id":"themes/landscape/source/css/images/175.jpg","hash":"0cb4242c76784d21247c2e0e374275d828fa7418","modified":1556698232759},{"_id":"themes/landscape/source/css/images/176.jpg","hash":"73665448fceceebc9d3093d5509e2f1763f8d370","modified":1556698234451},{"_id":"themes/landscape/source/css/images/177.jpg","hash":"4dd116ae9b1ce072e6c18631d92cc1b2036cb44e","modified":1556698234042},{"_id":"themes/landscape/source/css/images/178.jpg","hash":"fa93f985f6da897480065acf9c7126aa1647b016","modified":1556698233828},{"_id":"themes/landscape/source/css/images/179.jpg","hash":"f74b04fdc2c1a305fc79412961e32888ac1405bb","modified":1556698234198},{"_id":"themes/landscape/source/css/images/18.jpg","hash":"dce4b51f31487810fe9371d974731e1a8c56b79a","modified":1556698231192},{"_id":"themes/landscape/source/css/images/180.jpg","hash":"066d68b4bed841f4bfbc2da344dc5aac49f0d5eb","modified":1556698233086},{"_id":"themes/landscape/source/css/images/181.jpg","hash":"f176aab0535f01bf1fe6c7202fe7cbd5f64dac25","modified":1556698233086},{"_id":"themes/landscape/source/css/images/182.jpg","hash":"5c627b177f5479099ae7a92809870f45cc26e66f","modified":1556698234611},{"_id":"themes/landscape/source/css/images/183.jpg","hash":"75dc162caa2a57222d2ff821d0ce6b04601a3ca9","modified":1556698232775},{"_id":"themes/landscape/source/css/images/184.jpg","hash":"b7f22f44bd26a7a65e67f4f7481d85bad15c11de","modified":1556698234794},{"_id":"themes/landscape/source/css/images/185.jpg","hash":"1c89bcf2b5cadb5a733d43931ded8b03d342f041","modified":1556698233943},{"_id":"themes/landscape/source/css/images/187.jpg","hash":"7ab816ffb89b4ba08a5da451a78e7d4c3cc7ccff","modified":1556698231979},{"_id":"themes/landscape/source/css/images/188.jpg","hash":"d4f5e93dbbd9ad548c54c99e564203afb8612bb8","modified":1556698233166},{"_id":"themes/landscape/source/css/images/189.jpg","hash":"1540917ce96c6960c2d876b0b80e2d4396f2e655","modified":1556698232807},{"_id":"themes/landscape/source/css/images/190.jpg","hash":"6d2b43ab1af19702d0be869000da63071fdd259e","modified":1556698232649},{"_id":"themes/landscape/source/css/images/191.jpg","hash":"0081b235669ac78a46795ec63ddf710a827cfa6e","modified":1556698233252},{"_id":"themes/landscape/source/css/images/192.jpg","hash":"61de1be9bdd6376c1a69582eb69f9c11f386b7b6","modified":1556698231842},{"_id":"themes/landscape/source/css/images/193.jpg","hash":"85520fba01b9133e4e6b072b59c4356fe0c39026","modified":1556698233564},{"_id":"themes/landscape/source/css/images/194.jpg","hash":"d7fed4c34e992076fc12d1cd28d8e1e14e8d4938","modified":1556698231842},{"_id":"themes/landscape/source/css/images/195.jpg","hash":"d7fed4c34e992076fc12d1cd28d8e1e14e8d4938","modified":1556698231569},{"_id":"themes/landscape/source/css/images/196.jpg","hash":"2999f2667115d99980656a6daa6f10e2f3de8f99","modified":1556698233237},{"_id":"themes/landscape/source/css/images/197.gif","hash":"dfabd1da25920c84afa633d9c2d99962dd6132bd","modified":1556698232973},{"_id":"themes/landscape/source/css/images/199.jpg","hash":"d0d6d7bba1c41064b070ab60bf43c171be53278e","modified":1556698234184},{"_id":"themes/landscape/source/css/images/2.jpg","hash":"be37fe0d1ba22dfb8b2ffaebe7655b4d7bce35a4","modified":1556698231523},{"_id":"themes/landscape/source/css/images/200.jpg","hash":"44290eff66e05f3028bb1344c4b3e13e59997f74","modified":1556698234306},{"_id":"themes/landscape/source/css/images/201.jpg","hash":"7d82fc1afe7fe809cc8c4a7b1d09fe63049323f5","modified":1556698233561},{"_id":"themes/landscape/source/css/images/202.jpg","hash":"3aa5dbd663606c45fffac7479683abe33c7def72","modified":1556698233943},{"_id":"themes/landscape/source/css/images/203.jpg","hash":"b63b88b905acb3aba3fdd8af647c5e295295b743","modified":1556698233332},{"_id":"themes/landscape/source/css/images/204.jpg","hash":"5e3475a912f83d19056df644f1711c54035a78bd","modified":1556698234737},{"_id":"themes/landscape/source/css/images/205.jpg","hash":"3ede2ecc20a90d4e9e5145f60c90b37673d72325","modified":1556698234120},{"_id":"themes/landscape/source/css/images/206.jpg","hash":"70a4650edbe703ea25e7a8963d9fca54f38daef4","modified":1556698234492},{"_id":"themes/landscape/source/css/images/207.jpg","hash":"471c79ce3024a22d33fc60b4f01aa9f0a3697258","modified":1556698233755},{"_id":"themes/landscape/source/css/images/208.jpg","hash":"d49ec534de8b8c94ebb902cef74e07e2f2bb75dc","modified":1556698233927},{"_id":"themes/landscape/source/css/images/209.jpg","hash":"c19e5fe50e7f6b6ecbab7484f68d40296ab78792","modified":1556698233752},{"_id":"themes/landscape/source/css/images/21.jpg","hash":"5dd52df48bdfe596404b2568f1e705bf1ccef838","modified":1556698232926},{"_id":"themes/landscape/source/css/images/210.jpg","hash":"1228393937d08e8c4446d8d110942a5f42cbcf55","modified":1556698233729},{"_id":"themes/landscape/source/css/images/212.jpg","hash":"94f762712c2b8691e7860bb518d852755f6101fb","modified":1556698233924},{"_id":"themes/landscape/source/css/images/213.jpg","hash":"4cac318623cf318d76b6dd6d8df9fa8086c04ace","modified":1556698233930},{"_id":"themes/landscape/source/css/images/214.jpg","hash":"cb8292ff4fbf74ea0430784f883aae7a564a2ba0","modified":1556698234339},{"_id":"themes/landscape/source/css/images/215.jpg","hash":"840450c5cb1fec9f12d94dcfd7deaa777d6dd75b","modified":1556698234310},{"_id":"themes/landscape/source/css/images/216.jpg","hash":"0f2e34a309d28877ac47feb34f5c2af73cdffe55","modified":1556698233741},{"_id":"themes/landscape/source/css/images/218.jpg","hash":"366c54188548421854599c06dc958b10d27ac87e","modified":1556698233519},{"_id":"themes/landscape/source/css/images/219.jpg","hash":"3a80566f53c365fceed98607bac1bee164f80ea6","modified":1556698233932},{"_id":"themes/landscape/source/css/images/22.jpg","hash":"87ffaa9fb4620d75a00b4fd3489d7bc37a13751e","modified":1556698231178},{"_id":"themes/landscape/source/css/images/220.jpg","hash":"85f87174a3a86792c7354b1a2fa1b48c7972f132","modified":1556698234246},{"_id":"themes/landscape/source/css/images/221.jpg","hash":"3dcaf724e9de439c33d54d15e81755c964354d7f","modified":1556698233741},{"_id":"themes/landscape/source/css/images/223.jpg","hash":"3c5b9c30a52274f696d86fad9f1f1bbd5a546f73","modified":1556698233880},{"_id":"themes/landscape/source/css/images/224.jpg","hash":"252c0e8fa735db0815f92ca0ed32004b34ba45ab","modified":1556698233128},{"_id":"themes/landscape/source/css/images/226.jpg","hash":"499b3769543bed7901a2e4624ca0ff39736ed8dd","modified":1556698234125},{"_id":"themes/landscape/source/css/images/225.jpg","hash":"00a74e0664b484de559947fa37d1c4edd0879939","modified":1556698233922},{"_id":"themes/landscape/source/css/images/227.jpg","hash":"ba44db6859da411fad51ae3043ca427a1de45f62","modified":1556698234428},{"_id":"themes/landscape/source/css/images/228.jpg","hash":"fb554a943fee93cb37c51f2cc3097e49fbb1a7b6","modified":1556698233089},{"_id":"themes/landscape/source/css/images/229.jpg","hash":"a3b28d4922f904570898dec15dc367f0b3da9363","modified":1556698234034},{"_id":"themes/landscape/source/css/images/23.jpg","hash":"3ce17a00c5edadb0a4f8fbd69a315a8d96abd1da","modified":1556698231494},{"_id":"themes/landscape/source/css/images/230.jpg","hash":"f6cdeb80d76e978eab16a32099f8936c832ab075","modified":1556698234591},{"_id":"themes/landscape/source/css/images/231.jpg","hash":"0bbcb9531f36d5f347d23e24181b16c9bc72d192","modified":1556698234499},{"_id":"themes/landscape/source/css/images/232.jpg","hash":"63b7d4cdea0a02a7a3658144edcaa4846ff5c011","modified":1556698234451},{"_id":"themes/landscape/source/css/images/233.jpg","hash":"83ddb54b989291a35dc5984dee73a66a453862ad","modified":1556698234350},{"_id":"themes/landscape/source/css/images/235.jpg","hash":"2d5172a6bfe2275222cfd2f9eb0f106b4172a48a","modified":1556698233261},{"_id":"themes/landscape/source/css/images/236.jpg","hash":"09c7b7cd7d609bb893ef271d0d3a98b11fba3eb6","modified":1556698233775},{"_id":"themes/landscape/source/css/images/237.jpg","hash":"3d5d93beb8c1755a27f9705ba44b4caec927dc2e","modified":1556698232963},{"_id":"themes/landscape/source/css/images/238.jpg","hash":"d6411e4f417778542bebd1dfb60b9f96376d2484","modified":1556698233822},{"_id":"themes/landscape/source/css/images/239.jpg","hash":"df7a5e795b3711b913969778c8e0f6785bed2212","modified":1556698233054},{"_id":"themes/landscape/source/css/images/24.jpg","hash":"0a59cb748fa5285606d2003536822b3861a2ec51","modified":1556698231564},{"_id":"themes/landscape/source/css/images/240.jpg","hash":"30d86128ae46340ebd0fdebf2e86c11a26de29ab","modified":1556698233882},{"_id":"themes/landscape/source/css/images/25.jpg","hash":"1259667c5714fc2ddf1a795de36cce35e99e7b3e","modified":1556698231514},{"_id":"themes/landscape/source/css/images/27.jpg","hash":"98cab9f508d84610ae8ed7360f31df1b4e2cce21","modified":1556698231195},{"_id":"themes/landscape/source/css/images/28.jpg","hash":"3579c1ab6e4e11544521fc1525c098bd28a251d9","modified":1556698231246},{"_id":"themes/landscape/source/css/images/29.jpg","hash":"653b07b8235decb5f5fc4ed326c2aa1ae0d698ec","modified":1556698231575},{"_id":"themes/landscape/source/css/images/30.jpg","hash":"aff777b8cc2469dd9ef1f144a15b9f9b7e3d84fe","modified":1556698233721},{"_id":"themes/landscape/source/css/images/34.jpg","hash":"760913fa0e6a815ef7a4912aceeb84c5f4474712","modified":1556698231208},{"_id":"themes/landscape/source/css/images/35.jpg","hash":"dadf0f0baecc91f1cd06e4afd3351af35c07d2e0","modified":1556698231262},{"_id":"themes/landscape/source/css/images/37.jpg","hash":"82bdd99c91401da704e9355bc663737a94f0227a","modified":1556698231270},{"_id":"themes/landscape/source/css/images/38.jpg","hash":"d8e49b3bf44d860057c1f4000d2753c04f1349b1","modified":1556698231588},{"_id":"themes/landscape/source/css/images/4.jpg","hash":"fdf9b844e4104b8fb4d1ea48285e2b1fdcdcefac","modified":1556698234010},{"_id":"themes/landscape/source/css/images/41.jpg","hash":"5da0f445ff8687eb9c46c35c24c946a72b44b906","modified":1556698231372},{"_id":"themes/landscape/source/css/images/42.jpg","hash":"ada6757d5a59858bd05ff4049cab4e2e154eccbd","modified":1556698231368},{"_id":"themes/landscape/source/css/images/43.jpg","hash":"9cbcbd5f0029ec5d85d14b6b025182a78bdce87b","modified":1556698231978},{"_id":"themes/landscape/source/css/images/47.jpg","hash":"2c585acad7ea643665dc65d1617fde97b15bbdd8","modified":1556698231976},{"_id":"themes/landscape/source/css/images/48.jpg","hash":"54dd5bfdc6c976ad9758100430c88b9395971f43","modified":1556698231996},{"_id":"themes/landscape/source/css/images/49.jpg","hash":"5055c321486308f173f4b710cb1f556028bf93ba","modified":1556698232706},{"_id":"themes/landscape/source/css/images/5.jpg","hash":"cf91fb822d64278025ad0792dfe244aac7dafcc7","modified":1556698230711},{"_id":"themes/landscape/source/css/images/51.jpg","hash":"928bcb5c7f18a9b3cd16556f32e7a9d76694d001","modified":1556698231617},{"_id":"themes/landscape/source/css/images/53.jpg","hash":"23556098d044b02255d58b98d6a6256fd56df643","modified":1556698232007},{"_id":"themes/landscape/source/css/images/55.jpg","hash":"4db72cd6839a0d88865d1d0f269ffbb54b40b881","modified":1556698232208},{"_id":"themes/landscape/source/css/images/56.jpg","hash":"a4b57fa9dc23cb05d9fd8d5607059548bb9db06f","modified":1556698231999},{"_id":"themes/landscape/source/css/images/57.jpg","hash":"520d8ed74791587e96ba5779ffc93f0e172c41b7","modified":1556698232659},{"_id":"themes/landscape/source/css/images/58.jpg","hash":"fc89505c3c448bb0737be7ee93cc58edc58bdac1","modified":1556698233018},{"_id":"themes/landscape/source/css/images/59.jpg","hash":"1a397ee6e0798758958c3151657167e5101d1d87","modified":1556698231973},{"_id":"themes/landscape/source/css/images/6.jpg","hash":"366c65b0472ce781e9e61454d841c488a50809f2","modified":1556698231150},{"_id":"themes/landscape/source/css/images/60.jpg","hash":"ae2f71d1d4cab05efd028b1c1e6283b60566638d","modified":1556698232976},{"_id":"themes/landscape/source/css/images/61.jpg","hash":"309ac133a336355eecc251f5740687ac5150e0cc","modified":1556698231685},{"_id":"themes/landscape/source/css/images/62.jpg","hash":"7dc45e14ceea671da540afea2dfd0c4d63f43cc7","modified":1556698232979},{"_id":"themes/landscape/source/css/images/63.jpg","hash":"7c019e81c6aade196885dd3f85398e47002387a2","modified":1556698232997},{"_id":"themes/landscape/source/css/images/66.jpg","hash":"e6b7ffeaebfdc697376c4571e795169170e0c298","modified":1556698233242},{"_id":"themes/landscape/source/css/images/67.jpg","hash":"4f9a7ac3e7f3ae01c82e56af0bb46b7914905525","modified":1556698232985},{"_id":"themes/landscape/source/css/images/68.jpg","hash":"4754bba4ab5e9b9a1b3d957d32535499196b0f9c","modified":1556698233716},{"_id":"themes/landscape/source/css/images/69.jpg","hash":"da5a889b2c0124c61edc9065474232caf805eb9e","modified":1556698232025},{"_id":"themes/landscape/source/css/images/7.jpg","hash":"193660ac9035f7f005f33df45e132aa4c2944669","modified":1556698230973},{"_id":"themes/landscape/source/css/images/70.jpg","hash":"5774f334d5a6a826da353068c44d469deaa3c69f","modified":1556698232981},{"_id":"themes/landscape/source/css/images/71.jpg","hash":"4754bba4ab5e9b9a1b3d957d32535499196b0f9c","modified":1556698233201},{"_id":"themes/landscape/source/css/images/72.jpg","hash":"68bea57fe6629cfb9b16b65310640e0ef81e3c92","modified":1556698232842},{"_id":"themes/landscape/source/css/images/73.jpg","hash":"95bae811851f0b080b69c20ea637d3303f3ee965","modified":1556698231989},{"_id":"themes/landscape/source/css/images/74.jpg","hash":"44263beb7611a84264faafe56f9f60ee11e60432","modified":1556698233260},{"_id":"themes/landscape/source/css/images/75.jpg","hash":"6b1c84cca3b16588d25b27c3ff68444f653b0033","modified":1556698232567},{"_id":"themes/landscape/source/css/images/76.jpg","hash":"6125dd6731d6dfcb1e485c2708a2c306dec783fe","modified":1556698233618},{"_id":"themes/landscape/source/css/images/77.jpg","hash":"54f0a125474454ba3c1207350567bd6322f6573e","modified":1556698233513},{"_id":"themes/landscape/source/css/images/78.jpg","hash":"d285419e924cd7556ecea7b614fda0f0ba6d12ce","modified":1556698232189},{"_id":"themes/landscape/source/css/images/79.jpg","hash":"f48462c0c9f96526eddaed229747770b667ad7c3","modified":1556698231700},{"_id":"themes/landscape/source/css/images/80.jpg","hash":"63da186d92ce1db4a58fb6e20ea4d2c08c8ff4bf","modified":1556698233629},{"_id":"themes/landscape/source/css/images/81.jpg","hash":"f63a36285284415c2b797afa3c9ff233eced4016","modified":1556698232644},{"_id":"themes/landscape/source/css/images/82.jpg","hash":"eb1c1d0d23efc8ea1a2356abea9dc315296c4a19","modified":1556698232348},{"_id":"themes/landscape/source/css/images/83.jpg","hash":"9210a940c9f4282476c3c5bb9d168d24108e8c62","modified":1556698232764},{"_id":"themes/landscape/source/css/images/84.jpg","hash":"e7a80289c55cf03987db684de9d225f776c7761b","modified":1556698233278},{"_id":"themes/landscape/source/css/images/85.jpg","hash":"aaef79534df4f556bed16a39b5a309f145eaa3d0","modified":1556698232986},{"_id":"themes/landscape/source/css/images/86.jpg","hash":"9d8ebd508af09bca9e8a7bee5d73c7b79ed5b798","modified":1556698231749},{"_id":"themes/landscape/source/css/images/87.jpg","hash":"140d742aa20885951f6b52fa5c13f4a21297b54e","modified":1556698231696},{"_id":"themes/landscape/source/css/images/88.jpg","hash":"b0355cd9e4e41a12a00a510acd2eea4155f5ef85","modified":1556698232639},{"_id":"themes/landscape/source/css/images/89.jpg","hash":"93f7a556b6d4ca61d787ef1fc823d511aee4fe93","modified":1556698232356},{"_id":"themes/landscape/source/css/images/90.jpg","hash":"c2e9fb7d877744ae4ea14c222a997d2e11584ac0","modified":1556698232432},{"_id":"themes/landscape/source/css/images/91.jpg","hash":"35aecbe28dd3546a6925d451143b4128b869a097","modified":1556698233122},{"_id":"themes/landscape/source/css/images/92.jpg","hash":"8fdb3fb08f76beb8f933bb0f2934db04c9975505","modified":1556698232012},{"_id":"themes/landscape/source/css/images/93.jpg","hash":"0456d1cc8a21df2d00abd634cc1b03dd6e0d0ab4","modified":1556698233362},{"_id":"themes/landscape/source/css/images/94.jpg","hash":"ed209f0df511e4ecffb162acbdc53ace5cab0e03","modified":1556698234115},{"_id":"themes/landscape/source/css/images/95.jpg","hash":"e85ae3ced837f7966363a72aa5b4cba0052866e1","modified":1556698231756},{"_id":"themes/landscape/source/css/images/96.jpg","hash":"0456d1cc8a21df2d00abd634cc1b03dd6e0d0ab4","modified":1556698232970},{"_id":"themes/landscape/source/css/images/98.jpg","hash":"4e35dff4da428f2e6e5242ce0b413cffbb9164e2","modified":1556698232323},{"_id":"themes/landscape/source/css/images/99.jpg","hash":"e3a0befc4a52119106edde4922ecdfff9852f78b","modified":1556698232615},{"_id":"themes/landscape/source/css/images/favicon.ico","hash":"2d24bb80a013575e7ca5420ca3dd54e6b3d0f05b","modified":1555600714000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1555600714000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1555600714000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1555600714000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1555600714000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1555600714000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1555600714000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1555600714000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1555600714000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1555600714000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1555600714000},{"_id":"themes/landscape/source/css/images/10.jpg","hash":"77200f62dba0f3f5e5eba86f9eccdaa582b3cc6d","modified":1556698231492},{"_id":"themes/landscape/source/css/images/100.jpg","hash":"17f2a7c71c4d65c3d6fee25d2292af1038aef302","modified":1556698231990},{"_id":"themes/landscape/source/css/images/109.jpg","hash":"523d87c58a7f919b5c0a6089a1801263de1bb3de","modified":1556698232584},{"_id":"themes/landscape/source/css/images/11.jpg","hash":"133fb4b2e6a7748c17e2496ae46c6c79f125bfad","modified":1556698233276},{"_id":"themes/landscape/source/css/images/110.jpg","hash":"c9203ccb001eeb382b16f7bb6e5b75676c18b7e8","modified":1556698232406},{"_id":"themes/landscape/source/css/images/111.jpg","hash":"84e5bf9ca049e33865ea35ea5b32f411d7319d2b","modified":1556698233431},{"_id":"themes/landscape/source/css/images/117.jpg","hash":"9ff84b054023c97b8c30cec9bca21e1792b332eb","modified":1556698232494},{"_id":"themes/landscape/source/css/images/118.jpg","hash":"6fd5ce2480bcc8d6e2ba0b70a8de83073bb8ea9b","modified":1556698232482},{"_id":"themes/landscape/source/css/images/119.jpg","hash":"638dbc233f820f13a8c0b141ef6d282c272ef77f","modified":1556698232947},{"_id":"themes/landscape/source/css/images/12.jpg","hash":"0f3ca46bf6b10d3f215dee66d44db6c9101ee67e","modified":1556698233013},{"_id":"themes/landscape/source/css/images/13.jpg","hash":"003571265ea84b2e170d1561a57c4df4896c4b27","modified":1556698233388},{"_id":"themes/landscape/source/css/images/133.jpg","hash":"489756e5a3a015127f8ae5378a12eb53b53c5853","modified":1556698234708},{"_id":"themes/landscape/source/css/images/134.jpg","hash":"452a7fa4d70527e341cc2a5d07a01eef665a7a51","modified":1556698232714},{"_id":"themes/landscape/source/css/images/139.jpg","hash":"7ac32e5bca86a3774590876cf6de752f075bb3a6","modified":1556698232264},{"_id":"themes/landscape/source/css/images/14.jpg","hash":"d4c7e3c5bc6157168fa38f1a2c0cb176f15242d8","modified":1556698231149},{"_id":"themes/landscape/source/css/images/142.jpg","hash":"d76f37c006a503721fd46d6911dee1e04f076d28","modified":1556698234186},{"_id":"themes/landscape/source/css/images/143.jpg","hash":"c5f208e4cc30d58318ba06222d5e8db53497fc56","modified":1556698234824},{"_id":"themes/landscape/source/css/images/144.jpg","hash":"b573f546d76a60c4a40316caa000aeba279b26fd","modified":1556698233885},{"_id":"themes/landscape/source/css/images/145.jpg","hash":"b573f546d76a60c4a40316caa000aeba279b26fd","modified":1556698234786},{"_id":"themes/landscape/source/css/images/147.gif","hash":"f650b9d44818827f1d36b804012fac112a23b5c8","modified":1556698234872},{"_id":"themes/landscape/source/css/images/15.jpg","hash":"fdb41da41e707911f6249eb1d365abf262e06557","modified":1556698231484},{"_id":"themes/landscape/source/css/images/150.jpg","hash":"da5d1b470b0171443afe8f9130fc691e27389fe3","modified":1556698234823},{"_id":"themes/landscape/source/css/images/155.jpg","hash":"3e2c489b00be175c1bb917fba977a78143e4d3b4","modified":1556698234016},{"_id":"themes/landscape/source/css/images/156.gif","hash":"f650b9d44818827f1d36b804012fac112a23b5c8","modified":1556698234639},{"_id":"themes/landscape/source/css/images/158.jpg","hash":"5f944bb42767ca4f46a79e10a1092f8bbff48560","modified":1556698234814},{"_id":"themes/landscape/source/css/images/159.jpg","hash":"a4c228f7a2d6376f8414ee43f64b4f5668ce60ac","modified":1556698233574},{"_id":"themes/landscape/source/css/images/16.jpg","hash":"2c673199b1a9cb4d3f34e5bf0db436cc4c5d89f9","modified":1556698231186},{"_id":"themes/landscape/source/css/images/160.jpg","hash":"091e2eae16b9d2fd459e55609868a1b540e992a1","modified":1556698233895},{"_id":"themes/landscape/source/css/images/161.jpg","hash":"d994df510f5371637580640fa04b6761b88ea0a3","modified":1556698235633},{"_id":"themes/landscape/source/css/images/162.jpg","hash":"2a53dd3f48b6bf3fedea2a78ff05b8ae8d7b6234","modified":1556698234014},{"_id":"themes/landscape/source/css/images/165.gif","hash":"71d92ffb5a48d6341d6b887337c515da0fa71138","modified":1556698234893},{"_id":"themes/landscape/source/css/images/168.jpg","hash":"f80042d9d54e5fde580e9be8bb028d3d11574d77","modified":1556698233483},{"_id":"themes/landscape/source/css/images/171.jpg","hash":"d66e2abf9bdcc4760df9c992812566986381bf34","modified":1556698234873},{"_id":"themes/landscape/source/css/images/186.gif","hash":"cc1990446c7e4e1d562db8483f50e8eb335bb591","modified":1556698234862},{"_id":"themes/landscape/source/css/images/19.jpg","hash":"0623874290b6071c36d5f91438c499d21b0e4fc4","modified":1556698231176},{"_id":"themes/landscape/source/css/images/198.gif","hash":"cc1990446c7e4e1d562db8483f50e8eb335bb591","modified":1556698233941},{"_id":"themes/landscape/source/css/images/20.jpg","hash":"31b38c5d0509564de90f244a2c13f40d32325e73","modified":1556698231169},{"_id":"themes/landscape/source/css/images/211.jpg","hash":"5a06f45b55d7351c2b76ff8fae70e1051c44dc8b","modified":1556698234117},{"_id":"themes/landscape/source/css/images/217.jpg","hash":"064b1fe731a44e67081dea6eb98fd993053443b0","modified":1556698233859},{"_id":"themes/landscape/source/css/images/222.jpg","hash":"ea66cb3eec05a6ba462e96bade8fd7aa463e760b","modified":1556698234835},{"_id":"themes/landscape/source/css/images/234.jpg","hash":"bcdf3dd186971962780e745df1134036a4a9445c","modified":1556698234900},{"_id":"themes/landscape/source/css/images/241.jpg","hash":"e9d000bf70abe74c8a02f915ceed4f88daa96ad5","modified":1556698233354},{"_id":"themes/landscape/source/css/images/242.jpg","hash":"e4630b39621208a3a2b033531624bdd16d4d1546","modified":1556698233139},{"_id":"themes/landscape/source/css/images/26.jpg","hash":"3a32f847df28580a2cb1d26a3f4c7d40bdec81dc","modified":1556698231265},{"_id":"themes/landscape/source/css/images/31.jpg","hash":"5dfec656882e033017b79da0321fd8704c976af9","modified":1556698231558},{"_id":"themes/landscape/source/css/images/32.jpg","hash":"d39c1f01823adaa9fd13d04e37df76d261845262","modified":1556698231277},{"_id":"themes/landscape/source/css/images/33.jpg","hash":"269c04e8b6704d9b334d1ab582c977c580f5d8a0","modified":1556698231504},{"_id":"themes/landscape/source/css/images/36.jpg","hash":"1692dfee85aae29507c3241e44ae30e4b0efb915","modified":1556698231845},{"_id":"themes/landscape/source/css/images/39.jpg","hash":"e88c6ab0bb95c1aea1eff193b7dccb1e382257c3","modified":1556698234079},{"_id":"themes/landscape/source/css/images/40.jpg","hash":"86d8ad909b5dd6f74adc711f13232735350f27a5","modified":1556698231955},{"_id":"themes/landscape/source/css/images/44.jpg","hash":"2b26b959f4abdae43ff687891a06825d36879332","modified":1556698231377},{"_id":"themes/landscape/source/css/images/45.jpg","hash":"ad3264cde955ff90bf68b3e6a9676228db718068","modified":1556698231588},{"_id":"themes/landscape/source/css/images/46.jpg","hash":"84c47a40ccf3454a9af502e39799dc2aba290bf9","modified":1556698233865},{"_id":"themes/landscape/source/css/images/54.gif","hash":"f604fcf6be5740cf20a57958220b8ecc2eaa6224","modified":1556698233922},{"_id":"themes/landscape/source/css/images/64.jpg","hash":"e2a5fa9b8df639ada0129d5bf77025c3aa07fbbd","modified":1556698234906},{"_id":"themes/landscape/source/css/images/65.jpg","hash":"e2a5fa9b8df639ada0129d5bf77025c3aa07fbbd","modified":1556698232366},{"_id":"themes/landscape/source/css/images/8.jpg","hash":"5351682d35bd86b0a88d585373a4213f645c2286","modified":1556698231163},{"_id":"themes/landscape/source/css/images/9.jpg","hash":"b0a7f8411c9f1927aa4f6777258f46263880cabc","modified":1556698232111},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1555600714000},{"_id":"themes/landscape/source/css/images/146.jpg","hash":"8c083ccb4b159e4d1f416a726201bbc2fc74c1ea","modified":1556698232750},{"_id":"themes/landscape/source/css/images/50.jpg","hash":"4127e09dd86c370aabb56a3554e276f2ff04b2eb","modified":1556698234732},{"_id":"themes/landscape/source/css/images/52.jpg","hash":"6317475ab3ae4cb30ae343e24ba856b74cefa47e","modified":1556698232642},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"03303edc26dddb441b20732ec9f5753f26f5c0b2","modified":1555600714000},{"_id":"themes/landscape/source/css/images/154.jpg","hash":"59f35e8d93f338c3d9c7425b7e5443dc37a181e4","modified":1556698234919},{"_id":"themes/landscape/source/css/images/97.jpg","hash":"71d97fd57246974d4533ef39f9036367431eba69","modified":1556698233206},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1555600714000},{"_id":"themes/landscape/source/css/images/1.gif","hash":"0aedd787dec3bba4380de515d8e7d96f83385fe6","modified":1556698234175},{"_id":"themes/landscape/source/css/images/0.gif","hash":"cb584c92f66a069bb7805b74d152d4f87ecb7c2d","modified":1556698234811},{"_id":"themes/landscape/source/css/images/3.gif","hash":"cb584c92f66a069bb7805b74d152d4f87ecb7c2d","modified":1556698234727}],"Category":[],"Data":[],"Page":[{"title":"关于我","date":"2017-09-30T18:14:25.000Z","_content":"\n<img src=\"/css/images/242.jpg\" width = \"300\" alt=\"\" align=center style=\"border-radius:50%;\"/>\n\n刘一奇，90后程序员、吉他手、《React 与 Redux 开发实例精解》作者，先后在中科院计算所、360网络安全研究院学习工作，现就职于阿里巴巴，担任资深前端工程师。业余喜欢写博客、玩乐器、烧菜、练双节棍。\n\n邮箱：[lewis617@163.com](mailto:lewis617@163.com)\n\n博客：<http://www.liuyiqi.cn>\n\nGitHub：<https://github.com/lewis617>\n\n书籍著作：<http://www.liuyiqi.cn/2016/11/20/r2-book>\n\n演奏录音：<http://i.xiami.com/liuyiqi>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"//music.163.com/outchain/player?type=1&id=38248979&auto=0&height=430\"></iframe>\n\n阿里18周年年会演出视频：http://www.miaopai.com/show/uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P~JWQ__.htm\n\n<video src=\"https://gslb.miaopai.com/stream/uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P~JWQ__.mp4?ssig=5d6028719aca48456a32d02f2426cd7b&time_stamp=1539229377690&cookie_id=&vend=1&os=3&partner=1&platform=2&cookie_id=&refer=miaopai&scid=uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P%7EJWQ__\" controls poster=\"http://imgaliyuncdn.miaopai.com/stream/uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P~JWQ___la21_4.jpg\" preload=\"none\"></video>\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2017-10-01 02:14:25\n---\n\n<img src=\"/css/images/242.jpg\" width = \"300\" alt=\"\" align=center style=\"border-radius:50%;\"/>\n\n刘一奇，90后程序员、吉他手、《React 与 Redux 开发实例精解》作者，先后在中科院计算所、360网络安全研究院学习工作，现就职于阿里巴巴，担任资深前端工程师。业余喜欢写博客、玩乐器、烧菜、练双节棍。\n\n邮箱：[lewis617@163.com](mailto:lewis617@163.com)\n\n博客：<http://www.liuyiqi.cn>\n\nGitHub：<https://github.com/lewis617>\n\n书籍著作：<http://www.liuyiqi.cn/2016/11/20/r2-book>\n\n演奏录音：<http://i.xiami.com/liuyiqi>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"//music.163.com/outchain/player?type=1&id=38248979&auto=0&height=430\"></iframe>\n\n阿里18周年年会演出视频：http://www.miaopai.com/show/uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P~JWQ__.htm\n\n<video src=\"https://gslb.miaopai.com/stream/uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P~JWQ__.mp4?ssig=5d6028719aca48456a32d02f2426cd7b&time_stamp=1539229377690&cookie_id=&vend=1&os=3&partner=1&platform=2&cookie_id=&refer=miaopai&scid=uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P%7EJWQ__\" controls poster=\"http://imgaliyuncdn.miaopai.com/stream/uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P~JWQ___la21_4.jpg\" preload=\"none\"></video>\n","updated":"2019-05-01T08:10:30.643Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjv4xxvko0000tgyt0ktb6nod","content":"<p><img src=\"/css/images/242.jpg\" width=\"300\" alt=\"\" align=\"center\" style=\"border-radius:50%;\"></p>\n<p>刘一奇，90后程序员、吉他手、《React 与 Redux 开发实例精解》作者，先后在中科院计算所、360网络安全研究院学习工作，现就职于阿里巴巴，担任资深前端工程师。业余喜欢写博客、玩乐器、烧菜、练双节棍。</p>\n<p>邮箱：<a href=\"mailto:lewis617@163.com\" target=\"_blank\" rel=\"noopener\">lewis617@163.com</a></p>\n<p>博客：<a href=\"http://www.liuyiqi.cn\">http://www.liuyiqi.cn</a></p>\n<p>GitHub：<a href=\"https://github.com/lewis617\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617</a></p>\n<p>书籍著作：<a href=\"http://www.liuyiqi.cn/2016/11/20/r2-book\">http://www.liuyiqi.cn/2016/11/20/r2-book</a></p>\n<p>演奏录音：<a href=\"http://i.xiami.com/liuyiqi\" target=\"_blank\" rel=\"noopener\">http://i.xiami.com/liuyiqi</a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"450\" src=\"//music.163.com/outchain/player?type=1&id=38248979&auto=0&height=430\"></iframe>\n\n<p>阿里18周年年会演出视频：<a href=\"http://www.miaopai.com/show/uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P~JWQ__.htm\" target=\"_blank\" rel=\"noopener\">http://www.miaopai.com/show/uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P~JWQ__.htm</a></p>\n<video src=\"https://gslb.miaopai.com/stream/uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P~JWQ__.mp4?ssig=5d6028719aca48456a32d02f2426cd7b&time_stamp=1539229377690&cookie_id=&vend=1&os=3&partner=1&platform=2&cookie_id=&refer=miaopai&scid=uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P%7EJWQ__\" controls poster=\"http://imgaliyuncdn.miaopai.com/stream/uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P~JWQ___la21_4.jpg\" preload=\"none\"></video>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/css/images/242.jpg\" width=\"300\" alt=\"\" align=\"center\" style=\"border-radius:50%;\"></p>\n<p>刘一奇，90后程序员、吉他手、《React 与 Redux 开发实例精解》作者，先后在中科院计算所、360网络安全研究院学习工作，现就职于阿里巴巴，担任资深前端工程师。业余喜欢写博客、玩乐器、烧菜、练双节棍。</p>\n<p>邮箱：<a href=\"mailto:lewis617@163.com\" target=\"_blank\" rel=\"noopener\">lewis617@163.com</a></p>\n<p>博客：<a href=\"http://www.liuyiqi.cn\">http://www.liuyiqi.cn</a></p>\n<p>GitHub：<a href=\"https://github.com/lewis617\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617</a></p>\n<p>书籍著作：<a href=\"http://www.liuyiqi.cn/2016/11/20/r2-book\">http://www.liuyiqi.cn/2016/11/20/r2-book</a></p>\n<p>演奏录音：<a href=\"http://i.xiami.com/liuyiqi\" target=\"_blank\" rel=\"noopener\">http://i.xiami.com/liuyiqi</a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"450\" src=\"//music.163.com/outchain/player?type=1&id=38248979&auto=0&height=430\"></iframe>\n\n<p>阿里18周年年会演出视频：<a href=\"http://www.miaopai.com/show/uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P~JWQ__.htm\" target=\"_blank\" rel=\"noopener\">http://www.miaopai.com/show/uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P~JWQ__.htm</a></p>\n<video src=\"https://gslb.miaopai.com/stream/uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P~JWQ__.mp4?ssig=5d6028719aca48456a32d02f2426cd7b&time_stamp=1539229377690&cookie_id=&vend=1&os=3&partner=1&platform=2&cookie_id=&refer=miaopai&scid=uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P%7EJWQ__\" controls poster=\"http://imgaliyuncdn.miaopai.com/stream/uk8PpHEYyV3jaQgK3DyfLw2KiQwTdTGj5P~JWQ___la21_4.jpg\" preload=\"none\"></video>\n"}],"Post":[{"title":"JavaScript 版贪心算法题：分饼干","date":"2017-03-11T03:41:00.000Z","_content":"\n今天，我们要讲的是一道贪心算法题：分饼干。这道题也来自 LeetCode：\n\nhttps://leetcode.com/problems/assign-cookies\n\n本文将先介绍贪心算法的基础知识，然后使用贪心算法解决这个问题，所用的语言依然是 JavaScript。\n\n<!--more-->\n\n## 贪心算法简介\n\n贪心法，又称贪心算法、贪婪算法、或称贪婪法，是一种在**每一步选择中都采取在当前状态下最好或最优（即最有利）的选择**，从而希望导致结果是最好或最优的算法。简单来说，贪心算法的核心思想就是**今朝有酒今朝醉**，**活在当下**。举几个贪心算法的例子吧！\n\n1，一般人换零钱的时候会应用到贪心算法。把$36换散︰$20 > $10 > $5 > $1。先换大面额再换小面额！\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Greedy_algorithm_36_cents.svg/600px-Greedy_algorithm_36_cents.svg.png)\n\n2，但有时候贪心算法并不准确，比如上学时候，学渣使用贪心算法，坚持当下玩乐，但最后却没有好工作，当然前提是他也没有好爸爸。\n\n3，在编程中，贪心算法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。\n\n\n## 分饼干\n\n了解了贪心算法，我们来使用它解决“分饼干问题”。“分饼干问题”的题目是这样的：\n\n> 假设你是一个好爸爸（妈妈），你想给你的孩子们分一些饼干。每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。你的目标就是尽量让更多的孩子满意。\n\n下面我们再用断言表示一下需求。编写一个方法 `findContentChildren` ，它接受一个表示饼干的数组作为参数，返回能满足的孩子的最大数量。\n\n```js\n// 如果孩子的要求是 [1, 3, 5, 4, 2]，饼干是[1, 1]，最多能让1个孩子满足。\nexpect(findContentChildren([1, 3, 5, 4, 2], [1, 1])).toBe(1);\n// 如果孩子的要求是 [10, 9, 8, 7, 6]，饼干是[7, 6, 5]，最多能让2个孩子满足。\nexpect(findContentChildren([10, 9, 8, 7, 6], [7, 6, 5])).toBe(2);\n```\n\n题目分析完了，让我们使用贪心算法来解决它！贪心算法的核心思想是**坚持当下的最好选择**。那么在这道题中，**当下的最好选择**是什么？答案是，先将“较小的饼干”分给“对饼干尺寸要求最小”、“最好说话”的孩子，因为他们最容易满足，这样才能最大化满足孩子的数量。那么，整个分配流程就应该是这样的：\n\n- 首先，将孩子们按“对饼干尺寸要求最小”排序，将饼干按尺寸大小排序。\n- 然后，判断第一块饼干是否能满足第一个孩子，能就分给他，否则就换个稍微大点的，直到满足这个孩子。\n- 满足第一个孩子后，再对第二个、第三个以及后面的孩子重复上面一步，直到饼干分完为止。\n- 最后统计满足了多少个孩子，并返回结果。\n\n那么用 JavaScript 实现就是：\n\nLeetCode/455-assignCookies.js\n\n```js\n/**\n * @param {number[]} g\n * @param {number[]} s\n * @return {number}\n */\nvar findContentChildren = function (g, s) {\n  var sortFunc = function (a, b) {\n    return a - b;\n  };\n  g.sort(sortFunc);\n  s.sort(sortFunc);\n  var i = 0;\n  for (var j = 0; i < g.length && j < s.length; j++) {\n    if (g[i] <= s[j]) {\n      i++;\n    }\n  }\n  return i;\n};\n```\n至此，这道题就做完了！你理解贪心算法了吗？如果不理解，可以再做几道题练习一下：\n\nhttps://leetcode.com/tag/greedy/\n\n上面的网址是 LeetCode 的所有贪心算法题目，从易到难均有，祝你刷题愉快！\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>\n\n\n","source":"_posts/assign-cookies.md","raw":"---\ntitle: JavaScript 版贪心算法题：分饼干\ndate: 2017-03-11 11:41:00\ntags: [数据结构与算法, LeetCode]\n---\n\n今天，我们要讲的是一道贪心算法题：分饼干。这道题也来自 LeetCode：\n\nhttps://leetcode.com/problems/assign-cookies\n\n本文将先介绍贪心算法的基础知识，然后使用贪心算法解决这个问题，所用的语言依然是 JavaScript。\n\n<!--more-->\n\n## 贪心算法简介\n\n贪心法，又称贪心算法、贪婪算法、或称贪婪法，是一种在**每一步选择中都采取在当前状态下最好或最优（即最有利）的选择**，从而希望导致结果是最好或最优的算法。简单来说，贪心算法的核心思想就是**今朝有酒今朝醉**，**活在当下**。举几个贪心算法的例子吧！\n\n1，一般人换零钱的时候会应用到贪心算法。把$36换散︰$20 > $10 > $5 > $1。先换大面额再换小面额！\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Greedy_algorithm_36_cents.svg/600px-Greedy_algorithm_36_cents.svg.png)\n\n2，但有时候贪心算法并不准确，比如上学时候，学渣使用贪心算法，坚持当下玩乐，但最后却没有好工作，当然前提是他也没有好爸爸。\n\n3，在编程中，贪心算法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。\n\n\n## 分饼干\n\n了解了贪心算法，我们来使用它解决“分饼干问题”。“分饼干问题”的题目是这样的：\n\n> 假设你是一个好爸爸（妈妈），你想给你的孩子们分一些饼干。每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。你的目标就是尽量让更多的孩子满意。\n\n下面我们再用断言表示一下需求。编写一个方法 `findContentChildren` ，它接受一个表示饼干的数组作为参数，返回能满足的孩子的最大数量。\n\n```js\n// 如果孩子的要求是 [1, 3, 5, 4, 2]，饼干是[1, 1]，最多能让1个孩子满足。\nexpect(findContentChildren([1, 3, 5, 4, 2], [1, 1])).toBe(1);\n// 如果孩子的要求是 [10, 9, 8, 7, 6]，饼干是[7, 6, 5]，最多能让2个孩子满足。\nexpect(findContentChildren([10, 9, 8, 7, 6], [7, 6, 5])).toBe(2);\n```\n\n题目分析完了，让我们使用贪心算法来解决它！贪心算法的核心思想是**坚持当下的最好选择**。那么在这道题中，**当下的最好选择**是什么？答案是，先将“较小的饼干”分给“对饼干尺寸要求最小”、“最好说话”的孩子，因为他们最容易满足，这样才能最大化满足孩子的数量。那么，整个分配流程就应该是这样的：\n\n- 首先，将孩子们按“对饼干尺寸要求最小”排序，将饼干按尺寸大小排序。\n- 然后，判断第一块饼干是否能满足第一个孩子，能就分给他，否则就换个稍微大点的，直到满足这个孩子。\n- 满足第一个孩子后，再对第二个、第三个以及后面的孩子重复上面一步，直到饼干分完为止。\n- 最后统计满足了多少个孩子，并返回结果。\n\n那么用 JavaScript 实现就是：\n\nLeetCode/455-assignCookies.js\n\n```js\n/**\n * @param {number[]} g\n * @param {number[]} s\n * @return {number}\n */\nvar findContentChildren = function (g, s) {\n  var sortFunc = function (a, b) {\n    return a - b;\n  };\n  g.sort(sortFunc);\n  s.sort(sortFunc);\n  var i = 0;\n  for (var j = 0; i < g.length && j < s.length; j++) {\n    if (g[i] <= s[j]) {\n      i++;\n    }\n  }\n  return i;\n};\n```\n至此，这道题就做完了！你理解贪心算法了吗？如果不理解，可以再做几道题练习一下：\n\nhttps://leetcode.com/tag/greedy/\n\n上面的网址是 LeetCode 的所有贪心算法题目，从易到难均有，祝你刷题愉快！\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>\n\n\n","slug":"assign-cookies","published":1,"updated":"2019-05-01T08:02:08.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvkq0001tgyth49yc47m","content":"<p>今天，我们要讲的是一道贪心算法题：分饼干。这道题也来自 LeetCode：</p>\n<p><a href=\"https://leetcode.com/problems/assign-cookies\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/assign-cookies</a></p>\n<p>本文将先介绍贪心算法的基础知识，然后使用贪心算法解决这个问题，所用的语言依然是 JavaScript。</p>\n<a id=\"more\"></a>\n<h2 id=\"贪心算法简介\"><a href=\"#贪心算法简介\" class=\"headerlink\" title=\"贪心算法简介\"></a>贪心算法简介</h2><p>贪心法，又称贪心算法、贪婪算法、或称贪婪法，是一种在<strong>每一步选择中都采取在当前状态下最好或最优（即最有利）的选择</strong>，从而希望导致结果是最好或最优的算法。简单来说，贪心算法的核心思想就是<strong>今朝有酒今朝醉</strong>，<strong>活在当下</strong>。举几个贪心算法的例子吧！</p>\n<p>1，一般人换零钱的时候会应用到贪心算法。把$36换散︰$20 &gt; $10 &gt; $5 &gt; $1。先换大面额再换小面额！</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Greedy_algorithm_36_cents.svg/600px-Greedy_algorithm_36_cents.svg.png\" alt=\"\"></p>\n<p>2，但有时候贪心算法并不准确，比如上学时候，学渣使用贪心算法，坚持当下玩乐，但最后却没有好工作，当然前提是他也没有好爸爸。</p>\n<p>3，在编程中，贪心算法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。</p>\n<h2 id=\"分饼干\"><a href=\"#分饼干\" class=\"headerlink\" title=\"分饼干\"></a>分饼干</h2><p>了解了贪心算法，我们来使用它解决“分饼干问题”。“分饼干问题”的题目是这样的：</p>\n<blockquote>\n<p>假设你是一个好爸爸（妈妈），你想给你的孩子们分一些饼干。每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。你的目标就是尽量让更多的孩子满意。</p>\n</blockquote>\n<p>下面我们再用断言表示一下需求。编写一个方法 <code>findContentChildren</code> ，它接受一个表示饼干的数组作为参数，返回能满足的孩子的最大数量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果孩子的要求是 [1, 3, 5, 4, 2]，饼干是[1, 1]，最多能让1个孩子满足。</span></span><br><span class=\"line\">expect(findContentChildren([<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>], [<span class=\"number\">1</span>, <span class=\"number\">1</span>])).toBe(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 如果孩子的要求是 [10, 9, 8, 7, 6]，饼干是[7, 6, 5]，最多能让2个孩子满足。</span></span><br><span class=\"line\">expect(findContentChildren([<span class=\"number\">10</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>])).toBe(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>题目分析完了，让我们使用贪心算法来解决它！贪心算法的核心思想是<strong>坚持当下的最好选择</strong>。那么在这道题中，<strong>当下的最好选择</strong>是什么？答案是，先将“较小的饼干”分给“对饼干尺寸要求最小”、“最好说话”的孩子，因为他们最容易满足，这样才能最大化满足孩子的数量。那么，整个分配流程就应该是这样的：</p>\n<ul>\n<li>首先，将孩子们按“对饼干尺寸要求最小”排序，将饼干按尺寸大小排序。</li>\n<li>然后，判断第一块饼干是否能满足第一个孩子，能就分给他，否则就换个稍微大点的，直到满足这个孩子。</li>\n<li>满足第一个孩子后，再对第二个、第三个以及后面的孩子重复上面一步，直到饼干分完为止。</li>\n<li>最后统计满足了多少个孩子，并返回结果。</li>\n</ul>\n<p>那么用 JavaScript 实现就是：</p>\n<p>LeetCode/455-assignCookies.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; g</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; s</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> findContentChildren = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">g, s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sortFunc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  g.sort(sortFunc);</span><br><span class=\"line\">  s.sort(sortFunc);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; i &lt; g.length &amp;&amp; j &lt; s.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g[i] &lt;= s[j]) &#123;</span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>至此，这道题就做完了！你理解贪心算法了吗？如果不理解，可以再做几道题练习一下：</p>\n<p><a href=\"https://leetcode.com/tag/greedy/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/tag/greedy/</a></p>\n<p>上面的网址是 LeetCode 的所有贪心算法题目，从易到难均有，祝你刷题愉快！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是一道贪心算法题：分饼干。这道题也来自 LeetCode：</p>\n<p><a href=\"https://leetcode.com/problems/assign-cookies\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/assign-cookies</a></p>\n<p>本文将先介绍贪心算法的基础知识，然后使用贪心算法解决这个问题，所用的语言依然是 JavaScript。</p>","more":"<h2 id=\"贪心算法简介\"><a href=\"#贪心算法简介\" class=\"headerlink\" title=\"贪心算法简介\"></a>贪心算法简介</h2><p>贪心法，又称贪心算法、贪婪算法、或称贪婪法，是一种在<strong>每一步选择中都采取在当前状态下最好或最优（即最有利）的选择</strong>，从而希望导致结果是最好或最优的算法。简单来说，贪心算法的核心思想就是<strong>今朝有酒今朝醉</strong>，<strong>活在当下</strong>。举几个贪心算法的例子吧！</p>\n<p>1，一般人换零钱的时候会应用到贪心算法。把$36换散︰$20 &gt; $10 &gt; $5 &gt; $1。先换大面额再换小面额！</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Greedy_algorithm_36_cents.svg/600px-Greedy_algorithm_36_cents.svg.png\" alt=\"\"></p>\n<p>2，但有时候贪心算法并不准确，比如上学时候，学渣使用贪心算法，坚持当下玩乐，但最后却没有好工作，当然前提是他也没有好爸爸。</p>\n<p>3，在编程中，贪心算法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。</p>\n<h2 id=\"分饼干\"><a href=\"#分饼干\" class=\"headerlink\" title=\"分饼干\"></a>分饼干</h2><p>了解了贪心算法，我们来使用它解决“分饼干问题”。“分饼干问题”的题目是这样的：</p>\n<blockquote>\n<p>假设你是一个好爸爸（妈妈），你想给你的孩子们分一些饼干。每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。你的目标就是尽量让更多的孩子满意。</p>\n</blockquote>\n<p>下面我们再用断言表示一下需求。编写一个方法 <code>findContentChildren</code> ，它接受一个表示饼干的数组作为参数，返回能满足的孩子的最大数量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果孩子的要求是 [1, 3, 5, 4, 2]，饼干是[1, 1]，最多能让1个孩子满足。</span></span><br><span class=\"line\">expect(findContentChildren([<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>], [<span class=\"number\">1</span>, <span class=\"number\">1</span>])).toBe(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 如果孩子的要求是 [10, 9, 8, 7, 6]，饼干是[7, 6, 5]，最多能让2个孩子满足。</span></span><br><span class=\"line\">expect(findContentChildren([<span class=\"number\">10</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>])).toBe(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>题目分析完了，让我们使用贪心算法来解决它！贪心算法的核心思想是<strong>坚持当下的最好选择</strong>。那么在这道题中，<strong>当下的最好选择</strong>是什么？答案是，先将“较小的饼干”分给“对饼干尺寸要求最小”、“最好说话”的孩子，因为他们最容易满足，这样才能最大化满足孩子的数量。那么，整个分配流程就应该是这样的：</p>\n<ul>\n<li>首先，将孩子们按“对饼干尺寸要求最小”排序，将饼干按尺寸大小排序。</li>\n<li>然后，判断第一块饼干是否能满足第一个孩子，能就分给他，否则就换个稍微大点的，直到满足这个孩子。</li>\n<li>满足第一个孩子后，再对第二个、第三个以及后面的孩子重复上面一步，直到饼干分完为止。</li>\n<li>最后统计满足了多少个孩子，并返回结果。</li>\n</ul>\n<p>那么用 JavaScript 实现就是：</p>\n<p>LeetCode/455-assignCookies.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; g</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; s</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> findContentChildren = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">g, s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sortFunc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  g.sort(sortFunc);</span><br><span class=\"line\">  s.sort(sortFunc);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; i &lt; g.length &amp;&amp; j &lt; s.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g[i] &lt;= s[j]) &#123;</span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>至此，这道题就做完了！你理解贪心算法了吗？如果不理解，可以再做几道题练习一下：</p>\n<p><a href=\"https://leetcode.com/tag/greedy/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/tag/greedy/</a></p>\n<p>上面的网址是 LeetCode 的所有贪心算法题目，从易到难均有，祝你刷题愉快！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>"},{"title":"搭建 Appium 自动化测试环境（Android 篇）","date":"2018-08-08T06:23:00.000Z","_content":"\n今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 Android 系统的 App 进行自动化测试。\n\n> 本文仅讲解在 Mac 上的环境配置方法。\n\n<!--more-->\n\n## 配置 Android 的自动化驱动环境\n\nAppium 进行自动化的原理是：发送命令到各自系统对应的自动化驱动，来对相应的系统上的 App 进行自动化。这篇文章讲的是 Android 自动化，对应驱动的名字叫 UiAutomator2。为了让驱动正常工作，我们要配置 UiAutomator2 的环境：\n\n### 安装 Homebrew\n\n如果你的 Mac 已经有 Homebrew ，请忽略，否则执行此命令安装：\n\n```sh\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n### 安装 Java\n\n```sh\nbrew tap caskroom/versions\nbrew cask install java8\n```\n\n### 设置 JAVA_HOME 环境变量\n\n编辑登陆脚本：\n\n```sh\nvi ~/.bash_profile\n```\n\n添加这两行：\n\n```sh\nexport JAVA_HOME=\"$(/usr/libexec/java_home)\"\nexport PATH=$JAVA_HOME/bin:$PATH\n```\n\n使其生效：\n\n```sh\nsource ~/.bash_profile\n```\n\n### 安装 Android SDK\n\nAndroid SDK 最好的安装方法是安装 [Android Studio](https://developer.android.com/studio/index.html)。安装过程一路默认就好。\n\n安装完成后，点击这里查看 SDK 目录：\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/560667f7c3c2da24c502e5c9555367ac.png)\n\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/8191aafc8e1052d83d9dbad2315b4486.png)\n\n### 设置 ADNROID_HOME 环境变量\n\n将 ANDROID_HOME 环境变量设置为上步的 SDK 目录地址：\n\n编辑登陆脚本：\n\n```sh\nvi ~/.bash_profile\n```\n\n添加这两行（注意把 username 改为自己的）：\n\n```sh\nexport ANDROID_HOME=\"/Users/username/Library/Android/sdk\"\nexport PATH=$ANDROID_HOME/platform-tools:$PATH\n```\n\n使其生效：\n\n```sh\nsource ~/.bash_profile\n```\n\n至此，驱动环境就搭建好了！\n\n## 安装 Appium \n\n安装 Appium 有两种方式，NPM 和 桌面程序安装包，我们这次先选择前者：\n\n```sh\nnpm install -g appium\n```\n\n## 编写简单测试脚本\n\n### 查看设备名称\n\n打开手机开发者模式插到 Mac 上，输入此命令查看设备名称：\n\n```sh\nadb devices\n```\n\n### 下载被测试的 App\n\n[ApiDemos-debug.apk](https://github.com/appium/appium/raw/master/sample-code/apps/ApiDemos-debug.apk)\n\n### 新建测试项目\n\n```sh\nmkdir appium-test\n\ncd appium-test\n\nnpm i webdriverio\n```\n\n添加 test.js 文件，并填写以下内容：\n\n```js\n// javascript\n\nconst wdio = require(\"webdriverio\");\n\nconst opts = {\n  port: 4723,\n  desiredCapabilities: {\n    platformName: \"Android\",\n    deviceName: \"填写 adb devices 中的名称\",\n    app: \"填写 ApiDemos-debug.apk 的本地路径\",\n    automationName: \"UiAutomator2\"\n  }\n};\n\nconst client = wdio.remote(opts);\n\nclient\n  .init()\n  .click(\"~App\")\n  .back()\n  .end();\n```\n\n在一个命令行中启动 appium：\n\n```sh\nappium\n```\n\n在另一个命令行中执行测试脚本：\n\n```sh\nnode test.js\n```\n\n然后就会发现手机被安装了 ApiDemos.apk ，并模拟点击了脚本中的命令。\n\n\n\n\n\n","source":"_posts/appium-android-get-started.md","raw":"---\ntitle: 搭建 Appium 自动化测试环境（Android 篇）\ndate: 2018-08-08 14:23:00\ntags: [测试, 自动化测试, Appium, Android]\n---\n\n今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 Android 系统的 App 进行自动化测试。\n\n> 本文仅讲解在 Mac 上的环境配置方法。\n\n<!--more-->\n\n## 配置 Android 的自动化驱动环境\n\nAppium 进行自动化的原理是：发送命令到各自系统对应的自动化驱动，来对相应的系统上的 App 进行自动化。这篇文章讲的是 Android 自动化，对应驱动的名字叫 UiAutomator2。为了让驱动正常工作，我们要配置 UiAutomator2 的环境：\n\n### 安装 Homebrew\n\n如果你的 Mac 已经有 Homebrew ，请忽略，否则执行此命令安装：\n\n```sh\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n### 安装 Java\n\n```sh\nbrew tap caskroom/versions\nbrew cask install java8\n```\n\n### 设置 JAVA_HOME 环境变量\n\n编辑登陆脚本：\n\n```sh\nvi ~/.bash_profile\n```\n\n添加这两行：\n\n```sh\nexport JAVA_HOME=\"$(/usr/libexec/java_home)\"\nexport PATH=$JAVA_HOME/bin:$PATH\n```\n\n使其生效：\n\n```sh\nsource ~/.bash_profile\n```\n\n### 安装 Android SDK\n\nAndroid SDK 最好的安装方法是安装 [Android Studio](https://developer.android.com/studio/index.html)。安装过程一路默认就好。\n\n安装完成后，点击这里查看 SDK 目录：\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/560667f7c3c2da24c502e5c9555367ac.png)\n\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/8191aafc8e1052d83d9dbad2315b4486.png)\n\n### 设置 ADNROID_HOME 环境变量\n\n将 ANDROID_HOME 环境变量设置为上步的 SDK 目录地址：\n\n编辑登陆脚本：\n\n```sh\nvi ~/.bash_profile\n```\n\n添加这两行（注意把 username 改为自己的）：\n\n```sh\nexport ANDROID_HOME=\"/Users/username/Library/Android/sdk\"\nexport PATH=$ANDROID_HOME/platform-tools:$PATH\n```\n\n使其生效：\n\n```sh\nsource ~/.bash_profile\n```\n\n至此，驱动环境就搭建好了！\n\n## 安装 Appium \n\n安装 Appium 有两种方式，NPM 和 桌面程序安装包，我们这次先选择前者：\n\n```sh\nnpm install -g appium\n```\n\n## 编写简单测试脚本\n\n### 查看设备名称\n\n打开手机开发者模式插到 Mac 上，输入此命令查看设备名称：\n\n```sh\nadb devices\n```\n\n### 下载被测试的 App\n\n[ApiDemos-debug.apk](https://github.com/appium/appium/raw/master/sample-code/apps/ApiDemos-debug.apk)\n\n### 新建测试项目\n\n```sh\nmkdir appium-test\n\ncd appium-test\n\nnpm i webdriverio\n```\n\n添加 test.js 文件，并填写以下内容：\n\n```js\n// javascript\n\nconst wdio = require(\"webdriverio\");\n\nconst opts = {\n  port: 4723,\n  desiredCapabilities: {\n    platformName: \"Android\",\n    deviceName: \"填写 adb devices 中的名称\",\n    app: \"填写 ApiDemos-debug.apk 的本地路径\",\n    automationName: \"UiAutomator2\"\n  }\n};\n\nconst client = wdio.remote(opts);\n\nclient\n  .init()\n  .click(\"~App\")\n  .back()\n  .end();\n```\n\n在一个命令行中启动 appium：\n\n```sh\nappium\n```\n\n在另一个命令行中执行测试脚本：\n\n```sh\nnode test.js\n```\n\n然后就会发现手机被安装了 ApiDemos.apk ，并模拟点击了脚本中的命令。\n\n\n\n\n\n","slug":"appium-android-get-started","published":1,"updated":"2019-05-01T08:02:08.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvku0002tgyt388dwszg","content":"<p>今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 Android 系统的 App 进行自动化测试。</p>\n<blockquote>\n<p>本文仅讲解在 Mac 上的环境配置方法。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"配置-Android-的自动化驱动环境\"><a href=\"#配置-Android-的自动化驱动环境\" class=\"headerlink\" title=\"配置 Android 的自动化驱动环境\"></a>配置 Android 的自动化驱动环境</h2><p>Appium 进行自动化的原理是：发送命令到各自系统对应的自动化驱动，来对相应的系统上的 App 进行自动化。这篇文章讲的是 Android 自动化，对应驱动的名字叫 UiAutomator2。为了让驱动正常工作，我们要配置 UiAutomator2 的环境：</p>\n<h3 id=\"安装-Homebrew\"><a href=\"#安装-Homebrew\" class=\"headerlink\" title=\"安装 Homebrew\"></a>安装 Homebrew</h3><p>如果你的 Mac 已经有 Homebrew ，请忽略，否则执行此命令安装：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-Java\"><a href=\"#安装-Java\" class=\"headerlink\" title=\"安装 Java\"></a>安装 Java</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew tap caskroom/versions</span><br><span class=\"line\">brew cask install java8</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置-JAVA-HOME-环境变量\"><a href=\"#设置-JAVA-HOME-环境变量\" class=\"headerlink\" title=\"设置 JAVA_HOME 环境变量\"></a>设置 JAVA_HOME 环境变量</h3><p>编辑登陆脚本：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>添加这两行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=<span class=\"string\">\"<span class=\"variable\">$(/usr/libexec/java_home)</span>\"</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$JAVA_HOME</span>/bin:<span class=\"variable\">$PATH</span></span><br></pre></td></tr></table></figure>\n<p>使其生效：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-Android-SDK\"><a href=\"#安装-Android-SDK\" class=\"headerlink\" title=\"安装 Android SDK\"></a>安装 Android SDK</h3><p>Android SDK 最好的安装方法是安装 <a href=\"https://developer.android.com/studio/index.html\" target=\"_blank\" rel=\"noopener\">Android Studio</a>。安装过程一路默认就好。</p>\n<p>安装完成后，点击这里查看 SDK 目录：</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/560667f7c3c2da24c502e5c9555367ac.png\" alt=\"image.png\"></p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/8191aafc8e1052d83d9dbad2315b4486.png\" alt=\"image.png\"></p>\n<h3 id=\"设置-ADNROID-HOME-环境变量\"><a href=\"#设置-ADNROID-HOME-环境变量\" class=\"headerlink\" title=\"设置 ADNROID_HOME 环境变量\"></a>设置 ADNROID_HOME 环境变量</h3><p>将 ANDROID_HOME 环境变量设置为上步的 SDK 目录地址：</p>\n<p>编辑登陆脚本：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>添加这两行（注意把 username 改为自己的）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> ANDROID_HOME=<span class=\"string\">\"/Users/username/Library/Android/sdk\"</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$ANDROID_HOME</span>/platform-tools:<span class=\"variable\">$PATH</span></span><br></pre></td></tr></table></figure>\n<p>使其生效：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>至此，驱动环境就搭建好了！</p>\n<h2 id=\"安装-Appium\"><a href=\"#安装-Appium\" class=\"headerlink\" title=\"安装 Appium\"></a>安装 Appium</h2><p>安装 Appium 有两种方式，NPM 和 桌面程序安装包，我们这次先选择前者：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g appium</span><br></pre></td></tr></table></figure>\n<h2 id=\"编写简单测试脚本\"><a href=\"#编写简单测试脚本\" class=\"headerlink\" title=\"编写简单测试脚本\"></a>编写简单测试脚本</h2><h3 id=\"查看设备名称\"><a href=\"#查看设备名称\" class=\"headerlink\" title=\"查看设备名称\"></a>查看设备名称</h3><p>打开手机开发者模式插到 Mac 上，输入此命令查看设备名称：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb devices</span><br></pre></td></tr></table></figure>\n<h3 id=\"下载被测试的-App\"><a href=\"#下载被测试的-App\" class=\"headerlink\" title=\"下载被测试的 App\"></a>下载被测试的 App</h3><p><a href=\"https://github.com/appium/appium/raw/master/sample-code/apps/ApiDemos-debug.apk\" target=\"_blank\" rel=\"noopener\">ApiDemos-debug.apk</a></p>\n<h3 id=\"新建测试项目\"><a href=\"#新建测试项目\" class=\"headerlink\" title=\"新建测试项目\"></a>新建测试项目</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir appium-test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> appium-test</span><br><span class=\"line\"></span><br><span class=\"line\">npm i webdriverio</span><br></pre></td></tr></table></figure>\n<p>添加 test.js 文件，并填写以下内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javascript</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> wdio = <span class=\"built_in\">require</span>(<span class=\"string\">\"webdriverio\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> opts = &#123;</span><br><span class=\"line\">  port: <span class=\"number\">4723</span>,</span><br><span class=\"line\">  desiredCapabilities: &#123;</span><br><span class=\"line\">    platformName: <span class=\"string\">\"Android\"</span>,</span><br><span class=\"line\">    deviceName: <span class=\"string\">\"填写 adb devices 中的名称\"</span>,</span><br><span class=\"line\">    app: <span class=\"string\">\"填写 ApiDemos-debug.apk 的本地路径\"</span>,</span><br><span class=\"line\">    automationName: <span class=\"string\">\"UiAutomator2\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> client = wdio.remote(opts);</span><br><span class=\"line\"></span><br><span class=\"line\">client</span><br><span class=\"line\">  .init()</span><br><span class=\"line\">  .click(<span class=\"string\">\"~App\"</span>)</span><br><span class=\"line\">  .back()</span><br><span class=\"line\">  .end();</span><br></pre></td></tr></table></figure>\n<p>在一个命令行中启动 appium：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appium</span><br></pre></td></tr></table></figure>\n<p>在另一个命令行中执行测试脚本：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node test.js</span><br></pre></td></tr></table></figure>\n<p>然后就会发现手机被安装了 ApiDemos.apk ，并模拟点击了脚本中的命令。</p>\n","site":{"data":{}},"excerpt":"<p>今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 Android 系统的 App 进行自动化测试。</p>\n<blockquote>\n<p>本文仅讲解在 Mac 上的环境配置方法。</p>\n</blockquote>","more":"<h2 id=\"配置-Android-的自动化驱动环境\"><a href=\"#配置-Android-的自动化驱动环境\" class=\"headerlink\" title=\"配置 Android 的自动化驱动环境\"></a>配置 Android 的自动化驱动环境</h2><p>Appium 进行自动化的原理是：发送命令到各自系统对应的自动化驱动，来对相应的系统上的 App 进行自动化。这篇文章讲的是 Android 自动化，对应驱动的名字叫 UiAutomator2。为了让驱动正常工作，我们要配置 UiAutomator2 的环境：</p>\n<h3 id=\"安装-Homebrew\"><a href=\"#安装-Homebrew\" class=\"headerlink\" title=\"安装 Homebrew\"></a>安装 Homebrew</h3><p>如果你的 Mac 已经有 Homebrew ，请忽略，否则执行此命令安装：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-Java\"><a href=\"#安装-Java\" class=\"headerlink\" title=\"安装 Java\"></a>安装 Java</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew tap caskroom/versions</span><br><span class=\"line\">brew cask install java8</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置-JAVA-HOME-环境变量\"><a href=\"#设置-JAVA-HOME-环境变量\" class=\"headerlink\" title=\"设置 JAVA_HOME 环境变量\"></a>设置 JAVA_HOME 环境变量</h3><p>编辑登陆脚本：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>添加这两行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=<span class=\"string\">\"<span class=\"variable\">$(/usr/libexec/java_home)</span>\"</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$JAVA_HOME</span>/bin:<span class=\"variable\">$PATH</span></span><br></pre></td></tr></table></figure>\n<p>使其生效：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-Android-SDK\"><a href=\"#安装-Android-SDK\" class=\"headerlink\" title=\"安装 Android SDK\"></a>安装 Android SDK</h3><p>Android SDK 最好的安装方法是安装 <a href=\"https://developer.android.com/studio/index.html\" target=\"_blank\" rel=\"noopener\">Android Studio</a>。安装过程一路默认就好。</p>\n<p>安装完成后，点击这里查看 SDK 目录：</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/560667f7c3c2da24c502e5c9555367ac.png\" alt=\"image.png\"></p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/8191aafc8e1052d83d9dbad2315b4486.png\" alt=\"image.png\"></p>\n<h3 id=\"设置-ADNROID-HOME-环境变量\"><a href=\"#设置-ADNROID-HOME-环境变量\" class=\"headerlink\" title=\"设置 ADNROID_HOME 环境变量\"></a>设置 ADNROID_HOME 环境变量</h3><p>将 ANDROID_HOME 环境变量设置为上步的 SDK 目录地址：</p>\n<p>编辑登陆脚本：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>添加这两行（注意把 username 改为自己的）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> ANDROID_HOME=<span class=\"string\">\"/Users/username/Library/Android/sdk\"</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$ANDROID_HOME</span>/platform-tools:<span class=\"variable\">$PATH</span></span><br></pre></td></tr></table></figure>\n<p>使其生效：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>至此，驱动环境就搭建好了！</p>\n<h2 id=\"安装-Appium\"><a href=\"#安装-Appium\" class=\"headerlink\" title=\"安装 Appium\"></a>安装 Appium</h2><p>安装 Appium 有两种方式，NPM 和 桌面程序安装包，我们这次先选择前者：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g appium</span><br></pre></td></tr></table></figure>\n<h2 id=\"编写简单测试脚本\"><a href=\"#编写简单测试脚本\" class=\"headerlink\" title=\"编写简单测试脚本\"></a>编写简单测试脚本</h2><h3 id=\"查看设备名称\"><a href=\"#查看设备名称\" class=\"headerlink\" title=\"查看设备名称\"></a>查看设备名称</h3><p>打开手机开发者模式插到 Mac 上，输入此命令查看设备名称：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb devices</span><br></pre></td></tr></table></figure>\n<h3 id=\"下载被测试的-App\"><a href=\"#下载被测试的-App\" class=\"headerlink\" title=\"下载被测试的 App\"></a>下载被测试的 App</h3><p><a href=\"https://github.com/appium/appium/raw/master/sample-code/apps/ApiDemos-debug.apk\" target=\"_blank\" rel=\"noopener\">ApiDemos-debug.apk</a></p>\n<h3 id=\"新建测试项目\"><a href=\"#新建测试项目\" class=\"headerlink\" title=\"新建测试项目\"></a>新建测试项目</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir appium-test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> appium-test</span><br><span class=\"line\"></span><br><span class=\"line\">npm i webdriverio</span><br></pre></td></tr></table></figure>\n<p>添加 test.js 文件，并填写以下内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javascript</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> wdio = <span class=\"built_in\">require</span>(<span class=\"string\">\"webdriverio\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> opts = &#123;</span><br><span class=\"line\">  port: <span class=\"number\">4723</span>,</span><br><span class=\"line\">  desiredCapabilities: &#123;</span><br><span class=\"line\">    platformName: <span class=\"string\">\"Android\"</span>,</span><br><span class=\"line\">    deviceName: <span class=\"string\">\"填写 adb devices 中的名称\"</span>,</span><br><span class=\"line\">    app: <span class=\"string\">\"填写 ApiDemos-debug.apk 的本地路径\"</span>,</span><br><span class=\"line\">    automationName: <span class=\"string\">\"UiAutomator2\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> client = wdio.remote(opts);</span><br><span class=\"line\"></span><br><span class=\"line\">client</span><br><span class=\"line\">  .init()</span><br><span class=\"line\">  .click(<span class=\"string\">\"~App\"</span>)</span><br><span class=\"line\">  .back()</span><br><span class=\"line\">  .end();</span><br></pre></td></tr></table></figure>\n<p>在一个命令行中启动 appium：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appium</span><br></pre></td></tr></table></figure>\n<p>在另一个命令行中执行测试脚本：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node test.js</span><br></pre></td></tr></table></figure>\n<p>然后就会发现手机被安装了 ApiDemos.apk ，并模拟点击了脚本中的命令。</p>"},{"title":"搭建 Appium 自动化测试环境（IOS 篇）","date":"2018-08-10T09:51:00.000Z","_content":"\n今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 IOS 系统的 App 进行自动化测试。\n\n> 本文仅讲解在 Mac 上的环境配置方法。\n\n<!--more-->\n\n## 配置 IOS 的自动化驱动环境\n\nAppium 进行自动化的原理是：发送命令到各自系统对应的自动化驱动，来对相应的系统上的 App 进行自动化。这篇文章讲的是 IOS 自动化，对应驱动的名字叫 XCUITest。为了让驱动正常工作，我们要配置 XCUITest 的环境：\n\n### 安装 XCode7 或更高版本\n\n如果你的 Mac 已经安装 XCode，请忽略，否则去 App Store 里安装。\n\n### 添加 udid 到 IOS 开发者账号上\n\n让有 IOS 开发者账号的人（可能是你或着你的 IOS 开发同事）把被测试的 iPhone 的 udid （udid 的获取办法请 Google）添加到开发者账户上。IOS 开发者都知道，如果你不是 IOS 开发就找他们做这一步，这里就不再赘述。\n\n### 安装开发者证书\n\n让有 IOS 开发者账号的人（可能是你或着你的 IOS 开发同事）把证书文件给你，你把它们装在 Mac 上。\n\n文件清单：\n\n- xxx.cer\n- xxx.p12\n- xxx.mobileprovision\n\n三个文件都是双击安装，一路默认。\n\n注意：\n\n- 安装 xxx.p12 文件时候，可能有密码，还是找有 IOS 开发者账号的人要密码。\n- 双击 xxx.mobileprovision 文件时候，没有什么界面，但是只要你的电脑上有 XCode，就已经安装好了。\n\n\n### 安装 Homebrew\n\n如果你的 Mac 已经有 Homebrew ，请忽略，否则执行此命令安装：\n\n```sh\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n### 安装 Carthage\n\n```sh\nbrew install carthage\n```\n\n### 安装 libimobiledevice\n\n```sh\nbrew install libimobiledevice --HEAD\n```\n\n### 安装 ios-deploy \n\n```sh\nnpm install -g ios-deploy\n```\n\n或者\n\n```sh\nbrew install ios-deploy\n```\n\n至此，驱动环境就搭建好了！\n\n## 安装 Appium \n\n安装 Appium 有两种方式，NPM 和 桌面程序安装包，我们这次先选择前者：\n\n```\nnpm install -g appium\n```\n\n## 配置 WebDriverAgent\n\n打开 WebDriverAgent.xcodeproj：\n\n```\nopen $(npm root -g)/appium/node_modules/appium-xcuitest-driver/WebDriverAgent/WebDriverAgent.xcodeproj\n```\n\n选择 WebDriverAgentRunner，并在下面两个 Signing 面板上选择之前安装的 provisioning 文件。\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/e60eccda5f84c981c7ba933b4cc37f00.png)\n\n## 编写简单测试脚本\n\n把 iPhone 插到 Mac 上。然后： \n\n### 准备被测试的 App 的安装包\n\n准备一份被测试 IOS App 文件，就是 ipa 结尾的安装包。\n\n### 新建测试项目\n\n```\nmkdir appium-test\n\ncd appium-test\n\nnpm i webdriverio\n```\n\n添加 test.js 文件，并填写以下内容：\n\n```js\n// javascript\n\nconst wdio = require(\"webdriverio\");\n\nconst opts = {\n  port: 4723,\n  desiredCapabilities: {\n    platformName: \"IOS\",\n    deviceName: \"iPhone的设备名称（Settings -> General -> About -> Name ）\",\n    app: \"填写 xxx.ipa 的本地路径\",\n    automationName: \"XCUITest\",\n    udid: \"iPhone 的 udid\",\n  }\n};\n\nconst client = wdio.remote(opts);\n\nclient\n  .init()\n  .end();\n```\n\n在一个命令行中启动 appium：\n\n```\nappium\n```\n\n在另一个命令行中执行测试脚本：\n\n```\nnode test.js\n```\n\n然后就会发现手机被安装了 xxx.ipa ，并打开了。\n","source":"_posts/appium-ios-get-started.md","raw":"---\ntitle: 搭建 Appium 自动化测试环境（IOS 篇）\ndate: 2018-08-010 17:51:00\ntags: [测试, 自动化测试, Appium, IOS]\n---\n\n今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 IOS 系统的 App 进行自动化测试。\n\n> 本文仅讲解在 Mac 上的环境配置方法。\n\n<!--more-->\n\n## 配置 IOS 的自动化驱动环境\n\nAppium 进行自动化的原理是：发送命令到各自系统对应的自动化驱动，来对相应的系统上的 App 进行自动化。这篇文章讲的是 IOS 自动化，对应驱动的名字叫 XCUITest。为了让驱动正常工作，我们要配置 XCUITest 的环境：\n\n### 安装 XCode7 或更高版本\n\n如果你的 Mac 已经安装 XCode，请忽略，否则去 App Store 里安装。\n\n### 添加 udid 到 IOS 开发者账号上\n\n让有 IOS 开发者账号的人（可能是你或着你的 IOS 开发同事）把被测试的 iPhone 的 udid （udid 的获取办法请 Google）添加到开发者账户上。IOS 开发者都知道，如果你不是 IOS 开发就找他们做这一步，这里就不再赘述。\n\n### 安装开发者证书\n\n让有 IOS 开发者账号的人（可能是你或着你的 IOS 开发同事）把证书文件给你，你把它们装在 Mac 上。\n\n文件清单：\n\n- xxx.cer\n- xxx.p12\n- xxx.mobileprovision\n\n三个文件都是双击安装，一路默认。\n\n注意：\n\n- 安装 xxx.p12 文件时候，可能有密码，还是找有 IOS 开发者账号的人要密码。\n- 双击 xxx.mobileprovision 文件时候，没有什么界面，但是只要你的电脑上有 XCode，就已经安装好了。\n\n\n### 安装 Homebrew\n\n如果你的 Mac 已经有 Homebrew ，请忽略，否则执行此命令安装：\n\n```sh\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n### 安装 Carthage\n\n```sh\nbrew install carthage\n```\n\n### 安装 libimobiledevice\n\n```sh\nbrew install libimobiledevice --HEAD\n```\n\n### 安装 ios-deploy \n\n```sh\nnpm install -g ios-deploy\n```\n\n或者\n\n```sh\nbrew install ios-deploy\n```\n\n至此，驱动环境就搭建好了！\n\n## 安装 Appium \n\n安装 Appium 有两种方式，NPM 和 桌面程序安装包，我们这次先选择前者：\n\n```\nnpm install -g appium\n```\n\n## 配置 WebDriverAgent\n\n打开 WebDriverAgent.xcodeproj：\n\n```\nopen $(npm root -g)/appium/node_modules/appium-xcuitest-driver/WebDriverAgent/WebDriverAgent.xcodeproj\n```\n\n选择 WebDriverAgentRunner，并在下面两个 Signing 面板上选择之前安装的 provisioning 文件。\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/e60eccda5f84c981c7ba933b4cc37f00.png)\n\n## 编写简单测试脚本\n\n把 iPhone 插到 Mac 上。然后： \n\n### 准备被测试的 App 的安装包\n\n准备一份被测试 IOS App 文件，就是 ipa 结尾的安装包。\n\n### 新建测试项目\n\n```\nmkdir appium-test\n\ncd appium-test\n\nnpm i webdriverio\n```\n\n添加 test.js 文件，并填写以下内容：\n\n```js\n// javascript\n\nconst wdio = require(\"webdriverio\");\n\nconst opts = {\n  port: 4723,\n  desiredCapabilities: {\n    platformName: \"IOS\",\n    deviceName: \"iPhone的设备名称（Settings -> General -> About -> Name ）\",\n    app: \"填写 xxx.ipa 的本地路径\",\n    automationName: \"XCUITest\",\n    udid: \"iPhone 的 udid\",\n  }\n};\n\nconst client = wdio.remote(opts);\n\nclient\n  .init()\n  .end();\n```\n\n在一个命令行中启动 appium：\n\n```\nappium\n```\n\n在另一个命令行中执行测试脚本：\n\n```\nnode test.js\n```\n\n然后就会发现手机被安装了 xxx.ipa ，并打开了。\n","slug":"appium-ios-get-started","published":1,"updated":"2019-05-01T08:02:08.911Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvkx0004tgytnxauiukn","content":"<p>今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 IOS 系统的 App 进行自动化测试。</p>\n<blockquote>\n<p>本文仅讲解在 Mac 上的环境配置方法。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"配置-IOS-的自动化驱动环境\"><a href=\"#配置-IOS-的自动化驱动环境\" class=\"headerlink\" title=\"配置 IOS 的自动化驱动环境\"></a>配置 IOS 的自动化驱动环境</h2><p>Appium 进行自动化的原理是：发送命令到各自系统对应的自动化驱动，来对相应的系统上的 App 进行自动化。这篇文章讲的是 IOS 自动化，对应驱动的名字叫 XCUITest。为了让驱动正常工作，我们要配置 XCUITest 的环境：</p>\n<h3 id=\"安装-XCode7-或更高版本\"><a href=\"#安装-XCode7-或更高版本\" class=\"headerlink\" title=\"安装 XCode7 或更高版本\"></a>安装 XCode7 或更高版本</h3><p>如果你的 Mac 已经安装 XCode，请忽略，否则去 App Store 里安装。</p>\n<h3 id=\"添加-udid-到-IOS-开发者账号上\"><a href=\"#添加-udid-到-IOS-开发者账号上\" class=\"headerlink\" title=\"添加 udid 到 IOS 开发者账号上\"></a>添加 udid 到 IOS 开发者账号上</h3><p>让有 IOS 开发者账号的人（可能是你或着你的 IOS 开发同事）把被测试的 iPhone 的 udid （udid 的获取办法请 Google）添加到开发者账户上。IOS 开发者都知道，如果你不是 IOS 开发就找他们做这一步，这里就不再赘述。</p>\n<h3 id=\"安装开发者证书\"><a href=\"#安装开发者证书\" class=\"headerlink\" title=\"安装开发者证书\"></a>安装开发者证书</h3><p>让有 IOS 开发者账号的人（可能是你或着你的 IOS 开发同事）把证书文件给你，你把它们装在 Mac 上。</p>\n<p>文件清单：</p>\n<ul>\n<li>xxx.cer</li>\n<li>xxx.p12</li>\n<li>xxx.mobileprovision</li>\n</ul>\n<p>三个文件都是双击安装，一路默认。</p>\n<p>注意：</p>\n<ul>\n<li>安装 xxx.p12 文件时候，可能有密码，还是找有 IOS 开发者账号的人要密码。</li>\n<li>双击 xxx.mobileprovision 文件时候，没有什么界面，但是只要你的电脑上有 XCode，就已经安装好了。</li>\n</ul>\n<h3 id=\"安装-Homebrew\"><a href=\"#安装-Homebrew\" class=\"headerlink\" title=\"安装 Homebrew\"></a>安装 Homebrew</h3><p>如果你的 Mac 已经有 Homebrew ，请忽略，否则执行此命令安装：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-Carthage\"><a href=\"#安装-Carthage\" class=\"headerlink\" title=\"安装 Carthage\"></a>安装 Carthage</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install carthage</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-libimobiledevice\"><a href=\"#安装-libimobiledevice\" class=\"headerlink\" title=\"安装 libimobiledevice\"></a>安装 libimobiledevice</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install libimobiledevice --HEAD</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-ios-deploy\"><a href=\"#安装-ios-deploy\" class=\"headerlink\" title=\"安装 ios-deploy\"></a>安装 ios-deploy</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g ios-deploy</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install ios-deploy</span><br></pre></td></tr></table></figure>\n<p>至此，驱动环境就搭建好了！</p>\n<h2 id=\"安装-Appium\"><a href=\"#安装-Appium\" class=\"headerlink\" title=\"安装 Appium\"></a>安装 Appium</h2><p>安装 Appium 有两种方式，NPM 和 桌面程序安装包，我们这次先选择前者：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g appium</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置-WebDriverAgent\"><a href=\"#配置-WebDriverAgent\" class=\"headerlink\" title=\"配置 WebDriverAgent\"></a>配置 WebDriverAgent</h2><p>打开 WebDriverAgent.xcodeproj：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open $(npm root -g)/appium/node_modules/appium-xcuitest-driver/WebDriverAgent/WebDriverAgent.xcodeproj</span><br></pre></td></tr></table></figure>\n<p>选择 WebDriverAgentRunner，并在下面两个 Signing 面板上选择之前安装的 provisioning 文件。</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/e60eccda5f84c981c7ba933b4cc37f00.png\" alt=\"image.png\"></p>\n<h2 id=\"编写简单测试脚本\"><a href=\"#编写简单测试脚本\" class=\"headerlink\" title=\"编写简单测试脚本\"></a>编写简单测试脚本</h2><p>把 iPhone 插到 Mac 上。然后： </p>\n<h3 id=\"准备被测试的-App-的安装包\"><a href=\"#准备被测试的-App-的安装包\" class=\"headerlink\" title=\"准备被测试的 App 的安装包\"></a>准备被测试的 App 的安装包</h3><p>准备一份被测试 IOS App 文件，就是 ipa 结尾的安装包。</p>\n<h3 id=\"新建测试项目\"><a href=\"#新建测试项目\" class=\"headerlink\" title=\"新建测试项目\"></a>新建测试项目</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir appium-test</span><br><span class=\"line\"></span><br><span class=\"line\">cd appium-test</span><br><span class=\"line\"></span><br><span class=\"line\">npm i webdriverio</span><br></pre></td></tr></table></figure>\n<p>添加 test.js 文件，并填写以下内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javascript</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> wdio = <span class=\"built_in\">require</span>(<span class=\"string\">\"webdriverio\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> opts = &#123;</span><br><span class=\"line\">  port: <span class=\"number\">4723</span>,</span><br><span class=\"line\">  desiredCapabilities: &#123;</span><br><span class=\"line\">    platformName: <span class=\"string\">\"IOS\"</span>,</span><br><span class=\"line\">    deviceName: <span class=\"string\">\"iPhone的设备名称（Settings -&gt; General -&gt; About -&gt; Name ）\"</span>,</span><br><span class=\"line\">    app: <span class=\"string\">\"填写 xxx.ipa 的本地路径\"</span>,</span><br><span class=\"line\">    automationName: <span class=\"string\">\"XCUITest\"</span>,</span><br><span class=\"line\">    udid: <span class=\"string\">\"iPhone 的 udid\"</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> client = wdio.remote(opts);</span><br><span class=\"line\"></span><br><span class=\"line\">client</span><br><span class=\"line\">  .init()</span><br><span class=\"line\">  .end();</span><br></pre></td></tr></table></figure>\n<p>在一个命令行中启动 appium：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appium</span><br></pre></td></tr></table></figure>\n<p>在另一个命令行中执行测试脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node test.js</span><br></pre></td></tr></table></figure>\n<p>然后就会发现手机被安装了 xxx.ipa ，并打开了。</p>\n","site":{"data":{}},"excerpt":"<p>今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 IOS 系统的 App 进行自动化测试。</p>\n<blockquote>\n<p>本文仅讲解在 Mac 上的环境配置方法。</p>\n</blockquote>","more":"<h2 id=\"配置-IOS-的自动化驱动环境\"><a href=\"#配置-IOS-的自动化驱动环境\" class=\"headerlink\" title=\"配置 IOS 的自动化驱动环境\"></a>配置 IOS 的自动化驱动环境</h2><p>Appium 进行自动化的原理是：发送命令到各自系统对应的自动化驱动，来对相应的系统上的 App 进行自动化。这篇文章讲的是 IOS 自动化，对应驱动的名字叫 XCUITest。为了让驱动正常工作，我们要配置 XCUITest 的环境：</p>\n<h3 id=\"安装-XCode7-或更高版本\"><a href=\"#安装-XCode7-或更高版本\" class=\"headerlink\" title=\"安装 XCode7 或更高版本\"></a>安装 XCode7 或更高版本</h3><p>如果你的 Mac 已经安装 XCode，请忽略，否则去 App Store 里安装。</p>\n<h3 id=\"添加-udid-到-IOS-开发者账号上\"><a href=\"#添加-udid-到-IOS-开发者账号上\" class=\"headerlink\" title=\"添加 udid 到 IOS 开发者账号上\"></a>添加 udid 到 IOS 开发者账号上</h3><p>让有 IOS 开发者账号的人（可能是你或着你的 IOS 开发同事）把被测试的 iPhone 的 udid （udid 的获取办法请 Google）添加到开发者账户上。IOS 开发者都知道，如果你不是 IOS 开发就找他们做这一步，这里就不再赘述。</p>\n<h3 id=\"安装开发者证书\"><a href=\"#安装开发者证书\" class=\"headerlink\" title=\"安装开发者证书\"></a>安装开发者证书</h3><p>让有 IOS 开发者账号的人（可能是你或着你的 IOS 开发同事）把证书文件给你，你把它们装在 Mac 上。</p>\n<p>文件清单：</p>\n<ul>\n<li>xxx.cer</li>\n<li>xxx.p12</li>\n<li>xxx.mobileprovision</li>\n</ul>\n<p>三个文件都是双击安装，一路默认。</p>\n<p>注意：</p>\n<ul>\n<li>安装 xxx.p12 文件时候，可能有密码，还是找有 IOS 开发者账号的人要密码。</li>\n<li>双击 xxx.mobileprovision 文件时候，没有什么界面，但是只要你的电脑上有 XCode，就已经安装好了。</li>\n</ul>\n<h3 id=\"安装-Homebrew\"><a href=\"#安装-Homebrew\" class=\"headerlink\" title=\"安装 Homebrew\"></a>安装 Homebrew</h3><p>如果你的 Mac 已经有 Homebrew ，请忽略，否则执行此命令安装：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-Carthage\"><a href=\"#安装-Carthage\" class=\"headerlink\" title=\"安装 Carthage\"></a>安装 Carthage</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install carthage</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-libimobiledevice\"><a href=\"#安装-libimobiledevice\" class=\"headerlink\" title=\"安装 libimobiledevice\"></a>安装 libimobiledevice</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install libimobiledevice --HEAD</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装-ios-deploy\"><a href=\"#安装-ios-deploy\" class=\"headerlink\" title=\"安装 ios-deploy\"></a>安装 ios-deploy</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g ios-deploy</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install ios-deploy</span><br></pre></td></tr></table></figure>\n<p>至此，驱动环境就搭建好了！</p>\n<h2 id=\"安装-Appium\"><a href=\"#安装-Appium\" class=\"headerlink\" title=\"安装 Appium\"></a>安装 Appium</h2><p>安装 Appium 有两种方式，NPM 和 桌面程序安装包，我们这次先选择前者：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g appium</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置-WebDriverAgent\"><a href=\"#配置-WebDriverAgent\" class=\"headerlink\" title=\"配置 WebDriverAgent\"></a>配置 WebDriverAgent</h2><p>打开 WebDriverAgent.xcodeproj：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open $(npm root -g)/appium/node_modules/appium-xcuitest-driver/WebDriverAgent/WebDriverAgent.xcodeproj</span><br></pre></td></tr></table></figure>\n<p>选择 WebDriverAgentRunner，并在下面两个 Signing 面板上选择之前安装的 provisioning 文件。</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/e60eccda5f84c981c7ba933b4cc37f00.png\" alt=\"image.png\"></p>\n<h2 id=\"编写简单测试脚本\"><a href=\"#编写简单测试脚本\" class=\"headerlink\" title=\"编写简单测试脚本\"></a>编写简单测试脚本</h2><p>把 iPhone 插到 Mac 上。然后： </p>\n<h3 id=\"准备被测试的-App-的安装包\"><a href=\"#准备被测试的-App-的安装包\" class=\"headerlink\" title=\"准备被测试的 App 的安装包\"></a>准备被测试的 App 的安装包</h3><p>准备一份被测试 IOS App 文件，就是 ipa 结尾的安装包。</p>\n<h3 id=\"新建测试项目\"><a href=\"#新建测试项目\" class=\"headerlink\" title=\"新建测试项目\"></a>新建测试项目</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir appium-test</span><br><span class=\"line\"></span><br><span class=\"line\">cd appium-test</span><br><span class=\"line\"></span><br><span class=\"line\">npm i webdriverio</span><br></pre></td></tr></table></figure>\n<p>添加 test.js 文件，并填写以下内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javascript</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> wdio = <span class=\"built_in\">require</span>(<span class=\"string\">\"webdriverio\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> opts = &#123;</span><br><span class=\"line\">  port: <span class=\"number\">4723</span>,</span><br><span class=\"line\">  desiredCapabilities: &#123;</span><br><span class=\"line\">    platformName: <span class=\"string\">\"IOS\"</span>,</span><br><span class=\"line\">    deviceName: <span class=\"string\">\"iPhone的设备名称（Settings -&gt; General -&gt; About -&gt; Name ）\"</span>,</span><br><span class=\"line\">    app: <span class=\"string\">\"填写 xxx.ipa 的本地路径\"</span>,</span><br><span class=\"line\">    automationName: <span class=\"string\">\"XCUITest\"</span>,</span><br><span class=\"line\">    udid: <span class=\"string\">\"iPhone 的 udid\"</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> client = wdio.remote(opts);</span><br><span class=\"line\"></span><br><span class=\"line\">client</span><br><span class=\"line\">  .init()</span><br><span class=\"line\">  .end();</span><br></pre></td></tr></table></figure>\n<p>在一个命令行中启动 appium：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appium</span><br></pre></td></tr></table></figure>\n<p>在另一个命令行中执行测试脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node test.js</span><br></pre></td></tr></table></figure>\n<p>然后就会发现手机被安装了 xxx.ipa ，并打开了。</p>"},{"title":"端对端测试中常用的 Puppeteer 操作总结","date":"2017-12-05T06:51:00.000Z","_content":"\n上篇博客我们讲解了[《使用 Jest 与 Puppeteer 来进行端对端测试》](http://www.liuyiqi.cn/2017/12/05/e2e-testing-with-jest-and-puppeteer/)，但内容偏向于“快速开始”这种风格，并不涉及一些具体的、实用的操作，所以本篇博客将会补充这一点，即，总结一下端对端测试中常用的 Puppeteer 操作，比如模拟用户输入、执行 JavaScript 脚本、获取某个\b DOM 节点中的文本\b等。\n\n<!--more-->\n\n## 让所有操作可见\n\n还记得上篇博客中的端对端测试的动图演示吗？\n\n![](/css/images/3.gif)\n\n想实现这个效果，就需要将 Puppeteer 的 `headless` 选项设为 \b`false`，并将 `slowMo` 设为 20-100 中的某个值，前者使得所有浏览器自动化操作可见，后者控制了动作之间的间隔，使其变慢，从而通过人眼可以看清每步操作。示例代码：\n\n```js\nbrowser = await puppeteer.launch({\n    headless: false,\n    slowMo: 20\n  });\n```\n\n## 导航到某个页面\n\n这个操作太常用了！第一步是启动浏览器，那么第二步就是导航到某个页面，代码示例：\n\n```js\npage = await browser.newPage();\nawait page.goto('https://baidu.com');\n```\n\n上述代码会开启一个新页面，并将其导航到 `https://baidu.com`。\n\n## 等待某个 DOM 节点出现\n\n在进行某些页面操作前，我们必须要等待指定的 DOM 加载完成后才能操作，比如，一个 Input 没有加载出来时，你是无法在里面输入字符的等等。在 Puppeteer 中，你可以使用 `page.waitForSelector` 和选择器来等待某个 DOM 节点出现：\n\n```js\nawait page.waitForSelector('#loginForm');\n```\n\n上述代码会等待 ID 为 `loginForm` 的节点出现。\n\n## 等待几毫秒\n\n有时候，你找不到某个特定的时刻，只能通过时间间隔来确定，那么此时你可以使用 `page.waitFor(number)` 来实现：\n\n```js\nawait page.waitFor(500);\n```\n\n上述代码会等待 500 毫秒。\n\n## 等待某个 JavaScript 函数返回 true\n\n有时候，你需要等待某个复杂的时刻，这个时刻只能通过一些复杂的 JavaScript 函数来判断，那么此时你可以使用 `page.waitFor(Function)` 来实现：\n\n```js\nawait page.waitFor(() => !document.querySelector('.ant-spin.ant-spin-spinning'));\n```\n\n上述代码会等待 Antd 中的旋转图标消失。\n\n## 向某个 Input 中输入字符\n\n为了模拟用户登陆或仅仅就是输入某个表单，我们经常会向某个 Input 中输入字符，那么我们可以使用这个方法：\n\n```js\nawait page.type('#username', 'lewis');\n```\n\n上述代码向 ID 为 `username` 的 Input 中输入了 `lewis`。值得一提的是，该方法还会触发 Input 的 `keydown`、`keypress`, 和 `keyup` 事件，所以如果你有该事件的相关功能，也会被测试到哦，是不是很强大？\n\n## 点击某个节点\n\n在 Puppeteer 中模拟点击某个节点，非常简单，只需要：\n\n```js\nawait page.click('#btn-submit');\n```\n\n上述代码点击了 ID 为 `btn-submit` 的节点。\n\n## 在浏览器中执行一段 JavaScript 代码\n\n有时候我们需要在浏览器中执行一段 JavaScript 代码，此时你可以这样写：\n\n```js\npage.evaluate(() => alert('1'));\n```\n\n上述代码会在浏览器执行 `alert('1')`。\n\n## 获取某一个节点的某个属性\n\n有时候我们需要获取某个 Input 的 `value`，某个链接的 `href`，某个节点的文本 `textContent`，或者 `outerHTML`，那么你可以使用这个方法：\n\n```js\nconst searchValue = await page.$eval('#search', el => el.value);\nconst preloadHref = await page.$eval('link[rel=preload]', el => el.href);\nconst text = await page.$eval('.text', el => el.textContent);\nconst html = await page.$eval('.main-container', e => e.outerHTML);\n```\n\n## 获取某一类节点的某个属性集合\n\n有时候我们需要获取某一类节点的某个属性集合，那么你可以这么写：\n\n```js\nconst textArray = await page.$$eval('.text', els => Array.from(els).map(el => el.textContent));\n```\n\n上述代码将页面中所有类为 `text` 的节点中的文本拼装为数组放到了 `textArray` 中。\n\n\n以上就是 Puppeteer 的一些常用操作，当然仅仅掌握这些是不够的，更多的操作请参考 Puppeteer 的 API 文档：\n\n<https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md>\n\n## 综合应用小例子\n\n单个操作讲了这么多，我们来进行一次综合应用吧！我们依次让浏览器进行以下自动化操作：\n\n- 打开百度首页\n- 输入`刘一奇的个人博客`\n- 点击搜索按钮\n- 点击第一个搜索项\n- 进入`刘一奇的个人博客`\n- 断言新页面的 `logo` 为`刘一奇的个人博客`\n- 断言新页面的导航栏包括：`主页,归档,关于我` 三项\n\n示例代码： \n\n<https://github.com/lewis617/fe-test/blob/master/puppeteer-demo/liuyiqi-blog.test.js>\n\n```js\nconst puppeteer = require('puppeteer');\n\nlet browser, page;\n\nbeforeAll(async () => {\n  browser = await puppeteer.launch({\n    headless: false,\n    slowMo: 80\n  });\n  page = await browser.newPage();\n});\n\nafterAll(() => {\n  browser.close();\n});\n\ntest('open baidu page', async () => {\n  await page.goto('https://baidu.com');\n});\n\ntest('search liuiqi\\'s blog', async () => {\n  await page.waitForSelector('#kw');\n  await page.type('#kw', '刘一奇的个人博客');\n  await page.click('#su');\n});\n\ntest('goto liuyiqi\\'s blog', async () => {\n  await page.waitForSelector('h3.t > a');\n  await page.click('h3.t:nth-of-type(1) > a');\n\n  const pages = await browser.pages();\n  page = pages.pop();\n  await page.bringToFront();\n});\n\ntest('expect logo is 刘一奇的个人博客', async () => {\n  await page.waitForSelector('#logo');\n  const text = await page.$eval('#logo', el => el.textContent)\n  expect(text).toBe('刘一奇的个人博客');\n});\n\ntest('expect main-nav-link is 主页,归档,关于我', async () => {\n  const textArray = await page.$$eval('.main-nav-link', els => Array.from(els).map(el => el.textContent));\n  expect(textArray).toEqual(['主页', '归档', '关于我']);\n});\n```\n\n效果图：\n\n![](/css/images/1.gif)\n\n至此，端对端测试中常用的 Puppeteer 操作总结就讲完了。有更多操作请查阅官网文档，或给我发邮件，或在本文下方评论。\n\n## 更多测试文章：\n\n<http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/>","source":"_posts/common-puppeteer-api-collection.md","raw":"---\ntitle: 端对端测试中常用的 Puppeteer 操作总结\ndate: 2017-12-05 14:51:00\ntags: [Puppeteer, 测试, 端对端测试, e2e]\n---\n\n上篇博客我们讲解了[《使用 Jest 与 Puppeteer 来进行端对端测试》](http://www.liuyiqi.cn/2017/12/05/e2e-testing-with-jest-and-puppeteer/)，但内容偏向于“快速开始”这种风格，并不涉及一些具体的、实用的操作，所以本篇博客将会补充这一点，即，总结一下端对端测试中常用的 Puppeteer 操作，比如模拟用户输入、执行 JavaScript 脚本、获取某个\b DOM 节点中的文本\b等。\n\n<!--more-->\n\n## 让所有操作可见\n\n还记得上篇博客中的端对端测试的动图演示吗？\n\n![](/css/images/3.gif)\n\n想实现这个效果，就需要将 Puppeteer 的 `headless` 选项设为 \b`false`，并将 `slowMo` 设为 20-100 中的某个值，前者使得所有浏览器自动化操作可见，后者控制了动作之间的间隔，使其变慢，从而通过人眼可以看清每步操作。示例代码：\n\n```js\nbrowser = await puppeteer.launch({\n    headless: false,\n    slowMo: 20\n  });\n```\n\n## 导航到某个页面\n\n这个操作太常用了！第一步是启动浏览器，那么第二步就是导航到某个页面，代码示例：\n\n```js\npage = await browser.newPage();\nawait page.goto('https://baidu.com');\n```\n\n上述代码会开启一个新页面，并将其导航到 `https://baidu.com`。\n\n## 等待某个 DOM 节点出现\n\n在进行某些页面操作前，我们必须要等待指定的 DOM 加载完成后才能操作，比如，一个 Input 没有加载出来时，你是无法在里面输入字符的等等。在 Puppeteer 中，你可以使用 `page.waitForSelector` 和选择器来等待某个 DOM 节点出现：\n\n```js\nawait page.waitForSelector('#loginForm');\n```\n\n上述代码会等待 ID 为 `loginForm` 的节点出现。\n\n## 等待几毫秒\n\n有时候，你找不到某个特定的时刻，只能通过时间间隔来确定，那么此时你可以使用 `page.waitFor(number)` 来实现：\n\n```js\nawait page.waitFor(500);\n```\n\n上述代码会等待 500 毫秒。\n\n## 等待某个 JavaScript 函数返回 true\n\n有时候，你需要等待某个复杂的时刻，这个时刻只能通过一些复杂的 JavaScript 函数来判断，那么此时你可以使用 `page.waitFor(Function)` 来实现：\n\n```js\nawait page.waitFor(() => !document.querySelector('.ant-spin.ant-spin-spinning'));\n```\n\n上述代码会等待 Antd 中的旋转图标消失。\n\n## 向某个 Input 中输入字符\n\n为了模拟用户登陆或仅仅就是输入某个表单，我们经常会向某个 Input 中输入字符，那么我们可以使用这个方法：\n\n```js\nawait page.type('#username', 'lewis');\n```\n\n上述代码向 ID 为 `username` 的 Input 中输入了 `lewis`。值得一提的是，该方法还会触发 Input 的 `keydown`、`keypress`, 和 `keyup` 事件，所以如果你有该事件的相关功能，也会被测试到哦，是不是很强大？\n\n## 点击某个节点\n\n在 Puppeteer 中模拟点击某个节点，非常简单，只需要：\n\n```js\nawait page.click('#btn-submit');\n```\n\n上述代码点击了 ID 为 `btn-submit` 的节点。\n\n## 在浏览器中执行一段 JavaScript 代码\n\n有时候我们需要在浏览器中执行一段 JavaScript 代码，此时你可以这样写：\n\n```js\npage.evaluate(() => alert('1'));\n```\n\n上述代码会在浏览器执行 `alert('1')`。\n\n## 获取某一个节点的某个属性\n\n有时候我们需要获取某个 Input 的 `value`，某个链接的 `href`，某个节点的文本 `textContent`，或者 `outerHTML`，那么你可以使用这个方法：\n\n```js\nconst searchValue = await page.$eval('#search', el => el.value);\nconst preloadHref = await page.$eval('link[rel=preload]', el => el.href);\nconst text = await page.$eval('.text', el => el.textContent);\nconst html = await page.$eval('.main-container', e => e.outerHTML);\n```\n\n## 获取某一类节点的某个属性集合\n\n有时候我们需要获取某一类节点的某个属性集合，那么你可以这么写：\n\n```js\nconst textArray = await page.$$eval('.text', els => Array.from(els).map(el => el.textContent));\n```\n\n上述代码将页面中所有类为 `text` 的节点中的文本拼装为数组放到了 `textArray` 中。\n\n\n以上就是 Puppeteer 的一些常用操作，当然仅仅掌握这些是不够的，更多的操作请参考 Puppeteer 的 API 文档：\n\n<https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md>\n\n## 综合应用小例子\n\n单个操作讲了这么多，我们来进行一次综合应用吧！我们依次让浏览器进行以下自动化操作：\n\n- 打开百度首页\n- 输入`刘一奇的个人博客`\n- 点击搜索按钮\n- 点击第一个搜索项\n- 进入`刘一奇的个人博客`\n- 断言新页面的 `logo` 为`刘一奇的个人博客`\n- 断言新页面的导航栏包括：`主页,归档,关于我` 三项\n\n示例代码： \n\n<https://github.com/lewis617/fe-test/blob/master/puppeteer-demo/liuyiqi-blog.test.js>\n\n```js\nconst puppeteer = require('puppeteer');\n\nlet browser, page;\n\nbeforeAll(async () => {\n  browser = await puppeteer.launch({\n    headless: false,\n    slowMo: 80\n  });\n  page = await browser.newPage();\n});\n\nafterAll(() => {\n  browser.close();\n});\n\ntest('open baidu page', async () => {\n  await page.goto('https://baidu.com');\n});\n\ntest('search liuiqi\\'s blog', async () => {\n  await page.waitForSelector('#kw');\n  await page.type('#kw', '刘一奇的个人博客');\n  await page.click('#su');\n});\n\ntest('goto liuyiqi\\'s blog', async () => {\n  await page.waitForSelector('h3.t > a');\n  await page.click('h3.t:nth-of-type(1) > a');\n\n  const pages = await browser.pages();\n  page = pages.pop();\n  await page.bringToFront();\n});\n\ntest('expect logo is 刘一奇的个人博客', async () => {\n  await page.waitForSelector('#logo');\n  const text = await page.$eval('#logo', el => el.textContent)\n  expect(text).toBe('刘一奇的个人博客');\n});\n\ntest('expect main-nav-link is 主页,归档,关于我', async () => {\n  const textArray = await page.$$eval('.main-nav-link', els => Array.from(els).map(el => el.textContent));\n  expect(textArray).toEqual(['主页', '归档', '关于我']);\n});\n```\n\n效果图：\n\n![](/css/images/1.gif)\n\n至此，端对端测试中常用的 Puppeteer 操作总结就讲完了。有更多操作请查阅官网文档，或给我发邮件，或在本文下方评论。\n\n## 更多测试文章：\n\n<http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/>","slug":"common-puppeteer-api-collection","published":1,"updated":"2019-05-01T08:10:29.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvkz0005tgytoyohak5w","content":"<p>上篇博客我们讲解了<a href=\"http://www.liuyiqi.cn/2017/12/05/e2e-testing-with-jest-and-puppeteer/\">《使用 Jest 与 Puppeteer 来进行端对端测试》</a>，但内容偏向于“快速开始”这种风格，并不涉及一些具体的、实用的操作，所以本篇博客将会补充这一点，即，总结一下端对端测试中常用的 Puppeteer 操作，比如模拟用户输入、执行 JavaScript 脚本、获取某个\b DOM 节点中的文本\b等。</p>\n<a id=\"more\"></a>\n<h2 id=\"让所有操作可见\"><a href=\"#让所有操作可见\" class=\"headerlink\" title=\"让所有操作可见\"></a>让所有操作可见</h2><p>还记得上篇博客中的端对端测试的动图演示吗？</p>\n<p><img src=\"/css/images/3.gif\" alt=\"\"></p>\n<p>想实现这个效果，就需要将 Puppeteer 的 <code>headless</code> 选项设为 \b<code>false</code>，并将 <code>slowMo</code> 设为 20-100 中的某个值，前者使得所有浏览器自动化操作可见，后者控制了动作之间的间隔，使其变慢，从而通过人眼可以看清每步操作。示例代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">browser = <span class=\"keyword\">await</span> puppeteer.launch(&#123;</span><br><span class=\"line\">    headless: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    slowMo: <span class=\"number\">20</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"导航到某个页面\"><a href=\"#导航到某个页面\" class=\"headerlink\" title=\"导航到某个页面\"></a>导航到某个页面</h2><p>这个操作太常用了！第一步是启动浏览器，那么第二步就是导航到某个页面，代码示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">page = <span class=\"keyword\">await</span> browser.newPage();</span><br><span class=\"line\"><span class=\"keyword\">await</span> page.goto(<span class=\"string\">'https://baidu.com'</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码会开启一个新页面，并将其导航到 <code>https://baidu.com</code>。</p>\n<h2 id=\"等待某个-DOM-节点出现\"><a href=\"#等待某个-DOM-节点出现\" class=\"headerlink\" title=\"等待某个 DOM 节点出现\"></a>等待某个 DOM 节点出现</h2><p>在进行某些页面操作前，我们必须要等待指定的 DOM 加载完成后才能操作，比如，一个 Input 没有加载出来时，你是无法在里面输入字符的等等。在 Puppeteer 中，你可以使用 <code>page.waitForSelector</code> 和选择器来等待某个 DOM 节点出现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> page.waitForSelector(<span class=\"string\">'#loginForm'</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码会等待 ID 为 <code>loginForm</code> 的节点出现。</p>\n<h2 id=\"等待几毫秒\"><a href=\"#等待几毫秒\" class=\"headerlink\" title=\"等待几毫秒\"></a>等待几毫秒</h2><p>有时候，你找不到某个特定的时刻，只能通过时间间隔来确定，那么此时你可以使用 <code>page.waitFor(number)</code> 来实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> page.waitFor(<span class=\"number\">500</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码会等待 500 毫秒。</p>\n<h2 id=\"等待某个-JavaScript-函数返回-true\"><a href=\"#等待某个-JavaScript-函数返回-true\" class=\"headerlink\" title=\"等待某个 JavaScript 函数返回 true\"></a>等待某个 JavaScript 函数返回 true</h2><p>有时候，你需要等待某个复杂的时刻，这个时刻只能通过一些复杂的 JavaScript 函数来判断，那么此时你可以使用 <code>page.waitFor(Function)</code> 来实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> page.waitFor(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> !<span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.ant-spin.ant-spin-spinning'</span>));</span><br></pre></td></tr></table></figure>\n<p>上述代码会等待 Antd 中的旋转图标消失。</p>\n<h2 id=\"向某个-Input-中输入字符\"><a href=\"#向某个-Input-中输入字符\" class=\"headerlink\" title=\"向某个 Input 中输入字符\"></a>向某个 Input 中输入字符</h2><p>为了模拟用户登陆或仅仅就是输入某个表单，我们经常会向某个 Input 中输入字符，那么我们可以使用这个方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> page.type(<span class=\"string\">'#username'</span>, <span class=\"string\">'lewis'</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码向 ID 为 <code>username</code> 的 Input 中输入了 <code>lewis</code>。值得一提的是，该方法还会触发 Input 的 <code>keydown</code>、<code>keypress</code>, 和 <code>keyup</code> 事件，所以如果你有该事件的相关功能，也会被测试到哦，是不是很强大？</p>\n<h2 id=\"点击某个节点\"><a href=\"#点击某个节点\" class=\"headerlink\" title=\"点击某个节点\"></a>点击某个节点</h2><p>在 Puppeteer 中模拟点击某个节点，非常简单，只需要：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> page.click(<span class=\"string\">'#btn-submit'</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码点击了 ID 为 <code>btn-submit</code> 的节点。</p>\n<h2 id=\"在浏览器中执行一段-JavaScript-代码\"><a href=\"#在浏览器中执行一段-JavaScript-代码\" class=\"headerlink\" title=\"在浏览器中执行一段 JavaScript 代码\"></a>在浏览器中执行一段 JavaScript 代码</h2><p>有时候我们需要在浏览器中执行一段 JavaScript 代码，此时你可以这样写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">page.evaluate(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> alert(<span class=\"string\">'1'</span>));</span><br></pre></td></tr></table></figure>\n<p>上述代码会在浏览器执行 <code>alert(&#39;1&#39;)</code>。</p>\n<h2 id=\"获取某一个节点的某个属性\"><a href=\"#获取某一个节点的某个属性\" class=\"headerlink\" title=\"获取某一个节点的某个属性\"></a>获取某一个节点的某个属性</h2><p>有时候我们需要获取某个 Input 的 <code>value</code>，某个链接的 <code>href</code>，某个节点的文本 <code>textContent</code>，或者 <code>outerHTML</code>，那么你可以使用这个方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> searchValue = <span class=\"keyword\">await</span> page.$<span class=\"built_in\">eval</span>(<span class=\"string\">'#search'</span>, el =&gt; el.value);</span><br><span class=\"line\"><span class=\"keyword\">const</span> preloadHref = <span class=\"keyword\">await</span> page.$<span class=\"built_in\">eval</span>(<span class=\"string\">'link[rel=preload]'</span>, el =&gt; el.href);</span><br><span class=\"line\"><span class=\"keyword\">const</span> text = <span class=\"keyword\">await</span> page.$<span class=\"built_in\">eval</span>(<span class=\"string\">'.text'</span>, el =&gt; el.textContent);</span><br><span class=\"line\"><span class=\"keyword\">const</span> html = <span class=\"keyword\">await</span> page.$<span class=\"built_in\">eval</span>(<span class=\"string\">'.main-container'</span>, e =&gt; e.outerHTML);</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取某一类节点的某个属性集合\"><a href=\"#获取某一类节点的某个属性集合\" class=\"headerlink\" title=\"获取某一类节点的某个属性集合\"></a>获取某一类节点的某个属性集合</h2><p>有时候我们需要获取某一类节点的某个属性集合，那么你可以这么写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> textArray = <span class=\"keyword\">await</span> page.$$<span class=\"built_in\">eval</span>(<span class=\"string\">'.text'</span>, els =&gt; <span class=\"built_in\">Array</span>.from(els).map(<span class=\"function\"><span class=\"params\">el</span> =&gt;</span> el.textContent));</span><br></pre></td></tr></table></figure>\n<p>上述代码将页面中所有类为 <code>text</code> 的节点中的文本拼装为数组放到了 <code>textArray</code> 中。</p>\n<p>以上就是 Puppeteer 的一些常用操作，当然仅仅掌握这些是不够的，更多的操作请参考 Puppeteer 的 API 文档：</p>\n<p><a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md\" target=\"_blank\" rel=\"noopener\">https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md</a></p>\n<h2 id=\"综合应用小例子\"><a href=\"#综合应用小例子\" class=\"headerlink\" title=\"综合应用小例子\"></a>综合应用小例子</h2><p>单个操作讲了这么多，我们来进行一次综合应用吧！我们依次让浏览器进行以下自动化操作：</p>\n<ul>\n<li>打开百度首页</li>\n<li>输入<code>刘一奇的个人博客</code></li>\n<li>点击搜索按钮</li>\n<li>点击第一个搜索项</li>\n<li>进入<code>刘一奇的个人博客</code></li>\n<li>断言新页面的 <code>logo</code> 为<code>刘一奇的个人博客</code></li>\n<li>断言新页面的导航栏包括：<code>主页,归档,关于我</code> 三项</li>\n</ul>\n<p>示例代码： </p>\n<p><a href=\"https://github.com/lewis617/fe-test/blob/master/puppeteer-demo/liuyiqi-blog.test.js\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/fe-test/blob/master/puppeteer-demo/liuyiqi-blog.test.js</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> puppeteer = <span class=\"built_in\">require</span>(<span class=\"string\">'puppeteer'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> browser, page;</span><br><span class=\"line\"></span><br><span class=\"line\">beforeAll(<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  browser = <span class=\"keyword\">await</span> puppeteer.launch(&#123;</span><br><span class=\"line\">    headless: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    slowMo: <span class=\"number\">80</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  page = <span class=\"keyword\">await</span> browser.newPage();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">afterAll(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  browser.close();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'open baidu page'</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.goto(<span class=\"string\">'https://baidu.com'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'search liuiqi\\'s blog'</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.waitForSelector(<span class=\"string\">'#kw'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.type(<span class=\"string\">'#kw'</span>, <span class=\"string\">'刘一奇的个人博客'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.click(<span class=\"string\">'#su'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'goto liuyiqi\\'s blog'</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.waitForSelector(<span class=\"string\">'h3.t &gt; a'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.click(<span class=\"string\">'h3.t:nth-of-type(1) &gt; a'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> pages = <span class=\"keyword\">await</span> browser.pages();</span><br><span class=\"line\">  page = pages.pop();</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.bringToFront();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'expect logo is 刘一奇的个人博客'</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.waitForSelector(<span class=\"string\">'#logo'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> text = <span class=\"keyword\">await</span> page.$<span class=\"built_in\">eval</span>(<span class=\"string\">'#logo'</span>, el =&gt; el.textContent)</span><br><span class=\"line\">  expect(text).toBe(<span class=\"string\">'刘一奇的个人博客'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'expect main-nav-link is 主页,归档,关于我'</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> textArray = <span class=\"keyword\">await</span> page.$$<span class=\"built_in\">eval</span>(<span class=\"string\">'.main-nav-link'</span>, els =&gt; <span class=\"built_in\">Array</span>.from(els).map(<span class=\"function\"><span class=\"params\">el</span> =&gt;</span> el.textContent));</span><br><span class=\"line\">  expect(textArray).toEqual([<span class=\"string\">'主页'</span>, <span class=\"string\">'归档'</span>, <span class=\"string\">'关于我'</span>]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>效果图：</p>\n<p><img src=\"/css/images/1.gif\" alt=\"\"></p>\n<p>至此，端对端测试中常用的 Puppeteer 操作总结就讲完了。有更多操作请查阅官网文档，或给我发邮件，或在本文下方评论。</p>\n<h2 id=\"更多测试文章：\"><a href=\"#更多测试文章：\" class=\"headerlink\" title=\"更多测试文章：\"></a>更多测试文章：</h2><p><a href=\"http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/\">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>\n","site":{"data":{}},"excerpt":"<p>上篇博客我们讲解了<a href=\"http://www.liuyiqi.cn/2017/12/05/e2e-testing-with-jest-and-puppeteer/\">《使用 Jest 与 Puppeteer 来进行端对端测试》</a>，但内容偏向于“快速开始”这种风格，并不涉及一些具体的、实用的操作，所以本篇博客将会补充这一点，即，总结一下端对端测试中常用的 Puppeteer 操作，比如模拟用户输入、执行 JavaScript 脚本、获取某个\b DOM 节点中的文本\b等。</p>","more":"<h2 id=\"让所有操作可见\"><a href=\"#让所有操作可见\" class=\"headerlink\" title=\"让所有操作可见\"></a>让所有操作可见</h2><p>还记得上篇博客中的端对端测试的动图演示吗？</p>\n<p><img src=\"/css/images/3.gif\" alt=\"\"></p>\n<p>想实现这个效果，就需要将 Puppeteer 的 <code>headless</code> 选项设为 \b<code>false</code>，并将 <code>slowMo</code> 设为 20-100 中的某个值，前者使得所有浏览器自动化操作可见，后者控制了动作之间的间隔，使其变慢，从而通过人眼可以看清每步操作。示例代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">browser = <span class=\"keyword\">await</span> puppeteer.launch(&#123;</span><br><span class=\"line\">    headless: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    slowMo: <span class=\"number\">20</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"导航到某个页面\"><a href=\"#导航到某个页面\" class=\"headerlink\" title=\"导航到某个页面\"></a>导航到某个页面</h2><p>这个操作太常用了！第一步是启动浏览器，那么第二步就是导航到某个页面，代码示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">page = <span class=\"keyword\">await</span> browser.newPage();</span><br><span class=\"line\"><span class=\"keyword\">await</span> page.goto(<span class=\"string\">'https://baidu.com'</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码会开启一个新页面，并将其导航到 <code>https://baidu.com</code>。</p>\n<h2 id=\"等待某个-DOM-节点出现\"><a href=\"#等待某个-DOM-节点出现\" class=\"headerlink\" title=\"等待某个 DOM 节点出现\"></a>等待某个 DOM 节点出现</h2><p>在进行某些页面操作前，我们必须要等待指定的 DOM 加载完成后才能操作，比如，一个 Input 没有加载出来时，你是无法在里面输入字符的等等。在 Puppeteer 中，你可以使用 <code>page.waitForSelector</code> 和选择器来等待某个 DOM 节点出现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> page.waitForSelector(<span class=\"string\">'#loginForm'</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码会等待 ID 为 <code>loginForm</code> 的节点出现。</p>\n<h2 id=\"等待几毫秒\"><a href=\"#等待几毫秒\" class=\"headerlink\" title=\"等待几毫秒\"></a>等待几毫秒</h2><p>有时候，你找不到某个特定的时刻，只能通过时间间隔来确定，那么此时你可以使用 <code>page.waitFor(number)</code> 来实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> page.waitFor(<span class=\"number\">500</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码会等待 500 毫秒。</p>\n<h2 id=\"等待某个-JavaScript-函数返回-true\"><a href=\"#等待某个-JavaScript-函数返回-true\" class=\"headerlink\" title=\"等待某个 JavaScript 函数返回 true\"></a>等待某个 JavaScript 函数返回 true</h2><p>有时候，你需要等待某个复杂的时刻，这个时刻只能通过一些复杂的 JavaScript 函数来判断，那么此时你可以使用 <code>page.waitFor(Function)</code> 来实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> page.waitFor(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> !<span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.ant-spin.ant-spin-spinning'</span>));</span><br></pre></td></tr></table></figure>\n<p>上述代码会等待 Antd 中的旋转图标消失。</p>\n<h2 id=\"向某个-Input-中输入字符\"><a href=\"#向某个-Input-中输入字符\" class=\"headerlink\" title=\"向某个 Input 中输入字符\"></a>向某个 Input 中输入字符</h2><p>为了模拟用户登陆或仅仅就是输入某个表单，我们经常会向某个 Input 中输入字符，那么我们可以使用这个方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> page.type(<span class=\"string\">'#username'</span>, <span class=\"string\">'lewis'</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码向 ID 为 <code>username</code> 的 Input 中输入了 <code>lewis</code>。值得一提的是，该方法还会触发 Input 的 <code>keydown</code>、<code>keypress</code>, 和 <code>keyup</code> 事件，所以如果你有该事件的相关功能，也会被测试到哦，是不是很强大？</p>\n<h2 id=\"点击某个节点\"><a href=\"#点击某个节点\" class=\"headerlink\" title=\"点击某个节点\"></a>点击某个节点</h2><p>在 Puppeteer 中模拟点击某个节点，非常简单，只需要：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> page.click(<span class=\"string\">'#btn-submit'</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码点击了 ID 为 <code>btn-submit</code> 的节点。</p>\n<h2 id=\"在浏览器中执行一段-JavaScript-代码\"><a href=\"#在浏览器中执行一段-JavaScript-代码\" class=\"headerlink\" title=\"在浏览器中执行一段 JavaScript 代码\"></a>在浏览器中执行一段 JavaScript 代码</h2><p>有时候我们需要在浏览器中执行一段 JavaScript 代码，此时你可以这样写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">page.evaluate(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> alert(<span class=\"string\">'1'</span>));</span><br></pre></td></tr></table></figure>\n<p>上述代码会在浏览器执行 <code>alert(&#39;1&#39;)</code>。</p>\n<h2 id=\"获取某一个节点的某个属性\"><a href=\"#获取某一个节点的某个属性\" class=\"headerlink\" title=\"获取某一个节点的某个属性\"></a>获取某一个节点的某个属性</h2><p>有时候我们需要获取某个 Input 的 <code>value</code>，某个链接的 <code>href</code>，某个节点的文本 <code>textContent</code>，或者 <code>outerHTML</code>，那么你可以使用这个方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> searchValue = <span class=\"keyword\">await</span> page.$<span class=\"built_in\">eval</span>(<span class=\"string\">'#search'</span>, el =&gt; el.value);</span><br><span class=\"line\"><span class=\"keyword\">const</span> preloadHref = <span class=\"keyword\">await</span> page.$<span class=\"built_in\">eval</span>(<span class=\"string\">'link[rel=preload]'</span>, el =&gt; el.href);</span><br><span class=\"line\"><span class=\"keyword\">const</span> text = <span class=\"keyword\">await</span> page.$<span class=\"built_in\">eval</span>(<span class=\"string\">'.text'</span>, el =&gt; el.textContent);</span><br><span class=\"line\"><span class=\"keyword\">const</span> html = <span class=\"keyword\">await</span> page.$<span class=\"built_in\">eval</span>(<span class=\"string\">'.main-container'</span>, e =&gt; e.outerHTML);</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取某一类节点的某个属性集合\"><a href=\"#获取某一类节点的某个属性集合\" class=\"headerlink\" title=\"获取某一类节点的某个属性集合\"></a>获取某一类节点的某个属性集合</h2><p>有时候我们需要获取某一类节点的某个属性集合，那么你可以这么写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> textArray = <span class=\"keyword\">await</span> page.$$<span class=\"built_in\">eval</span>(<span class=\"string\">'.text'</span>, els =&gt; <span class=\"built_in\">Array</span>.from(els).map(<span class=\"function\"><span class=\"params\">el</span> =&gt;</span> el.textContent));</span><br></pre></td></tr></table></figure>\n<p>上述代码将页面中所有类为 <code>text</code> 的节点中的文本拼装为数组放到了 <code>textArray</code> 中。</p>\n<p>以上就是 Puppeteer 的一些常用操作，当然仅仅掌握这些是不够的，更多的操作请参考 Puppeteer 的 API 文档：</p>\n<p><a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md\" target=\"_blank\" rel=\"noopener\">https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md</a></p>\n<h2 id=\"综合应用小例子\"><a href=\"#综合应用小例子\" class=\"headerlink\" title=\"综合应用小例子\"></a>综合应用小例子</h2><p>单个操作讲了这么多，我们来进行一次综合应用吧！我们依次让浏览器进行以下自动化操作：</p>\n<ul>\n<li>打开百度首页</li>\n<li>输入<code>刘一奇的个人博客</code></li>\n<li>点击搜索按钮</li>\n<li>点击第一个搜索项</li>\n<li>进入<code>刘一奇的个人博客</code></li>\n<li>断言新页面的 <code>logo</code> 为<code>刘一奇的个人博客</code></li>\n<li>断言新页面的导航栏包括：<code>主页,归档,关于我</code> 三项</li>\n</ul>\n<p>示例代码： </p>\n<p><a href=\"https://github.com/lewis617/fe-test/blob/master/puppeteer-demo/liuyiqi-blog.test.js\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/fe-test/blob/master/puppeteer-demo/liuyiqi-blog.test.js</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> puppeteer = <span class=\"built_in\">require</span>(<span class=\"string\">'puppeteer'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> browser, page;</span><br><span class=\"line\"></span><br><span class=\"line\">beforeAll(<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  browser = <span class=\"keyword\">await</span> puppeteer.launch(&#123;</span><br><span class=\"line\">    headless: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    slowMo: <span class=\"number\">80</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  page = <span class=\"keyword\">await</span> browser.newPage();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">afterAll(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  browser.close();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'open baidu page'</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.goto(<span class=\"string\">'https://baidu.com'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'search liuiqi\\'s blog'</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.waitForSelector(<span class=\"string\">'#kw'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.type(<span class=\"string\">'#kw'</span>, <span class=\"string\">'刘一奇的个人博客'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.click(<span class=\"string\">'#su'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'goto liuyiqi\\'s blog'</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.waitForSelector(<span class=\"string\">'h3.t &gt; a'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.click(<span class=\"string\">'h3.t:nth-of-type(1) &gt; a'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> pages = <span class=\"keyword\">await</span> browser.pages();</span><br><span class=\"line\">  page = pages.pop();</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.bringToFront();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'expect logo is 刘一奇的个人博客'</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.waitForSelector(<span class=\"string\">'#logo'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> text = <span class=\"keyword\">await</span> page.$<span class=\"built_in\">eval</span>(<span class=\"string\">'#logo'</span>, el =&gt; el.textContent)</span><br><span class=\"line\">  expect(text).toBe(<span class=\"string\">'刘一奇的个人博客'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'expect main-nav-link is 主页,归档,关于我'</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> textArray = <span class=\"keyword\">await</span> page.$$<span class=\"built_in\">eval</span>(<span class=\"string\">'.main-nav-link'</span>, els =&gt; <span class=\"built_in\">Array</span>.from(els).map(<span class=\"function\"><span class=\"params\">el</span> =&gt;</span> el.textContent));</span><br><span class=\"line\">  expect(textArray).toEqual([<span class=\"string\">'主页'</span>, <span class=\"string\">'归档'</span>, <span class=\"string\">'关于我'</span>]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>效果图：</p>\n<p><img src=\"/css/images/1.gif\" alt=\"\"></p>\n<p>至此，端对端测试中常用的 Puppeteer 操作总结就讲完了。有更多操作请查阅官网文档，或给我发邮件，或在本文下方评论。</p>\n<h2 id=\"更多测试文章：\"><a href=\"#更多测试文章：\" class=\"headerlink\" title=\"更多测试文章：\"></a>更多测试文章：</h2><p><a href=\"http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/\">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>"},{"title":"JavaScript 版链表算法题：两个数相加","date":"2017-03-12T03:41:00.000Z","_content":"\n今天，我们要讲的是一道链表算法题：两个数相加。这道题有两个版本，它们都来自 LeetCode：\n\nhttps://leetcode.com/problems/add-two-numbers/\n\nhttps://leetcode.com/problems/add-two-numbers-ii/\n\n本文将先回顾链表的基础知识，然后解决这两个问题，所用的语言依然是 JavaScript。\n\n<!--more-->\n\n## 链表基础\n\n在前面的博文[《JavaScript 版数据结构与算法（三）链表》](https://lewis617.github.io/2017/02/15/linked-list/)中，我们讲解了：\n\n- 什么是链表？\n- 链表的作用？\n- 链表的数据结构长啥样？\n- 如何用 JavaScript 编写一个链表类，并实现 `append`、`toString`、`removeAt`、`insert`、`indexOf` 等多个链表方法。\n\n这些基础知识对做链表题非常有帮助，如果你之前没有阅读过这篇博文，那么我强烈建议你读一遍，然后自己写一个链表类。如果你对链表的基础知识比较熟悉，那么就继续往下读吧！\n\n## 两个数相加\n\n让我们开始做题吧！首先，先来看下题目：\n\n> 给你两个非空的链表来表示两个非负整数。整数的每个数字倒序存储在链表的每个节点中。现在你需要写一个函数，将两个整数相加，并以链表的形式返回它们的和。\n> \n> 你可以假设两个整数没有任何前导零，除非是零本身。\n\n我们再通过测试用例来表达一下题意：\n\n```\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8\n\nInput: (1 -> 8) + (0)\nOutput: 1 -> 8\n\nInput: (9) + (1)\nOutput: 0 -> 1\n```\n\n要实现的函数以及链表的结构是：\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n}\n```\n\n题目表述完了，那么如何做呢？其实两个数相加的逻辑非常简单，无非是：\n\n- 从个位开始相加，生成的数字的个位数就是新数字的个位数，十位数放到下个数中相加。\n- 对其他位数执行上述操作。\n\n这个小学生都会，那么如何在链表中实现呢？这需要你了解链表几个常用操作：\n\n- 如何遍历链表？\n- 如何生成新链表？\n\n如何遍历链表呢？非常简单，你需要一个 `current` 指针（其实就是个变量），然后在 while 循环中执行 `current = current.next` 即可。\n\n如何生成新链表？这也非常简单，你只需要一个 `current` 指针指向链表最后一位，然后执行 `current.next = new Node(val)` 即可。\n\n了解了链表的这两个操作，然后我们对前两个链表进行遍历相加，生成新链表即可。为此，我们需要设置几个变量：\n\n- 三个链表的 `current` 指针：`c1`、`c2`、`c3`。\n- 新链表：`l3`。\n- 放到下一位相加的数字：`carry`。\n\n完整代码就是：\n\nLeetCode/002-addTwoNumbers.js\n\n```js\nvar addTwoNumbers = function (l1, l2) {\n  var c1 = l1,\n    c2 = l2,\n    l3, c3,\n    carry = 0;\n\n  while (c1 || c2 || carry) {\n    var v1 = 0,\n      v2 = 0;\n    \n    // 这么做是为了防止整数中当前位上没有数字\n    if (c1) {\n      v1 = c1.val;\n      c1 = c1.next;\n    }\n\n    if (c2) {\n      v2 = c2.val;\n      c2 = c2.next;\n    }\n\n    var sum = v1 + v2 + carry;\n    carry = Math.floor(sum / 10);\n\n    if (!c3) {\n      l3 = new ListNode(sum % 10);\n      c3 = l3;\n    } else {\n      c3.next = new ListNode(sum % 10);\n      c3 = c3.next;\n    }\n\n  }\n  return l3;\n};\n```\n\n## 两个数相加第二版\n\n上面的题目相对来说还是比较简单的，因为两个数相加是从低位到高位，而链表遍历是从前面到后面，正好是一致的。那么如果我们将整数的每个数字正序存贮在链表中，如何实现这道题呢？\n\n```\nInput: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 8 -> 0 -> 7\n\nInput: (7) + (5)\nOutput: 1 -> 2\n```\n\n虽然正序存储更符合我们的书写阅读整数的习惯，但在链表中执行相加操作时却很麻烦，我们需要从低位开始计算才行。那么如何解决这个问题呢？答案是使用栈！\n\n- 先遍历两个链表，将数字 push 到各自的栈中。\n- 然后依次 pop 出数字进行相加操作，生成的新数字存储在第三个栈中。\n- 最后将第三个栈的每个数字 pop 出来添加到新链表中。\n\n完整代码是：\n\n\nLeetCode/445-addTwoNumbers2.js\n\n```js\nvar addTwoNumbers = function (l1, l2) {\n  var c1 = l1,\n    c2 = l2,\n    l3, c3,\n    s1 = [],\n    s2 = [],\n    s3 = [],\n    carry = 0;\n\n  while (c1 || c2) {\n    if (c1) {\n      s1.push(c1.val);\n      c1 = c1.next;\n    }\n\n    if (c2) {\n      s2.push(c2.val);\n      c2 = c2.next;\n    }\n  }\n\n  while (s1.length || s2.length || carry) {\n    var v1 = 0,\n      v2 = 0;\n\n    if (s1.length) {\n      v1 = s1.pop();\n    }\n\n    if (s2.length) {\n      v2 = s2.pop();\n    }\n\n    var sum = v1 + v2 + carry;\n    carry = Math.floor(sum / 10);\n\n    s3.push(sum % 10);\n  }\n\n  while (s3.length) {\n    var val = s3.pop();\n    if (!c3) {\n      l3 = new ListNode(val);\n      c3 = l3;\n    } else {\n      c3.next = new ListNode(val);\n      c3 = c3.next;\n    }\n  }\n  return l3;\n};\n```\n\n## 总结\n\n两个数相加这道题的本质是考察链表和栈的操作，所以如果你对链表和栈的数据结构和常用操作非常熟悉，那么做这道题就是小菜一碟！\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","source":"_posts/add-two-numbers.md","raw":"---\ntitle: JavaScript 版链表算法题：两个数相加\ndate: 2017-03-12 11:41:00\ntags: [数据结构与算法, LeetCode]\n---\n\n今天，我们要讲的是一道链表算法题：两个数相加。这道题有两个版本，它们都来自 LeetCode：\n\nhttps://leetcode.com/problems/add-two-numbers/\n\nhttps://leetcode.com/problems/add-two-numbers-ii/\n\n本文将先回顾链表的基础知识，然后解决这两个问题，所用的语言依然是 JavaScript。\n\n<!--more-->\n\n## 链表基础\n\n在前面的博文[《JavaScript 版数据结构与算法（三）链表》](https://lewis617.github.io/2017/02/15/linked-list/)中，我们讲解了：\n\n- 什么是链表？\n- 链表的作用？\n- 链表的数据结构长啥样？\n- 如何用 JavaScript 编写一个链表类，并实现 `append`、`toString`、`removeAt`、`insert`、`indexOf` 等多个链表方法。\n\n这些基础知识对做链表题非常有帮助，如果你之前没有阅读过这篇博文，那么我强烈建议你读一遍，然后自己写一个链表类。如果你对链表的基础知识比较熟悉，那么就继续往下读吧！\n\n## 两个数相加\n\n让我们开始做题吧！首先，先来看下题目：\n\n> 给你两个非空的链表来表示两个非负整数。整数的每个数字倒序存储在链表的每个节点中。现在你需要写一个函数，将两个整数相加，并以链表的形式返回它们的和。\n> \n> 你可以假设两个整数没有任何前导零，除非是零本身。\n\n我们再通过测试用例来表达一下题意：\n\n```\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8\n\nInput: (1 -> 8) + (0)\nOutput: 1 -> 8\n\nInput: (9) + (1)\nOutput: 0 -> 1\n```\n\n要实现的函数以及链表的结构是：\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n}\n```\n\n题目表述完了，那么如何做呢？其实两个数相加的逻辑非常简单，无非是：\n\n- 从个位开始相加，生成的数字的个位数就是新数字的个位数，十位数放到下个数中相加。\n- 对其他位数执行上述操作。\n\n这个小学生都会，那么如何在链表中实现呢？这需要你了解链表几个常用操作：\n\n- 如何遍历链表？\n- 如何生成新链表？\n\n如何遍历链表呢？非常简单，你需要一个 `current` 指针（其实就是个变量），然后在 while 循环中执行 `current = current.next` 即可。\n\n如何生成新链表？这也非常简单，你只需要一个 `current` 指针指向链表最后一位，然后执行 `current.next = new Node(val)` 即可。\n\n了解了链表的这两个操作，然后我们对前两个链表进行遍历相加，生成新链表即可。为此，我们需要设置几个变量：\n\n- 三个链表的 `current` 指针：`c1`、`c2`、`c3`。\n- 新链表：`l3`。\n- 放到下一位相加的数字：`carry`。\n\n完整代码就是：\n\nLeetCode/002-addTwoNumbers.js\n\n```js\nvar addTwoNumbers = function (l1, l2) {\n  var c1 = l1,\n    c2 = l2,\n    l3, c3,\n    carry = 0;\n\n  while (c1 || c2 || carry) {\n    var v1 = 0,\n      v2 = 0;\n    \n    // 这么做是为了防止整数中当前位上没有数字\n    if (c1) {\n      v1 = c1.val;\n      c1 = c1.next;\n    }\n\n    if (c2) {\n      v2 = c2.val;\n      c2 = c2.next;\n    }\n\n    var sum = v1 + v2 + carry;\n    carry = Math.floor(sum / 10);\n\n    if (!c3) {\n      l3 = new ListNode(sum % 10);\n      c3 = l3;\n    } else {\n      c3.next = new ListNode(sum % 10);\n      c3 = c3.next;\n    }\n\n  }\n  return l3;\n};\n```\n\n## 两个数相加第二版\n\n上面的题目相对来说还是比较简单的，因为两个数相加是从低位到高位，而链表遍历是从前面到后面，正好是一致的。那么如果我们将整数的每个数字正序存贮在链表中，如何实现这道题呢？\n\n```\nInput: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 8 -> 0 -> 7\n\nInput: (7) + (5)\nOutput: 1 -> 2\n```\n\n虽然正序存储更符合我们的书写阅读整数的习惯，但在链表中执行相加操作时却很麻烦，我们需要从低位开始计算才行。那么如何解决这个问题呢？答案是使用栈！\n\n- 先遍历两个链表，将数字 push 到各自的栈中。\n- 然后依次 pop 出数字进行相加操作，生成的新数字存储在第三个栈中。\n- 最后将第三个栈的每个数字 pop 出来添加到新链表中。\n\n完整代码是：\n\n\nLeetCode/445-addTwoNumbers2.js\n\n```js\nvar addTwoNumbers = function (l1, l2) {\n  var c1 = l1,\n    c2 = l2,\n    l3, c3,\n    s1 = [],\n    s2 = [],\n    s3 = [],\n    carry = 0;\n\n  while (c1 || c2) {\n    if (c1) {\n      s1.push(c1.val);\n      c1 = c1.next;\n    }\n\n    if (c2) {\n      s2.push(c2.val);\n      c2 = c2.next;\n    }\n  }\n\n  while (s1.length || s2.length || carry) {\n    var v1 = 0,\n      v2 = 0;\n\n    if (s1.length) {\n      v1 = s1.pop();\n    }\n\n    if (s2.length) {\n      v2 = s2.pop();\n    }\n\n    var sum = v1 + v2 + carry;\n    carry = Math.floor(sum / 10);\n\n    s3.push(sum % 10);\n  }\n\n  while (s3.length) {\n    var val = s3.pop();\n    if (!c3) {\n      l3 = new ListNode(val);\n      c3 = l3;\n    } else {\n      c3.next = new ListNode(val);\n      c3 = c3.next;\n    }\n  }\n  return l3;\n};\n```\n\n## 总结\n\n两个数相加这道题的本质是考察链表和栈的操作，所以如果你对链表和栈的数据结构和常用操作非常熟悉，那么做这道题就是小菜一碟！\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","slug":"add-two-numbers","published":1,"updated":"2019-05-01T08:02:08.774Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvl10006tgytlkr0qvhp","content":"<p>今天，我们要讲的是一道链表算法题：两个数相加。这道题有两个版本，它们都来自 LeetCode：</p>\n<p><a href=\"https://leetcode.com/problems/add-two-numbers/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/add-two-numbers/</a></p>\n<p><a href=\"https://leetcode.com/problems/add-two-numbers-ii/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/add-two-numbers-ii/</a></p>\n<p>本文将先回顾链表的基础知识，然后解决这两个问题，所用的语言依然是 JavaScript。</p>\n<a id=\"more\"></a>\n<h2 id=\"链表基础\"><a href=\"#链表基础\" class=\"headerlink\" title=\"链表基础\"></a>链表基础</h2><p>在前面的博文<a href=\"https://lewis617.github.io/2017/02/15/linked-list/\" target=\"_blank\" rel=\"noopener\">《JavaScript 版数据结构与算法（三）链表》</a>中，我们讲解了：</p>\n<ul>\n<li>什么是链表？</li>\n<li>链表的作用？</li>\n<li>链表的数据结构长啥样？</li>\n<li>如何用 JavaScript 编写一个链表类，并实现 <code>append</code>、<code>toString</code>、<code>removeAt</code>、<code>insert</code>、<code>indexOf</code> 等多个链表方法。</li>\n</ul>\n<p>这些基础知识对做链表题非常有帮助，如果你之前没有阅读过这篇博文，那么我强烈建议你读一遍，然后自己写一个链表类。如果你对链表的基础知识比较熟悉，那么就继续往下读吧！</p>\n<h2 id=\"两个数相加\"><a href=\"#两个数相加\" class=\"headerlink\" title=\"两个数相加\"></a>两个数相加</h2><p>让我们开始做题吧！首先，先来看下题目：</p>\n<blockquote>\n<p>给你两个非空的链表来表示两个非负整数。整数的每个数字倒序存储在链表的每个节点中。现在你需要写一个函数，将两个整数相加，并以链表的形式返回它们的和。</p>\n<p>你可以假设两个整数没有任何前导零，除非是零本身。</p>\n</blockquote>\n<p>我们再通过测试用例来表达一下题意：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class=\"line\">Output: 7 -&gt; 0 -&gt; 8</span><br><span class=\"line\"></span><br><span class=\"line\">Input: (1 -&gt; 8) + (0)</span><br><span class=\"line\">Output: 1 -&gt; 8</span><br><span class=\"line\"></span><br><span class=\"line\">Input: (9) + (1)</span><br><span class=\"line\">Output: 0 -&gt; 1</span><br></pre></td></tr></table></figure>\n<p>要实现的函数以及链表的结构是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * function ListNode(val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;ListNode&#125; l1</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;ListNode&#125; l2</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;ListNode&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addTwoNumbers = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">l1, l2</span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>题目表述完了，那么如何做呢？其实两个数相加的逻辑非常简单，无非是：</p>\n<ul>\n<li>从个位开始相加，生成的数字的个位数就是新数字的个位数，十位数放到下个数中相加。</li>\n<li>对其他位数执行上述操作。</li>\n</ul>\n<p>这个小学生都会，那么如何在链表中实现呢？这需要你了解链表几个常用操作：</p>\n<ul>\n<li>如何遍历链表？</li>\n<li>如何生成新链表？</li>\n</ul>\n<p>如何遍历链表呢？非常简单，你需要一个 <code>current</code> 指针（其实就是个变量），然后在 while 循环中执行 <code>current = current.next</code> 即可。</p>\n<p>如何生成新链表？这也非常简单，你只需要一个 <code>current</code> 指针指向链表最后一位，然后执行 <code>current.next = new Node(val)</code> 即可。</p>\n<p>了解了链表的这两个操作，然后我们对前两个链表进行遍历相加，生成新链表即可。为此，我们需要设置几个变量：</p>\n<ul>\n<li>三个链表的 <code>current</code> 指针：<code>c1</code>、<code>c2</code>、<code>c3</code>。</li>\n<li>新链表：<code>l3</code>。</li>\n<li>放到下一位相加的数字：<code>carry</code>。</li>\n</ul>\n<p>完整代码就是：</p>\n<p>LeetCode/002-addTwoNumbers.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addTwoNumbers = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">l1, l2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> c1 = l1,</span><br><span class=\"line\">    c2 = l2,</span><br><span class=\"line\">    l3, c3,</span><br><span class=\"line\">    carry = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (c1 || c2 || carry) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v1 = <span class=\"number\">0</span>,</span><br><span class=\"line\">      v2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 这么做是为了防止整数中当前位上没有数字</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c1) &#123;</span><br><span class=\"line\">      v1 = c1.val;</span><br><span class=\"line\">      c1 = c1.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c2) &#123;</span><br><span class=\"line\">      v2 = c2.val;</span><br><span class=\"line\">      c2 = c2.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = v1 + v2 + carry;</span><br><span class=\"line\">    carry = <span class=\"built_in\">Math</span>.floor(sum / <span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!c3) &#123;</span><br><span class=\"line\">      l3 = <span class=\"keyword\">new</span> ListNode(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">      c3 = l3;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      c3.next = <span class=\"keyword\">new</span> ListNode(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">      c3 = c3.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l3;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"两个数相加第二版\"><a href=\"#两个数相加第二版\" class=\"headerlink\" title=\"两个数相加第二版\"></a>两个数相加第二版</h2><p>上面的题目相对来说还是比较简单的，因为两个数相加是从低位到高位，而链表遍历是从前面到后面，正好是一致的。那么如果我们将整数的每个数字正序存贮在链表中，如何实现这道题呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class=\"line\">Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br><span class=\"line\"></span><br><span class=\"line\">Input: (7) + (5)</span><br><span class=\"line\">Output: 1 -&gt; 2</span><br></pre></td></tr></table></figure>\n<p>虽然正序存储更符合我们的书写阅读整数的习惯，但在链表中执行相加操作时却很麻烦，我们需要从低位开始计算才行。那么如何解决这个问题呢？答案是使用栈！</p>\n<ul>\n<li>先遍历两个链表，将数字 push 到各自的栈中。</li>\n<li>然后依次 pop 出数字进行相加操作，生成的新数字存储在第三个栈中。</li>\n<li>最后将第三个栈的每个数字 pop 出来添加到新链表中。</li>\n</ul>\n<p>完整代码是：</p>\n<p>LeetCode/445-addTwoNumbers2.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addTwoNumbers = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">l1, l2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> c1 = l1,</span><br><span class=\"line\">    c2 = l2,</span><br><span class=\"line\">    l3, c3,</span><br><span class=\"line\">    s1 = [],</span><br><span class=\"line\">    s2 = [],</span><br><span class=\"line\">    s3 = [],</span><br><span class=\"line\">    carry = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (c1 || c2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c1) &#123;</span><br><span class=\"line\">      s1.push(c1.val);</span><br><span class=\"line\">      c1 = c1.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c2) &#123;</span><br><span class=\"line\">      s2.push(c2.val);</span><br><span class=\"line\">      c2 = c2.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (s1.length || s2.length || carry) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v1 = <span class=\"number\">0</span>,</span><br><span class=\"line\">      v2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s1.length) &#123;</span><br><span class=\"line\">      v1 = s1.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s2.length) &#123;</span><br><span class=\"line\">      v2 = s2.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = v1 + v2 + carry;</span><br><span class=\"line\">    carry = <span class=\"built_in\">Math</span>.floor(sum / <span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    s3.push(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (s3.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> val = s3.pop();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!c3) &#123;</span><br><span class=\"line\">      l3 = <span class=\"keyword\">new</span> ListNode(val);</span><br><span class=\"line\">      c3 = l3;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      c3.next = <span class=\"keyword\">new</span> ListNode(val);</span><br><span class=\"line\">      c3 = c3.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l3;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>两个数相加这道题的本质是考察链表和栈的操作，所以如果你对链表和栈的数据结构和常用操作非常熟悉，那么做这道题就是小菜一碟！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是一道链表算法题：两个数相加。这道题有两个版本，它们都来自 LeetCode：</p>\n<p><a href=\"https://leetcode.com/problems/add-two-numbers/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/add-two-numbers/</a></p>\n<p><a href=\"https://leetcode.com/problems/add-two-numbers-ii/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/add-two-numbers-ii/</a></p>\n<p>本文将先回顾链表的基础知识，然后解决这两个问题，所用的语言依然是 JavaScript。</p>","more":"<h2 id=\"链表基础\"><a href=\"#链表基础\" class=\"headerlink\" title=\"链表基础\"></a>链表基础</h2><p>在前面的博文<a href=\"https://lewis617.github.io/2017/02/15/linked-list/\" target=\"_blank\" rel=\"noopener\">《JavaScript 版数据结构与算法（三）链表》</a>中，我们讲解了：</p>\n<ul>\n<li>什么是链表？</li>\n<li>链表的作用？</li>\n<li>链表的数据结构长啥样？</li>\n<li>如何用 JavaScript 编写一个链表类，并实现 <code>append</code>、<code>toString</code>、<code>removeAt</code>、<code>insert</code>、<code>indexOf</code> 等多个链表方法。</li>\n</ul>\n<p>这些基础知识对做链表题非常有帮助，如果你之前没有阅读过这篇博文，那么我强烈建议你读一遍，然后自己写一个链表类。如果你对链表的基础知识比较熟悉，那么就继续往下读吧！</p>\n<h2 id=\"两个数相加\"><a href=\"#两个数相加\" class=\"headerlink\" title=\"两个数相加\"></a>两个数相加</h2><p>让我们开始做题吧！首先，先来看下题目：</p>\n<blockquote>\n<p>给你两个非空的链表来表示两个非负整数。整数的每个数字倒序存储在链表的每个节点中。现在你需要写一个函数，将两个整数相加，并以链表的形式返回它们的和。</p>\n<p>你可以假设两个整数没有任何前导零，除非是零本身。</p>\n</blockquote>\n<p>我们再通过测试用例来表达一下题意：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class=\"line\">Output: 7 -&gt; 0 -&gt; 8</span><br><span class=\"line\"></span><br><span class=\"line\">Input: (1 -&gt; 8) + (0)</span><br><span class=\"line\">Output: 1 -&gt; 8</span><br><span class=\"line\"></span><br><span class=\"line\">Input: (9) + (1)</span><br><span class=\"line\">Output: 0 -&gt; 1</span><br></pre></td></tr></table></figure>\n<p>要实现的函数以及链表的结构是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * function ListNode(val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;ListNode&#125; l1</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;ListNode&#125; l2</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;ListNode&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addTwoNumbers = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">l1, l2</span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>题目表述完了，那么如何做呢？其实两个数相加的逻辑非常简单，无非是：</p>\n<ul>\n<li>从个位开始相加，生成的数字的个位数就是新数字的个位数，十位数放到下个数中相加。</li>\n<li>对其他位数执行上述操作。</li>\n</ul>\n<p>这个小学生都会，那么如何在链表中实现呢？这需要你了解链表几个常用操作：</p>\n<ul>\n<li>如何遍历链表？</li>\n<li>如何生成新链表？</li>\n</ul>\n<p>如何遍历链表呢？非常简单，你需要一个 <code>current</code> 指针（其实就是个变量），然后在 while 循环中执行 <code>current = current.next</code> 即可。</p>\n<p>如何生成新链表？这也非常简单，你只需要一个 <code>current</code> 指针指向链表最后一位，然后执行 <code>current.next = new Node(val)</code> 即可。</p>\n<p>了解了链表的这两个操作，然后我们对前两个链表进行遍历相加，生成新链表即可。为此，我们需要设置几个变量：</p>\n<ul>\n<li>三个链表的 <code>current</code> 指针：<code>c1</code>、<code>c2</code>、<code>c3</code>。</li>\n<li>新链表：<code>l3</code>。</li>\n<li>放到下一位相加的数字：<code>carry</code>。</li>\n</ul>\n<p>完整代码就是：</p>\n<p>LeetCode/002-addTwoNumbers.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addTwoNumbers = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">l1, l2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> c1 = l1,</span><br><span class=\"line\">    c2 = l2,</span><br><span class=\"line\">    l3, c3,</span><br><span class=\"line\">    carry = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (c1 || c2 || carry) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v1 = <span class=\"number\">0</span>,</span><br><span class=\"line\">      v2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 这么做是为了防止整数中当前位上没有数字</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c1) &#123;</span><br><span class=\"line\">      v1 = c1.val;</span><br><span class=\"line\">      c1 = c1.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c2) &#123;</span><br><span class=\"line\">      v2 = c2.val;</span><br><span class=\"line\">      c2 = c2.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = v1 + v2 + carry;</span><br><span class=\"line\">    carry = <span class=\"built_in\">Math</span>.floor(sum / <span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!c3) &#123;</span><br><span class=\"line\">      l3 = <span class=\"keyword\">new</span> ListNode(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">      c3 = l3;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      c3.next = <span class=\"keyword\">new</span> ListNode(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">      c3 = c3.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l3;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"两个数相加第二版\"><a href=\"#两个数相加第二版\" class=\"headerlink\" title=\"两个数相加第二版\"></a>两个数相加第二版</h2><p>上面的题目相对来说还是比较简单的，因为两个数相加是从低位到高位，而链表遍历是从前面到后面，正好是一致的。那么如果我们将整数的每个数字正序存贮在链表中，如何实现这道题呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class=\"line\">Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br><span class=\"line\"></span><br><span class=\"line\">Input: (7) + (5)</span><br><span class=\"line\">Output: 1 -&gt; 2</span><br></pre></td></tr></table></figure>\n<p>虽然正序存储更符合我们的书写阅读整数的习惯，但在链表中执行相加操作时却很麻烦，我们需要从低位开始计算才行。那么如何解决这个问题呢？答案是使用栈！</p>\n<ul>\n<li>先遍历两个链表，将数字 push 到各自的栈中。</li>\n<li>然后依次 pop 出数字进行相加操作，生成的新数字存储在第三个栈中。</li>\n<li>最后将第三个栈的每个数字 pop 出来添加到新链表中。</li>\n</ul>\n<p>完整代码是：</p>\n<p>LeetCode/445-addTwoNumbers2.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addTwoNumbers = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">l1, l2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> c1 = l1,</span><br><span class=\"line\">    c2 = l2,</span><br><span class=\"line\">    l3, c3,</span><br><span class=\"line\">    s1 = [],</span><br><span class=\"line\">    s2 = [],</span><br><span class=\"line\">    s3 = [],</span><br><span class=\"line\">    carry = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (c1 || c2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c1) &#123;</span><br><span class=\"line\">      s1.push(c1.val);</span><br><span class=\"line\">      c1 = c1.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c2) &#123;</span><br><span class=\"line\">      s2.push(c2.val);</span><br><span class=\"line\">      c2 = c2.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (s1.length || s2.length || carry) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v1 = <span class=\"number\">0</span>,</span><br><span class=\"line\">      v2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s1.length) &#123;</span><br><span class=\"line\">      v1 = s1.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s2.length) &#123;</span><br><span class=\"line\">      v2 = s2.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = v1 + v2 + carry;</span><br><span class=\"line\">    carry = <span class=\"built_in\">Math</span>.floor(sum / <span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    s3.push(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (s3.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> val = s3.pop();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!c3) &#123;</span><br><span class=\"line\">      l3 = <span class=\"keyword\">new</span> ListNode(val);</span><br><span class=\"line\">      c3 = l3;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      c3.next = <span class=\"keyword\">new</span> ListNode(val);</span><br><span class=\"line\">      c3 = c3.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l3;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>两个数相加这道题的本质是考察链表和栈的操作，所以如果你对链表和栈的数据结构和常用操作非常熟悉，那么做这道题就是小菜一碟！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>"},{"title":"在 JavaScript 中使用构造器函数模拟类","date":"2017-02-15T01:46:00.000Z","_content":"\n今天，我们要讲的是在 JavaScript 中使用构造器函数（construcor function）模拟类。\n\n<!--more-->\n\n## 构造器函数简介\n\n你可以使用 ES6 的 class 关键字来实现类，不过我建议你使用传统的构造器函数来模拟类，因为这样可以给人一种你是个 JavaScript 老手的错觉，哈哈！\n\n什么是构造器函数？构造器函数是编写对象的方法之一。一般情况下，你可以这样编写一个对象：\n\n```js\nvar obj = { a:1, b:2 };\n```\n \n但也可以使用构造器函数来编写对象：\n```js\n function Obj(a, b){\n   this.a = a;\n   this.b = b;\n }\n var obj = new Obj(1, 2); //obj 等价于 { a:1, b:2 }\n```\n使用构造器函数的好处在于可以传递参数。构造器函数通常首字母大写，而且需要使用 new 关键词来调用。在 JavaScript 中是没有类的，利用构造器函数我们可以模拟一个类。\n\n## 使用构造器函数编写栈类\n\n了解了构造器函数，我们使用它编写一个迷你的栈类，下面就是实现代码：\n\nStack.js\n\n```js\nfunction Stack() {\n  // 私有变量 items，用于记录数组，对象不能直接操作\n  var items = [];\n  // 类方法 push，在数组末尾添加项，对象可以直接调用\n  this.push = function (element) {\n    items.push(element);\n  };\n  // 删除并返回数组末尾的项\n  this.pop = function () {\n    return items.pop();\n  };\n}\n```\n\n上述栈类中，有个私有变量 `items` ，为何它就不能直接操作呢？为何挂在 this 上的方法可以直接调用？因为 **new 操作符会将构造器函数中的 this 指向生成的对象**，也就是说挂在 this 上的方法或属性将来会成为生成对象的方法或属性，所以可以直接调用。而 **`items` 则是函数内部的一个局部变量，它在函数外部是不可见的**，生成对象只能通过调用自身的方法，沿着作用域链来操作 `items`。\n\n```js\nvar stack = new Stack();\n\n// stack 对象不能直接操作items，结果是 undefined\nconsole.log(stack.items) \n \n// stack 对象可以直接操作构造器函数中挂在 this 上的属性和方法\nstack.push(1);\n// 打印了1\nconsole.log(stack.pop())\n```\n\n如果你不熟悉 JavaScript ，那么你应该先学习一下 JavaScript 作用域、this 和 new 操作符的相关知识。推荐阅读参考 Stoyan Stefanow 的《JavaScript 面向对象编程指南》，这本书里面有很多小的代码片段以及相关的图文解读，可以帮助你更好地理解 JavaScript 的相关特性。\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","source":"_posts/construcor-function-create-class.md","raw":"---\ntitle: 在 JavaScript 中使用构造器函数模拟类\ndate: 2017-02-15 09:46:00\ntags: [面向对象编程]\n---\n\n今天，我们要讲的是在 JavaScript 中使用构造器函数（construcor function）模拟类。\n\n<!--more-->\n\n## 构造器函数简介\n\n你可以使用 ES6 的 class 关键字来实现类，不过我建议你使用传统的构造器函数来模拟类，因为这样可以给人一种你是个 JavaScript 老手的错觉，哈哈！\n\n什么是构造器函数？构造器函数是编写对象的方法之一。一般情况下，你可以这样编写一个对象：\n\n```js\nvar obj = { a:1, b:2 };\n```\n \n但也可以使用构造器函数来编写对象：\n```js\n function Obj(a, b){\n   this.a = a;\n   this.b = b;\n }\n var obj = new Obj(1, 2); //obj 等价于 { a:1, b:2 }\n```\n使用构造器函数的好处在于可以传递参数。构造器函数通常首字母大写，而且需要使用 new 关键词来调用。在 JavaScript 中是没有类的，利用构造器函数我们可以模拟一个类。\n\n## 使用构造器函数编写栈类\n\n了解了构造器函数，我们使用它编写一个迷你的栈类，下面就是实现代码：\n\nStack.js\n\n```js\nfunction Stack() {\n  // 私有变量 items，用于记录数组，对象不能直接操作\n  var items = [];\n  // 类方法 push，在数组末尾添加项，对象可以直接调用\n  this.push = function (element) {\n    items.push(element);\n  };\n  // 删除并返回数组末尾的项\n  this.pop = function () {\n    return items.pop();\n  };\n}\n```\n\n上述栈类中，有个私有变量 `items` ，为何它就不能直接操作呢？为何挂在 this 上的方法可以直接调用？因为 **new 操作符会将构造器函数中的 this 指向生成的对象**，也就是说挂在 this 上的方法或属性将来会成为生成对象的方法或属性，所以可以直接调用。而 **`items` 则是函数内部的一个局部变量，它在函数外部是不可见的**，生成对象只能通过调用自身的方法，沿着作用域链来操作 `items`。\n\n```js\nvar stack = new Stack();\n\n// stack 对象不能直接操作items，结果是 undefined\nconsole.log(stack.items) \n \n// stack 对象可以直接操作构造器函数中挂在 this 上的属性和方法\nstack.push(1);\n// 打印了1\nconsole.log(stack.pop())\n```\n\n如果你不熟悉 JavaScript ，那么你应该先学习一下 JavaScript 作用域、this 和 new 操作符的相关知识。推荐阅读参考 Stoyan Stefanow 的《JavaScript 面向对象编程指南》，这本书里面有很多小的代码片段以及相关的图文解读，可以帮助你更好地理解 JavaScript 的相关特性。\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","slug":"construcor-function-create-class","published":1,"updated":"2019-05-01T08:02:09.118Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvl30008tgytbzl2u0sa","content":"<p>今天，我们要讲的是在 JavaScript 中使用构造器函数（construcor function）模拟类。</p>\n<a id=\"more\"></a>\n<h2 id=\"构造器函数简介\"><a href=\"#构造器函数简介\" class=\"headerlink\" title=\"构造器函数简介\"></a>构造器函数简介</h2><p>你可以使用 ES6 的 class 关键字来实现类，不过我建议你使用传统的构造器函数来模拟类，因为这样可以给人一种你是个 JavaScript 老手的错觉，哈哈！</p>\n<p>什么是构造器函数？构造器函数是编写对象的方法之一。一般情况下，你可以这样编写一个对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>:<span class=\"number\">1</span>, <span class=\"attr\">b</span>:<span class=\"number\">2</span> &#125;;</span><br></pre></td></tr></table></figure>\n<p>但也可以使用构造器函数来编写对象：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Obj</span>(<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.b = b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> Obj(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">//obj 等价于 &#123; a:1, b:2 &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>使用构造器函数的好处在于可以传递参数。构造器函数通常首字母大写，而且需要使用 new 关键词来调用。在 JavaScript 中是没有类的，利用构造器函数我们可以模拟一个类。</p>\n<h2 id=\"使用构造器函数编写栈类\"><a href=\"#使用构造器函数编写栈类\" class=\"headerlink\" title=\"使用构造器函数编写栈类\"></a>使用构造器函数编写栈类</h2><p>了解了构造器函数，我们使用它编写一个迷你的栈类，下面就是实现代码：</p>\n<p>Stack.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Stack</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量 items，用于记录数组，对象不能直接操作</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">  <span class=\"comment\">// 类方法 push，在数组末尾添加项，对象可以直接调用</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.push = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">    items.push(element);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 删除并返回数组末尾的项</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pop = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.pop();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述栈类中，有个私有变量 <code>items</code> ，为何它就不能直接操作呢？为何挂在 this 上的方法可以直接调用？因为 <strong>new 操作符会将构造器函数中的 this 指向生成的对象</strong>，也就是说挂在 this 上的方法或属性将来会成为生成对象的方法或属性，所以可以直接调用。而 <strong><code>items</code> 则是函数内部的一个局部变量，它在函数外部是不可见的</strong>，生成对象只能通过调用自身的方法，沿着作用域链来操作 <code>items</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// stack 对象不能直接操作items，结果是 undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stack.items) </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// stack 对象可以直接操作构造器函数中挂在 this 上的属性和方法</span></span><br><span class=\"line\">stack.push(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印了1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stack.pop())</span><br></pre></td></tr></table></figure>\n<p>如果你不熟悉 JavaScript ，那么你应该先学习一下 JavaScript 作用域、this 和 new 操作符的相关知识。推荐阅读参考 Stoyan Stefanow 的《JavaScript 面向对象编程指南》，这本书里面有很多小的代码片段以及相关的图文解读，可以帮助你更好地理解 JavaScript 的相关特性。</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是在 JavaScript 中使用构造器函数（construcor function）模拟类。</p>","more":"<h2 id=\"构造器函数简介\"><a href=\"#构造器函数简介\" class=\"headerlink\" title=\"构造器函数简介\"></a>构造器函数简介</h2><p>你可以使用 ES6 的 class 关键字来实现类，不过我建议你使用传统的构造器函数来模拟类，因为这样可以给人一种你是个 JavaScript 老手的错觉，哈哈！</p>\n<p>什么是构造器函数？构造器函数是编写对象的方法之一。一般情况下，你可以这样编写一个对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>:<span class=\"number\">1</span>, <span class=\"attr\">b</span>:<span class=\"number\">2</span> &#125;;</span><br></pre></td></tr></table></figure>\n<p>但也可以使用构造器函数来编写对象：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Obj</span>(<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.b = b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> Obj(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">//obj 等价于 &#123; a:1, b:2 &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>使用构造器函数的好处在于可以传递参数。构造器函数通常首字母大写，而且需要使用 new 关键词来调用。在 JavaScript 中是没有类的，利用构造器函数我们可以模拟一个类。</p>\n<h2 id=\"使用构造器函数编写栈类\"><a href=\"#使用构造器函数编写栈类\" class=\"headerlink\" title=\"使用构造器函数编写栈类\"></a>使用构造器函数编写栈类</h2><p>了解了构造器函数，我们使用它编写一个迷你的栈类，下面就是实现代码：</p>\n<p>Stack.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Stack</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量 items，用于记录数组，对象不能直接操作</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">  <span class=\"comment\">// 类方法 push，在数组末尾添加项，对象可以直接调用</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.push = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">    items.push(element);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 删除并返回数组末尾的项</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pop = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.pop();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述栈类中，有个私有变量 <code>items</code> ，为何它就不能直接操作呢？为何挂在 this 上的方法可以直接调用？因为 <strong>new 操作符会将构造器函数中的 this 指向生成的对象</strong>，也就是说挂在 this 上的方法或属性将来会成为生成对象的方法或属性，所以可以直接调用。而 <strong><code>items</code> 则是函数内部的一个局部变量，它在函数外部是不可见的</strong>，生成对象只能通过调用自身的方法，沿着作用域链来操作 <code>items</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// stack 对象不能直接操作items，结果是 undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stack.items) </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// stack 对象可以直接操作构造器函数中挂在 this 上的属性和方法</span></span><br><span class=\"line\">stack.push(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 打印了1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stack.pop())</span><br></pre></td></tr></table></figure>\n<p>如果你不熟悉 JavaScript ，那么你应该先学习一下 JavaScript 作用域、this 和 new 操作符的相关知识。推荐阅读参考 Stoyan Stefanow 的《JavaScript 面向对象编程指南》，这本书里面有很多小的代码片段以及相关的图文解读，可以帮助你更好地理解 JavaScript 的相关特性。</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>"},{"title":"自定义 Jinja2 过滤器","date":"2016-02-06T19:31:00.000Z","_content":"\n今天，我们要讲的是自定义Jinja2 过滤器这个知识点，因为官方文档对此一代而过，讲得不够清楚，所以我们专门拿出来讲一下。\n\n<!--more-->\n\n# 例子\n\n例子写了两个自定义过滤器，一个是转换字典到字符串的过滤器，一个是返回当前参数的类型的过滤器。\n\n源代码：\n\n[https://github.com/lewis617/myflask/tree/master/jinja2-filter](https://github.com/lewis617/myflask/tree/master/jinja2-filter)\n\n# 过滤器是个函数\n\n过滤器是个函数，跟Angular的过滤器几乎一模一样。参数就是管道（pipe）前面那个变量。比如   `123|myfilter`，`123`就是`myFilter`的参数。如果需要两个参数，则在`myFilter`后面加`（）`，即`123|myFilter(234)`。\n\n# 过滤器函数写在哪\n\n这是这个是编写过滤器的关键。过滤器函数写在`app.run`前，注册在`app.jinja_env.filters`中，这是什么意思？看代码：\n\n```python\napp = Flask(__name__) # custom filter # convert dict to string\ndef json_dumps(dict):\n        result = json.dumps(dict) return result # return type of arg\ndef typeFilter(arg):\n        result = type(arg) return result\n\nenv = app.jinja_env\nenv.filters['json_dumps'] = json_dumps\nenv.filters['typeFilter'] = typeFilter\n```\n\n1.  实例化一个Flask对象`app`\n2.  编写两个函数\n3.  将函数挂在`app.jinja_env.filters`上\n\n就是这么简单！\n\n# 测试示例代码\n\n第一个过滤器转换字典到字符串，第二个返回当前参数的类型\n\n我们在index.html中编写：\n\n```html\n<body> \ndict is {{ dict|typeFilter}} <hr> \ndict | json_dumps is{{ dict|json_dumps |typeFilter}} <hr> \nyou can use json_dumps filter to send dict to js,remember to add safe filter,<br> press f12 to test it \n</body>\n<script>\n    //you can use json_dumps filter to send dict to js,remember to add safe filter\n console.log({{ dict |json_dumps|safe}}) \n</script>\n```\n\n然后在app.py中渲染这个html\n\n```python\n@app.route('/')\ndef hello_world():\n    dict={'name':'lewis','age':24} return render_template('index.html',dict=dict) if __name__ == '__main__':\n    app.run()\n```\n\n结果：\n\n![](/css/images/2.jpg)\n\n`json_dumps`可以将dict转为字符串，这样我们用Jinja渲染的对象列表之类的就可以，以字符串的形式打印出来，便于我们在开发环境下监视渲染状态。\n","source":"_posts/custom-jinja2-filter.md","raw":"---\ntitle: 自定义 Jinja2 过滤器\ndate: 2016-02-07 03:31:00\ntags: [Jinja2, Flask]\n---\n\n今天，我们要讲的是自定义Jinja2 过滤器这个知识点，因为官方文档对此一代而过，讲得不够清楚，所以我们专门拿出来讲一下。\n\n<!--more-->\n\n# 例子\n\n例子写了两个自定义过滤器，一个是转换字典到字符串的过滤器，一个是返回当前参数的类型的过滤器。\n\n源代码：\n\n[https://github.com/lewis617/myflask/tree/master/jinja2-filter](https://github.com/lewis617/myflask/tree/master/jinja2-filter)\n\n# 过滤器是个函数\n\n过滤器是个函数，跟Angular的过滤器几乎一模一样。参数就是管道（pipe）前面那个变量。比如   `123|myfilter`，`123`就是`myFilter`的参数。如果需要两个参数，则在`myFilter`后面加`（）`，即`123|myFilter(234)`。\n\n# 过滤器函数写在哪\n\n这是这个是编写过滤器的关键。过滤器函数写在`app.run`前，注册在`app.jinja_env.filters`中，这是什么意思？看代码：\n\n```python\napp = Flask(__name__) # custom filter # convert dict to string\ndef json_dumps(dict):\n        result = json.dumps(dict) return result # return type of arg\ndef typeFilter(arg):\n        result = type(arg) return result\n\nenv = app.jinja_env\nenv.filters['json_dumps'] = json_dumps\nenv.filters['typeFilter'] = typeFilter\n```\n\n1.  实例化一个Flask对象`app`\n2.  编写两个函数\n3.  将函数挂在`app.jinja_env.filters`上\n\n就是这么简单！\n\n# 测试示例代码\n\n第一个过滤器转换字典到字符串，第二个返回当前参数的类型\n\n我们在index.html中编写：\n\n```html\n<body> \ndict is {{ dict|typeFilter}} <hr> \ndict | json_dumps is{{ dict|json_dumps |typeFilter}} <hr> \nyou can use json_dumps filter to send dict to js,remember to add safe filter,<br> press f12 to test it \n</body>\n<script>\n    //you can use json_dumps filter to send dict to js,remember to add safe filter\n console.log({{ dict |json_dumps|safe}}) \n</script>\n```\n\n然后在app.py中渲染这个html\n\n```python\n@app.route('/')\ndef hello_world():\n    dict={'name':'lewis','age':24} return render_template('index.html',dict=dict) if __name__ == '__main__':\n    app.run()\n```\n\n结果：\n\n![](/css/images/2.jpg)\n\n`json_dumps`可以将dict转为字符串，这样我们用Jinja渲染的对象列表之类的就可以，以字符串的形式打印出来，便于我们在开发环境下监视渲染状态。\n","slug":"custom-jinja2-filter","published":1,"updated":"2019-05-01T08:10:29.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvl40009tgytlhxoft20","content":"<p>今天，我们要讲的是自定义Jinja2 过滤器这个知识点，因为官方文档对此一代而过，讲得不够清楚，所以我们专门拿出来讲一下。</p>\n<a id=\"more\"></a>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p>例子写了两个自定义过滤器，一个是转换字典到字符串的过滤器，一个是返回当前参数的类型的过滤器。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/myflask/tree/master/jinja2-filter\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/myflask/tree/master/jinja2-filter</a></p>\n<h1 id=\"过滤器是个函数\"><a href=\"#过滤器是个函数\" class=\"headerlink\" title=\"过滤器是个函数\"></a>过滤器是个函数</h1><p>过滤器是个函数，跟Angular的过滤器几乎一模一样。参数就是管道（pipe）前面那个变量。比如   <code>123|myfilter</code>，<code>123</code>就是<code>myFilter</code>的参数。如果需要两个参数，则在<code>myFilter</code>后面加<code>（）</code>，即<code>123|myFilter(234)</code>。</p>\n<h1 id=\"过滤器函数写在哪\"><a href=\"#过滤器函数写在哪\" class=\"headerlink\" title=\"过滤器函数写在哪\"></a>过滤器函数写在哪</h1><p>这是这个是编写过滤器的关键。过滤器函数写在<code>app.run</code>前，注册在<code>app.jinja_env.filters</code>中，这是什么意思？看代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = Flask(__name__) <span class=\"comment\"># custom filter # convert dict to string</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">json_dumps</span><span class=\"params\">(dict)</span>:</span></span><br><span class=\"line\">        result = json.dumps(dict) <span class=\"keyword\">return</span> result <span class=\"comment\"># return type of arg</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">typeFilter</span><span class=\"params\">(arg)</span>:</span></span><br><span class=\"line\">        result = type(arg) <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\">env = app.jinja_env</span><br><span class=\"line\">env.filters[<span class=\"string\">'json_dumps'</span>] = json_dumps</span><br><span class=\"line\">env.filters[<span class=\"string\">'typeFilter'</span>] = typeFilter</span><br></pre></td></tr></table></figure>\n<ol>\n<li>实例化一个Flask对象<code>app</code></li>\n<li>编写两个函数</li>\n<li>将函数挂在<code>app.jinja_env.filters</code>上</li>\n</ol>\n<p>就是这么简单！</p>\n<h1 id=\"测试示例代码\"><a href=\"#测试示例代码\" class=\"headerlink\" title=\"测试示例代码\"></a>测试示例代码</h1><p>第一个过滤器转换字典到字符串，第二个返回当前参数的类型</p>\n<p>我们在index.html中编写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\">dict is &#123;&#123; dict|typeFilter&#125;&#125; <span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span> </span><br><span class=\"line\">dict | json_dumps is&#123;&#123; dict|json_dumps |typeFilter&#125;&#125; <span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span> </span><br><span class=\"line\">you can use json_dumps filter to send dict to js,remember to add safe filter,<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span> press f12 to test it </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">//you can use json_dumps filter to send dict to js,remember to add safe filter</span></span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"built_in\">console</span>.log(&#123;&#123; dict |json_dumps|safe&#125;&#125;) </span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后在app.py中渲染这个html</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@app.route('/')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello_world</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    dict=&#123;<span class=\"string\">'name'</span>:<span class=\"string\">'lewis'</span>,<span class=\"string\">'age'</span>:<span class=\"number\">24</span>&#125; <span class=\"keyword\">return</span> render_template(<span class=\"string\">'index.html'</span>,dict=dict) <span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<p><img src=\"/css/images/2.jpg\" alt=\"\"></p>\n<p><code>json_dumps</code>可以将dict转为字符串，这样我们用Jinja渲染的对象列表之类的就可以，以字符串的形式打印出来，便于我们在开发环境下监视渲染状态。</p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是自定义Jinja2 过滤器这个知识点，因为官方文档对此一代而过，讲得不够清楚，所以我们专门拿出来讲一下。</p>","more":"<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p>例子写了两个自定义过滤器，一个是转换字典到字符串的过滤器，一个是返回当前参数的类型的过滤器。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/myflask/tree/master/jinja2-filter\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/myflask/tree/master/jinja2-filter</a></p>\n<h1 id=\"过滤器是个函数\"><a href=\"#过滤器是个函数\" class=\"headerlink\" title=\"过滤器是个函数\"></a>过滤器是个函数</h1><p>过滤器是个函数，跟Angular的过滤器几乎一模一样。参数就是管道（pipe）前面那个变量。比如   <code>123|myfilter</code>，<code>123</code>就是<code>myFilter</code>的参数。如果需要两个参数，则在<code>myFilter</code>后面加<code>（）</code>，即<code>123|myFilter(234)</code>。</p>\n<h1 id=\"过滤器函数写在哪\"><a href=\"#过滤器函数写在哪\" class=\"headerlink\" title=\"过滤器函数写在哪\"></a>过滤器函数写在哪</h1><p>这是这个是编写过滤器的关键。过滤器函数写在<code>app.run</code>前，注册在<code>app.jinja_env.filters</code>中，这是什么意思？看代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = Flask(__name__) <span class=\"comment\"># custom filter # convert dict to string</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">json_dumps</span><span class=\"params\">(dict)</span>:</span></span><br><span class=\"line\">        result = json.dumps(dict) <span class=\"keyword\">return</span> result <span class=\"comment\"># return type of arg</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">typeFilter</span><span class=\"params\">(arg)</span>:</span></span><br><span class=\"line\">        result = type(arg) <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\">env = app.jinja_env</span><br><span class=\"line\">env.filters[<span class=\"string\">'json_dumps'</span>] = json_dumps</span><br><span class=\"line\">env.filters[<span class=\"string\">'typeFilter'</span>] = typeFilter</span><br></pre></td></tr></table></figure>\n<ol>\n<li>实例化一个Flask对象<code>app</code></li>\n<li>编写两个函数</li>\n<li>将函数挂在<code>app.jinja_env.filters</code>上</li>\n</ol>\n<p>就是这么简单！</p>\n<h1 id=\"测试示例代码\"><a href=\"#测试示例代码\" class=\"headerlink\" title=\"测试示例代码\"></a>测试示例代码</h1><p>第一个过滤器转换字典到字符串，第二个返回当前参数的类型</p>\n<p>我们在index.html中编写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\">dict is &#123;&#123; dict|typeFilter&#125;&#125; <span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span> </span><br><span class=\"line\">dict | json_dumps is&#123;&#123; dict|json_dumps |typeFilter&#125;&#125; <span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span> </span><br><span class=\"line\">you can use json_dumps filter to send dict to js,remember to add safe filter,<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span> press f12 to test it </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">//you can use json_dumps filter to send dict to js,remember to add safe filter</span></span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"built_in\">console</span>.log(&#123;&#123; dict |json_dumps|safe&#125;&#125;) </span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后在app.py中渲染这个html</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@app.route('/')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello_world</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    dict=&#123;<span class=\"string\">'name'</span>:<span class=\"string\">'lewis'</span>,<span class=\"string\">'age'</span>:<span class=\"number\">24</span>&#125; <span class=\"keyword\">return</span> render_template(<span class=\"string\">'index.html'</span>,dict=dict) <span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<p><img src=\"/css/images/2.jpg\" alt=\"\"></p>\n<p><code>json_dumps</code>可以将dict转为字符串，这样我们用Jinja渲染的对象列表之类的就可以，以字符串的形式打印出来，便于我们在开发环境下监视渲染状态。</p>"},{"title":"JavaScript 版数据结构与算法（五）字典","date":"2017-02-17T02:29:00.000Z","_content":"\n今天，我们要讲的是数据结构与算法中的字典。\n\n<!--more-->\n\n## 字典简介\n\n什么是字典？与集合类似，字典也是一种**存储唯一值**的数据结构，但它是以**键值对**的形式来存储。字典有什么用？在生活中，字典可以模拟汉英字典等真实字典这种场景。另外，ES6 也新增了字典这种数据结构，不过名字叫——Map。Map 和对象都是键值对，那么它俩有什么区别呢？MDN 给了一个非常清晰的总结：\n\n- 一个对象通常都有自己的原型,所以一个对象总有一个\"prototype\"键。不过，从 ES5 开始可以使用map = Object.create(null)来创建一个没有原型的对象。\n- 一个对象的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。\n- 你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。\n\n想了解更多的 Map 的知识，可以参考 MDN 文档——[Map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)。\n\n## 用 JavaScript 编写字典类\n\n让我们自己用 JavaScript 写个字典类吧！我们不要求和 Map 的实现一模一样，只要能够表达键值对和唯一值这两个特性，再实现一些 `set`、`get`、`values`、`getItems`等方法即可。\n\n### 私有变量\n\n为了用键值对存储唯一的元素，我们使用一个对象 `items` 来作为私有变量：\n\n```js\nfunction Set(){\n  var items = {};\n}\n```\n\n然后，将键值对作为该对象的键和值。比如：\n```js\n{\n  '李四': 'lisi@email.com',\n  '王五': 'wangwu@email.com'\n}\n```\n\n### 实现 set 、get、remove 方法\n\n实现 `set` 方法（给字典设置键值对）、`get` 方法（通过键在字典中取值）、`remove` 方法（删除字典中的指定键值），可以跑通如下测试：\n\n```js\nvar dictionary = new Dictionary();\n\ndictionary.set('张三', 'zhangsan@email.com'); // 代码一\ndictionary.set('李四', 'lisi@email.com'); // 代码二\n\nexpect(dictionary.has('张三')).toBeTruthy(); // 断言一\nexpect(dictionary.get('李四')).toBe('lisi@email.com'); // 断言二\nexpect(dictionary.get('王五')).toBe(undefined); // 断言三\n\nexpect(dictionary.remove('张三')).toBeTruthy(); // 断言四\nexpect(dictionary.remove('张三')).toBeFalsy(); // 断言五\n\n```\n\n来分析下需求吧！\n\n- 代码一、二都比较简单，就是给私有变量 `items` 设置键值对即可。 \n- 断言一需要判断 `items` 中是否有指定属性，可以用 `hasOwnProperty` 方法也可以用 `in` 操作符。它俩的区别主要是前者不会判断从原型继承来的属性，因为 `items` 没有从原型继承到一些属性，所以两个方法都可以。 \n- 断言二、三主要是判断 `items` 是否有指定属性，有就返回对应的值，没有则返回 `undefined`。 \n- 断言四、五需要删除指定键值并返回 `true`，如果没有该属性则返回 `false`。 \n\n分析完了需求直接上代码：\n\n```js\nthis.has = function (key) {\n  return key in items;\n};\n\nthis.set = function (key, value) {\n  items[key] = value;\n};\n\nthis.get = function (key) {\n  return this.has(key) ? items[key] : undefined;\n};\n\nthis.remove = function (key) {\n  if (this.has(key)) {\n    delete items[key];\n    return true;\n  }\n  return false;\n};\n```\n\n### 实现 values 、getItems 方法\n\n实现 `values` 方法（返回字典中所有的值）、`getItems` 方法（获取私有变量 `items`），可以跑通如下测试：\n\n```js\nvar dictionary = new Dictionary();\n\ndictionary.set('李四', 'lisi@email.com');\ndictionary.set('王五', 'wangwu@email.com');\n\nexpect(dictionary.values()).toEqual(['lisi@email.com', 'wangwu@email.com']); //断言一\nexpect(dictionary.getItems()).toEqual({\n  '李四': 'lisi@email.com',\n  '王五': 'wangwu@email.com'\n}); // 断言二\n```\n\n来分析下需求吧！\n\n- 实现断言一只需要遍历 `items` 的属性，将其 push 到数组中返回即可。遍历属性是用的是 `for...in`，这种方法可能会遍历原型上继承来的属性（虽然本例中不存在这种情况，不过保险起见，还是写上吧！）。所以还需要判断 `items` 是否有该属性。\n- 实现断言二只需要直接返回 `items` 即可。\n\n> `for...in` 以任意序迭代一个对象的可枚举属性。每个不同的属性，语句都会被执行一次。更多细节请参考 MDN 文档 —— [for...in](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in)。\n\n分析完了需求直接上代码：\n\n```js\nthis.values = function () {\n  var values = [];\n  for (var key in items){\n    if(this.has(key)){\n      values.push(items[key]);\n    }\n  }\n  return values;\n};\n\nthis.getItems = function () {\n  return items;\n};\n```\n\n至此，字典类就写完了。\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","source":"_posts/dictionary.md","raw":"---\ntitle: JavaScript 版数据结构与算法（五）字典\ndate: 2017-02-17 10:29:00\ntags: [数据结构与算法]\n---\n\n今天，我们要讲的是数据结构与算法中的字典。\n\n<!--more-->\n\n## 字典简介\n\n什么是字典？与集合类似，字典也是一种**存储唯一值**的数据结构，但它是以**键值对**的形式来存储。字典有什么用？在生活中，字典可以模拟汉英字典等真实字典这种场景。另外，ES6 也新增了字典这种数据结构，不过名字叫——Map。Map 和对象都是键值对，那么它俩有什么区别呢？MDN 给了一个非常清晰的总结：\n\n- 一个对象通常都有自己的原型,所以一个对象总有一个\"prototype\"键。不过，从 ES5 开始可以使用map = Object.create(null)来创建一个没有原型的对象。\n- 一个对象的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。\n- 你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。\n\n想了解更多的 Map 的知识，可以参考 MDN 文档——[Map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)。\n\n## 用 JavaScript 编写字典类\n\n让我们自己用 JavaScript 写个字典类吧！我们不要求和 Map 的实现一模一样，只要能够表达键值对和唯一值这两个特性，再实现一些 `set`、`get`、`values`、`getItems`等方法即可。\n\n### 私有变量\n\n为了用键值对存储唯一的元素，我们使用一个对象 `items` 来作为私有变量：\n\n```js\nfunction Set(){\n  var items = {};\n}\n```\n\n然后，将键值对作为该对象的键和值。比如：\n```js\n{\n  '李四': 'lisi@email.com',\n  '王五': 'wangwu@email.com'\n}\n```\n\n### 实现 set 、get、remove 方法\n\n实现 `set` 方法（给字典设置键值对）、`get` 方法（通过键在字典中取值）、`remove` 方法（删除字典中的指定键值），可以跑通如下测试：\n\n```js\nvar dictionary = new Dictionary();\n\ndictionary.set('张三', 'zhangsan@email.com'); // 代码一\ndictionary.set('李四', 'lisi@email.com'); // 代码二\n\nexpect(dictionary.has('张三')).toBeTruthy(); // 断言一\nexpect(dictionary.get('李四')).toBe('lisi@email.com'); // 断言二\nexpect(dictionary.get('王五')).toBe(undefined); // 断言三\n\nexpect(dictionary.remove('张三')).toBeTruthy(); // 断言四\nexpect(dictionary.remove('张三')).toBeFalsy(); // 断言五\n\n```\n\n来分析下需求吧！\n\n- 代码一、二都比较简单，就是给私有变量 `items` 设置键值对即可。 \n- 断言一需要判断 `items` 中是否有指定属性，可以用 `hasOwnProperty` 方法也可以用 `in` 操作符。它俩的区别主要是前者不会判断从原型继承来的属性，因为 `items` 没有从原型继承到一些属性，所以两个方法都可以。 \n- 断言二、三主要是判断 `items` 是否有指定属性，有就返回对应的值，没有则返回 `undefined`。 \n- 断言四、五需要删除指定键值并返回 `true`，如果没有该属性则返回 `false`。 \n\n分析完了需求直接上代码：\n\n```js\nthis.has = function (key) {\n  return key in items;\n};\n\nthis.set = function (key, value) {\n  items[key] = value;\n};\n\nthis.get = function (key) {\n  return this.has(key) ? items[key] : undefined;\n};\n\nthis.remove = function (key) {\n  if (this.has(key)) {\n    delete items[key];\n    return true;\n  }\n  return false;\n};\n```\n\n### 实现 values 、getItems 方法\n\n实现 `values` 方法（返回字典中所有的值）、`getItems` 方法（获取私有变量 `items`），可以跑通如下测试：\n\n```js\nvar dictionary = new Dictionary();\n\ndictionary.set('李四', 'lisi@email.com');\ndictionary.set('王五', 'wangwu@email.com');\n\nexpect(dictionary.values()).toEqual(['lisi@email.com', 'wangwu@email.com']); //断言一\nexpect(dictionary.getItems()).toEqual({\n  '李四': 'lisi@email.com',\n  '王五': 'wangwu@email.com'\n}); // 断言二\n```\n\n来分析下需求吧！\n\n- 实现断言一只需要遍历 `items` 的属性，将其 push 到数组中返回即可。遍历属性是用的是 `for...in`，这种方法可能会遍历原型上继承来的属性（虽然本例中不存在这种情况，不过保险起见，还是写上吧！）。所以还需要判断 `items` 是否有该属性。\n- 实现断言二只需要直接返回 `items` 即可。\n\n> `for...in` 以任意序迭代一个对象的可枚举属性。每个不同的属性，语句都会被执行一次。更多细节请参考 MDN 文档 —— [for...in](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in)。\n\n分析完了需求直接上代码：\n\n```js\nthis.values = function () {\n  var values = [];\n  for (var key in items){\n    if(this.has(key)){\n      values.push(items[key]);\n    }\n  }\n  return values;\n};\n\nthis.getItems = function () {\n  return items;\n};\n```\n\n至此，字典类就写完了。\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","slug":"dictionary","published":1,"updated":"2019-05-01T08:02:09.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvl6000btgytyftxx0tp","content":"<p>今天，我们要讲的是数据结构与算法中的字典。</p>\n<a id=\"more\"></a>\n<h2 id=\"字典简介\"><a href=\"#字典简介\" class=\"headerlink\" title=\"字典简介\"></a>字典简介</h2><p>什么是字典？与集合类似，字典也是一种<strong>存储唯一值</strong>的数据结构，但它是以<strong>键值对</strong>的形式来存储。字典有什么用？在生活中，字典可以模拟汉英字典等真实字典这种场景。另外，ES6 也新增了字典这种数据结构，不过名字叫——Map。Map 和对象都是键值对，那么它俩有什么区别呢？MDN 给了一个非常清晰的总结：</p>\n<ul>\n<li>一个对象通常都有自己的原型,所以一个对象总有一个”prototype”键。不过，从 ES5 开始可以使用map = Object.create(null)来创建一个没有原型的对象。</li>\n<li>一个对象的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li>\n<li>你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。</li>\n</ul>\n<p>想了解更多的 Map 的知识，可以参考 MDN 文档——<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\" target=\"_blank\" rel=\"noopener\">Map</a>。</p>\n<h2 id=\"用-JavaScript-编写字典类\"><a href=\"#用-JavaScript-编写字典类\" class=\"headerlink\" title=\"用 JavaScript 编写字典类\"></a>用 JavaScript 编写字典类</h2><p>让我们自己用 JavaScript 写个字典类吧！我们不要求和 Map 的实现一模一样，只要能够表达键值对和唯一值这两个特性，再实现一些 <code>set</code>、<code>get</code>、<code>values</code>、<code>getItems</code>等方法即可。</p>\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>为了用键值对存储唯一的元素，我们使用一个对象 <code>items</code> 来作为私有变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Set</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，将键值对作为该对象的键和值。比如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">'李四'</span>: <span class=\"string\">'lisi@email.com'</span>,</span><br><span class=\"line\">  <span class=\"string\">'王五'</span>: <span class=\"string\">'wangwu@email.com'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"实现-set-、get、remove-方法\"><a href=\"#实现-set-、get、remove-方法\" class=\"headerlink\" title=\"实现 set 、get、remove 方法\"></a>实现 set 、get、remove 方法</h3><p>实现 <code>set</code> 方法（给字典设置键值对）、<code>get</code> 方法（通过键在字典中取值）、<code>remove</code> 方法（删除字典中的指定键值），可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dictionary = <span class=\"keyword\">new</span> Dictionary();</span><br><span class=\"line\"></span><br><span class=\"line\">dictionary.set(<span class=\"string\">'张三'</span>, <span class=\"string\">'zhangsan@email.com'</span>); <span class=\"comment\">// 代码一</span></span><br><span class=\"line\">dictionary.set(<span class=\"string\">'李四'</span>, <span class=\"string\">'lisi@email.com'</span>); <span class=\"comment\">// 代码二</span></span><br><span class=\"line\"></span><br><span class=\"line\">expect(dictionary.has(<span class=\"string\">'张三'</span>)).toBeTruthy(); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">expect(dictionary.get(<span class=\"string\">'李四'</span>)).toBe(<span class=\"string\">'lisi@email.com'</span>); <span class=\"comment\">// 断言二</span></span><br><span class=\"line\">expect(dictionary.get(<span class=\"string\">'王五'</span>)).toBe(<span class=\"literal\">undefined</span>); <span class=\"comment\">// 断言三</span></span><br><span class=\"line\"></span><br><span class=\"line\">expect(dictionary.remove(<span class=\"string\">'张三'</span>)).toBeTruthy(); <span class=\"comment\">// 断言四</span></span><br><span class=\"line\">expect(dictionary.remove(<span class=\"string\">'张三'</span>)).toBeFalsy(); <span class=\"comment\">// 断言五</span></span><br></pre></td></tr></table></figure>\n<p>来分析下需求吧！</p>\n<ul>\n<li>代码一、二都比较简单，就是给私有变量 <code>items</code> 设置键值对即可。 </li>\n<li>断言一需要判断 <code>items</code> 中是否有指定属性，可以用 <code>hasOwnProperty</code> 方法也可以用 <code>in</code> 操作符。它俩的区别主要是前者不会判断从原型继承来的属性，因为 <code>items</code> 没有从原型继承到一些属性，所以两个方法都可以。 </li>\n<li>断言二、三主要是判断 <code>items</code> 是否有指定属性，有就返回对应的值，没有则返回 <code>undefined</code>。 </li>\n<li>断言四、五需要删除指定键值并返回 <code>true</code>，如果没有该属性则返回 <code>false</code>。 </li>\n</ul>\n<p>分析完了需求直接上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.has = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> key <span class=\"keyword\">in</span> items;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.set = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  items[key] = value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.get = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.has(key) ? items[key] : <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.remove = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.has(key)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> items[key];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-values-、getItems-方法\"><a href=\"#实现-values-、getItems-方法\" class=\"headerlink\" title=\"实现 values 、getItems 方法\"></a>实现 values 、getItems 方法</h3><p>实现 <code>values</code> 方法（返回字典中所有的值）、<code>getItems</code> 方法（获取私有变量 <code>items</code>），可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dictionary = <span class=\"keyword\">new</span> Dictionary();</span><br><span class=\"line\"></span><br><span class=\"line\">dictionary.set(<span class=\"string\">'李四'</span>, <span class=\"string\">'lisi@email.com'</span>);</span><br><span class=\"line\">dictionary.set(<span class=\"string\">'王五'</span>, <span class=\"string\">'wangwu@email.com'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(dictionary.values()).toEqual([<span class=\"string\">'lisi@email.com'</span>, <span class=\"string\">'wangwu@email.com'</span>]); <span class=\"comment\">//断言一</span></span><br><span class=\"line\">expect(dictionary.getItems()).toEqual(&#123;</span><br><span class=\"line\">  <span class=\"string\">'李四'</span>: <span class=\"string\">'lisi@email.com'</span>,</span><br><span class=\"line\">  <span class=\"string\">'王五'</span>: <span class=\"string\">'wangwu@email.com'</span></span><br><span class=\"line\">&#125;); <span class=\"comment\">// 断言二</span></span><br></pre></td></tr></table></figure>\n<p>来分析下需求吧！</p>\n<ul>\n<li>实现断言一只需要遍历 <code>items</code> 的属性，将其 push 到数组中返回即可。遍历属性是用的是 <code>for...in</code>，这种方法可能会遍历原型上继承来的属性（虽然本例中不存在这种情况，不过保险起见，还是写上吧！）。所以还需要判断 <code>items</code> 是否有该属性。</li>\n<li>实现断言二只需要直接返回 <code>items</code> 即可。</li>\n</ul>\n<blockquote>\n<p><code>for...in</code> 以任意序迭代一个对象的可枚举属性。每个不同的属性，语句都会被执行一次。更多细节请参考 MDN 文档 —— <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in\" target=\"_blank\" rel=\"noopener\">for…in</a>。</p>\n</blockquote>\n<p>分析完了需求直接上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.values = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> values = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> items)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.has(key))&#123;</span><br><span class=\"line\">      values.push(items[key]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.getItems = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> items;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>至此，字典类就写完了。</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是数据结构与算法中的字典。</p>","more":"<h2 id=\"字典简介\"><a href=\"#字典简介\" class=\"headerlink\" title=\"字典简介\"></a>字典简介</h2><p>什么是字典？与集合类似，字典也是一种<strong>存储唯一值</strong>的数据结构，但它是以<strong>键值对</strong>的形式来存储。字典有什么用？在生活中，字典可以模拟汉英字典等真实字典这种场景。另外，ES6 也新增了字典这种数据结构，不过名字叫——Map。Map 和对象都是键值对，那么它俩有什么区别呢？MDN 给了一个非常清晰的总结：</p>\n<ul>\n<li>一个对象通常都有自己的原型,所以一个对象总有一个”prototype”键。不过，从 ES5 开始可以使用map = Object.create(null)来创建一个没有原型的对象。</li>\n<li>一个对象的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li>\n<li>你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。</li>\n</ul>\n<p>想了解更多的 Map 的知识，可以参考 MDN 文档——<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\" target=\"_blank\" rel=\"noopener\">Map</a>。</p>\n<h2 id=\"用-JavaScript-编写字典类\"><a href=\"#用-JavaScript-编写字典类\" class=\"headerlink\" title=\"用 JavaScript 编写字典类\"></a>用 JavaScript 编写字典类</h2><p>让我们自己用 JavaScript 写个字典类吧！我们不要求和 Map 的实现一模一样，只要能够表达键值对和唯一值这两个特性，再实现一些 <code>set</code>、<code>get</code>、<code>values</code>、<code>getItems</code>等方法即可。</p>\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>为了用键值对存储唯一的元素，我们使用一个对象 <code>items</code> 来作为私有变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Set</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，将键值对作为该对象的键和值。比如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">'李四'</span>: <span class=\"string\">'lisi@email.com'</span>,</span><br><span class=\"line\">  <span class=\"string\">'王五'</span>: <span class=\"string\">'wangwu@email.com'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"实现-set-、get、remove-方法\"><a href=\"#实现-set-、get、remove-方法\" class=\"headerlink\" title=\"实现 set 、get、remove 方法\"></a>实现 set 、get、remove 方法</h3><p>实现 <code>set</code> 方法（给字典设置键值对）、<code>get</code> 方法（通过键在字典中取值）、<code>remove</code> 方法（删除字典中的指定键值），可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dictionary = <span class=\"keyword\">new</span> Dictionary();</span><br><span class=\"line\"></span><br><span class=\"line\">dictionary.set(<span class=\"string\">'张三'</span>, <span class=\"string\">'zhangsan@email.com'</span>); <span class=\"comment\">// 代码一</span></span><br><span class=\"line\">dictionary.set(<span class=\"string\">'李四'</span>, <span class=\"string\">'lisi@email.com'</span>); <span class=\"comment\">// 代码二</span></span><br><span class=\"line\"></span><br><span class=\"line\">expect(dictionary.has(<span class=\"string\">'张三'</span>)).toBeTruthy(); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">expect(dictionary.get(<span class=\"string\">'李四'</span>)).toBe(<span class=\"string\">'lisi@email.com'</span>); <span class=\"comment\">// 断言二</span></span><br><span class=\"line\">expect(dictionary.get(<span class=\"string\">'王五'</span>)).toBe(<span class=\"literal\">undefined</span>); <span class=\"comment\">// 断言三</span></span><br><span class=\"line\"></span><br><span class=\"line\">expect(dictionary.remove(<span class=\"string\">'张三'</span>)).toBeTruthy(); <span class=\"comment\">// 断言四</span></span><br><span class=\"line\">expect(dictionary.remove(<span class=\"string\">'张三'</span>)).toBeFalsy(); <span class=\"comment\">// 断言五</span></span><br></pre></td></tr></table></figure>\n<p>来分析下需求吧！</p>\n<ul>\n<li>代码一、二都比较简单，就是给私有变量 <code>items</code> 设置键值对即可。 </li>\n<li>断言一需要判断 <code>items</code> 中是否有指定属性，可以用 <code>hasOwnProperty</code> 方法也可以用 <code>in</code> 操作符。它俩的区别主要是前者不会判断从原型继承来的属性，因为 <code>items</code> 没有从原型继承到一些属性，所以两个方法都可以。 </li>\n<li>断言二、三主要是判断 <code>items</code> 是否有指定属性，有就返回对应的值，没有则返回 <code>undefined</code>。 </li>\n<li>断言四、五需要删除指定键值并返回 <code>true</code>，如果没有该属性则返回 <code>false</code>。 </li>\n</ul>\n<p>分析完了需求直接上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.has = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> key <span class=\"keyword\">in</span> items;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.set = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  items[key] = value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.get = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.has(key) ? items[key] : <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.remove = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.has(key)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> items[key];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-values-、getItems-方法\"><a href=\"#实现-values-、getItems-方法\" class=\"headerlink\" title=\"实现 values 、getItems 方法\"></a>实现 values 、getItems 方法</h3><p>实现 <code>values</code> 方法（返回字典中所有的值）、<code>getItems</code> 方法（获取私有变量 <code>items</code>），可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dictionary = <span class=\"keyword\">new</span> Dictionary();</span><br><span class=\"line\"></span><br><span class=\"line\">dictionary.set(<span class=\"string\">'李四'</span>, <span class=\"string\">'lisi@email.com'</span>);</span><br><span class=\"line\">dictionary.set(<span class=\"string\">'王五'</span>, <span class=\"string\">'wangwu@email.com'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(dictionary.values()).toEqual([<span class=\"string\">'lisi@email.com'</span>, <span class=\"string\">'wangwu@email.com'</span>]); <span class=\"comment\">//断言一</span></span><br><span class=\"line\">expect(dictionary.getItems()).toEqual(&#123;</span><br><span class=\"line\">  <span class=\"string\">'李四'</span>: <span class=\"string\">'lisi@email.com'</span>,</span><br><span class=\"line\">  <span class=\"string\">'王五'</span>: <span class=\"string\">'wangwu@email.com'</span></span><br><span class=\"line\">&#125;); <span class=\"comment\">// 断言二</span></span><br></pre></td></tr></table></figure>\n<p>来分析下需求吧！</p>\n<ul>\n<li>实现断言一只需要遍历 <code>items</code> 的属性，将其 push 到数组中返回即可。遍历属性是用的是 <code>for...in</code>，这种方法可能会遍历原型上继承来的属性（虽然本例中不存在这种情况，不过保险起见，还是写上吧！）。所以还需要判断 <code>items</code> 是否有该属性。</li>\n<li>实现断言二只需要直接返回 <code>items</code> 即可。</li>\n</ul>\n<blockquote>\n<p><code>for...in</code> 以任意序迭代一个对象的可枚举属性。每个不同的属性，语句都会被执行一次。更多细节请参考 MDN 文档 —— <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in\" target=\"_blank\" rel=\"noopener\">for…in</a>。</p>\n</blockquote>\n<p>分析完了需求直接上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.values = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> values = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> items)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.has(key))&#123;</span><br><span class=\"line\">      values.push(items[key]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.getItems = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> items;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>至此，字典类就写完了。</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>"},{"title":"使用 Jest 与 Puppeteer 来进行端对端测试","date":"2017-12-05T02:07:00.000Z","_content":"\n今天我们要讲的是如何使用 Jest 与 Puppeteer 来进行端对端测试（e2e testing）。\n\n<!--more-->\n\n## 端对端测试 vs. 单元测试\n\n在前面[很多文章](http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/)中，我们都介绍了单元测试。如果你了解单元测试，或者读过我之前写的单元测试的文章，那么你一定知道，单元测试的测试对象是单独的、隔离的小代码片段或者代码单元。与单元测试不同，端对端测试的测试对象则是页面上的用户交互，我们对底层实现一无所知，也就是说我们的测试是黑盒的。另外，一些跨页测试，比如链接检查，登陆跳转等功能必须使用端对端测试才能检查出来，单元测试是无法测这些功能的。以前我只写单元测试，不写端对端测试，结果有一次所负责的页面上有个链接不能点了，还好及时修复，但还是让我感受到了端对端测试，或者说是自动化端对端测试的重要性。这是我在物流服务中做的端对端测试演示：\n\n![](/css/images/3.gif)\n\n话不多说，让我们开始学习端对端测试吧！\n\n> Puppeteer 默认情况下，所有操作是不可见的，如果你想像我这样监视发生的一切，需要将 Puppeteer 的 `headless` 选项设为 `false`，具体操作将会在[下篇博文](http://www.liuyiqi.cn/2017/12/05/common-puppeteer-api-collection/)中介绍。\n\n## 使用 Puppeteer 进行浏览器自动化\n\n我使用过很多端对端测试的轮子，比如 Selenium、Appium、Protractor、Zombie.js、Cypress、Nightmare、Puppeteer 等。但最终还是选择了 Puppeteer，因为 Selenium 和 Appium 太难用了，Protractor 则像是专门给 Angular 设计的，Zombie.js 太简单了，而且使用的浏览器内核不是市面上流行的任何一个，而是自定义的。Cypress 有平台依赖，我只是想要个本地运行的工具而已。只剩 Nightmare 和 Puppeteer 了，其实这两个都是好选择，但是我是个 star 控，Puppeteer 的 star 比 Nightmare 多，所以我选择了 Puppeteer。但事实上 Nightmare 更流行，因为我发现蚂蚁最新的那个 Antd Pro 就是用的 Nightmare，阿里一些其他端对端测试的工具也有基于 Nightmare 来做的。所以如果你想使用 Nightmare 来进行自动化端对端测试也是完全没有问题的。\n\n\n使用 Puppeteer 非常简单，首先安装它：\n\n```sh\nyarn add puppeteer\n# or \"npm i puppeteer\"\n```\n\n然后就可以在 Node 脚本中使用它了！来个简单的导航并截屏例子吧！这个例子先启动浏览器，导航到 `https://baidu.com` 页面，然后截屏并保存为 `baidu.png`，最后关闭浏览器。\n\n```js\nconst puppeteer = require('puppeteer');\n\n(async () => {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  await page.goto('https://baidu.com');\n  await page.screenshot({path: 'baidu.png'});\n\n  await browser.close();\n})();\n```\n\n将上述代码写进 Node 脚本中，并运行就可以了！看下生成的截图：\n\n![image](/css/images/4.jpg)\n\n是不是很简单？短短几行代码就做了这么多事。如果你对 `async`、`await` 这种语法不熟悉，那么我强烈建议你去学习一下，这种语法在 Puppeteer 中使用率简直不要太高。不过也不要担心学习成本， `async`、`await` 语法非常简单，就是 Promise 的一种新写法而已，让你的异步代码看起来就像是同步的一样。\n\n## 使用 Jest 来进行测试\n\n要知道，Puppeteer 是一个浏览器自动化工具，它只能进行浏览器的自动化，本身并不具有测试功能。我说的测试功能指的是，断言啊，生成测试报告啊这些功能。如果你不熟悉这些概念，那么请移步：[《Jest 单元测试入门》](http://www.liuyiqi.cn/2017/02/15/start-jest/)。所以，除了 Puppeteer 外，我们还需要使用一个测试工具，我选择了 Jest，理由在[之前的博文中](http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/)已经说过很多遍了，这里不再赘述。使用 Jest 非常简单，只需要\n\n- 安装 Jest\n- 编写测试脚本 *.test.js\n- 最后在终端中输入 jest 命令运行测试\n\n具体用法看之前的博文：[《Jest 单元测试入门》](http://www.liuyiqi.cn/2017/02/15/start-jest/)。\n\n## 将 Jest 与 Puppeteer 结合使用\n\n讲完了 Puppeteer 和 Jest 的基本用法，我们来看一下，如何将两者结合起来使用。其实将 Jest 与 Puppeteer 结合使用非常简单，因为 Puppeteer 的本质就是个 NPM 模块而已，所以我们只需要在 Jest 测试脚本中引入它即可使用了。为何如此呢？因为测试脚本的本质其实也是 Node 脚本，既然是 Node 脚本那么当然可以直接引入 NPM 模块来用了！\n\n> 需要注意的是，因为 Puppeteer 通常需要使用 `async`、`await` 这种语法，如果你的 Node 版本在7.6及以上，那么恭喜你，直接大胆使用，否则需要在 Jest 中配置 Babel，来使其支持这种新语法。在 Jest 中配置 Babel 非常简单，你可以在[这里](http://facebook.github.io/jest/docs/en/getting-started#using-babel)找到具体方法。\n\n让我们来个小例子吧！首先，我们打开百度页面，并断言百度页面的 `title` 是 `百度一下，你就知道`。那么测试脚本应该这么写：\n\n```js\nconst puppeteer = require('puppeteer');\n\ntest('baidu title is correct', async () => {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  await page.goto('https://baidu.com');\n  const title = await page.title();\n  expect(title).toBe('百度一下，你就知道');\n  await browser.close();\n});\n```\n\n看到 `test` 和 `expect` 两个\b\b全局函数了吗？这就是 Jest 所赋予的能力，让你可以编写测试\b\b用例和断言。最后在命令行输入 `npm test`，即 `jest`（这是在 package.json 中配置好的命令），即可看到\b生成的测试报告：\n\n```sh\n$ npm test\n\n> fe-test@1.0.0 test /Users/liuyiqi/code/fe-test\n> jest\n\n PASS  puppeteer-demo/baidu-title.test.js\n PASS  puppeteer-demo/screenshot.test.js\n\nTest Suites: 2 passed, 2 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        3.241s\nRan all test suites.\n```\n\n其中 `screenshot.test.js` 是截屏的那个例子，`baidu-title.test.js` 是断言百度首页 title 的例子。\b你可以在这里找到源码：\n\n<https://github.com/lewis617/fe-test/tree/master/puppeteer-demo>\n\n至此，使用 Jest 与 Puppeteer 来进行端对端测试的基本用法就讲完了。下篇博文我们将会集中讲解常用 Puppeteer 功能，比如模拟用户输入、执行 JavaScript 脚本、获取某个\b DOM 节点中的文本\b等。\n\n## 更多测试文章：\n\n<http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/>","source":"_posts/e2e-testing-with-jest-and-puppeteer.md","raw":"---\ntitle: 使用 Jest 与 Puppeteer 来进行端对端测试\ndate: 2017-12-05 10:07:00\ntags: [Jest, Puppeteer, 测试, 端对端测试, 黑盒测试, e2e]\n---\n\n今天我们要讲的是如何使用 Jest 与 Puppeteer 来进行端对端测试（e2e testing）。\n\n<!--more-->\n\n## 端对端测试 vs. 单元测试\n\n在前面[很多文章](http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/)中，我们都介绍了单元测试。如果你了解单元测试，或者读过我之前写的单元测试的文章，那么你一定知道，单元测试的测试对象是单独的、隔离的小代码片段或者代码单元。与单元测试不同，端对端测试的测试对象则是页面上的用户交互，我们对底层实现一无所知，也就是说我们的测试是黑盒的。另外，一些跨页测试，比如链接检查，登陆跳转等功能必须使用端对端测试才能检查出来，单元测试是无法测这些功能的。以前我只写单元测试，不写端对端测试，结果有一次所负责的页面上有个链接不能点了，还好及时修复，但还是让我感受到了端对端测试，或者说是自动化端对端测试的重要性。这是我在物流服务中做的端对端测试演示：\n\n![](/css/images/3.gif)\n\n话不多说，让我们开始学习端对端测试吧！\n\n> Puppeteer 默认情况下，所有操作是不可见的，如果你想像我这样监视发生的一切，需要将 Puppeteer 的 `headless` 选项设为 `false`，具体操作将会在[下篇博文](http://www.liuyiqi.cn/2017/12/05/common-puppeteer-api-collection/)中介绍。\n\n## 使用 Puppeteer 进行浏览器自动化\n\n我使用过很多端对端测试的轮子，比如 Selenium、Appium、Protractor、Zombie.js、Cypress、Nightmare、Puppeteer 等。但最终还是选择了 Puppeteer，因为 Selenium 和 Appium 太难用了，Protractor 则像是专门给 Angular 设计的，Zombie.js 太简单了，而且使用的浏览器内核不是市面上流行的任何一个，而是自定义的。Cypress 有平台依赖，我只是想要个本地运行的工具而已。只剩 Nightmare 和 Puppeteer 了，其实这两个都是好选择，但是我是个 star 控，Puppeteer 的 star 比 Nightmare 多，所以我选择了 Puppeteer。但事实上 Nightmare 更流行，因为我发现蚂蚁最新的那个 Antd Pro 就是用的 Nightmare，阿里一些其他端对端测试的工具也有基于 Nightmare 来做的。所以如果你想使用 Nightmare 来进行自动化端对端测试也是完全没有问题的。\n\n\n使用 Puppeteer 非常简单，首先安装它：\n\n```sh\nyarn add puppeteer\n# or \"npm i puppeteer\"\n```\n\n然后就可以在 Node 脚本中使用它了！来个简单的导航并截屏例子吧！这个例子先启动浏览器，导航到 `https://baidu.com` 页面，然后截屏并保存为 `baidu.png`，最后关闭浏览器。\n\n```js\nconst puppeteer = require('puppeteer');\n\n(async () => {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  await page.goto('https://baidu.com');\n  await page.screenshot({path: 'baidu.png'});\n\n  await browser.close();\n})();\n```\n\n将上述代码写进 Node 脚本中，并运行就可以了！看下生成的截图：\n\n![image](/css/images/4.jpg)\n\n是不是很简单？短短几行代码就做了这么多事。如果你对 `async`、`await` 这种语法不熟悉，那么我强烈建议你去学习一下，这种语法在 Puppeteer 中使用率简直不要太高。不过也不要担心学习成本， `async`、`await` 语法非常简单，就是 Promise 的一种新写法而已，让你的异步代码看起来就像是同步的一样。\n\n## 使用 Jest 来进行测试\n\n要知道，Puppeteer 是一个浏览器自动化工具，它只能进行浏览器的自动化，本身并不具有测试功能。我说的测试功能指的是，断言啊，生成测试报告啊这些功能。如果你不熟悉这些概念，那么请移步：[《Jest 单元测试入门》](http://www.liuyiqi.cn/2017/02/15/start-jest/)。所以，除了 Puppeteer 外，我们还需要使用一个测试工具，我选择了 Jest，理由在[之前的博文中](http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/)已经说过很多遍了，这里不再赘述。使用 Jest 非常简单，只需要\n\n- 安装 Jest\n- 编写测试脚本 *.test.js\n- 最后在终端中输入 jest 命令运行测试\n\n具体用法看之前的博文：[《Jest 单元测试入门》](http://www.liuyiqi.cn/2017/02/15/start-jest/)。\n\n## 将 Jest 与 Puppeteer 结合使用\n\n讲完了 Puppeteer 和 Jest 的基本用法，我们来看一下，如何将两者结合起来使用。其实将 Jest 与 Puppeteer 结合使用非常简单，因为 Puppeteer 的本质就是个 NPM 模块而已，所以我们只需要在 Jest 测试脚本中引入它即可使用了。为何如此呢？因为测试脚本的本质其实也是 Node 脚本，既然是 Node 脚本那么当然可以直接引入 NPM 模块来用了！\n\n> 需要注意的是，因为 Puppeteer 通常需要使用 `async`、`await` 这种语法，如果你的 Node 版本在7.6及以上，那么恭喜你，直接大胆使用，否则需要在 Jest 中配置 Babel，来使其支持这种新语法。在 Jest 中配置 Babel 非常简单，你可以在[这里](http://facebook.github.io/jest/docs/en/getting-started#using-babel)找到具体方法。\n\n让我们来个小例子吧！首先，我们打开百度页面，并断言百度页面的 `title` 是 `百度一下，你就知道`。那么测试脚本应该这么写：\n\n```js\nconst puppeteer = require('puppeteer');\n\ntest('baidu title is correct', async () => {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  await page.goto('https://baidu.com');\n  const title = await page.title();\n  expect(title).toBe('百度一下，你就知道');\n  await browser.close();\n});\n```\n\n看到 `test` 和 `expect` 两个\b\b全局函数了吗？这就是 Jest 所赋予的能力，让你可以编写测试\b\b用例和断言。最后在命令行输入 `npm test`，即 `jest`（这是在 package.json 中配置好的命令），即可看到\b生成的测试报告：\n\n```sh\n$ npm test\n\n> fe-test@1.0.0 test /Users/liuyiqi/code/fe-test\n> jest\n\n PASS  puppeteer-demo/baidu-title.test.js\n PASS  puppeteer-demo/screenshot.test.js\n\nTest Suites: 2 passed, 2 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        3.241s\nRan all test suites.\n```\n\n其中 `screenshot.test.js` 是截屏的那个例子，`baidu-title.test.js` 是断言百度首页 title 的例子。\b你可以在这里找到源码：\n\n<https://github.com/lewis617/fe-test/tree/master/puppeteer-demo>\n\n至此，使用 Jest 与 Puppeteer 来进行端对端测试的基本用法就讲完了。下篇博文我们将会集中讲解常用 Puppeteer 功能，比如模拟用户输入、执行 JavaScript 脚本、获取某个\b DOM 节点中的文本\b等。\n\n## 更多测试文章：\n\n<http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/>","slug":"e2e-testing-with-jest-and-puppeteer","published":1,"updated":"2019-05-01T08:10:29.448Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvl7000dtgyt0usvwnem","content":"<p>今天我们要讲的是如何使用 Jest 与 Puppeteer 来进行端对端测试（e2e testing）。</p>\n<a id=\"more\"></a>\n<h2 id=\"端对端测试-vs-单元测试\"><a href=\"#端对端测试-vs-单元测试\" class=\"headerlink\" title=\"端对端测试 vs. 单元测试\"></a>端对端测试 vs. 单元测试</h2><p>在前面<a href=\"http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/\">很多文章</a>中，我们都介绍了单元测试。如果你了解单元测试，或者读过我之前写的单元测试的文章，那么你一定知道，单元测试的测试对象是单独的、隔离的小代码片段或者代码单元。与单元测试不同，端对端测试的测试对象则是页面上的用户交互，我们对底层实现一无所知，也就是说我们的测试是黑盒的。另外，一些跨页测试，比如链接检查，登陆跳转等功能必须使用端对端测试才能检查出来，单元测试是无法测这些功能的。以前我只写单元测试，不写端对端测试，结果有一次所负责的页面上有个链接不能点了，还好及时修复，但还是让我感受到了端对端测试，或者说是自动化端对端测试的重要性。这是我在物流服务中做的端对端测试演示：</p>\n<p><img src=\"/css/images/3.gif\" alt=\"\"></p>\n<p>话不多说，让我们开始学习端对端测试吧！</p>\n<blockquote>\n<p>Puppeteer 默认情况下，所有操作是不可见的，如果你想像我这样监视发生的一切，需要将 Puppeteer 的 <code>headless</code> 选项设为 <code>false</code>，具体操作将会在<a href=\"http://www.liuyiqi.cn/2017/12/05/common-puppeteer-api-collection/\">下篇博文</a>中介绍。</p>\n</blockquote>\n<h2 id=\"使用-Puppeteer-进行浏览器自动化\"><a href=\"#使用-Puppeteer-进行浏览器自动化\" class=\"headerlink\" title=\"使用 Puppeteer 进行浏览器自动化\"></a>使用 Puppeteer 进行浏览器自动化</h2><p>我使用过很多端对端测试的轮子，比如 Selenium、Appium、Protractor、Zombie.js、Cypress、Nightmare、Puppeteer 等。但最终还是选择了 Puppeteer，因为 Selenium 和 Appium 太难用了，Protractor 则像是专门给 Angular 设计的，Zombie.js 太简单了，而且使用的浏览器内核不是市面上流行的任何一个，而是自定义的。Cypress 有平台依赖，我只是想要个本地运行的工具而已。只剩 Nightmare 和 Puppeteer 了，其实这两个都是好选择，但是我是个 star 控，Puppeteer 的 star 比 Nightmare 多，所以我选择了 Puppeteer。但事实上 Nightmare 更流行，因为我发现蚂蚁最新的那个 Antd Pro 就是用的 Nightmare，阿里一些其他端对端测试的工具也有基于 Nightmare 来做的。所以如果你想使用 Nightmare 来进行自动化端对端测试也是完全没有问题的。</p>\n<p>使用 Puppeteer 非常简单，首先安装它：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add puppeteer</span><br><span class=\"line\"><span class=\"comment\"># or \"npm i puppeteer\"</span></span><br></pre></td></tr></table></figure>\n<p>然后就可以在 Node 脚本中使用它了！来个简单的导航并截屏例子吧！这个例子先启动浏览器，导航到 <code>https://baidu.com</code> 页面，然后截屏并保存为 <code>baidu.png</code>，最后关闭浏览器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> puppeteer = <span class=\"built_in\">require</span>(<span class=\"string\">'puppeteer'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> browser = <span class=\"keyword\">await</span> puppeteer.launch();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> page = <span class=\"keyword\">await</span> browser.newPage();</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.goto(<span class=\"string\">'https://baidu.com'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.screenshot(&#123;<span class=\"attr\">path</span>: <span class=\"string\">'baidu.png'</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">await</span> browser.close();</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>将上述代码写进 Node 脚本中，并运行就可以了！看下生成的截图：</p>\n<p><img src=\"/css/images/4.jpg\" alt=\"image\"></p>\n<p>是不是很简单？短短几行代码就做了这么多事。如果你对 <code>async</code>、<code>await</code> 这种语法不熟悉，那么我强烈建议你去学习一下，这种语法在 Puppeteer 中使用率简直不要太高。不过也不要担心学习成本， <code>async</code>、<code>await</code> 语法非常简单，就是 Promise 的一种新写法而已，让你的异步代码看起来就像是同步的一样。</p>\n<h2 id=\"使用-Jest-来进行测试\"><a href=\"#使用-Jest-来进行测试\" class=\"headerlink\" title=\"使用 Jest 来进行测试\"></a>使用 Jest 来进行测试</h2><p>要知道，Puppeteer 是一个浏览器自动化工具，它只能进行浏览器的自动化，本身并不具有测试功能。我说的测试功能指的是，断言啊，生成测试报告啊这些功能。如果你不熟悉这些概念，那么请移步：<a href=\"http://www.liuyiqi.cn/2017/02/15/start-jest/\">《Jest 单元测试入门》</a>。所以，除了 Puppeteer 外，我们还需要使用一个测试工具，我选择了 Jest，理由在<a href=\"http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/\">之前的博文中</a>已经说过很多遍了，这里不再赘述。使用 Jest 非常简单，只需要</p>\n<ul>\n<li>安装 Jest</li>\n<li>编写测试脚本 *.test.js</li>\n<li>最后在终端中输入 jest 命令运行测试</li>\n</ul>\n<p>具体用法看之前的博文：<a href=\"http://www.liuyiqi.cn/2017/02/15/start-jest/\">《Jest 单元测试入门》</a>。</p>\n<h2 id=\"将-Jest-与-Puppeteer-结合使用\"><a href=\"#将-Jest-与-Puppeteer-结合使用\" class=\"headerlink\" title=\"将 Jest 与 Puppeteer 结合使用\"></a>将 Jest 与 Puppeteer 结合使用</h2><p>讲完了 Puppeteer 和 Jest 的基本用法，我们来看一下，如何将两者结合起来使用。其实将 Jest 与 Puppeteer 结合使用非常简单，因为 Puppeteer 的本质就是个 NPM 模块而已，所以我们只需要在 Jest 测试脚本中引入它即可使用了。为何如此呢？因为测试脚本的本质其实也是 Node 脚本，既然是 Node 脚本那么当然可以直接引入 NPM 模块来用了！</p>\n<blockquote>\n<p>需要注意的是，因为 Puppeteer 通常需要使用 <code>async</code>、<code>await</code> 这种语法，如果你的 Node 版本在7.6及以上，那么恭喜你，直接大胆使用，否则需要在 Jest 中配置 Babel，来使其支持这种新语法。在 Jest 中配置 Babel 非常简单，你可以在<a href=\"http://facebook.github.io/jest/docs/en/getting-started#using-babel\" target=\"_blank\" rel=\"noopener\">这里</a>找到具体方法。</p>\n</blockquote>\n<p>让我们来个小例子吧！首先，我们打开百度页面，并断言百度页面的 <code>title</code> 是 <code>百度一下，你就知道</code>。那么测试脚本应该这么写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> puppeteer = <span class=\"built_in\">require</span>(<span class=\"string\">'puppeteer'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'baidu title is correct'</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> browser = <span class=\"keyword\">await</span> puppeteer.launch();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> page = <span class=\"keyword\">await</span> browser.newPage();</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.goto(<span class=\"string\">'https://baidu.com'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> title = <span class=\"keyword\">await</span> page.title();</span><br><span class=\"line\">  expect(title).toBe(<span class=\"string\">'百度一下，你就知道'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> browser.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>看到 <code>test</code> 和 <code>expect</code> 两个\b\b全局函数了吗？这就是 Jest 所赋予的能力，让你可以编写测试\b\b用例和断言。最后在命令行输入 <code>npm test</code>，即 <code>jest</code>（这是在 package.json 中配置好的命令），即可看到\b生成的测试报告：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; fe-test@1.0.0 <span class=\"built_in\">test</span> /Users/liuyiqi/code/fe-test</span><br><span class=\"line\">&gt; jest</span><br><span class=\"line\"></span><br><span class=\"line\"> PASS  puppeteer-demo/baidu-title.test.js</span><br><span class=\"line\"> PASS  puppeteer-demo/screenshot.test.js</span><br><span class=\"line\"></span><br><span class=\"line\">Test Suites: 2 passed, 2 total</span><br><span class=\"line\">Tests:       2 passed, 2 total</span><br><span class=\"line\">Snapshots:   0 total</span><br><span class=\"line\">Time:        3.241s</span><br><span class=\"line\">Ran all <span class=\"built_in\">test</span> suites.</span><br></pre></td></tr></table></figure>\n<p>其中 <code>screenshot.test.js</code> 是截屏的那个例子，<code>baidu-title.test.js</code> 是断言百度首页 title 的例子。\b你可以在这里找到源码：</p>\n<p><a href=\"https://github.com/lewis617/fe-test/tree/master/puppeteer-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/fe-test/tree/master/puppeteer-demo</a></p>\n<p>至此，使用 Jest 与 Puppeteer 来进行端对端测试的基本用法就讲完了。下篇博文我们将会集中讲解常用 Puppeteer 功能，比如模拟用户输入、执行 JavaScript 脚本、获取某个\b DOM 节点中的文本\b等。</p>\n<h2 id=\"更多测试文章：\"><a href=\"#更多测试文章：\" class=\"headerlink\" title=\"更多测试文章：\"></a>更多测试文章：</h2><p><a href=\"http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/\">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天我们要讲的是如何使用 Jest 与 Puppeteer 来进行端对端测试（e2e testing）。</p>","more":"<h2 id=\"端对端测试-vs-单元测试\"><a href=\"#端对端测试-vs-单元测试\" class=\"headerlink\" title=\"端对端测试 vs. 单元测试\"></a>端对端测试 vs. 单元测试</h2><p>在前面<a href=\"http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/\">很多文章</a>中，我们都介绍了单元测试。如果你了解单元测试，或者读过我之前写的单元测试的文章，那么你一定知道，单元测试的测试对象是单独的、隔离的小代码片段或者代码单元。与单元测试不同，端对端测试的测试对象则是页面上的用户交互，我们对底层实现一无所知，也就是说我们的测试是黑盒的。另外，一些跨页测试，比如链接检查，登陆跳转等功能必须使用端对端测试才能检查出来，单元测试是无法测这些功能的。以前我只写单元测试，不写端对端测试，结果有一次所负责的页面上有个链接不能点了，还好及时修复，但还是让我感受到了端对端测试，或者说是自动化端对端测试的重要性。这是我在物流服务中做的端对端测试演示：</p>\n<p><img src=\"/css/images/3.gif\" alt=\"\"></p>\n<p>话不多说，让我们开始学习端对端测试吧！</p>\n<blockquote>\n<p>Puppeteer 默认情况下，所有操作是不可见的，如果你想像我这样监视发生的一切，需要将 Puppeteer 的 <code>headless</code> 选项设为 <code>false</code>，具体操作将会在<a href=\"http://www.liuyiqi.cn/2017/12/05/common-puppeteer-api-collection/\">下篇博文</a>中介绍。</p>\n</blockquote>\n<h2 id=\"使用-Puppeteer-进行浏览器自动化\"><a href=\"#使用-Puppeteer-进行浏览器自动化\" class=\"headerlink\" title=\"使用 Puppeteer 进行浏览器自动化\"></a>使用 Puppeteer 进行浏览器自动化</h2><p>我使用过很多端对端测试的轮子，比如 Selenium、Appium、Protractor、Zombie.js、Cypress、Nightmare、Puppeteer 等。但最终还是选择了 Puppeteer，因为 Selenium 和 Appium 太难用了，Protractor 则像是专门给 Angular 设计的，Zombie.js 太简单了，而且使用的浏览器内核不是市面上流行的任何一个，而是自定义的。Cypress 有平台依赖，我只是想要个本地运行的工具而已。只剩 Nightmare 和 Puppeteer 了，其实这两个都是好选择，但是我是个 star 控，Puppeteer 的 star 比 Nightmare 多，所以我选择了 Puppeteer。但事实上 Nightmare 更流行，因为我发现蚂蚁最新的那个 Antd Pro 就是用的 Nightmare，阿里一些其他端对端测试的工具也有基于 Nightmare 来做的。所以如果你想使用 Nightmare 来进行自动化端对端测试也是完全没有问题的。</p>\n<p>使用 Puppeteer 非常简单，首先安装它：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add puppeteer</span><br><span class=\"line\"><span class=\"comment\"># or \"npm i puppeteer\"</span></span><br></pre></td></tr></table></figure>\n<p>然后就可以在 Node 脚本中使用它了！来个简单的导航并截屏例子吧！这个例子先启动浏览器，导航到 <code>https://baidu.com</code> 页面，然后截屏并保存为 <code>baidu.png</code>，最后关闭浏览器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> puppeteer = <span class=\"built_in\">require</span>(<span class=\"string\">'puppeteer'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> browser = <span class=\"keyword\">await</span> puppeteer.launch();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> page = <span class=\"keyword\">await</span> browser.newPage();</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.goto(<span class=\"string\">'https://baidu.com'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.screenshot(&#123;<span class=\"attr\">path</span>: <span class=\"string\">'baidu.png'</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">await</span> browser.close();</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>将上述代码写进 Node 脚本中，并运行就可以了！看下生成的截图：</p>\n<p><img src=\"/css/images/4.jpg\" alt=\"image\"></p>\n<p>是不是很简单？短短几行代码就做了这么多事。如果你对 <code>async</code>、<code>await</code> 这种语法不熟悉，那么我强烈建议你去学习一下，这种语法在 Puppeteer 中使用率简直不要太高。不过也不要担心学习成本， <code>async</code>、<code>await</code> 语法非常简单，就是 Promise 的一种新写法而已，让你的异步代码看起来就像是同步的一样。</p>\n<h2 id=\"使用-Jest-来进行测试\"><a href=\"#使用-Jest-来进行测试\" class=\"headerlink\" title=\"使用 Jest 来进行测试\"></a>使用 Jest 来进行测试</h2><p>要知道，Puppeteer 是一个浏览器自动化工具，它只能进行浏览器的自动化，本身并不具有测试功能。我说的测试功能指的是，断言啊，生成测试报告啊这些功能。如果你不熟悉这些概念，那么请移步：<a href=\"http://www.liuyiqi.cn/2017/02/15/start-jest/\">《Jest 单元测试入门》</a>。所以，除了 Puppeteer 外，我们还需要使用一个测试工具，我选择了 Jest，理由在<a href=\"http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/\">之前的博文中</a>已经说过很多遍了，这里不再赘述。使用 Jest 非常简单，只需要</p>\n<ul>\n<li>安装 Jest</li>\n<li>编写测试脚本 *.test.js</li>\n<li>最后在终端中输入 jest 命令运行测试</li>\n</ul>\n<p>具体用法看之前的博文：<a href=\"http://www.liuyiqi.cn/2017/02/15/start-jest/\">《Jest 单元测试入门》</a>。</p>\n<h2 id=\"将-Jest-与-Puppeteer-结合使用\"><a href=\"#将-Jest-与-Puppeteer-结合使用\" class=\"headerlink\" title=\"将 Jest 与 Puppeteer 结合使用\"></a>将 Jest 与 Puppeteer 结合使用</h2><p>讲完了 Puppeteer 和 Jest 的基本用法，我们来看一下，如何将两者结合起来使用。其实将 Jest 与 Puppeteer 结合使用非常简单，因为 Puppeteer 的本质就是个 NPM 模块而已，所以我们只需要在 Jest 测试脚本中引入它即可使用了。为何如此呢？因为测试脚本的本质其实也是 Node 脚本，既然是 Node 脚本那么当然可以直接引入 NPM 模块来用了！</p>\n<blockquote>\n<p>需要注意的是，因为 Puppeteer 通常需要使用 <code>async</code>、<code>await</code> 这种语法，如果你的 Node 版本在7.6及以上，那么恭喜你，直接大胆使用，否则需要在 Jest 中配置 Babel，来使其支持这种新语法。在 Jest 中配置 Babel 非常简单，你可以在<a href=\"http://facebook.github.io/jest/docs/en/getting-started#using-babel\" target=\"_blank\" rel=\"noopener\">这里</a>找到具体方法。</p>\n</blockquote>\n<p>让我们来个小例子吧！首先，我们打开百度页面，并断言百度页面的 <code>title</code> 是 <code>百度一下，你就知道</code>。那么测试脚本应该这么写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> puppeteer = <span class=\"built_in\">require</span>(<span class=\"string\">'puppeteer'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'baidu title is correct'</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> browser = <span class=\"keyword\">await</span> puppeteer.launch();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> page = <span class=\"keyword\">await</span> browser.newPage();</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.goto(<span class=\"string\">'https://baidu.com'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> title = <span class=\"keyword\">await</span> page.title();</span><br><span class=\"line\">  expect(title).toBe(<span class=\"string\">'百度一下，你就知道'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> browser.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>看到 <code>test</code> 和 <code>expect</code> 两个\b\b全局函数了吗？这就是 Jest 所赋予的能力，让你可以编写测试\b\b用例和断言。最后在命令行输入 <code>npm test</code>，即 <code>jest</code>（这是在 package.json 中配置好的命令），即可看到\b生成的测试报告：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; fe-test@1.0.0 <span class=\"built_in\">test</span> /Users/liuyiqi/code/fe-test</span><br><span class=\"line\">&gt; jest</span><br><span class=\"line\"></span><br><span class=\"line\"> PASS  puppeteer-demo/baidu-title.test.js</span><br><span class=\"line\"> PASS  puppeteer-demo/screenshot.test.js</span><br><span class=\"line\"></span><br><span class=\"line\">Test Suites: 2 passed, 2 total</span><br><span class=\"line\">Tests:       2 passed, 2 total</span><br><span class=\"line\">Snapshots:   0 total</span><br><span class=\"line\">Time:        3.241s</span><br><span class=\"line\">Ran all <span class=\"built_in\">test</span> suites.</span><br></pre></td></tr></table></figure>\n<p>其中 <code>screenshot.test.js</code> 是截屏的那个例子，<code>baidu-title.test.js</code> 是断言百度首页 title 的例子。\b你可以在这里找到源码：</p>\n<p><a href=\"https://github.com/lewis617/fe-test/tree/master/puppeteer-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/fe-test/tree/master/puppeteer-demo</a></p>\n<p>至此，使用 Jest 与 Puppeteer 来进行端对端测试的基本用法就讲完了。下篇博文我们将会集中讲解常用 Puppeteer 功能，比如模拟用户输入、执行 JavaScript 脚本、获取某个\b DOM 节点中的文本\b等。</p>\n<h2 id=\"更多测试文章：\"><a href=\"#更多测试文章：\" class=\"headerlink\" title=\"更多测试文章：\"></a>更多测试文章：</h2><p><a href=\"http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/\">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>"},{"title":"JavaScript 版数据结构与算法（八）图","date":"2017-02-19T05:27:00.000Z","_content":"\n今天，我们要讲的是数据结构与算法中的图。\n\n<!--more-->\n\n## 图简介\n\n图是什么？图是网络结构的抽象模型。图是一组由**边**连接的**节点**(或顶点)。图有啥用？图的作用有这些：\n\n- 图可以表示任何二元关系，比如道路、航班、通信状态。\n- 非加权图可以用广度优先遍历来计算最短路径。\n\n图的应用非常广泛，远远不止上面这些，有兴趣的同学可以自行去了解更多的图的用途，这里不再详述。\n\n## 用 JavaScript 编写图类\n\n图的展现方式有很多，常见的包括：\n\n- **邻接矩阵**：矩阵的行列都是图的顶点，数字代表是否连接\n- **邻接表**： 由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表(数组)、链表，甚至是散列表或是字典来表示相邻顶点列表。\n- **关联矩阵**： 矩阵的行表示顶点，列表示边，数字代表是否连接。\n\n本文将会使用**邻接表**来展现图。下面就让我们用 JavaScript 来编写图类吧！\n\n### 私有变量\n\n既然使用 **邻接表** 来展现图，那么私有变量就是一个数组 `vertices` 来表示图的所有顶点，还有一个字典 `adjList` 来表示每个顶点以及它相邻顶点列表。\n\n```js\nvar vertices = [];\nvar adjList = new Dictionary();\n```\n\n### 实现 addVertex 、addEdge 和 getAdjList 方法\n\n实现 `addVertex` 方法（添加顶点）、`addEdge` 方法（添加边）和 `getAdjList` 方法（获取顶点和相邻顶点组成的字典，即 `adjList`），可以跑通如下测试：\n\n```js\nvar graph = new Graph();\n\nvar myVertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];\nfor (var i = 0; i < myVertices.length; i++) {\n  graph.addVertex(myVertices[i]);\n}\ngraph.addEdge('A', 'B');\ngraph.addEdge('A', 'C');\ngraph.addEdge('A', 'D');\ngraph.addEdge('C', 'D');\ngraph.addEdge('C', 'G');\ngraph.addEdge('D', 'G');\ngraph.addEdge('D', 'H');\ngraph.addEdge('B', 'E');\ngraph.addEdge('B', 'F');\ngraph.addEdge('E', 'I');\n\nexpect(graph.getAdjList()).toEqual({\n  'A': ['B', 'C', 'D'],\n  'B': ['A', 'E', 'F'],\n  'C': ['A', 'D', 'G'],\n  'D': ['A', 'C', 'G', 'H'],\n  'E': ['B', 'I'],\n  'F': ['B'],\n  'G': ['C', 'D'],\n  'H': ['D'],\n  'I': ['E']\n});\n```\n\n我们来分析下需求，`addVertex` 方法其实就是向私有变量 `vertices` 中 push 新的值，不过也需要在 `adjList` 中添加新的键，所以实现代码如下：\n\n```js\nthis.addVertex = function (v) {\n  vertices.push(v);\n  adjList.set(v, []);\n};\n```\n\n`addEdge` 方法其实就是向私有变量 `adjList` 中相关的顶点赋值：\n\n```js\nthis.addEdge = function (v, w) {\n  adjList.get(v).push(w);\n  adjList.get(w).push(v);\n};\n```\n\n`getAdjList` 方法更简单，直接返回私有变量 `adjList.getItems()` 即可：\n\n```js\nthis.getAdjList = function () {\n  return adjList.getItems();\n};\n```\n\n### 实现广度优先遍历\n\n什么是广度优先遍历？简单来说就是先广后深来遍历图中的顶点。比如一个这样的图：\n\n![](https://ws1.sinaimg.cn/mw690/83900b4egy1fcvopomghbj20dz09ajru)\n\n那么如何实现广度优先遍历呢？这需要用到队列。实现思路如下：\n\n- 把一个顶点的相邻顶点入队，然后访问该顶点（也可以先访问再入队）\n- 出队重复第一步\n\n比如，访问 A 时，把 BCD 入队，然后接下来就可以最先访问到 BCD 了，不过注意：因为 B 的相邻顶点也包括 A 所以在入队前，需要判断相邻顶点是否入队（或访问过）。为此，我们需要设置两种状态来记录：\n\n- 白色：没入队\n- 黑色：入队了\n\n所以，我们只需要在不同阶段设置不同颜色，并根据颜色选择性入队即可。实现代码如下：\n\n```js\n// 将所有顶点初始化为白色\nvar initializeColor = function () {\n  var color = {};\n  for (var i = 0; i < vertices.length; i++) {\n    color[vertices[i]] = 'white';\n  }\n  return color;\n};\n\nthis.bfs = function (v, callback) {\n  var color = initializeColor(),\n    queue = new Queue();\n \n  queue.enqueue(v);  // 入队了就设置为黑色\n  color[v] = 'black';\n\n  while (!queue.isEmpty()) {\n    var u = queue.dequeue(),  // 出队重复第一步\n      neighbors = adjList.get(u);\n\n    for (var i = 0; i < neighbors.length; i++) {  // 将所有相邻顶点入队\n      var w = neighbors[i];\n      if (color[w] === 'white') {\n        queue.enqueue(w);\n        color[w] = 'black';  // 入队了就设置为黑色\n      }\n    }\n    if (callback) {\n      callback(u);  // 入队完了相邻顶点，就访问该顶点\n    }\n  }\n};\n```\n\n### 实现深度优先遍历\n\n什么是深度优先遍历？简单来说，深度优先遍历就是先深后广来遍历。如图：\n\n![](https://ws1.sinaimg.cn/mw690/83900b4egy1fcvp988h6bj20bu08vmxg)\n \n 那么如何实现深度优先遍历？这需要用到递归。实现思路如下：\n\n- 先访问一个顶点，然后对相邻顶点挨个进行深度优先遍历。\n\n为了记录访问过的节点，我们用黑色来代表访问过。实现代码如下：\n\n```js\nthis.dfs = function (v, callback) {\n  var color = initializeColor();\n  dfsVisit(v, color, callback);\n};\n\nvar dfsVisit = function (u, color, callback) {\n  if (callback) {\n    callback(u);\n  }\n  var neighbors = adjList.get(u);\n  color[u] = 'black';\n  for (var i = 0; i < neighbors.length; i++) {\n    var w = neighbors[i];\n    if (color[w] === 'white') {\n      dfsVisit(w, color, callback);\n    }\n  }\n};\n```\n\n以上就是广度优先遍历和深度优先遍历的 JavaScript 实现。\n\n \n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>\n\n","source":"_posts/graph.md","raw":"---\ntitle: JavaScript 版数据结构与算法（八）图\ndate: 2017-02-19 13:27:00\ntags: [数据结构与算法]\n---\n\n今天，我们要讲的是数据结构与算法中的图。\n\n<!--more-->\n\n## 图简介\n\n图是什么？图是网络结构的抽象模型。图是一组由**边**连接的**节点**(或顶点)。图有啥用？图的作用有这些：\n\n- 图可以表示任何二元关系，比如道路、航班、通信状态。\n- 非加权图可以用广度优先遍历来计算最短路径。\n\n图的应用非常广泛，远远不止上面这些，有兴趣的同学可以自行去了解更多的图的用途，这里不再详述。\n\n## 用 JavaScript 编写图类\n\n图的展现方式有很多，常见的包括：\n\n- **邻接矩阵**：矩阵的行列都是图的顶点，数字代表是否连接\n- **邻接表**： 由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表(数组)、链表，甚至是散列表或是字典来表示相邻顶点列表。\n- **关联矩阵**： 矩阵的行表示顶点，列表示边，数字代表是否连接。\n\n本文将会使用**邻接表**来展现图。下面就让我们用 JavaScript 来编写图类吧！\n\n### 私有变量\n\n既然使用 **邻接表** 来展现图，那么私有变量就是一个数组 `vertices` 来表示图的所有顶点，还有一个字典 `adjList` 来表示每个顶点以及它相邻顶点列表。\n\n```js\nvar vertices = [];\nvar adjList = new Dictionary();\n```\n\n### 实现 addVertex 、addEdge 和 getAdjList 方法\n\n实现 `addVertex` 方法（添加顶点）、`addEdge` 方法（添加边）和 `getAdjList` 方法（获取顶点和相邻顶点组成的字典，即 `adjList`），可以跑通如下测试：\n\n```js\nvar graph = new Graph();\n\nvar myVertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];\nfor (var i = 0; i < myVertices.length; i++) {\n  graph.addVertex(myVertices[i]);\n}\ngraph.addEdge('A', 'B');\ngraph.addEdge('A', 'C');\ngraph.addEdge('A', 'D');\ngraph.addEdge('C', 'D');\ngraph.addEdge('C', 'G');\ngraph.addEdge('D', 'G');\ngraph.addEdge('D', 'H');\ngraph.addEdge('B', 'E');\ngraph.addEdge('B', 'F');\ngraph.addEdge('E', 'I');\n\nexpect(graph.getAdjList()).toEqual({\n  'A': ['B', 'C', 'D'],\n  'B': ['A', 'E', 'F'],\n  'C': ['A', 'D', 'G'],\n  'D': ['A', 'C', 'G', 'H'],\n  'E': ['B', 'I'],\n  'F': ['B'],\n  'G': ['C', 'D'],\n  'H': ['D'],\n  'I': ['E']\n});\n```\n\n我们来分析下需求，`addVertex` 方法其实就是向私有变量 `vertices` 中 push 新的值，不过也需要在 `adjList` 中添加新的键，所以实现代码如下：\n\n```js\nthis.addVertex = function (v) {\n  vertices.push(v);\n  adjList.set(v, []);\n};\n```\n\n`addEdge` 方法其实就是向私有变量 `adjList` 中相关的顶点赋值：\n\n```js\nthis.addEdge = function (v, w) {\n  adjList.get(v).push(w);\n  adjList.get(w).push(v);\n};\n```\n\n`getAdjList` 方法更简单，直接返回私有变量 `adjList.getItems()` 即可：\n\n```js\nthis.getAdjList = function () {\n  return adjList.getItems();\n};\n```\n\n### 实现广度优先遍历\n\n什么是广度优先遍历？简单来说就是先广后深来遍历图中的顶点。比如一个这样的图：\n\n![](https://ws1.sinaimg.cn/mw690/83900b4egy1fcvopomghbj20dz09ajru)\n\n那么如何实现广度优先遍历呢？这需要用到队列。实现思路如下：\n\n- 把一个顶点的相邻顶点入队，然后访问该顶点（也可以先访问再入队）\n- 出队重复第一步\n\n比如，访问 A 时，把 BCD 入队，然后接下来就可以最先访问到 BCD 了，不过注意：因为 B 的相邻顶点也包括 A 所以在入队前，需要判断相邻顶点是否入队（或访问过）。为此，我们需要设置两种状态来记录：\n\n- 白色：没入队\n- 黑色：入队了\n\n所以，我们只需要在不同阶段设置不同颜色，并根据颜色选择性入队即可。实现代码如下：\n\n```js\n// 将所有顶点初始化为白色\nvar initializeColor = function () {\n  var color = {};\n  for (var i = 0; i < vertices.length; i++) {\n    color[vertices[i]] = 'white';\n  }\n  return color;\n};\n\nthis.bfs = function (v, callback) {\n  var color = initializeColor(),\n    queue = new Queue();\n \n  queue.enqueue(v);  // 入队了就设置为黑色\n  color[v] = 'black';\n\n  while (!queue.isEmpty()) {\n    var u = queue.dequeue(),  // 出队重复第一步\n      neighbors = adjList.get(u);\n\n    for (var i = 0; i < neighbors.length; i++) {  // 将所有相邻顶点入队\n      var w = neighbors[i];\n      if (color[w] === 'white') {\n        queue.enqueue(w);\n        color[w] = 'black';  // 入队了就设置为黑色\n      }\n    }\n    if (callback) {\n      callback(u);  // 入队完了相邻顶点，就访问该顶点\n    }\n  }\n};\n```\n\n### 实现深度优先遍历\n\n什么是深度优先遍历？简单来说，深度优先遍历就是先深后广来遍历。如图：\n\n![](https://ws1.sinaimg.cn/mw690/83900b4egy1fcvp988h6bj20bu08vmxg)\n \n 那么如何实现深度优先遍历？这需要用到递归。实现思路如下：\n\n- 先访问一个顶点，然后对相邻顶点挨个进行深度优先遍历。\n\n为了记录访问过的节点，我们用黑色来代表访问过。实现代码如下：\n\n```js\nthis.dfs = function (v, callback) {\n  var color = initializeColor();\n  dfsVisit(v, color, callback);\n};\n\nvar dfsVisit = function (u, color, callback) {\n  if (callback) {\n    callback(u);\n  }\n  var neighbors = adjList.get(u);\n  color[u] = 'black';\n  for (var i = 0; i < neighbors.length; i++) {\n    var w = neighbors[i];\n    if (color[w] === 'white') {\n      dfsVisit(w, color, callback);\n    }\n  }\n};\n```\n\n以上就是广度优先遍历和深度优先遍历的 JavaScript 实现。\n\n \n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>\n\n","slug":"graph","published":1,"updated":"2019-05-01T08:02:09.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvl8000gtgytutwdje3f","content":"<p>今天，我们要讲的是数据结构与算法中的图。</p>\n<a id=\"more\"></a>\n<h2 id=\"图简介\"><a href=\"#图简介\" class=\"headerlink\" title=\"图简介\"></a>图简介</h2><p>图是什么？图是网络结构的抽象模型。图是一组由<strong>边</strong>连接的<strong>节点</strong>(或顶点)。图有啥用？图的作用有这些：</p>\n<ul>\n<li>图可以表示任何二元关系，比如道路、航班、通信状态。</li>\n<li>非加权图可以用广度优先遍历来计算最短路径。</li>\n</ul>\n<p>图的应用非常广泛，远远不止上面这些，有兴趣的同学可以自行去了解更多的图的用途，这里不再详述。</p>\n<h2 id=\"用-JavaScript-编写图类\"><a href=\"#用-JavaScript-编写图类\" class=\"headerlink\" title=\"用 JavaScript 编写图类\"></a>用 JavaScript 编写图类</h2><p>图的展现方式有很多，常见的包括：</p>\n<ul>\n<li><strong>邻接矩阵</strong>：矩阵的行列都是图的顶点，数字代表是否连接</li>\n<li><strong>邻接表</strong>： 由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表(数组)、链表，甚至是散列表或是字典来表示相邻顶点列表。</li>\n<li><strong>关联矩阵</strong>： 矩阵的行表示顶点，列表示边，数字代表是否连接。</li>\n</ul>\n<p>本文将会使用<strong>邻接表</strong>来展现图。下面就让我们用 JavaScript 来编写图类吧！</p>\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>既然使用 <strong>邻接表</strong> 来展现图，那么私有变量就是一个数组 <code>vertices</code> 来表示图的所有顶点，还有一个字典 <code>adjList</code> 来表示每个顶点以及它相邻顶点列表。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vertices = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> adjList = <span class=\"keyword\">new</span> Dictionary();</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-addVertex-、addEdge-和-getAdjList-方法\"><a href=\"#实现-addVertex-、addEdge-和-getAdjList-方法\" class=\"headerlink\" title=\"实现 addVertex 、addEdge 和 getAdjList 方法\"></a>实现 addVertex 、addEdge 和 getAdjList 方法</h3><p>实现 <code>addVertex</code> 方法（添加顶点）、<code>addEdge</code> 方法（添加边）和 <code>getAdjList</code> 方法（获取顶点和相邻顶点组成的字典，即 <code>adjList</code>），可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> graph = <span class=\"keyword\">new</span> Graph();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myVertices = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'E'</span>, <span class=\"string\">'F'</span>, <span class=\"string\">'G'</span>, <span class=\"string\">'H'</span>, <span class=\"string\">'I'</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class=\"line\">  graph.addVertex(myVertices[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'C'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'D'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'C'</span>, <span class=\"string\">'G'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'D'</span>, <span class=\"string\">'G'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'D'</span>, <span class=\"string\">'H'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'B'</span>, <span class=\"string\">'E'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'B'</span>, <span class=\"string\">'F'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'E'</span>, <span class=\"string\">'I'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(graph.getAdjList()).toEqual(&#123;</span><br><span class=\"line\">  <span class=\"string\">'A'</span>: [<span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>],</span><br><span class=\"line\">  <span class=\"string\">'B'</span>: [<span class=\"string\">'A'</span>, <span class=\"string\">'E'</span>, <span class=\"string\">'F'</span>],</span><br><span class=\"line\">  <span class=\"string\">'C'</span>: [<span class=\"string\">'A'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'G'</span>],</span><br><span class=\"line\">  <span class=\"string\">'D'</span>: [<span class=\"string\">'A'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'G'</span>, <span class=\"string\">'H'</span>],</span><br><span class=\"line\">  <span class=\"string\">'E'</span>: [<span class=\"string\">'B'</span>, <span class=\"string\">'I'</span>],</span><br><span class=\"line\">  <span class=\"string\">'F'</span>: [<span class=\"string\">'B'</span>],</span><br><span class=\"line\">  <span class=\"string\">'G'</span>: [<span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>],</span><br><span class=\"line\">  <span class=\"string\">'H'</span>: [<span class=\"string\">'D'</span>],</span><br><span class=\"line\">  <span class=\"string\">'I'</span>: [<span class=\"string\">'E'</span>]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们来分析下需求，<code>addVertex</code> 方法其实就是向私有变量 <code>vertices</code> 中 push 新的值，不过也需要在 <code>adjList</code> 中添加新的键，所以实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.addVertex = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">  vertices.push(v);</span><br><span class=\"line\">  adjList.set(v, []);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>addEdge</code> 方法其实就是向私有变量 <code>adjList</code> 中相关的顶点赋值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.addEdge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v, w</span>) </span>&#123;</span><br><span class=\"line\">  adjList.get(v).push(w);</span><br><span class=\"line\">  adjList.get(w).push(v);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>getAdjList</code> 方法更简单，直接返回私有变量 <code>adjList.getItems()</code> 即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.getAdjList = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> adjList.getItems();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现广度优先遍历\"><a href=\"#实现广度优先遍历\" class=\"headerlink\" title=\"实现广度优先遍历\"></a>实现广度优先遍历</h3><p>什么是广度优先遍历？简单来说就是先广后深来遍历图中的顶点。比如一个这样的图：</p>\n<p><img src=\"https://ws1.sinaimg.cn/mw690/83900b4egy1fcvopomghbj20dz09ajru\" alt=\"\"></p>\n<p>那么如何实现广度优先遍历呢？这需要用到队列。实现思路如下：</p>\n<ul>\n<li>把一个顶点的相邻顶点入队，然后访问该顶点（也可以先访问再入队）</li>\n<li>出队重复第一步</li>\n</ul>\n<p>比如，访问 A 时，把 BCD 入队，然后接下来就可以最先访问到 BCD 了，不过注意：因为 B 的相邻顶点也包括 A 所以在入队前，需要判断相邻顶点是否入队（或访问过）。为此，我们需要设置两种状态来记录：</p>\n<ul>\n<li>白色：没入队</li>\n<li>黑色：入队了</li>\n</ul>\n<p>所以，我们只需要在不同阶段设置不同颜色，并根据颜色选择性入队即可。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将所有顶点初始化为白色</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> initializeColor = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> color = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    color[vertices[i]] = <span class=\"string\">'white'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.bfs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> color = initializeColor(),</span><br><span class=\"line\">    queue = <span class=\"keyword\">new</span> Queue();</span><br><span class=\"line\"> </span><br><span class=\"line\">  queue.enqueue(v);  <span class=\"comment\">// 入队了就设置为黑色</span></span><br><span class=\"line\">  color[v] = <span class=\"string\">'black'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> u = queue.dequeue(),  <span class=\"comment\">// 出队重复第一步</span></span><br><span class=\"line\">      neighbors = adjList.get(u);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;  <span class=\"comment\">// 将所有相邻顶点入队</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> w = neighbors[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (color[w] === <span class=\"string\">'white'</span>) &#123;</span><br><span class=\"line\">        queue.enqueue(w);</span><br><span class=\"line\">        color[w] = <span class=\"string\">'black'</span>;  <span class=\"comment\">// 入队了就设置为黑色</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback) &#123;</span><br><span class=\"line\">      callback(u);  <span class=\"comment\">// 入队完了相邻顶点，就访问该顶点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现深度优先遍历\"><a href=\"#实现深度优先遍历\" class=\"headerlink\" title=\"实现深度优先遍历\"></a>实现深度优先遍历</h3><p>什么是深度优先遍历？简单来说，深度优先遍历就是先深后广来遍历。如图：</p>\n<p><img src=\"https://ws1.sinaimg.cn/mw690/83900b4egy1fcvp988h6bj20bu08vmxg\" alt=\"\"></p>\n<p> 那么如何实现深度优先遍历？这需要用到递归。实现思路如下：</p>\n<ul>\n<li>先访问一个顶点，然后对相邻顶点挨个进行深度优先遍历。</li>\n</ul>\n<p>为了记录访问过的节点，我们用黑色来代表访问过。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.dfs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> color = initializeColor();</span><br><span class=\"line\">  dfsVisit(v, color, callback);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dfsVisit = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">u, color, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (callback) &#123;</span><br><span class=\"line\">    callback(u);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> neighbors = adjList.get(u);</span><br><span class=\"line\">  color[u] = <span class=\"string\">'black'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> w = neighbors[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[w] === <span class=\"string\">'white'</span>) &#123;</span><br><span class=\"line\">      dfsVisit(w, color, callback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>以上就是广度优先遍历和深度优先遍历的 JavaScript 实现。</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是数据结构与算法中的图。</p>","more":"<h2 id=\"图简介\"><a href=\"#图简介\" class=\"headerlink\" title=\"图简介\"></a>图简介</h2><p>图是什么？图是网络结构的抽象模型。图是一组由<strong>边</strong>连接的<strong>节点</strong>(或顶点)。图有啥用？图的作用有这些：</p>\n<ul>\n<li>图可以表示任何二元关系，比如道路、航班、通信状态。</li>\n<li>非加权图可以用广度优先遍历来计算最短路径。</li>\n</ul>\n<p>图的应用非常广泛，远远不止上面这些，有兴趣的同学可以自行去了解更多的图的用途，这里不再详述。</p>\n<h2 id=\"用-JavaScript-编写图类\"><a href=\"#用-JavaScript-编写图类\" class=\"headerlink\" title=\"用 JavaScript 编写图类\"></a>用 JavaScript 编写图类</h2><p>图的展现方式有很多，常见的包括：</p>\n<ul>\n<li><strong>邻接矩阵</strong>：矩阵的行列都是图的顶点，数字代表是否连接</li>\n<li><strong>邻接表</strong>： 由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表(数组)、链表，甚至是散列表或是字典来表示相邻顶点列表。</li>\n<li><strong>关联矩阵</strong>： 矩阵的行表示顶点，列表示边，数字代表是否连接。</li>\n</ul>\n<p>本文将会使用<strong>邻接表</strong>来展现图。下面就让我们用 JavaScript 来编写图类吧！</p>\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>既然使用 <strong>邻接表</strong> 来展现图，那么私有变量就是一个数组 <code>vertices</code> 来表示图的所有顶点，还有一个字典 <code>adjList</code> 来表示每个顶点以及它相邻顶点列表。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vertices = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> adjList = <span class=\"keyword\">new</span> Dictionary();</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-addVertex-、addEdge-和-getAdjList-方法\"><a href=\"#实现-addVertex-、addEdge-和-getAdjList-方法\" class=\"headerlink\" title=\"实现 addVertex 、addEdge 和 getAdjList 方法\"></a>实现 addVertex 、addEdge 和 getAdjList 方法</h3><p>实现 <code>addVertex</code> 方法（添加顶点）、<code>addEdge</code> 方法（添加边）和 <code>getAdjList</code> 方法（获取顶点和相邻顶点组成的字典，即 <code>adjList</code>），可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> graph = <span class=\"keyword\">new</span> Graph();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myVertices = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'E'</span>, <span class=\"string\">'F'</span>, <span class=\"string\">'G'</span>, <span class=\"string\">'H'</span>, <span class=\"string\">'I'</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class=\"line\">  graph.addVertex(myVertices[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'C'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'A'</span>, <span class=\"string\">'D'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'C'</span>, <span class=\"string\">'G'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'D'</span>, <span class=\"string\">'G'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'D'</span>, <span class=\"string\">'H'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'B'</span>, <span class=\"string\">'E'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'B'</span>, <span class=\"string\">'F'</span>);</span><br><span class=\"line\">graph.addEdge(<span class=\"string\">'E'</span>, <span class=\"string\">'I'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(graph.getAdjList()).toEqual(&#123;</span><br><span class=\"line\">  <span class=\"string\">'A'</span>: [<span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>],</span><br><span class=\"line\">  <span class=\"string\">'B'</span>: [<span class=\"string\">'A'</span>, <span class=\"string\">'E'</span>, <span class=\"string\">'F'</span>],</span><br><span class=\"line\">  <span class=\"string\">'C'</span>: [<span class=\"string\">'A'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'G'</span>],</span><br><span class=\"line\">  <span class=\"string\">'D'</span>: [<span class=\"string\">'A'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'G'</span>, <span class=\"string\">'H'</span>],</span><br><span class=\"line\">  <span class=\"string\">'E'</span>: [<span class=\"string\">'B'</span>, <span class=\"string\">'I'</span>],</span><br><span class=\"line\">  <span class=\"string\">'F'</span>: [<span class=\"string\">'B'</span>],</span><br><span class=\"line\">  <span class=\"string\">'G'</span>: [<span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>],</span><br><span class=\"line\">  <span class=\"string\">'H'</span>: [<span class=\"string\">'D'</span>],</span><br><span class=\"line\">  <span class=\"string\">'I'</span>: [<span class=\"string\">'E'</span>]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们来分析下需求，<code>addVertex</code> 方法其实就是向私有变量 <code>vertices</code> 中 push 新的值，不过也需要在 <code>adjList</code> 中添加新的键，所以实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.addVertex = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">  vertices.push(v);</span><br><span class=\"line\">  adjList.set(v, []);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>addEdge</code> 方法其实就是向私有变量 <code>adjList</code> 中相关的顶点赋值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.addEdge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v, w</span>) </span>&#123;</span><br><span class=\"line\">  adjList.get(v).push(w);</span><br><span class=\"line\">  adjList.get(w).push(v);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>getAdjList</code> 方法更简单，直接返回私有变量 <code>adjList.getItems()</code> 即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.getAdjList = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> adjList.getItems();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现广度优先遍历\"><a href=\"#实现广度优先遍历\" class=\"headerlink\" title=\"实现广度优先遍历\"></a>实现广度优先遍历</h3><p>什么是广度优先遍历？简单来说就是先广后深来遍历图中的顶点。比如一个这样的图：</p>\n<p><img src=\"https://ws1.sinaimg.cn/mw690/83900b4egy1fcvopomghbj20dz09ajru\" alt=\"\"></p>\n<p>那么如何实现广度优先遍历呢？这需要用到队列。实现思路如下：</p>\n<ul>\n<li>把一个顶点的相邻顶点入队，然后访问该顶点（也可以先访问再入队）</li>\n<li>出队重复第一步</li>\n</ul>\n<p>比如，访问 A 时，把 BCD 入队，然后接下来就可以最先访问到 BCD 了，不过注意：因为 B 的相邻顶点也包括 A 所以在入队前，需要判断相邻顶点是否入队（或访问过）。为此，我们需要设置两种状态来记录：</p>\n<ul>\n<li>白色：没入队</li>\n<li>黑色：入队了</li>\n</ul>\n<p>所以，我们只需要在不同阶段设置不同颜色，并根据颜色选择性入队即可。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将所有顶点初始化为白色</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> initializeColor = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> color = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class=\"line\">    color[vertices[i]] = <span class=\"string\">'white'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> color;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.bfs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> color = initializeColor(),</span><br><span class=\"line\">    queue = <span class=\"keyword\">new</span> Queue();</span><br><span class=\"line\"> </span><br><span class=\"line\">  queue.enqueue(v);  <span class=\"comment\">// 入队了就设置为黑色</span></span><br><span class=\"line\">  color[v] = <span class=\"string\">'black'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> u = queue.dequeue(),  <span class=\"comment\">// 出队重复第一步</span></span><br><span class=\"line\">      neighbors = adjList.get(u);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;  <span class=\"comment\">// 将所有相邻顶点入队</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> w = neighbors[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (color[w] === <span class=\"string\">'white'</span>) &#123;</span><br><span class=\"line\">        queue.enqueue(w);</span><br><span class=\"line\">        color[w] = <span class=\"string\">'black'</span>;  <span class=\"comment\">// 入队了就设置为黑色</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callback) &#123;</span><br><span class=\"line\">      callback(u);  <span class=\"comment\">// 入队完了相邻顶点，就访问该顶点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现深度优先遍历\"><a href=\"#实现深度优先遍历\" class=\"headerlink\" title=\"实现深度优先遍历\"></a>实现深度优先遍历</h3><p>什么是深度优先遍历？简单来说，深度优先遍历就是先深后广来遍历。如图：</p>\n<p><img src=\"https://ws1.sinaimg.cn/mw690/83900b4egy1fcvp988h6bj20bu08vmxg\" alt=\"\"></p>\n<p> 那么如何实现深度优先遍历？这需要用到递归。实现思路如下：</p>\n<ul>\n<li>先访问一个顶点，然后对相邻顶点挨个进行深度优先遍历。</li>\n</ul>\n<p>为了记录访问过的节点，我们用黑色来代表访问过。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.dfs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> color = initializeColor();</span><br><span class=\"line\">  dfsVisit(v, color, callback);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dfsVisit = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">u, color, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (callback) &#123;</span><br><span class=\"line\">    callback(u);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> neighbors = adjList.get(u);</span><br><span class=\"line\">  color[u] = <span class=\"string\">'black'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> w = neighbors[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color[w] === <span class=\"string\">'white'</span>) &#123;</span><br><span class=\"line\">      dfsVisit(w, color, callback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>以上就是广度优先遍历和深度优先遍历的 JavaScript 实现。</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>"},{"title":"深度优先搜索和链表指针在 JSON 操作中的应用","date":"2019-01-23T08:25:00.000Z","_content":"\n最近的工作涉及了大量 JSON 操作，用到了一些之前做过的算法题中的知识，深刻感觉到，传统数据结构与算法在前端开发中的应用也挺多的。所以，想借此文记录总结一番。\n\n<!--more-->\n\n## 深度优先搜索简介\n\n深度优先搜索（Depth-First-Search，DFS）是一种用于遍历或搜索树或者图的算法。顾名思义，它的搜索的规则是深度优先：先访问根结点，如果有孩子节点（或者邻居节点）就优先访问孩子节点，并对孩子节点也进行上述递归访问。\n\n![dfs](https://ws1.sinaimg.cn/mw690/83900b4egy1fcvp988h6bj20bu08vmxg)\n\nDFS 可谓是 LeetCode 中考察最多的知识点了，另外由于动态规划算法可以和 DFS 算法相互转换（就像是所有的递归都可以用“栈”来改写一样），所以 DFS 的题目简直不能更多。\n\n## 使用深度优先搜索打印 JSON\n\n那么 DFS 在 JSON 操作中有什么用处呢？假如你想在网页上渲染一个 JSON，甚至想渲染出一个表单来编辑这个 JSON，那么就要用到 DFS 了。思路也很简单，先访问一个 JSON 的根结点，然后访问它的所有 key（也就是孩子节点），并对 key 也进行上述递归。\n\n示例代码：\n\n```js\nconst json = { a: { b: 'hello' }, c: [1, 2] };\nconst dfs = (n) => {\n  console.log(n);\n  if(String(n) === '[object Object]' || Array.isArray(n)){\n    Object.keys(n).forEach(k => { dfs(n[k]); });\n  }\n}; \ndfs(json);\n```\n\n结果如下：\n\n![打印 JSON](https://s2.ax1x.com/2019/01/23/kECv8A.png)\n\n可以发现 JSON 中每个节点都被遍历到了。\n\n## DFS 用于构建无限递归表单\n\n只需要更改上述 `dfs` 函数的参数，就可以渲染 JSON 树中的任意一项了，也可以渲染表单项来编辑它们。比如之前做的递归表单组件：\n\n![递归表单](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/9d7c702a9e3e240b4945ed53a7c5070f.png)\n\n## 链表指针简介\n\n**链表**（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针。\n\n链表遍历及操作也是 LeetCode 考察非常多的题目。通常我们会定义一个变量作为指针，然后在循环里让它遍历链表的多个 `next`。比如：\n\n```js\nlet p = linkedList;\n// 某个循环中\np = p.next;\n\n```\n\n\n## 使用链表指针获取 JSON 中的叶子节点的值\n\n那么链表指针在 JSON 操作中有什么用呢？我们可以把 JS 中 Object 的 key 当作链表中的 `next`。那么如果知道一个叶子节点的路径，我们就可以用指针像遍历链表那样遍历到 JSON 的叶子节点处。比如：\n\n```js\nconst json = { a: { b: 'hello' }, c: [1, 2] };\nconst path = ['a', 'b'];\nlet point = json;\npath.forEach(key => { point = point[key] });\n// point 为 'hello'，即 json.a.b 的值。\nconsole.log(point);\n```\n\n上述代码中，`json` 是我们要查找的 JSON 对象，`path` 是叶子节点的路径，`point` 是指针，通过遍历，`point` 最后指向了指定的叶子节点的值。\n\n## 使用链表指针构造 immutibility-helper 所需要的数据结构\n\n另外，由于 React Redux 的风行，不可变数据结构在前端用的非常多，有个不可变数据工具包叫 immutibility-helper ，它经常用到这样的结构来“不可变”地改变数据：\n\n```js\nupdate(obj, {a: {b: {c: {$set: 1}}}});\n```\n\n所以，还可以通过指针来将路径与它所需要的结构进行互转。\n\n## 结语\n\n本文讲述的算法都非常简单，在 LeetCode 上应该属于 Easy 中的 Easy 级别的，但是将算法应用到实际工作中也是一件有趣的事情，故记录下来，作为总结，也抛砖引玉，分享给大家。","source":"_posts/dfs-linked-list-in-json.md","raw":"---\n\ntitle: 深度优先搜索和链表指针在 JSON 操作中的应用\n\ndate: 2019-01-23 16:25:00\n\ntags: [数据结构与算法, LeetCode]\n\n---\n\n最近的工作涉及了大量 JSON 操作，用到了一些之前做过的算法题中的知识，深刻感觉到，传统数据结构与算法在前端开发中的应用也挺多的。所以，想借此文记录总结一番。\n\n<!--more-->\n\n## 深度优先搜索简介\n\n深度优先搜索（Depth-First-Search，DFS）是一种用于遍历或搜索树或者图的算法。顾名思义，它的搜索的规则是深度优先：先访问根结点，如果有孩子节点（或者邻居节点）就优先访问孩子节点，并对孩子节点也进行上述递归访问。\n\n![dfs](https://ws1.sinaimg.cn/mw690/83900b4egy1fcvp988h6bj20bu08vmxg)\n\nDFS 可谓是 LeetCode 中考察最多的知识点了，另外由于动态规划算法可以和 DFS 算法相互转换（就像是所有的递归都可以用“栈”来改写一样），所以 DFS 的题目简直不能更多。\n\n## 使用深度优先搜索打印 JSON\n\n那么 DFS 在 JSON 操作中有什么用处呢？假如你想在网页上渲染一个 JSON，甚至想渲染出一个表单来编辑这个 JSON，那么就要用到 DFS 了。思路也很简单，先访问一个 JSON 的根结点，然后访问它的所有 key（也就是孩子节点），并对 key 也进行上述递归。\n\n示例代码：\n\n```js\nconst json = { a: { b: 'hello' }, c: [1, 2] };\nconst dfs = (n) => {\n  console.log(n);\n  if(String(n) === '[object Object]' || Array.isArray(n)){\n    Object.keys(n).forEach(k => { dfs(n[k]); });\n  }\n}; \ndfs(json);\n```\n\n结果如下：\n\n![打印 JSON](https://s2.ax1x.com/2019/01/23/kECv8A.png)\n\n可以发现 JSON 中每个节点都被遍历到了。\n\n## DFS 用于构建无限递归表单\n\n只需要更改上述 `dfs` 函数的参数，就可以渲染 JSON 树中的任意一项了，也可以渲染表单项来编辑它们。比如之前做的递归表单组件：\n\n![递归表单](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/9d7c702a9e3e240b4945ed53a7c5070f.png)\n\n## 链表指针简介\n\n**链表**（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针。\n\n链表遍历及操作也是 LeetCode 考察非常多的题目。通常我们会定义一个变量作为指针，然后在循环里让它遍历链表的多个 `next`。比如：\n\n```js\nlet p = linkedList;\n// 某个循环中\np = p.next;\n\n```\n\n\n## 使用链表指针获取 JSON 中的叶子节点的值\n\n那么链表指针在 JSON 操作中有什么用呢？我们可以把 JS 中 Object 的 key 当作链表中的 `next`。那么如果知道一个叶子节点的路径，我们就可以用指针像遍历链表那样遍历到 JSON 的叶子节点处。比如：\n\n```js\nconst json = { a: { b: 'hello' }, c: [1, 2] };\nconst path = ['a', 'b'];\nlet point = json;\npath.forEach(key => { point = point[key] });\n// point 为 'hello'，即 json.a.b 的值。\nconsole.log(point);\n```\n\n上述代码中，`json` 是我们要查找的 JSON 对象，`path` 是叶子节点的路径，`point` 是指针，通过遍历，`point` 最后指向了指定的叶子节点的值。\n\n## 使用链表指针构造 immutibility-helper 所需要的数据结构\n\n另外，由于 React Redux 的风行，不可变数据结构在前端用的非常多，有个不可变数据工具包叫 immutibility-helper ，它经常用到这样的结构来“不可变”地改变数据：\n\n```js\nupdate(obj, {a: {b: {c: {$set: 1}}}});\n```\n\n所以，还可以通过指针来将路径与它所需要的结构进行互转。\n\n## 结语\n\n本文讲述的算法都非常简单，在 LeetCode 上应该属于 Easy 中的 Easy 级别的，但是将算法应用到实际工作中也是一件有趣的事情，故记录下来，作为总结，也抛砖引玉，分享给大家。","slug":"dfs-linked-list-in-json","published":1,"updated":"2019-05-01T08:02:09.241Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvl9000itgytjq6n6uui","content":"<p>最近的工作涉及了大量 JSON 操作，用到了一些之前做过的算法题中的知识，深刻感觉到，传统数据结构与算法在前端开发中的应用也挺多的。所以，想借此文记录总结一番。</p>\n<a id=\"more\"></a>\n<h2 id=\"深度优先搜索简介\"><a href=\"#深度优先搜索简介\" class=\"headerlink\" title=\"深度优先搜索简介\"></a>深度优先搜索简介</h2><p>深度优先搜索（Depth-First-Search，DFS）是一种用于遍历或搜索树或者图的算法。顾名思义，它的搜索的规则是深度优先：先访问根结点，如果有孩子节点（或者邻居节点）就优先访问孩子节点，并对孩子节点也进行上述递归访问。</p>\n<p><img src=\"https://ws1.sinaimg.cn/mw690/83900b4egy1fcvp988h6bj20bu08vmxg\" alt=\"dfs\"></p>\n<p>DFS 可谓是 LeetCode 中考察最多的知识点了，另外由于动态规划算法可以和 DFS 算法相互转换（就像是所有的递归都可以用“栈”来改写一样），所以 DFS 的题目简直不能更多。</p>\n<h2 id=\"使用深度优先搜索打印-JSON\"><a href=\"#使用深度优先搜索打印-JSON\" class=\"headerlink\" title=\"使用深度优先搜索打印 JSON\"></a>使用深度优先搜索打印 JSON</h2><p>那么 DFS 在 JSON 操作中有什么用处呢？假如你想在网页上渲染一个 JSON，甚至想渲染出一个表单来编辑这个 JSON，那么就要用到 DFS 了。思路也很简单，先访问一个 JSON 的根结点，然后访问它的所有 key（也就是孩子节点），并对 key 也进行上述递归。</p>\n<p>示例代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> json = &#123; <span class=\"attr\">a</span>: &#123; <span class=\"attr\">b</span>: <span class=\"string\">'hello'</span> &#125;, <span class=\"attr\">c</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>] &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dfs = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(n);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">String</span>(n) === <span class=\"string\">'[object Object]'</span> || <span class=\"built_in\">Array</span>.isArray(n))&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(n).forEach(<span class=\"function\"><span class=\"params\">k</span> =&gt;</span> &#123; dfs(n[k]); &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">dfs(json);</span><br></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<p><img src=\"https://s2.ax1x.com/2019/01/23/kECv8A.png\" alt=\"打印 JSON\"></p>\n<p>可以发现 JSON 中每个节点都被遍历到了。</p>\n<h2 id=\"DFS-用于构建无限递归表单\"><a href=\"#DFS-用于构建无限递归表单\" class=\"headerlink\" title=\"DFS 用于构建无限递归表单\"></a>DFS 用于构建无限递归表单</h2><p>只需要更改上述 <code>dfs</code> 函数的参数，就可以渲染 JSON 树中的任意一项了，也可以渲染表单项来编辑它们。比如之前做的递归表单组件：</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/9d7c702a9e3e240b4945ed53a7c5070f.png\" alt=\"递归表单\"></p>\n<h2 id=\"链表指针简介\"><a href=\"#链表指针简介\" class=\"headerlink\" title=\"链表指针简介\"></a>链表指针简介</h2><p><strong>链表</strong>（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针。</p>\n<p>链表遍历及操作也是 LeetCode 考察非常多的题目。通常我们会定义一个变量作为指针，然后在循环里让它遍历链表的多个 <code>next</code>。比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = linkedList;</span><br><span class=\"line\"><span class=\"comment\">// 某个循环中</span></span><br><span class=\"line\">p = p.next;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用链表指针获取-JSON-中的叶子节点的值\"><a href=\"#使用链表指针获取-JSON-中的叶子节点的值\" class=\"headerlink\" title=\"使用链表指针获取 JSON 中的叶子节点的值\"></a>使用链表指针获取 JSON 中的叶子节点的值</h2><p>那么链表指针在 JSON 操作中有什么用呢？我们可以把 JS 中 Object 的 key 当作链表中的 <code>next</code>。那么如果知道一个叶子节点的路径，我们就可以用指针像遍历链表那样遍历到 JSON 的叶子节点处。比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> json = &#123; <span class=\"attr\">a</span>: &#123; <span class=\"attr\">b</span>: <span class=\"string\">'hello'</span> &#125;, <span class=\"attr\">c</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>] &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> point = json;</span><br><span class=\"line\">path.forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123; point = point[key] &#125;);</span><br><span class=\"line\"><span class=\"comment\">// point 为 'hello'，即 json.a.b 的值。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(point);</span><br></pre></td></tr></table></figure>\n<p>上述代码中，<code>json</code> 是我们要查找的 JSON 对象，<code>path</code> 是叶子节点的路径，<code>point</code> 是指针，通过遍历，<code>point</code> 最后指向了指定的叶子节点的值。</p>\n<h2 id=\"使用链表指针构造-immutibility-helper-所需要的数据结构\"><a href=\"#使用链表指针构造-immutibility-helper-所需要的数据结构\" class=\"headerlink\" title=\"使用链表指针构造 immutibility-helper 所需要的数据结构\"></a>使用链表指针构造 immutibility-helper 所需要的数据结构</h2><p>另外，由于 React Redux 的风行，不可变数据结构在前端用的非常多，有个不可变数据工具包叫 immutibility-helper ，它经常用到这样的结构来“不可变”地改变数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update(obj, &#123;<span class=\"attr\">a</span>: &#123;<span class=\"attr\">b</span>: &#123;<span class=\"attr\">c</span>: &#123;<span class=\"attr\">$set</span>: <span class=\"number\">1</span>&#125;&#125;&#125;&#125;);</span><br></pre></td></tr></table></figure>\n<p>所以，还可以通过指针来将路径与它所需要的结构进行互转。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本文讲述的算法都非常简单，在 LeetCode 上应该属于 Easy 中的 Easy 级别的，但是将算法应用到实际工作中也是一件有趣的事情，故记录下来，作为总结，也抛砖引玉，分享给大家。</p>\n","site":{"data":{}},"excerpt":"<p>最近的工作涉及了大量 JSON 操作，用到了一些之前做过的算法题中的知识，深刻感觉到，传统数据结构与算法在前端开发中的应用也挺多的。所以，想借此文记录总结一番。</p>","more":"<h2 id=\"深度优先搜索简介\"><a href=\"#深度优先搜索简介\" class=\"headerlink\" title=\"深度优先搜索简介\"></a>深度优先搜索简介</h2><p>深度优先搜索（Depth-First-Search，DFS）是一种用于遍历或搜索树或者图的算法。顾名思义，它的搜索的规则是深度优先：先访问根结点，如果有孩子节点（或者邻居节点）就优先访问孩子节点，并对孩子节点也进行上述递归访问。</p>\n<p><img src=\"https://ws1.sinaimg.cn/mw690/83900b4egy1fcvp988h6bj20bu08vmxg\" alt=\"dfs\"></p>\n<p>DFS 可谓是 LeetCode 中考察最多的知识点了，另外由于动态规划算法可以和 DFS 算法相互转换（就像是所有的递归都可以用“栈”来改写一样），所以 DFS 的题目简直不能更多。</p>\n<h2 id=\"使用深度优先搜索打印-JSON\"><a href=\"#使用深度优先搜索打印-JSON\" class=\"headerlink\" title=\"使用深度优先搜索打印 JSON\"></a>使用深度优先搜索打印 JSON</h2><p>那么 DFS 在 JSON 操作中有什么用处呢？假如你想在网页上渲染一个 JSON，甚至想渲染出一个表单来编辑这个 JSON，那么就要用到 DFS 了。思路也很简单，先访问一个 JSON 的根结点，然后访问它的所有 key（也就是孩子节点），并对 key 也进行上述递归。</p>\n<p>示例代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> json = &#123; <span class=\"attr\">a</span>: &#123; <span class=\"attr\">b</span>: <span class=\"string\">'hello'</span> &#125;, <span class=\"attr\">c</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>] &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dfs = <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(n);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">String</span>(n) === <span class=\"string\">'[object Object]'</span> || <span class=\"built_in\">Array</span>.isArray(n))&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(n).forEach(<span class=\"function\"><span class=\"params\">k</span> =&gt;</span> &#123; dfs(n[k]); &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">dfs(json);</span><br></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<p><img src=\"https://s2.ax1x.com/2019/01/23/kECv8A.png\" alt=\"打印 JSON\"></p>\n<p>可以发现 JSON 中每个节点都被遍历到了。</p>\n<h2 id=\"DFS-用于构建无限递归表单\"><a href=\"#DFS-用于构建无限递归表单\" class=\"headerlink\" title=\"DFS 用于构建无限递归表单\"></a>DFS 用于构建无限递归表单</h2><p>只需要更改上述 <code>dfs</code> 函数的参数，就可以渲染 JSON 树中的任意一项了，也可以渲染表单项来编辑它们。比如之前做的递归表单组件：</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/9d7c702a9e3e240b4945ed53a7c5070f.png\" alt=\"递归表单\"></p>\n<h2 id=\"链表指针简介\"><a href=\"#链表指针简介\" class=\"headerlink\" title=\"链表指针简介\"></a>链表指针简介</h2><p><strong>链表</strong>（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针。</p>\n<p>链表遍历及操作也是 LeetCode 考察非常多的题目。通常我们会定义一个变量作为指针，然后在循环里让它遍历链表的多个 <code>next</code>。比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = linkedList;</span><br><span class=\"line\"><span class=\"comment\">// 某个循环中</span></span><br><span class=\"line\">p = p.next;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用链表指针获取-JSON-中的叶子节点的值\"><a href=\"#使用链表指针获取-JSON-中的叶子节点的值\" class=\"headerlink\" title=\"使用链表指针获取 JSON 中的叶子节点的值\"></a>使用链表指针获取 JSON 中的叶子节点的值</h2><p>那么链表指针在 JSON 操作中有什么用呢？我们可以把 JS 中 Object 的 key 当作链表中的 <code>next</code>。那么如果知道一个叶子节点的路径，我们就可以用指针像遍历链表那样遍历到 JSON 的叶子节点处。比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> json = &#123; <span class=\"attr\">a</span>: &#123; <span class=\"attr\">b</span>: <span class=\"string\">'hello'</span> &#125;, <span class=\"attr\">c</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>] &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> point = json;</span><br><span class=\"line\">path.forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123; point = point[key] &#125;);</span><br><span class=\"line\"><span class=\"comment\">// point 为 'hello'，即 json.a.b 的值。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(point);</span><br></pre></td></tr></table></figure>\n<p>上述代码中，<code>json</code> 是我们要查找的 JSON 对象，<code>path</code> 是叶子节点的路径，<code>point</code> 是指针，通过遍历，<code>point</code> 最后指向了指定的叶子节点的值。</p>\n<h2 id=\"使用链表指针构造-immutibility-helper-所需要的数据结构\"><a href=\"#使用链表指针构造-immutibility-helper-所需要的数据结构\" class=\"headerlink\" title=\"使用链表指针构造 immutibility-helper 所需要的数据结构\"></a>使用链表指针构造 immutibility-helper 所需要的数据结构</h2><p>另外，由于 React Redux 的风行，不可变数据结构在前端用的非常多，有个不可变数据工具包叫 immutibility-helper ，它经常用到这样的结构来“不可变”地改变数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update(obj, &#123;<span class=\"attr\">a</span>: &#123;<span class=\"attr\">b</span>: &#123;<span class=\"attr\">c</span>: &#123;<span class=\"attr\">$set</span>: <span class=\"number\">1</span>&#125;&#125;&#125;&#125;);</span><br></pre></td></tr></table></figure>\n<p>所以，还可以通过指针来将路径与它所需要的结构进行互转。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本文讲述的算法都非常简单，在 LeetCode 上应该属于 Easy 中的 Easy 级别的，但是将算法应用到实际工作中也是一件有趣的事情，故记录下来，作为总结，也抛砖引玉，分享给大家。</p>"},{"title":"JavaScript 版数据结构与算法（六）散列表","date":"2017-02-17T07:19:00.000Z","_content":"\n今天，我们要讲的是数据结构与算法中的散列表。\n\n<!--more-->\n\n## 散列表简介\n\n散列表是什么？散列表也是一种以**键值对**存储数据的数据结构，但是它的键是通过**散列函数**生成的**位置或索引**，也正因为此，我们可以**更快**地访问某个值（散列表的查找复杂度为O(1)，而其他顺序数据结构如栈、队列、链表的查找复杂度都为O(n)，因为需要遍历）。比如，电话簿就是散列表的一种应用。电话簿用姓名首字母作为索引帮助使用者快速检索出电话号码。那么首字母就是**键**，电话号码就是**值**，姓名到首字母的算法就是一种**散列函数**，而这种方法显然加快了检索的速度，就像散列表设计的初衷（为了加快速度）一样。\n\n## 散列函数简介\n\n电话簿这个例子中我们看到了一种散列函数，那么什么是散列函数？散列函数是一种从任何一种数据中创建**小的数字“指纹”**的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。散列函数构造方法有很多，包括：直接定址法、数字分析法、平方取中法、折叠法、随机数法、除留余数法等。本文就将会使用**除留余数法**来构造散列函数。除留余数法的实现思路是：取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址。对 p 的选择很重要，一般取素数或 m，若 p 选择不好，容易产生冲突。\n\n## 用 JavaScript 编写散列表类\n\n让我们自己用 JavaScript 写个散列表类吧！\n\n### 私有变量\n\n为了用键（位置或索引）值对存储元素，我们使用一个数组 `table` 来作为私有变量。另外，还要再编写一个私有的散列函数 `loseloseHashCode`，这个散列函数的实现思路是：先累加所有字母的 Ascii 值得到 `hash`，然后返回 `hash` 除以某个值（本例取37，你也可以选择其他值）的余数。这就是除留余数法的一种应用。\n\n> ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。想了解更多的细节，请访问 http://www.asciitable.com/。\n\n```js\nfunction HashTable(){\n  var table = [];\n\n  var loseloseHashCode = function (key) {\n    var hash = 0;\n    for (var i = 0; i < key.length; i++) {\n      hash += key.charCodeAt(i);\n    }\n    return hash % 37;\n  };\n}\n```\n\n那么散列表里的数据究竟长什么样呢？举个例子，假如要存储的数据是：\n```js\n{\n  'zhangsan': 'zhangsan@email.com'\n  'lisi': 'lisi@email.com'\n}\n```\n\n那么经过 `loseloseHashCode`，存储在 `table` 中的数据就是这样：\n\n```js\n[ ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  'zhangsan@email.com', // zhangsan 的 Ascii 码值之和是858，除以37余7\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  'lisi@email.com' // lisi 的 Ascii 码值之和是433，除以37余26\n]\n```\n散列表中的**键**就是位置或索引，查起来就是快！\n\n### 实现 put 、get 和 remove 方法\n\n实现 `put` 方法（设置键值对）、`get` 方法（通过键取值）、`remove` 方法（删除指定键值），可以跑通如下测试：\n\n```js\nvar hashTable = new HashTable();\n\nhashTable.put('zhangsan', 'zhangsan@email.com');\nhashTable.put('lisi', 'lisi@email.com');\n\nexpect(hashTable.get('zhangsan')).toBe('zhangsan@email.com');\nexpect(hashTable.get('lisi')).toBe('lisi@email.com');\n\nhashTable.remove('zhangsan');\nexpect(hashTable.get('zhangsan')).toBe(undefined);\n```\n\n实现方法比较简单，直接上代码：\n\n```js\nthis.put = function (key, value) {\n  var position = loseloseHashCode(key);\n  table[position] = value;\n};\n\nthis.get = function (key) {\n  return table[loseloseHashCode(key)];\n};\n\nthis.remove = function (key) {\n  table[loseloseHashCode(key)] = undefined;\n};\n```\n\n### 使用分离链接法解决冲突\n\n看了上述方法，很多同学会有疑问：如果某两个键通过 `loseloseHashCode` 返回的余数相同怎么办？这时候就需要解决冲突。其实一个好的散列函数的冲突是很少的，可惜 `loseloseHashCode` 只能算是一般般吧！解决冲突有很多方法，我们先使用**分离链接法**来解决冲突。\n\n分离链接法的实现思路是，`put` 时将输入的值放到链表里再放到散列表的某个位置上，假如遇到位置冲突就追加到链表最后。`get` 和 `remove` 时，先算出位置，然后遍历链表，找到需要的值再返回或删除。\n\n让我们改写 `get` 、 `put` 和 `remove` 方法，跑通如下测试：\n\n```js\nvar hashTable = new HashTable();\n\nhashTable.put('zhangsan', 'zhangsan@email.com'); // 代码一\nhashTable.put('zhangsan12', 'zhangsan12@email.com'); // 代码二\nhashTable.put('zhangsan21', 'zhangsan21@email.com'); // 代码三\nhashTable.put('zhangsan30', 'zhangsan30@email.com'); // 代码四\nexpect(hashTable.get('zhangsan')).toBe('zhangsan@email.com'); // 断言一\nexpect(hashTable.get('zhangsan12')).toBe('zhangsan12@email.com'); // 断言二\nexpect(hashTable.get('zhangsan21')).toBe('zhangsan21@email.com'); // 断言三\nexpect(hashTable.get('zhangsan30')).toBe('zhangsan30@email.com'); // 断言四\nexpect(hashTable.remove('zhangsan')).toBeTruthy(); // 断言五\nexpect(hashTable.get('zhangsan')).toBe(undefined); // 断言六\nexpect(hashTable.remove('zhangsan21')).toBeTruthy(); // 断言七\nexpect(hashTable.remove('zhangsan12')).toBeTruthy(); // 断言八\nexpect(hashTable.remove('zhangsan30')).toBeTruthy(); // 断言九\nexpect(hashTable.remove('zhangsan30')).toBeFalsy(); // 断言十\n```\n\n实现代码如下：\n\n```js\nvar ValuePair = function (key, value) {\n  this.key = key;\n  this.value = value;\n};\n\nthis.put = function (key, value) {\n  var postion = loseloseHashCode(key);\n  if (table[postion] == undefined) {  // 代码一的情况\n    table[postion] = new LinkedList();\n  }\n  table[postion].append(new ValuePair(key, value)); // 代码二、三、四的情况\n};\n\nthis.get = function (key) {\n  var position = loseloseHashCode(key);\n\n  if (table[position] !== undefined) {\n    var current = table[position].getHead();\n\n    while (current.next) {  // 断言二、三的情况\n      if (current.element.key === key) {\n        return current.element.value;\n      }\n      current = current.next;\n    }\n\n    if (current.element.key === key) { // 断言一、四的情况\n      return current.element.value;\n    }\n  }\n  return undefined; // 断言六\n};\n\nthis.remove = function (key) {\n  var position = loseloseHashCode(key);\n\n  if (table[position] !== undefined){\n    var current = table[position].getHead();\n\n    do {\n      if (current.element.key === key){\n        table[position].remove(current.element); // 断言五、七、八、九\n        if (table[position].isEmpty()){\n          table[position] = undefined; // 断言五、九\n        }\n        return true;\n      }\n      current = current.next;\n    } while(current);\n  }\n  return false; // 断言十\n}\n```\n\n自己看着测试用例把边界写全吧！\n\n### 使用线性探查法解决冲突\n\n除了分离链接法，还可以通过线性探查法解决冲突，它的实现思路是，`put` 时如果冲突就设置在下个位置，还冲突就继续，直到找到空位，然后设置。`get` 和 `remove` 时，则先找到位置，然后判断是不是当前值，不是就往后找，找到就返回或删除。\n\n改写 `put`、`get` 和 `remove`，跑通如下测试：\n\n```js\nvar hashTable = new HashTable();\n\nhashTable.put('zhangsan', 'zhangsan@email.com'); // 代码一\nhashTable.put('zhangsan12', 'zhangsan12@email.com'); // 代码二\nhashTable.put('zhangsan21', 'zhangsan21@email.com'); // 代码三\nhashTable.put('zhangsan30', 'zhangsan30@email.com'); // 代码四\nexpect(hashTable.get('zhangsan')).toBe('zhangsan@email.com'); // 断言一\nexpect(hashTable.get('zhangsan12')).toBe('zhangsan12@email.com'); // 断言二\nexpect(hashTable.get('zhangsan21')).toBe('zhangsan21@email.com'); // 断言三\nexpect(hashTable.get('zhangsan30')).toBe('zhangsan30@email.com'); // 断言四\nexpect(hashTable.remove('zhangsan')).toBeTruthy(); // 断言五\nexpect(hashTable.get('zhangsan')).toBe(undefined); // 断言六\nexpect(hashTable.remove('zhangsan30')).toBeTruthy();  // 断言七\nexpect(hashTable.remove('zhangsan21')).toBeTruthy(); // 断言八\nexpect(hashTable.remove('zhangsan12')).toBeTruthy(); // 断言九\nexpect(hashTable.remove('zhangsan12')).toBeFalsy(); // 断言十\n```\n\n实现代码如下：\n\n```js\nvar ValuePair = function (key, value) {\n  this.key = key;\n  this.value = value;\n};\n\nthis.put = function (key, value) {\n  var position = loseloseHashCode(key);\n\n  if (table[position] === undefined) {\n    table[position] = new ValuePair(key, value); // 代码一、二\n  } else {\n    var index = ++position;\n    while (table[index] !== undefined) {\n      index++;\n    }\n    table[index] = new ValuePair(key, value); // 代码三、四\n  }\n};\n\nthis.get = function (key) {\n  var position = loseloseHashCode(key);\n\n  if (table[position] !== undefined) {\n    if (table[position].key === key) {\n      return table[position].value; // 断言一、二\n    } else {\n      var index = ++position;\n      while (table[index] !== undefined && (table[index] && table[index].key !== key)) {\n        index++;\n      }\n      if (table[index] && table[index].key === key) {\n        return table[index].value; // 断言三、四\n      }\n    }\n  }\n  return undefined; // 断言六\n};\n\nthis.remove = function (key) {\n  var position = loseloseHashCode(key);\n\n  if (table[position] !== undefined) {\n    if (table[position].key === key) {\n      table[position] = undefined; // 断言五\n      return true;\n    } else {\n      var index = ++position;\n      while (table[index] === undefined || table[index].key !== key) {\n        index++;\n      }\n      if (table[index].key === key) {\n        table[index] = undefined;  // 断言七、八、九\n      }\n      return true;\n    }\n  }\n  return false; // 断言十\n}\n```\n\n两种冲突方法知道原理即可，代码写起来挺无聊的，都是边界问题。今天就到此为止吧！\n \n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>\n","source":"_posts/hash-table.md","raw":"---\ntitle: JavaScript 版数据结构与算法（六）散列表\ndate: 2017-02-17 15:19:00\ntags: [数据结构与算法]\n---\n\n今天，我们要讲的是数据结构与算法中的散列表。\n\n<!--more-->\n\n## 散列表简介\n\n散列表是什么？散列表也是一种以**键值对**存储数据的数据结构，但是它的键是通过**散列函数**生成的**位置或索引**，也正因为此，我们可以**更快**地访问某个值（散列表的查找复杂度为O(1)，而其他顺序数据结构如栈、队列、链表的查找复杂度都为O(n)，因为需要遍历）。比如，电话簿就是散列表的一种应用。电话簿用姓名首字母作为索引帮助使用者快速检索出电话号码。那么首字母就是**键**，电话号码就是**值**，姓名到首字母的算法就是一种**散列函数**，而这种方法显然加快了检索的速度，就像散列表设计的初衷（为了加快速度）一样。\n\n## 散列函数简介\n\n电话簿这个例子中我们看到了一种散列函数，那么什么是散列函数？散列函数是一种从任何一种数据中创建**小的数字“指纹”**的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。散列函数构造方法有很多，包括：直接定址法、数字分析法、平方取中法、折叠法、随机数法、除留余数法等。本文就将会使用**除留余数法**来构造散列函数。除留余数法的实现思路是：取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址。对 p 的选择很重要，一般取素数或 m，若 p 选择不好，容易产生冲突。\n\n## 用 JavaScript 编写散列表类\n\n让我们自己用 JavaScript 写个散列表类吧！\n\n### 私有变量\n\n为了用键（位置或索引）值对存储元素，我们使用一个数组 `table` 来作为私有变量。另外，还要再编写一个私有的散列函数 `loseloseHashCode`，这个散列函数的实现思路是：先累加所有字母的 Ascii 值得到 `hash`，然后返回 `hash` 除以某个值（本例取37，你也可以选择其他值）的余数。这就是除留余数法的一种应用。\n\n> ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。想了解更多的细节，请访问 http://www.asciitable.com/。\n\n```js\nfunction HashTable(){\n  var table = [];\n\n  var loseloseHashCode = function (key) {\n    var hash = 0;\n    for (var i = 0; i < key.length; i++) {\n      hash += key.charCodeAt(i);\n    }\n    return hash % 37;\n  };\n}\n```\n\n那么散列表里的数据究竟长什么样呢？举个例子，假如要存储的数据是：\n```js\n{\n  'zhangsan': 'zhangsan@email.com'\n  'lisi': 'lisi@email.com'\n}\n```\n\n那么经过 `loseloseHashCode`，存储在 `table` 中的数据就是这样：\n\n```js\n[ ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  'zhangsan@email.com', // zhangsan 的 Ascii 码值之和是858，除以37余7\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  ,\n  'lisi@email.com' // lisi 的 Ascii 码值之和是433，除以37余26\n]\n```\n散列表中的**键**就是位置或索引，查起来就是快！\n\n### 实现 put 、get 和 remove 方法\n\n实现 `put` 方法（设置键值对）、`get` 方法（通过键取值）、`remove` 方法（删除指定键值），可以跑通如下测试：\n\n```js\nvar hashTable = new HashTable();\n\nhashTable.put('zhangsan', 'zhangsan@email.com');\nhashTable.put('lisi', 'lisi@email.com');\n\nexpect(hashTable.get('zhangsan')).toBe('zhangsan@email.com');\nexpect(hashTable.get('lisi')).toBe('lisi@email.com');\n\nhashTable.remove('zhangsan');\nexpect(hashTable.get('zhangsan')).toBe(undefined);\n```\n\n实现方法比较简单，直接上代码：\n\n```js\nthis.put = function (key, value) {\n  var position = loseloseHashCode(key);\n  table[position] = value;\n};\n\nthis.get = function (key) {\n  return table[loseloseHashCode(key)];\n};\n\nthis.remove = function (key) {\n  table[loseloseHashCode(key)] = undefined;\n};\n```\n\n### 使用分离链接法解决冲突\n\n看了上述方法，很多同学会有疑问：如果某两个键通过 `loseloseHashCode` 返回的余数相同怎么办？这时候就需要解决冲突。其实一个好的散列函数的冲突是很少的，可惜 `loseloseHashCode` 只能算是一般般吧！解决冲突有很多方法，我们先使用**分离链接法**来解决冲突。\n\n分离链接法的实现思路是，`put` 时将输入的值放到链表里再放到散列表的某个位置上，假如遇到位置冲突就追加到链表最后。`get` 和 `remove` 时，先算出位置，然后遍历链表，找到需要的值再返回或删除。\n\n让我们改写 `get` 、 `put` 和 `remove` 方法，跑通如下测试：\n\n```js\nvar hashTable = new HashTable();\n\nhashTable.put('zhangsan', 'zhangsan@email.com'); // 代码一\nhashTable.put('zhangsan12', 'zhangsan12@email.com'); // 代码二\nhashTable.put('zhangsan21', 'zhangsan21@email.com'); // 代码三\nhashTable.put('zhangsan30', 'zhangsan30@email.com'); // 代码四\nexpect(hashTable.get('zhangsan')).toBe('zhangsan@email.com'); // 断言一\nexpect(hashTable.get('zhangsan12')).toBe('zhangsan12@email.com'); // 断言二\nexpect(hashTable.get('zhangsan21')).toBe('zhangsan21@email.com'); // 断言三\nexpect(hashTable.get('zhangsan30')).toBe('zhangsan30@email.com'); // 断言四\nexpect(hashTable.remove('zhangsan')).toBeTruthy(); // 断言五\nexpect(hashTable.get('zhangsan')).toBe(undefined); // 断言六\nexpect(hashTable.remove('zhangsan21')).toBeTruthy(); // 断言七\nexpect(hashTable.remove('zhangsan12')).toBeTruthy(); // 断言八\nexpect(hashTable.remove('zhangsan30')).toBeTruthy(); // 断言九\nexpect(hashTable.remove('zhangsan30')).toBeFalsy(); // 断言十\n```\n\n实现代码如下：\n\n```js\nvar ValuePair = function (key, value) {\n  this.key = key;\n  this.value = value;\n};\n\nthis.put = function (key, value) {\n  var postion = loseloseHashCode(key);\n  if (table[postion] == undefined) {  // 代码一的情况\n    table[postion] = new LinkedList();\n  }\n  table[postion].append(new ValuePair(key, value)); // 代码二、三、四的情况\n};\n\nthis.get = function (key) {\n  var position = loseloseHashCode(key);\n\n  if (table[position] !== undefined) {\n    var current = table[position].getHead();\n\n    while (current.next) {  // 断言二、三的情况\n      if (current.element.key === key) {\n        return current.element.value;\n      }\n      current = current.next;\n    }\n\n    if (current.element.key === key) { // 断言一、四的情况\n      return current.element.value;\n    }\n  }\n  return undefined; // 断言六\n};\n\nthis.remove = function (key) {\n  var position = loseloseHashCode(key);\n\n  if (table[position] !== undefined){\n    var current = table[position].getHead();\n\n    do {\n      if (current.element.key === key){\n        table[position].remove(current.element); // 断言五、七、八、九\n        if (table[position].isEmpty()){\n          table[position] = undefined; // 断言五、九\n        }\n        return true;\n      }\n      current = current.next;\n    } while(current);\n  }\n  return false; // 断言十\n}\n```\n\n自己看着测试用例把边界写全吧！\n\n### 使用线性探查法解决冲突\n\n除了分离链接法，还可以通过线性探查法解决冲突，它的实现思路是，`put` 时如果冲突就设置在下个位置，还冲突就继续，直到找到空位，然后设置。`get` 和 `remove` 时，则先找到位置，然后判断是不是当前值，不是就往后找，找到就返回或删除。\n\n改写 `put`、`get` 和 `remove`，跑通如下测试：\n\n```js\nvar hashTable = new HashTable();\n\nhashTable.put('zhangsan', 'zhangsan@email.com'); // 代码一\nhashTable.put('zhangsan12', 'zhangsan12@email.com'); // 代码二\nhashTable.put('zhangsan21', 'zhangsan21@email.com'); // 代码三\nhashTable.put('zhangsan30', 'zhangsan30@email.com'); // 代码四\nexpect(hashTable.get('zhangsan')).toBe('zhangsan@email.com'); // 断言一\nexpect(hashTable.get('zhangsan12')).toBe('zhangsan12@email.com'); // 断言二\nexpect(hashTable.get('zhangsan21')).toBe('zhangsan21@email.com'); // 断言三\nexpect(hashTable.get('zhangsan30')).toBe('zhangsan30@email.com'); // 断言四\nexpect(hashTable.remove('zhangsan')).toBeTruthy(); // 断言五\nexpect(hashTable.get('zhangsan')).toBe(undefined); // 断言六\nexpect(hashTable.remove('zhangsan30')).toBeTruthy();  // 断言七\nexpect(hashTable.remove('zhangsan21')).toBeTruthy(); // 断言八\nexpect(hashTable.remove('zhangsan12')).toBeTruthy(); // 断言九\nexpect(hashTable.remove('zhangsan12')).toBeFalsy(); // 断言十\n```\n\n实现代码如下：\n\n```js\nvar ValuePair = function (key, value) {\n  this.key = key;\n  this.value = value;\n};\n\nthis.put = function (key, value) {\n  var position = loseloseHashCode(key);\n\n  if (table[position] === undefined) {\n    table[position] = new ValuePair(key, value); // 代码一、二\n  } else {\n    var index = ++position;\n    while (table[index] !== undefined) {\n      index++;\n    }\n    table[index] = new ValuePair(key, value); // 代码三、四\n  }\n};\n\nthis.get = function (key) {\n  var position = loseloseHashCode(key);\n\n  if (table[position] !== undefined) {\n    if (table[position].key === key) {\n      return table[position].value; // 断言一、二\n    } else {\n      var index = ++position;\n      while (table[index] !== undefined && (table[index] && table[index].key !== key)) {\n        index++;\n      }\n      if (table[index] && table[index].key === key) {\n        return table[index].value; // 断言三、四\n      }\n    }\n  }\n  return undefined; // 断言六\n};\n\nthis.remove = function (key) {\n  var position = loseloseHashCode(key);\n\n  if (table[position] !== undefined) {\n    if (table[position].key === key) {\n      table[position] = undefined; // 断言五\n      return true;\n    } else {\n      var index = ++position;\n      while (table[index] === undefined || table[index].key !== key) {\n        index++;\n      }\n      if (table[index].key === key) {\n        table[index] = undefined;  // 断言七、八、九\n      }\n      return true;\n    }\n  }\n  return false; // 断言十\n}\n```\n\n两种冲突方法知道原理即可，代码写起来挺无聊的，都是边界问题。今天就到此为止吧！\n \n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>\n","slug":"hash-table","published":1,"updated":"2019-05-01T08:02:09.545Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvla000ltgytepkeftoo","content":"<p>今天，我们要讲的是数据结构与算法中的散列表。</p>\n<a id=\"more\"></a>\n<h2 id=\"散列表简介\"><a href=\"#散列表简介\" class=\"headerlink\" title=\"散列表简介\"></a>散列表简介</h2><p>散列表是什么？散列表也是一种以<strong>键值对</strong>存储数据的数据结构，但是它的键是通过<strong>散列函数</strong>生成的<strong>位置或索引</strong>，也正因为此，我们可以<strong>更快</strong>地访问某个值（散列表的查找复杂度为O(1)，而其他顺序数据结构如栈、队列、链表的查找复杂度都为O(n)，因为需要遍历）。比如，电话簿就是散列表的一种应用。电话簿用姓名首字母作为索引帮助使用者快速检索出电话号码。那么首字母就是<strong>键</strong>，电话号码就是<strong>值</strong>，姓名到首字母的算法就是一种<strong>散列函数</strong>，而这种方法显然加快了检索的速度，就像散列表设计的初衷（为了加快速度）一样。</p>\n<h2 id=\"散列函数简介\"><a href=\"#散列函数简介\" class=\"headerlink\" title=\"散列函数简介\"></a>散列函数简介</h2><p>电话簿这个例子中我们看到了一种散列函数，那么什么是散列函数？散列函数是一种从任何一种数据中创建<strong>小的数字“指纹”</strong>的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。散列函数构造方法有很多，包括：直接定址法、数字分析法、平方取中法、折叠法、随机数法、除留余数法等。本文就将会使用<strong>除留余数法</strong>来构造散列函数。除留余数法的实现思路是：取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址。对 p 的选择很重要，一般取素数或 m，若 p 选择不好，容易产生冲突。</p>\n<h2 id=\"用-JavaScript-编写散列表类\"><a href=\"#用-JavaScript-编写散列表类\" class=\"headerlink\" title=\"用 JavaScript 编写散列表类\"></a>用 JavaScript 编写散列表类</h2><p>让我们自己用 JavaScript 写个散列表类吧！</p>\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>为了用键（位置或索引）值对存储元素，我们使用一个数组 <code>table</code> 来作为私有变量。另外，还要再编写一个私有的散列函数 <code>loseloseHashCode</code>，这个散列函数的实现思路是：先累加所有字母的 Ascii 值得到 <code>hash</code>，然后返回 <code>hash</code> 除以某个值（本例取37，你也可以选择其他值）的余数。这就是除留余数法的一种应用。</p>\n<blockquote>\n<p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。想了解更多的细节，请访问 <a href=\"http://www.asciitable.com/。\" target=\"_blank\" rel=\"noopener\">http://www.asciitable.com/。</a></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HashTable</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> table = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> loseloseHashCode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hash = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; key.length; i++) &#123;</span><br><span class=\"line\">      hash += key.charCodeAt(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hash % <span class=\"number\">37</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么散列表里的数据究竟长什么样呢？举个例子，假如要存储的数据是：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">'zhangsan'</span>: <span class=\"string\">'zhangsan@email.com'</span></span><br><span class=\"line\">  <span class=\"string\">'lisi'</span>: <span class=\"string\">'lisi@email.com'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么经过 <code>loseloseHashCode</code>，存储在 <code>table</code> 中的数据就是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  <span class=\"string\">'zhangsan@email.com'</span>, <span class=\"comment\">// zhangsan 的 Ascii 码值之和是858，除以37余7</span></span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  <span class=\"string\">'lisi@email.com'</span> <span class=\"comment\">// lisi 的 Ascii 码值之和是433，除以37余26</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>散列表中的<strong>键</strong>就是位置或索引，查起来就是快！</p>\n<h3 id=\"实现-put-、get-和-remove-方法\"><a href=\"#实现-put-、get-和-remove-方法\" class=\"headerlink\" title=\"实现 put 、get 和 remove 方法\"></a>实现 put 、get 和 remove 方法</h3><p>实现 <code>put</code> 方法（设置键值对）、<code>get</code> 方法（通过键取值）、<code>remove</code> 方法（删除指定键值），可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hashTable = <span class=\"keyword\">new</span> HashTable();</span><br><span class=\"line\"></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan'</span>, <span class=\"string\">'zhangsan@email.com'</span>);</span><br><span class=\"line\">hashTable.put(<span class=\"string\">'lisi'</span>, <span class=\"string\">'lisi@email.com'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan'</span>)).toBe(<span class=\"string\">'zhangsan@email.com'</span>);</span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'lisi'</span>)).toBe(<span class=\"string\">'lisi@email.com'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">hashTable.remove(<span class=\"string\">'zhangsan'</span>);</span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan'</span>)).toBe(<span class=\"literal\">undefined</span>);</span><br></pre></td></tr></table></figure>\n<p>实现方法比较简单，直接上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.put = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> position = loseloseHashCode(key);</span><br><span class=\"line\">  table[position] = value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.get = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> table[loseloseHashCode(key)];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.remove = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  table[loseloseHashCode(key)] = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用分离链接法解决冲突\"><a href=\"#使用分离链接法解决冲突\" class=\"headerlink\" title=\"使用分离链接法解决冲突\"></a>使用分离链接法解决冲突</h3><p>看了上述方法，很多同学会有疑问：如果某两个键通过 <code>loseloseHashCode</code> 返回的余数相同怎么办？这时候就需要解决冲突。其实一个好的散列函数的冲突是很少的，可惜 <code>loseloseHashCode</code> 只能算是一般般吧！解决冲突有很多方法，我们先使用<strong>分离链接法</strong>来解决冲突。</p>\n<p>分离链接法的实现思路是，<code>put</code> 时将输入的值放到链表里再放到散列表的某个位置上，假如遇到位置冲突就追加到链表最后。<code>get</code> 和 <code>remove</code> 时，先算出位置，然后遍历链表，找到需要的值再返回或删除。</p>\n<p>让我们改写 <code>get</code> 、 <code>put</code> 和 <code>remove</code> 方法，跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hashTable = <span class=\"keyword\">new</span> HashTable();</span><br><span class=\"line\"></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan'</span>, <span class=\"string\">'zhangsan@email.com'</span>); <span class=\"comment\">// 代码一</span></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan12'</span>, <span class=\"string\">'zhangsan12@email.com'</span>); <span class=\"comment\">// 代码二</span></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan21'</span>, <span class=\"string\">'zhangsan21@email.com'</span>); <span class=\"comment\">// 代码三</span></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan30'</span>, <span class=\"string\">'zhangsan30@email.com'</span>); <span class=\"comment\">// 代码四</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan'</span>)).toBe(<span class=\"string\">'zhangsan@email.com'</span>); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan12'</span>)).toBe(<span class=\"string\">'zhangsan12@email.com'</span>); <span class=\"comment\">// 断言二</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan21'</span>)).toBe(<span class=\"string\">'zhangsan21@email.com'</span>); <span class=\"comment\">// 断言三</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan30'</span>)).toBe(<span class=\"string\">'zhangsan30@email.com'</span>); <span class=\"comment\">// 断言四</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan'</span>)).toBeTruthy(); <span class=\"comment\">// 断言五</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan'</span>)).toBe(<span class=\"literal\">undefined</span>); <span class=\"comment\">// 断言六</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan21'</span>)).toBeTruthy(); <span class=\"comment\">// 断言七</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan12'</span>)).toBeTruthy(); <span class=\"comment\">// 断言八</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan30'</span>)).toBeTruthy(); <span class=\"comment\">// 断言九</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan30'</span>)).toBeFalsy(); <span class=\"comment\">// 断言十</span></span><br></pre></td></tr></table></figure>\n<p>实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ValuePair = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.put = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> postion = loseloseHashCode(key);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (table[postion] == <span class=\"literal\">undefined</span>) &#123;  <span class=\"comment\">// 代码一的情况</span></span><br><span class=\"line\">    table[postion] = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  table[postion].append(<span class=\"keyword\">new</span> ValuePair(key, value)); <span class=\"comment\">// 代码二、三、四的情况</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.get = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> position = loseloseHashCode(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (table[position] !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = table[position].getHead();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current.next) &#123;  <span class=\"comment\">// 断言二、三的情况</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (current.element.key === key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> current.element.value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      current = current.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current.element.key === key) &#123; <span class=\"comment\">// 断言一、四的情况</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> current.element.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// 断言六</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.remove = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> position = loseloseHashCode(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (table[position] !== <span class=\"literal\">undefined</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = table[position].getHead();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (current.element.key === key)&#123;</span><br><span class=\"line\">        table[position].remove(current.element); <span class=\"comment\">// 断言五、七、八、九</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[position].isEmpty())&#123;</span><br><span class=\"line\">          table[position] = <span class=\"literal\">undefined</span>; <span class=\"comment\">// 断言五、九</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      current = current.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(current);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 断言十</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自己看着测试用例把边界写全吧！</p>\n<h3 id=\"使用线性探查法解决冲突\"><a href=\"#使用线性探查法解决冲突\" class=\"headerlink\" title=\"使用线性探查法解决冲突\"></a>使用线性探查法解决冲突</h3><p>除了分离链接法，还可以通过线性探查法解决冲突，它的实现思路是，<code>put</code> 时如果冲突就设置在下个位置，还冲突就继续，直到找到空位，然后设置。<code>get</code> 和 <code>remove</code> 时，则先找到位置，然后判断是不是当前值，不是就往后找，找到就返回或删除。</p>\n<p>改写 <code>put</code>、<code>get</code> 和 <code>remove</code>，跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hashTable = <span class=\"keyword\">new</span> HashTable();</span><br><span class=\"line\"></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan'</span>, <span class=\"string\">'zhangsan@email.com'</span>); <span class=\"comment\">// 代码一</span></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan12'</span>, <span class=\"string\">'zhangsan12@email.com'</span>); <span class=\"comment\">// 代码二</span></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan21'</span>, <span class=\"string\">'zhangsan21@email.com'</span>); <span class=\"comment\">// 代码三</span></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan30'</span>, <span class=\"string\">'zhangsan30@email.com'</span>); <span class=\"comment\">// 代码四</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan'</span>)).toBe(<span class=\"string\">'zhangsan@email.com'</span>); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan12'</span>)).toBe(<span class=\"string\">'zhangsan12@email.com'</span>); <span class=\"comment\">// 断言二</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan21'</span>)).toBe(<span class=\"string\">'zhangsan21@email.com'</span>); <span class=\"comment\">// 断言三</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan30'</span>)).toBe(<span class=\"string\">'zhangsan30@email.com'</span>); <span class=\"comment\">// 断言四</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan'</span>)).toBeTruthy(); <span class=\"comment\">// 断言五</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan'</span>)).toBe(<span class=\"literal\">undefined</span>); <span class=\"comment\">// 断言六</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan30'</span>)).toBeTruthy();  <span class=\"comment\">// 断言七</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan21'</span>)).toBeTruthy(); <span class=\"comment\">// 断言八</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan12'</span>)).toBeTruthy(); <span class=\"comment\">// 断言九</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan12'</span>)).toBeFalsy(); <span class=\"comment\">// 断言十</span></span><br></pre></td></tr></table></figure>\n<p>实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ValuePair = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.put = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> position = loseloseHashCode(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (table[position] === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    table[position] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// 代码一、二</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> index = ++position;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (table[index] !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      index++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    table[index] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// 代码三、四</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.get = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> position = loseloseHashCode(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (table[position] !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (table[position].key === key) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> table[position].value; <span class=\"comment\">// 断言一、二</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> index = ++position;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (table[index] !== <span class=\"literal\">undefined</span> &amp;&amp; (table[index] &amp;&amp; table[index].key !== key)) &#123;</span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (table[index] &amp;&amp; table[index].key === key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> table[index].value; <span class=\"comment\">// 断言三、四</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// 断言六</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.remove = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> position = loseloseHashCode(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (table[position] !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (table[position].key === key) &#123;</span><br><span class=\"line\">      table[position] = <span class=\"literal\">undefined</span>; <span class=\"comment\">// 断言五</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> index = ++position;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (table[index] === <span class=\"literal\">undefined</span> || table[index].key !== key) &#123;</span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (table[index].key === key) &#123;</span><br><span class=\"line\">        table[index] = <span class=\"literal\">undefined</span>;  <span class=\"comment\">// 断言七、八、九</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 断言十</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>两种冲突方法知道原理即可，代码写起来挺无聊的，都是边界问题。今天就到此为止吧！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是数据结构与算法中的散列表。</p>","more":"<h2 id=\"散列表简介\"><a href=\"#散列表简介\" class=\"headerlink\" title=\"散列表简介\"></a>散列表简介</h2><p>散列表是什么？散列表也是一种以<strong>键值对</strong>存储数据的数据结构，但是它的键是通过<strong>散列函数</strong>生成的<strong>位置或索引</strong>，也正因为此，我们可以<strong>更快</strong>地访问某个值（散列表的查找复杂度为O(1)，而其他顺序数据结构如栈、队列、链表的查找复杂度都为O(n)，因为需要遍历）。比如，电话簿就是散列表的一种应用。电话簿用姓名首字母作为索引帮助使用者快速检索出电话号码。那么首字母就是<strong>键</strong>，电话号码就是<strong>值</strong>，姓名到首字母的算法就是一种<strong>散列函数</strong>，而这种方法显然加快了检索的速度，就像散列表设计的初衷（为了加快速度）一样。</p>\n<h2 id=\"散列函数简介\"><a href=\"#散列函数简介\" class=\"headerlink\" title=\"散列函数简介\"></a>散列函数简介</h2><p>电话簿这个例子中我们看到了一种散列函数，那么什么是散列函数？散列函数是一种从任何一种数据中创建<strong>小的数字“指纹”</strong>的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。散列函数构造方法有很多，包括：直接定址法、数字分析法、平方取中法、折叠法、随机数法、除留余数法等。本文就将会使用<strong>除留余数法</strong>来构造散列函数。除留余数法的实现思路是：取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址。对 p 的选择很重要，一般取素数或 m，若 p 选择不好，容易产生冲突。</p>\n<h2 id=\"用-JavaScript-编写散列表类\"><a href=\"#用-JavaScript-编写散列表类\" class=\"headerlink\" title=\"用 JavaScript 编写散列表类\"></a>用 JavaScript 编写散列表类</h2><p>让我们自己用 JavaScript 写个散列表类吧！</p>\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>为了用键（位置或索引）值对存储元素，我们使用一个数组 <code>table</code> 来作为私有变量。另外，还要再编写一个私有的散列函数 <code>loseloseHashCode</code>，这个散列函数的实现思路是：先累加所有字母的 Ascii 值得到 <code>hash</code>，然后返回 <code>hash</code> 除以某个值（本例取37，你也可以选择其他值）的余数。这就是除留余数法的一种应用。</p>\n<blockquote>\n<p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。想了解更多的细节，请访问 <a href=\"http://www.asciitable.com/。\" target=\"_blank\" rel=\"noopener\">http://www.asciitable.com/。</a></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HashTable</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> table = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> loseloseHashCode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hash = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; key.length; i++) &#123;</span><br><span class=\"line\">      hash += key.charCodeAt(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hash % <span class=\"number\">37</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么散列表里的数据究竟长什么样呢？举个例子，假如要存储的数据是：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">'zhangsan'</span>: <span class=\"string\">'zhangsan@email.com'</span></span><br><span class=\"line\">  <span class=\"string\">'lisi'</span>: <span class=\"string\">'lisi@email.com'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么经过 <code>loseloseHashCode</code>，存储在 <code>table</code> 中的数据就是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  <span class=\"string\">'zhangsan@email.com'</span>, <span class=\"comment\">// zhangsan 的 Ascii 码值之和是858，除以37余7</span></span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  ,</span><br><span class=\"line\">  <span class=\"string\">'lisi@email.com'</span> <span class=\"comment\">// lisi 的 Ascii 码值之和是433，除以37余26</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>散列表中的<strong>键</strong>就是位置或索引，查起来就是快！</p>\n<h3 id=\"实现-put-、get-和-remove-方法\"><a href=\"#实现-put-、get-和-remove-方法\" class=\"headerlink\" title=\"实现 put 、get 和 remove 方法\"></a>实现 put 、get 和 remove 方法</h3><p>实现 <code>put</code> 方法（设置键值对）、<code>get</code> 方法（通过键取值）、<code>remove</code> 方法（删除指定键值），可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hashTable = <span class=\"keyword\">new</span> HashTable();</span><br><span class=\"line\"></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan'</span>, <span class=\"string\">'zhangsan@email.com'</span>);</span><br><span class=\"line\">hashTable.put(<span class=\"string\">'lisi'</span>, <span class=\"string\">'lisi@email.com'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan'</span>)).toBe(<span class=\"string\">'zhangsan@email.com'</span>);</span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'lisi'</span>)).toBe(<span class=\"string\">'lisi@email.com'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">hashTable.remove(<span class=\"string\">'zhangsan'</span>);</span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan'</span>)).toBe(<span class=\"literal\">undefined</span>);</span><br></pre></td></tr></table></figure>\n<p>实现方法比较简单，直接上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.put = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> position = loseloseHashCode(key);</span><br><span class=\"line\">  table[position] = value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.get = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> table[loseloseHashCode(key)];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.remove = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  table[loseloseHashCode(key)] = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用分离链接法解决冲突\"><a href=\"#使用分离链接法解决冲突\" class=\"headerlink\" title=\"使用分离链接法解决冲突\"></a>使用分离链接法解决冲突</h3><p>看了上述方法，很多同学会有疑问：如果某两个键通过 <code>loseloseHashCode</code> 返回的余数相同怎么办？这时候就需要解决冲突。其实一个好的散列函数的冲突是很少的，可惜 <code>loseloseHashCode</code> 只能算是一般般吧！解决冲突有很多方法，我们先使用<strong>分离链接法</strong>来解决冲突。</p>\n<p>分离链接法的实现思路是，<code>put</code> 时将输入的值放到链表里再放到散列表的某个位置上，假如遇到位置冲突就追加到链表最后。<code>get</code> 和 <code>remove</code> 时，先算出位置，然后遍历链表，找到需要的值再返回或删除。</p>\n<p>让我们改写 <code>get</code> 、 <code>put</code> 和 <code>remove</code> 方法，跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hashTable = <span class=\"keyword\">new</span> HashTable();</span><br><span class=\"line\"></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan'</span>, <span class=\"string\">'zhangsan@email.com'</span>); <span class=\"comment\">// 代码一</span></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan12'</span>, <span class=\"string\">'zhangsan12@email.com'</span>); <span class=\"comment\">// 代码二</span></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan21'</span>, <span class=\"string\">'zhangsan21@email.com'</span>); <span class=\"comment\">// 代码三</span></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan30'</span>, <span class=\"string\">'zhangsan30@email.com'</span>); <span class=\"comment\">// 代码四</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan'</span>)).toBe(<span class=\"string\">'zhangsan@email.com'</span>); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan12'</span>)).toBe(<span class=\"string\">'zhangsan12@email.com'</span>); <span class=\"comment\">// 断言二</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan21'</span>)).toBe(<span class=\"string\">'zhangsan21@email.com'</span>); <span class=\"comment\">// 断言三</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan30'</span>)).toBe(<span class=\"string\">'zhangsan30@email.com'</span>); <span class=\"comment\">// 断言四</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan'</span>)).toBeTruthy(); <span class=\"comment\">// 断言五</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan'</span>)).toBe(<span class=\"literal\">undefined</span>); <span class=\"comment\">// 断言六</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan21'</span>)).toBeTruthy(); <span class=\"comment\">// 断言七</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan12'</span>)).toBeTruthy(); <span class=\"comment\">// 断言八</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan30'</span>)).toBeTruthy(); <span class=\"comment\">// 断言九</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan30'</span>)).toBeFalsy(); <span class=\"comment\">// 断言十</span></span><br></pre></td></tr></table></figure>\n<p>实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ValuePair = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.put = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> postion = loseloseHashCode(key);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (table[postion] == <span class=\"literal\">undefined</span>) &#123;  <span class=\"comment\">// 代码一的情况</span></span><br><span class=\"line\">    table[postion] = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  table[postion].append(<span class=\"keyword\">new</span> ValuePair(key, value)); <span class=\"comment\">// 代码二、三、四的情况</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.get = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> position = loseloseHashCode(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (table[position] !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = table[position].getHead();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current.next) &#123;  <span class=\"comment\">// 断言二、三的情况</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (current.element.key === key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> current.element.value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      current = current.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current.element.key === key) &#123; <span class=\"comment\">// 断言一、四的情况</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> current.element.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// 断言六</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.remove = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> position = loseloseHashCode(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (table[position] !== <span class=\"literal\">undefined</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = table[position].getHead();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (current.element.key === key)&#123;</span><br><span class=\"line\">        table[position].remove(current.element); <span class=\"comment\">// 断言五、七、八、九</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[position].isEmpty())&#123;</span><br><span class=\"line\">          table[position] = <span class=\"literal\">undefined</span>; <span class=\"comment\">// 断言五、九</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      current = current.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(current);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 断言十</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自己看着测试用例把边界写全吧！</p>\n<h3 id=\"使用线性探查法解决冲突\"><a href=\"#使用线性探查法解决冲突\" class=\"headerlink\" title=\"使用线性探查法解决冲突\"></a>使用线性探查法解决冲突</h3><p>除了分离链接法，还可以通过线性探查法解决冲突，它的实现思路是，<code>put</code> 时如果冲突就设置在下个位置，还冲突就继续，直到找到空位，然后设置。<code>get</code> 和 <code>remove</code> 时，则先找到位置，然后判断是不是当前值，不是就往后找，找到就返回或删除。</p>\n<p>改写 <code>put</code>、<code>get</code> 和 <code>remove</code>，跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hashTable = <span class=\"keyword\">new</span> HashTable();</span><br><span class=\"line\"></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan'</span>, <span class=\"string\">'zhangsan@email.com'</span>); <span class=\"comment\">// 代码一</span></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan12'</span>, <span class=\"string\">'zhangsan12@email.com'</span>); <span class=\"comment\">// 代码二</span></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan21'</span>, <span class=\"string\">'zhangsan21@email.com'</span>); <span class=\"comment\">// 代码三</span></span><br><span class=\"line\">hashTable.put(<span class=\"string\">'zhangsan30'</span>, <span class=\"string\">'zhangsan30@email.com'</span>); <span class=\"comment\">// 代码四</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan'</span>)).toBe(<span class=\"string\">'zhangsan@email.com'</span>); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan12'</span>)).toBe(<span class=\"string\">'zhangsan12@email.com'</span>); <span class=\"comment\">// 断言二</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan21'</span>)).toBe(<span class=\"string\">'zhangsan21@email.com'</span>); <span class=\"comment\">// 断言三</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan30'</span>)).toBe(<span class=\"string\">'zhangsan30@email.com'</span>); <span class=\"comment\">// 断言四</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan'</span>)).toBeTruthy(); <span class=\"comment\">// 断言五</span></span><br><span class=\"line\">expect(hashTable.get(<span class=\"string\">'zhangsan'</span>)).toBe(<span class=\"literal\">undefined</span>); <span class=\"comment\">// 断言六</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan30'</span>)).toBeTruthy();  <span class=\"comment\">// 断言七</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan21'</span>)).toBeTruthy(); <span class=\"comment\">// 断言八</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan12'</span>)).toBeTruthy(); <span class=\"comment\">// 断言九</span></span><br><span class=\"line\">expect(hashTable.remove(<span class=\"string\">'zhangsan12'</span>)).toBeFalsy(); <span class=\"comment\">// 断言十</span></span><br></pre></td></tr></table></figure>\n<p>实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ValuePair = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.put = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> position = loseloseHashCode(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (table[position] === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    table[position] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// 代码一、二</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> index = ++position;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (table[index] !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      index++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    table[index] = <span class=\"keyword\">new</span> ValuePair(key, value); <span class=\"comment\">// 代码三、四</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.get = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> position = loseloseHashCode(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (table[position] !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (table[position].key === key) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> table[position].value; <span class=\"comment\">// 断言一、二</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> index = ++position;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (table[index] !== <span class=\"literal\">undefined</span> &amp;&amp; (table[index] &amp;&amp; table[index].key !== key)) &#123;</span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (table[index] &amp;&amp; table[index].key === key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> table[index].value; <span class=\"comment\">// 断言三、四</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>; <span class=\"comment\">// 断言六</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.remove = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> position = loseloseHashCode(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (table[position] !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (table[position].key === key) &#123;</span><br><span class=\"line\">      table[position] = <span class=\"literal\">undefined</span>; <span class=\"comment\">// 断言五</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> index = ++position;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (table[index] === <span class=\"literal\">undefined</span> || table[index].key !== key) &#123;</span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (table[index].key === key) &#123;</span><br><span class=\"line\">        table[index] = <span class=\"literal\">undefined</span>;  <span class=\"comment\">// 断言七、八、九</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 断言十</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>两种冲突方法知道原理即可，代码写起来挺无聊的，都是边界问题。今天就到此为止吧！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>"},{"title":"JavaScript 版动态规划算法题：打家劫舍","date":"2017-03-10T08:45:00.000Z","_content":"\n今天，我们要讲的是一道动态规划算法题：打家劫舍。这道题有三个版本，它们都来自 LeetCode：\n\nhttps://leetcode.com/problems/house-robber\n\nhttps://leetcode.com/problems/house-robber-ii\n\nhttps://leetcode.com/problems/house-robber-iii\n\n本文将先介绍动态规划的基础知识，然后使用动态规划思想解决这个问题，所用的语言仍然是 JavaScript。\n\n<!--more-->\n\n## 动态规划简介\n\n动态规划是(Dynamic Programming，DP)是一种将复杂问题分解成更小的子问题来解决的优化技术。那么具体哪些算法用到了动态规划呢？使用动态规划的算法很多，先列举一些简单的吧！比如：\n\n1，求斐波那契数列：\n\n```js\nfunction fibonacci(num) {\n  if (num === 1 || num === 2) {\n    return 1;\n  }\n  return fibonacci(num - 1) + fibonacci(num - 2);\n}\n```\n\n上述函数将 `fibonacci(num)` 分解成 `fibonacci(num - 1)` 和 `fibonacci(num - 2)`，然后继续分解直到 `num` 为1或2时终止。\n\n2，深度优先遍历（DFS）：\n\n   - 先访问一个顶点，然后对相邻顶点挨个进行深度优先遍历。\n\n上述做法将复杂的图遍历分解为“每个顶点的**访问**与**相邻顶点的深度优先遍历**”。有点类似于二叉树先序遍历。具体代码请参考前面的博文[《 JavaScript 版数据结构与算法（八）图 》](https://lewis617.github.io/2017/02/19/graph/)。\n\n## 动态规划和分而治之的区别\n\n了解了动态规划，我们来看另一种思想——分而治之。分而治之方法与软件设计的模块化方法非常相似。为了解决一个大的问题，可以： \n\n1. 把它分成两个或多个更小的问题； \n2. 分别解决每个小问题； \n3. 把各小问题的解答组合起来，即可得到原问题的解答。\n\n小问题通常与原问题相似，可以递归地使用分而治之策略来解决。\n\n动态规划和分而治之都是**大问题分解成多个子问题**，那么这两者有什么区别呢？动态规划和分而治之的区别在于**子问题之间是否独立**。分而治之是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则把问题分解成相互依赖的子问题。\n\n常见的使用分而治之的算法有**归并排序**和**快速排序**。具体实现代码可以参考前面的博文[《JavaScript 版数据结构与算法（九）排序和搜索》](https://lewis617.github.io/2017/02/20/sort-and-search/)。\n\n## 用动态规划解决“打家劫舍问题”\n\n通过前面的介绍，大家应该对动态规划有个大致的了解了，下面让我们用动态规划来解决“打家劫舍问题”。“打家劫舍问题”的题目是：\n\n> 假设你是一个专业的劫匪，你计划去打劫一条街上的家舍。每家有一定数量的钱财，但相邻两家有一个彼此连接的安全系统。一旦相邻两家在同一晚被打劫，那么这个安全系统就会自动报警。\n\n> 给你一个由非负整数组成的数组，用来代表每家的钱财，在不让安全系统自动报警的前提下，求你能打劫到的钱财的最大数量。\n\n我们还是用单元测试来表达一下需求吧！毕竟好多程序员看机器语言要比自然语言还舒服：\n\n```js\n// 对于 [2, 0, 0, 4, 5]，能打劫到的最大钱财是7\nexpect(rob([2, 0, 0, 4, 5])).toBe(7);\n```\n\n我们要编写一个 `rob` 方法，可以返回内部数组的最大的不相邻数字之和。\n\n那么如何实现这个算法呢？我们需要借助动态规划思想：\n\n- 如果数组长度为1，那么直接返回数组唯一项。\n- 如果数组长度为2，那么返回“第1项”和“第2项”的较大者。\n- 如果数组长度为3，那么返回“数组长度为1的结果+第3项”与“数组长度为2的结果”的较大者。\n- 如果数组长度为4，那么返回“数组长度为2的结果+第4项”与“数组长度为3的结果”的较大者。\n- ……\n- 如果数组长度为n，那么返回“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”的较大者。\n\n为何会如此呢？因为题目要求不能打劫相邻两家，所以数组的当前项只能和上上次的结果相加。那么子问题就是“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”。用方程来表示就是：\n\n```\nf(0) = array[0]\nf(1) = max(array[0], array[1])\nf(n) = max( f(n-2) + array[n], f(n-1) )\n```\n\n所以实现代码就是：\n\nLeetCode/198-rob1.js\n\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function (nums) {\n  var last = 0,\n    now = 0;\n  for (var i = 0; i < nums.length; i++) {\n    var temp = last;\n    last = now;\n    now = Math.max(temp + nums[i], now);\n  }\n\n  return now;\n};\n```\n## 圆圈版打家劫舍\n\n“打家劫舍”问题还有另一个版本，它的题目是：\n\n> 在上次打劫后，作为专业劫匪的你意识到自己需要去一个新的地方打劫，这样才不会引起太多注意。这次，你去的地方的家舍是按圆圈形状来排列的。这意味着第一家和最后一家是挨着的，同时，安全系统和上个地方的一样。\n\n> 给你一个由非负整数组成的数组，用来代表每家的钱财，在不让安全系统自动报警的前提下，求你能打劫到的钱财的最大数量。\n\n那么这道题该如何解答呢？因为家舍首尾相连，所以你不能在同一晚打劫第一家和最后一家，既然不能打劫，机智的你索性将计就计，先排除最后一家不管，或者先排除第一家不管，打劫剩余的家舍，然后比较那个更划算。所以这道题可以这么来解答：\n\n- 先求出第一家到倒数第二家的最大钱财数量\n- 然后求出第二家到最后一家的最大钱财数量\n- 最后求两者的较大值\n\n所以实现代码就是：\n\nLeetCode/213-rob2.js\n\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function(nums) {\n  var rob1 = require('./rob1');\n\n  if (nums.length === 1) {\n    return nums[0];\n  }\n  return Math.max(rob1(nums.slice(1)), rob1(nums.slice(0, nums.length - 1)));\n};\n```\n上述代码中，`nums.slice(1)`代表排除了第一家，`nums.slice(0, array.length - 1)`代表排除了最后一家。然后运行测试，发现确实没有上次打劫的多：\n\n```js\nexpect(rob([2, 0, 0, 4, 5])).toBe(6);\n```\n\n\n## 二叉树版打家劫舍\n\n我们再看一道二叉树版打家劫舍吧！题目如下：\n\n> 作为专业劫匪的你又找到了一个新地方可以下手，这个地方的家舍是按二叉树形状排列的，安全系统和之前一样。在不让安全系统自动报警的前提下，求你能打劫到的钱财的最大数量。\n\n为了表述题意，我们来看个例子吧：\n\n```\n     3\n    / \\\n   2   3\n    \\   \\ \n     3   1\n```\n那么最大钱财就是第一行的3和第三行的3、1，一共是7。\n\n看完了题目，我们该如何编写代码呢？首先，按照动态规划，我们需要找到**子问题**！在第一版的打家劫舍问题中，子问题是“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”的较大者。那么这道题的子问题是什么呢？这道题的子问题是“打劫当前节点”和“不打劫当前节点”哪个更划算？那么如何比较哪个更划算呢？这得看“打劫子节点”和“不打劫子节点”的值各是多少。如果“打劫当前节点”，那么就不能打劫子节点，那么这时值就是“不打劫子节点”的值加上自己值。如果“不打劫当前节点”，那么就可以打劫子节点，也可以不打劫子节点，那么这时值就是“打劫子节点”和“不打劫子节点”的值的较大者。用代码表示就是：\n\nLeetCode/337-rob3.js\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(key) {\n *     this.val = key;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar rob = function(root) {\n  var dfs = function (node) {\n    if (node === null) {\n      return [null, null];\n    }\n    var left = dfs(node.left);\n    var right = dfs(node.right);\n    var res = [];\n    res[0] = left[1] + right[1] + node.key;\n    res[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n    return res;\n  };\n\n  var num = dfs(root);\n  return Math.max(num[0], num[1]);\n};\n```\n我们首先写一个 `dfs`来深度优先遍历节点，其实就是先序遍历。这个 `dfs` 方法返回了“打劫当前节点”和“不打劫当前节点”的值各是多少，这里用 `res` 数组来表示。由于深度优先遍历是对左右节点也进行 `dfs`，所以我们可以通过子节点的返回值（这里用 `left` 和 `right`来表示）得到当前节点的返回值，直到节点为空，就把递归终结掉！编写完了 `dfs`，我们对 `root` 入口进行 `dfs`，得到的数组就是“打劫根节点”和“不打劫根节点”的数值。最后，返回较大者即可得到答案。\n\n测试代码如下：\n\nLeetCode/\\__tests\\__/337-rob3.test.js\n\n```js\nvar rob = require('../rob3');\nvar BinarySearchTree = require('../../Tree/BinarySearchTree');\n\ntest('rob3', function () {\n  var binarySearchTree = new BinarySearchTree();\n\n  binarySearchTree.insert(11);\n  binarySearchTree.insert(7);\n  binarySearchTree.insert(13);\n  binarySearchTree.insert(5);\n  binarySearchTree.insert(3);\n  binarySearchTree.insert(9);\n\n  expect(rob(binarySearchTree.getRoot())).toBe(27);\n});\n```\n\n这里使用了前面编写的数据结构 `BinarySearchTree`，它的实现代码和具体讲解可以参考前面的博文[《JavaScript 版数据结构与算法（七）树》](https://lewis617.github.io/2017/02/18/tree/)。\n\n至此，“打家劫舍问题”就讲完了！其实，“打家劫舍问题”的本质在于使用“动态规划”，而“动态规划”的本质在于将大问题分解为相互依赖的子问题。看清问题本质，才能练好算法！加油吧！\n\n \n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>\n","source":"_posts/house-robber.md","raw":"---\ntitle: JavaScript 版动态规划算法题：打家劫舍\ndate: 2017-03-10 16:45:00\ntags: [数据结构与算法, LeetCode]\n---\n\n今天，我们要讲的是一道动态规划算法题：打家劫舍。这道题有三个版本，它们都来自 LeetCode：\n\nhttps://leetcode.com/problems/house-robber\n\nhttps://leetcode.com/problems/house-robber-ii\n\nhttps://leetcode.com/problems/house-robber-iii\n\n本文将先介绍动态规划的基础知识，然后使用动态规划思想解决这个问题，所用的语言仍然是 JavaScript。\n\n<!--more-->\n\n## 动态规划简介\n\n动态规划是(Dynamic Programming，DP)是一种将复杂问题分解成更小的子问题来解决的优化技术。那么具体哪些算法用到了动态规划呢？使用动态规划的算法很多，先列举一些简单的吧！比如：\n\n1，求斐波那契数列：\n\n```js\nfunction fibonacci(num) {\n  if (num === 1 || num === 2) {\n    return 1;\n  }\n  return fibonacci(num - 1) + fibonacci(num - 2);\n}\n```\n\n上述函数将 `fibonacci(num)` 分解成 `fibonacci(num - 1)` 和 `fibonacci(num - 2)`，然后继续分解直到 `num` 为1或2时终止。\n\n2，深度优先遍历（DFS）：\n\n   - 先访问一个顶点，然后对相邻顶点挨个进行深度优先遍历。\n\n上述做法将复杂的图遍历分解为“每个顶点的**访问**与**相邻顶点的深度优先遍历**”。有点类似于二叉树先序遍历。具体代码请参考前面的博文[《 JavaScript 版数据结构与算法（八）图 》](https://lewis617.github.io/2017/02/19/graph/)。\n\n## 动态规划和分而治之的区别\n\n了解了动态规划，我们来看另一种思想——分而治之。分而治之方法与软件设计的模块化方法非常相似。为了解决一个大的问题，可以： \n\n1. 把它分成两个或多个更小的问题； \n2. 分别解决每个小问题； \n3. 把各小问题的解答组合起来，即可得到原问题的解答。\n\n小问题通常与原问题相似，可以递归地使用分而治之策略来解决。\n\n动态规划和分而治之都是**大问题分解成多个子问题**，那么这两者有什么区别呢？动态规划和分而治之的区别在于**子问题之间是否独立**。分而治之是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则把问题分解成相互依赖的子问题。\n\n常见的使用分而治之的算法有**归并排序**和**快速排序**。具体实现代码可以参考前面的博文[《JavaScript 版数据结构与算法（九）排序和搜索》](https://lewis617.github.io/2017/02/20/sort-and-search/)。\n\n## 用动态规划解决“打家劫舍问题”\n\n通过前面的介绍，大家应该对动态规划有个大致的了解了，下面让我们用动态规划来解决“打家劫舍问题”。“打家劫舍问题”的题目是：\n\n> 假设你是一个专业的劫匪，你计划去打劫一条街上的家舍。每家有一定数量的钱财，但相邻两家有一个彼此连接的安全系统。一旦相邻两家在同一晚被打劫，那么这个安全系统就会自动报警。\n\n> 给你一个由非负整数组成的数组，用来代表每家的钱财，在不让安全系统自动报警的前提下，求你能打劫到的钱财的最大数量。\n\n我们还是用单元测试来表达一下需求吧！毕竟好多程序员看机器语言要比自然语言还舒服：\n\n```js\n// 对于 [2, 0, 0, 4, 5]，能打劫到的最大钱财是7\nexpect(rob([2, 0, 0, 4, 5])).toBe(7);\n```\n\n我们要编写一个 `rob` 方法，可以返回内部数组的最大的不相邻数字之和。\n\n那么如何实现这个算法呢？我们需要借助动态规划思想：\n\n- 如果数组长度为1，那么直接返回数组唯一项。\n- 如果数组长度为2，那么返回“第1项”和“第2项”的较大者。\n- 如果数组长度为3，那么返回“数组长度为1的结果+第3项”与“数组长度为2的结果”的较大者。\n- 如果数组长度为4，那么返回“数组长度为2的结果+第4项”与“数组长度为3的结果”的较大者。\n- ……\n- 如果数组长度为n，那么返回“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”的较大者。\n\n为何会如此呢？因为题目要求不能打劫相邻两家，所以数组的当前项只能和上上次的结果相加。那么子问题就是“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”。用方程来表示就是：\n\n```\nf(0) = array[0]\nf(1) = max(array[0], array[1])\nf(n) = max( f(n-2) + array[n], f(n-1) )\n```\n\n所以实现代码就是：\n\nLeetCode/198-rob1.js\n\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function (nums) {\n  var last = 0,\n    now = 0;\n  for (var i = 0; i < nums.length; i++) {\n    var temp = last;\n    last = now;\n    now = Math.max(temp + nums[i], now);\n  }\n\n  return now;\n};\n```\n## 圆圈版打家劫舍\n\n“打家劫舍”问题还有另一个版本，它的题目是：\n\n> 在上次打劫后，作为专业劫匪的你意识到自己需要去一个新的地方打劫，这样才不会引起太多注意。这次，你去的地方的家舍是按圆圈形状来排列的。这意味着第一家和最后一家是挨着的，同时，安全系统和上个地方的一样。\n\n> 给你一个由非负整数组成的数组，用来代表每家的钱财，在不让安全系统自动报警的前提下，求你能打劫到的钱财的最大数量。\n\n那么这道题该如何解答呢？因为家舍首尾相连，所以你不能在同一晚打劫第一家和最后一家，既然不能打劫，机智的你索性将计就计，先排除最后一家不管，或者先排除第一家不管，打劫剩余的家舍，然后比较那个更划算。所以这道题可以这么来解答：\n\n- 先求出第一家到倒数第二家的最大钱财数量\n- 然后求出第二家到最后一家的最大钱财数量\n- 最后求两者的较大值\n\n所以实现代码就是：\n\nLeetCode/213-rob2.js\n\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function(nums) {\n  var rob1 = require('./rob1');\n\n  if (nums.length === 1) {\n    return nums[0];\n  }\n  return Math.max(rob1(nums.slice(1)), rob1(nums.slice(0, nums.length - 1)));\n};\n```\n上述代码中，`nums.slice(1)`代表排除了第一家，`nums.slice(0, array.length - 1)`代表排除了最后一家。然后运行测试，发现确实没有上次打劫的多：\n\n```js\nexpect(rob([2, 0, 0, 4, 5])).toBe(6);\n```\n\n\n## 二叉树版打家劫舍\n\n我们再看一道二叉树版打家劫舍吧！题目如下：\n\n> 作为专业劫匪的你又找到了一个新地方可以下手，这个地方的家舍是按二叉树形状排列的，安全系统和之前一样。在不让安全系统自动报警的前提下，求你能打劫到的钱财的最大数量。\n\n为了表述题意，我们来看个例子吧：\n\n```\n     3\n    / \\\n   2   3\n    \\   \\ \n     3   1\n```\n那么最大钱财就是第一行的3和第三行的3、1，一共是7。\n\n看完了题目，我们该如何编写代码呢？首先，按照动态规划，我们需要找到**子问题**！在第一版的打家劫舍问题中，子问题是“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”的较大者。那么这道题的子问题是什么呢？这道题的子问题是“打劫当前节点”和“不打劫当前节点”哪个更划算？那么如何比较哪个更划算呢？这得看“打劫子节点”和“不打劫子节点”的值各是多少。如果“打劫当前节点”，那么就不能打劫子节点，那么这时值就是“不打劫子节点”的值加上自己值。如果“不打劫当前节点”，那么就可以打劫子节点，也可以不打劫子节点，那么这时值就是“打劫子节点”和“不打劫子节点”的值的较大者。用代码表示就是：\n\nLeetCode/337-rob3.js\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(key) {\n *     this.val = key;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar rob = function(root) {\n  var dfs = function (node) {\n    if (node === null) {\n      return [null, null];\n    }\n    var left = dfs(node.left);\n    var right = dfs(node.right);\n    var res = [];\n    res[0] = left[1] + right[1] + node.key;\n    res[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n    return res;\n  };\n\n  var num = dfs(root);\n  return Math.max(num[0], num[1]);\n};\n```\n我们首先写一个 `dfs`来深度优先遍历节点，其实就是先序遍历。这个 `dfs` 方法返回了“打劫当前节点”和“不打劫当前节点”的值各是多少，这里用 `res` 数组来表示。由于深度优先遍历是对左右节点也进行 `dfs`，所以我们可以通过子节点的返回值（这里用 `left` 和 `right`来表示）得到当前节点的返回值，直到节点为空，就把递归终结掉！编写完了 `dfs`，我们对 `root` 入口进行 `dfs`，得到的数组就是“打劫根节点”和“不打劫根节点”的数值。最后，返回较大者即可得到答案。\n\n测试代码如下：\n\nLeetCode/\\__tests\\__/337-rob3.test.js\n\n```js\nvar rob = require('../rob3');\nvar BinarySearchTree = require('../../Tree/BinarySearchTree');\n\ntest('rob3', function () {\n  var binarySearchTree = new BinarySearchTree();\n\n  binarySearchTree.insert(11);\n  binarySearchTree.insert(7);\n  binarySearchTree.insert(13);\n  binarySearchTree.insert(5);\n  binarySearchTree.insert(3);\n  binarySearchTree.insert(9);\n\n  expect(rob(binarySearchTree.getRoot())).toBe(27);\n});\n```\n\n这里使用了前面编写的数据结构 `BinarySearchTree`，它的实现代码和具体讲解可以参考前面的博文[《JavaScript 版数据结构与算法（七）树》](https://lewis617.github.io/2017/02/18/tree/)。\n\n至此，“打家劫舍问题”就讲完了！其实，“打家劫舍问题”的本质在于使用“动态规划”，而“动态规划”的本质在于将大问题分解为相互依赖的子问题。看清问题本质，才能练好算法！加油吧！\n\n \n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>\n","slug":"house-robber","published":1,"updated":"2019-05-01T08:02:09.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvlb000ntgytvnxwfb3a","content":"<p>今天，我们要讲的是一道动态规划算法题：打家劫舍。这道题有三个版本，它们都来自 LeetCode：</p>\n<p><a href=\"https://leetcode.com/problems/house-robber\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/house-robber</a></p>\n<p><a href=\"https://leetcode.com/problems/house-robber-ii\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/house-robber-ii</a></p>\n<p><a href=\"https://leetcode.com/problems/house-robber-iii\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/house-robber-iii</a></p>\n<p>本文将先介绍动态规划的基础知识，然后使用动态规划思想解决这个问题，所用的语言仍然是 JavaScript。</p>\n<a id=\"more\"></a>\n<h2 id=\"动态规划简介\"><a href=\"#动态规划简介\" class=\"headerlink\" title=\"动态规划简介\"></a>动态规划简介</h2><p>动态规划是(Dynamic Programming，DP)是一种将复杂问题分解成更小的子问题来解决的优化技术。那么具体哪些算法用到了动态规划呢？使用动态规划的算法很多，先列举一些简单的吧！比如：</p>\n<p>1，求斐波那契数列：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fibonacci</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num === <span class=\"number\">1</span> || num === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fibonacci(num - <span class=\"number\">1</span>) + fibonacci(num - <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述函数将 <code>fibonacci(num)</code> 分解成 <code>fibonacci(num - 1)</code> 和 <code>fibonacci(num - 2)</code>，然后继续分解直到 <code>num</code> 为1或2时终止。</p>\n<p>2，深度优先遍历（DFS）：</p>\n<ul>\n<li>先访问一个顶点，然后对相邻顶点挨个进行深度优先遍历。</li>\n</ul>\n<p>上述做法将复杂的图遍历分解为“每个顶点的<strong>访问</strong>与<strong>相邻顶点的深度优先遍历</strong>”。有点类似于二叉树先序遍历。具体代码请参考前面的博文<a href=\"https://lewis617.github.io/2017/02/19/graph/\" target=\"_blank\" rel=\"noopener\">《 JavaScript 版数据结构与算法（八）图 》</a>。</p>\n<h2 id=\"动态规划和分而治之的区别\"><a href=\"#动态规划和分而治之的区别\" class=\"headerlink\" title=\"动态规划和分而治之的区别\"></a>动态规划和分而治之的区别</h2><p>了解了动态规划，我们来看另一种思想——分而治之。分而治之方法与软件设计的模块化方法非常相似。为了解决一个大的问题，可以： </p>\n<ol>\n<li>把它分成两个或多个更小的问题； </li>\n<li>分别解决每个小问题； </li>\n<li>把各小问题的解答组合起来，即可得到原问题的解答。</li>\n</ol>\n<p>小问题通常与原问题相似，可以递归地使用分而治之策略来解决。</p>\n<p>动态规划和分而治之都是<strong>大问题分解成多个子问题</strong>，那么这两者有什么区别呢？动态规划和分而治之的区别在于<strong>子问题之间是否独立</strong>。分而治之是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则把问题分解成相互依赖的子问题。</p>\n<p>常见的使用分而治之的算法有<strong>归并排序</strong>和<strong>快速排序</strong>。具体实现代码可以参考前面的博文<a href=\"https://lewis617.github.io/2017/02/20/sort-and-search/\" target=\"_blank\" rel=\"noopener\">《JavaScript 版数据结构与算法（九）排序和搜索》</a>。</p>\n<h2 id=\"用动态规划解决“打家劫舍问题”\"><a href=\"#用动态规划解决“打家劫舍问题”\" class=\"headerlink\" title=\"用动态规划解决“打家劫舍问题”\"></a>用动态规划解决“打家劫舍问题”</h2><p>通过前面的介绍，大家应该对动态规划有个大致的了解了，下面让我们用动态规划来解决“打家劫舍问题”。“打家劫舍问题”的题目是：</p>\n<blockquote>\n<p>假设你是一个专业的劫匪，你计划去打劫一条街上的家舍。每家有一定数量的钱财，但相邻两家有一个彼此连接的安全系统。一旦相邻两家在同一晚被打劫，那么这个安全系统就会自动报警。</p>\n</blockquote>\n<blockquote>\n<p>给你一个由非负整数组成的数组，用来代表每家的钱财，在不让安全系统自动报警的前提下，求你能打劫到的钱财的最大数量。</p>\n</blockquote>\n<p>我们还是用单元测试来表达一下需求吧！毕竟好多程序员看机器语言要比自然语言还舒服：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对于 [2, 0, 0, 4, 5]，能打劫到的最大钱财是7</span></span><br><span class=\"line\">expect(rob([<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])).toBe(<span class=\"number\">7</span>);</span><br></pre></td></tr></table></figure>\n<p>我们要编写一个 <code>rob</code> 方法，可以返回内部数组的最大的不相邻数字之和。</p>\n<p>那么如何实现这个算法呢？我们需要借助动态规划思想：</p>\n<ul>\n<li>如果数组长度为1，那么直接返回数组唯一项。</li>\n<li>如果数组长度为2，那么返回“第1项”和“第2项”的较大者。</li>\n<li>如果数组长度为3，那么返回“数组长度为1的结果+第3项”与“数组长度为2的结果”的较大者。</li>\n<li>如果数组长度为4，那么返回“数组长度为2的结果+第4项”与“数组长度为3的结果”的较大者。</li>\n<li>……</li>\n<li>如果数组长度为n，那么返回“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”的较大者。</li>\n</ul>\n<p>为何会如此呢？因为题目要求不能打劫相邻两家，所以数组的当前项只能和上上次的结果相加。那么子问题就是“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”。用方程来表示就是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(0) = array[0]</span><br><span class=\"line\">f(1) = max(array[0], array[1])</span><br><span class=\"line\">f(n) = max( f(n-2) + array[n], f(n-1) )</span><br></pre></td></tr></table></figure>\n<p>所以实现代码就是：</p>\n<p>LeetCode/198-rob1.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; nums</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rob = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> last = <span class=\"number\">0</span>,</span><br><span class=\"line\">    now = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = last;</span><br><span class=\"line\">    last = now;</span><br><span class=\"line\">    now = <span class=\"built_in\">Math</span>.max(temp + nums[i], now);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> now;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"圆圈版打家劫舍\"><a href=\"#圆圈版打家劫舍\" class=\"headerlink\" title=\"圆圈版打家劫舍\"></a>圆圈版打家劫舍</h2><p>“打家劫舍”问题还有另一个版本，它的题目是：</p>\n<blockquote>\n<p>在上次打劫后，作为专业劫匪的你意识到自己需要去一个新的地方打劫，这样才不会引起太多注意。这次，你去的地方的家舍是按圆圈形状来排列的。这意味着第一家和最后一家是挨着的，同时，安全系统和上个地方的一样。</p>\n</blockquote>\n<blockquote>\n<p>给你一个由非负整数组成的数组，用来代表每家的钱财，在不让安全系统自动报警的前提下，求你能打劫到的钱财的最大数量。</p>\n</blockquote>\n<p>那么这道题该如何解答呢？因为家舍首尾相连，所以你不能在同一晚打劫第一家和最后一家，既然不能打劫，机智的你索性将计就计，先排除最后一家不管，或者先排除第一家不管，打劫剩余的家舍，然后比较那个更划算。所以这道题可以这么来解答：</p>\n<ul>\n<li>先求出第一家到倒数第二家的最大钱财数量</li>\n<li>然后求出第二家到最后一家的最大钱财数量</li>\n<li>最后求两者的较大值</li>\n</ul>\n<p>所以实现代码就是：</p>\n<p>LeetCode/213-rob2.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; nums</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rob = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> rob1 = <span class=\"built_in\">require</span>(<span class=\"string\">'./rob1'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.max(rob1(nums.slice(<span class=\"number\">1</span>)), rob1(nums.slice(<span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>)));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，<code>nums.slice(1)</code>代表排除了第一家，<code>nums.slice(0, array.length - 1)</code>代表排除了最后一家。然后运行测试，发现确实没有上次打劫的多：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(rob([<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])).toBe(<span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树版打家劫舍\"><a href=\"#二叉树版打家劫舍\" class=\"headerlink\" title=\"二叉树版打家劫舍\"></a>二叉树版打家劫舍</h2><p>我们再看一道二叉树版打家劫舍吧！题目如下：</p>\n<blockquote>\n<p>作为专业劫匪的你又找到了一个新地方可以下手，这个地方的家舍是按二叉树形状排列的，安全系统和之前一样。在不让安全系统自动报警的前提下，求你能打劫到的钱财的最大数量。</p>\n</blockquote>\n<p>为了表述题意，我们来看个例子吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  3</span><br><span class=\"line\"> / \\</span><br><span class=\"line\">2   3</span><br><span class=\"line\"> \\   \\ </span><br><span class=\"line\">  3   1</span><br></pre></td></tr></table></figure>\n<p>那么最大钱财就是第一行的3和第三行的3、1，一共是7。</p>\n<p>看完了题目，我们该如何编写代码呢？首先，按照动态规划，我们需要找到<strong>子问题</strong>！在第一版的打家劫舍问题中，子问题是“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”的较大者。那么这道题的子问题是什么呢？这道题的子问题是“打劫当前节点”和“不打劫当前节点”哪个更划算？那么如何比较哪个更划算呢？这得看“打劫子节点”和“不打劫子节点”的值各是多少。如果“打劫当前节点”，那么就不能打劫子节点，那么这时值就是“不打劫子节点”的值加上自己值。如果“不打劫当前节点”，那么就可以打劫子节点，也可以不打劫子节点，那么这时值就是“打劫子节点”和“不打劫子节点”的值的较大者。用代码表示就是：</p>\n<p>LeetCode/337-rob3.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(key) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = key;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = this.right = null;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;TreeNode&#125; root</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rob = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dfs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [<span class=\"literal\">null</span>, <span class=\"literal\">null</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = dfs(node.left);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> right = dfs(node.right);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\">    res[<span class=\"number\">0</span>] = left[<span class=\"number\">1</span>] + right[<span class=\"number\">1</span>] + node.key;</span><br><span class=\"line\">    res[<span class=\"number\">1</span>] = <span class=\"built_in\">Math</span>.max(left[<span class=\"number\">0</span>], left[<span class=\"number\">1</span>]) + <span class=\"built_in\">Math</span>.max(right[<span class=\"number\">0</span>], right[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> num = dfs(root);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.max(num[<span class=\"number\">0</span>], num[<span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们首先写一个 <code>dfs</code>来深度优先遍历节点，其实就是先序遍历。这个 <code>dfs</code> 方法返回了“打劫当前节点”和“不打劫当前节点”的值各是多少，这里用 <code>res</code> 数组来表示。由于深度优先遍历是对左右节点也进行 <code>dfs</code>，所以我们可以通过子节点的返回值（这里用 <code>left</code> 和 <code>right</code>来表示）得到当前节点的返回值，直到节点为空，就把递归终结掉！编写完了 <code>dfs</code>，我们对 <code>root</code> 入口进行 <code>dfs</code>，得到的数组就是“打劫根节点”和“不打劫根节点”的数值。最后，返回较大者即可得到答案。</p>\n<p>测试代码如下：</p>\n<p>LeetCode/__tests__/337-rob3.test.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> rob = <span class=\"built_in\">require</span>(<span class=\"string\">'../rob3'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> BinarySearchTree = <span class=\"built_in\">require</span>(<span class=\"string\">'../../Tree/BinarySearchTree'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'rob3'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> binarySearchTree = <span class=\"keyword\">new</span> BinarySearchTree();</span><br><span class=\"line\"></span><br><span class=\"line\">  binarySearchTree.insert(<span class=\"number\">11</span>);</span><br><span class=\"line\">  binarySearchTree.insert(<span class=\"number\">7</span>);</span><br><span class=\"line\">  binarySearchTree.insert(<span class=\"number\">13</span>);</span><br><span class=\"line\">  binarySearchTree.insert(<span class=\"number\">5</span>);</span><br><span class=\"line\">  binarySearchTree.insert(<span class=\"number\">3</span>);</span><br><span class=\"line\">  binarySearchTree.insert(<span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  expect(rob(binarySearchTree.getRoot())).toBe(<span class=\"number\">27</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里使用了前面编写的数据结构 <code>BinarySearchTree</code>，它的实现代码和具体讲解可以参考前面的博文<a href=\"https://lewis617.github.io/2017/02/18/tree/\" target=\"_blank\" rel=\"noopener\">《JavaScript 版数据结构与算法（七）树》</a>。</p>\n<p>至此，“打家劫舍问题”就讲完了！其实，“打家劫舍问题”的本质在于使用“动态规划”，而“动态规划”的本质在于将大问题分解为相互依赖的子问题。看清问题本质，才能练好算法！加油吧！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是一道动态规划算法题：打家劫舍。这道题有三个版本，它们都来自 LeetCode：</p>\n<p><a href=\"https://leetcode.com/problems/house-robber\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/house-robber</a></p>\n<p><a href=\"https://leetcode.com/problems/house-robber-ii\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/house-robber-ii</a></p>\n<p><a href=\"https://leetcode.com/problems/house-robber-iii\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/house-robber-iii</a></p>\n<p>本文将先介绍动态规划的基础知识，然后使用动态规划思想解决这个问题，所用的语言仍然是 JavaScript。</p>","more":"<h2 id=\"动态规划简介\"><a href=\"#动态规划简介\" class=\"headerlink\" title=\"动态规划简介\"></a>动态规划简介</h2><p>动态规划是(Dynamic Programming，DP)是一种将复杂问题分解成更小的子问题来解决的优化技术。那么具体哪些算法用到了动态规划呢？使用动态规划的算法很多，先列举一些简单的吧！比如：</p>\n<p>1，求斐波那契数列：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fibonacci</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num === <span class=\"number\">1</span> || num === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fibonacci(num - <span class=\"number\">1</span>) + fibonacci(num - <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述函数将 <code>fibonacci(num)</code> 分解成 <code>fibonacci(num - 1)</code> 和 <code>fibonacci(num - 2)</code>，然后继续分解直到 <code>num</code> 为1或2时终止。</p>\n<p>2，深度优先遍历（DFS）：</p>\n<ul>\n<li>先访问一个顶点，然后对相邻顶点挨个进行深度优先遍历。</li>\n</ul>\n<p>上述做法将复杂的图遍历分解为“每个顶点的<strong>访问</strong>与<strong>相邻顶点的深度优先遍历</strong>”。有点类似于二叉树先序遍历。具体代码请参考前面的博文<a href=\"https://lewis617.github.io/2017/02/19/graph/\" target=\"_blank\" rel=\"noopener\">《 JavaScript 版数据结构与算法（八）图 》</a>。</p>\n<h2 id=\"动态规划和分而治之的区别\"><a href=\"#动态规划和分而治之的区别\" class=\"headerlink\" title=\"动态规划和分而治之的区别\"></a>动态规划和分而治之的区别</h2><p>了解了动态规划，我们来看另一种思想——分而治之。分而治之方法与软件设计的模块化方法非常相似。为了解决一个大的问题，可以： </p>\n<ol>\n<li>把它分成两个或多个更小的问题； </li>\n<li>分别解决每个小问题； </li>\n<li>把各小问题的解答组合起来，即可得到原问题的解答。</li>\n</ol>\n<p>小问题通常与原问题相似，可以递归地使用分而治之策略来解决。</p>\n<p>动态规划和分而治之都是<strong>大问题分解成多个子问题</strong>，那么这两者有什么区别呢？动态规划和分而治之的区别在于<strong>子问题之间是否独立</strong>。分而治之是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则把问题分解成相互依赖的子问题。</p>\n<p>常见的使用分而治之的算法有<strong>归并排序</strong>和<strong>快速排序</strong>。具体实现代码可以参考前面的博文<a href=\"https://lewis617.github.io/2017/02/20/sort-and-search/\" target=\"_blank\" rel=\"noopener\">《JavaScript 版数据结构与算法（九）排序和搜索》</a>。</p>\n<h2 id=\"用动态规划解决“打家劫舍问题”\"><a href=\"#用动态规划解决“打家劫舍问题”\" class=\"headerlink\" title=\"用动态规划解决“打家劫舍问题”\"></a>用动态规划解决“打家劫舍问题”</h2><p>通过前面的介绍，大家应该对动态规划有个大致的了解了，下面让我们用动态规划来解决“打家劫舍问题”。“打家劫舍问题”的题目是：</p>\n<blockquote>\n<p>假设你是一个专业的劫匪，你计划去打劫一条街上的家舍。每家有一定数量的钱财，但相邻两家有一个彼此连接的安全系统。一旦相邻两家在同一晚被打劫，那么这个安全系统就会自动报警。</p>\n</blockquote>\n<blockquote>\n<p>给你一个由非负整数组成的数组，用来代表每家的钱财，在不让安全系统自动报警的前提下，求你能打劫到的钱财的最大数量。</p>\n</blockquote>\n<p>我们还是用单元测试来表达一下需求吧！毕竟好多程序员看机器语言要比自然语言还舒服：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对于 [2, 0, 0, 4, 5]，能打劫到的最大钱财是7</span></span><br><span class=\"line\">expect(rob([<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])).toBe(<span class=\"number\">7</span>);</span><br></pre></td></tr></table></figure>\n<p>我们要编写一个 <code>rob</code> 方法，可以返回内部数组的最大的不相邻数字之和。</p>\n<p>那么如何实现这个算法呢？我们需要借助动态规划思想：</p>\n<ul>\n<li>如果数组长度为1，那么直接返回数组唯一项。</li>\n<li>如果数组长度为2，那么返回“第1项”和“第2项”的较大者。</li>\n<li>如果数组长度为3，那么返回“数组长度为1的结果+第3项”与“数组长度为2的结果”的较大者。</li>\n<li>如果数组长度为4，那么返回“数组长度为2的结果+第4项”与“数组长度为3的结果”的较大者。</li>\n<li>……</li>\n<li>如果数组长度为n，那么返回“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”的较大者。</li>\n</ul>\n<p>为何会如此呢？因为题目要求不能打劫相邻两家，所以数组的当前项只能和上上次的结果相加。那么子问题就是“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”。用方程来表示就是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(0) = array[0]</span><br><span class=\"line\">f(1) = max(array[0], array[1])</span><br><span class=\"line\">f(n) = max( f(n-2) + array[n], f(n-1) )</span><br></pre></td></tr></table></figure>\n<p>所以实现代码就是：</p>\n<p>LeetCode/198-rob1.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; nums</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rob = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> last = <span class=\"number\">0</span>,</span><br><span class=\"line\">    now = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = last;</span><br><span class=\"line\">    last = now;</span><br><span class=\"line\">    now = <span class=\"built_in\">Math</span>.max(temp + nums[i], now);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> now;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"圆圈版打家劫舍\"><a href=\"#圆圈版打家劫舍\" class=\"headerlink\" title=\"圆圈版打家劫舍\"></a>圆圈版打家劫舍</h2><p>“打家劫舍”问题还有另一个版本，它的题目是：</p>\n<blockquote>\n<p>在上次打劫后，作为专业劫匪的你意识到自己需要去一个新的地方打劫，这样才不会引起太多注意。这次，你去的地方的家舍是按圆圈形状来排列的。这意味着第一家和最后一家是挨着的，同时，安全系统和上个地方的一样。</p>\n</blockquote>\n<blockquote>\n<p>给你一个由非负整数组成的数组，用来代表每家的钱财，在不让安全系统自动报警的前提下，求你能打劫到的钱财的最大数量。</p>\n</blockquote>\n<p>那么这道题该如何解答呢？因为家舍首尾相连，所以你不能在同一晚打劫第一家和最后一家，既然不能打劫，机智的你索性将计就计，先排除最后一家不管，或者先排除第一家不管，打劫剩余的家舍，然后比较那个更划算。所以这道题可以这么来解答：</p>\n<ul>\n<li>先求出第一家到倒数第二家的最大钱财数量</li>\n<li>然后求出第二家到最后一家的最大钱财数量</li>\n<li>最后求两者的较大值</li>\n</ul>\n<p>所以实现代码就是：</p>\n<p>LeetCode/213-rob2.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; nums</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rob = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> rob1 = <span class=\"built_in\">require</span>(<span class=\"string\">'./rob1'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.max(rob1(nums.slice(<span class=\"number\">1</span>)), rob1(nums.slice(<span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>)));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，<code>nums.slice(1)</code>代表排除了第一家，<code>nums.slice(0, array.length - 1)</code>代表排除了最后一家。然后运行测试，发现确实没有上次打劫的多：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(rob([<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])).toBe(<span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树版打家劫舍\"><a href=\"#二叉树版打家劫舍\" class=\"headerlink\" title=\"二叉树版打家劫舍\"></a>二叉树版打家劫舍</h2><p>我们再看一道二叉树版打家劫舍吧！题目如下：</p>\n<blockquote>\n<p>作为专业劫匪的你又找到了一个新地方可以下手，这个地方的家舍是按二叉树形状排列的，安全系统和之前一样。在不让安全系统自动报警的前提下，求你能打劫到的钱财的最大数量。</p>\n</blockquote>\n<p>为了表述题意，我们来看个例子吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  3</span><br><span class=\"line\"> / \\</span><br><span class=\"line\">2   3</span><br><span class=\"line\"> \\   \\ </span><br><span class=\"line\">  3   1</span><br></pre></td></tr></table></figure>\n<p>那么最大钱财就是第一行的3和第三行的3、1，一共是7。</p>\n<p>看完了题目，我们该如何编写代码呢？首先，按照动态规划，我们需要找到<strong>子问题</strong>！在第一版的打家劫舍问题中，子问题是“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”的较大者。那么这道题的子问题是什么呢？这道题的子问题是“打劫当前节点”和“不打劫当前节点”哪个更划算？那么如何比较哪个更划算呢？这得看“打劫子节点”和“不打劫子节点”的值各是多少。如果“打劫当前节点”，那么就不能打劫子节点，那么这时值就是“不打劫子节点”的值加上自己值。如果“不打劫当前节点”，那么就可以打劫子节点，也可以不打劫子节点，那么这时值就是“打劫子节点”和“不打劫子节点”的值的较大者。用代码表示就是：</p>\n<p>LeetCode/337-rob3.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * function TreeNode(key) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = key;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.left = this.right = null;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;TreeNode&#125; root</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rob = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dfs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [<span class=\"literal\">null</span>, <span class=\"literal\">null</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = dfs(node.left);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> right = dfs(node.right);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\">    res[<span class=\"number\">0</span>] = left[<span class=\"number\">1</span>] + right[<span class=\"number\">1</span>] + node.key;</span><br><span class=\"line\">    res[<span class=\"number\">1</span>] = <span class=\"built_in\">Math</span>.max(left[<span class=\"number\">0</span>], left[<span class=\"number\">1</span>]) + <span class=\"built_in\">Math</span>.max(right[<span class=\"number\">0</span>], right[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> num = dfs(root);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.max(num[<span class=\"number\">0</span>], num[<span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们首先写一个 <code>dfs</code>来深度优先遍历节点，其实就是先序遍历。这个 <code>dfs</code> 方法返回了“打劫当前节点”和“不打劫当前节点”的值各是多少，这里用 <code>res</code> 数组来表示。由于深度优先遍历是对左右节点也进行 <code>dfs</code>，所以我们可以通过子节点的返回值（这里用 <code>left</code> 和 <code>right</code>来表示）得到当前节点的返回值，直到节点为空，就把递归终结掉！编写完了 <code>dfs</code>，我们对 <code>root</code> 入口进行 <code>dfs</code>，得到的数组就是“打劫根节点”和“不打劫根节点”的数值。最后，返回较大者即可得到答案。</p>\n<p>测试代码如下：</p>\n<p>LeetCode/__tests__/337-rob3.test.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> rob = <span class=\"built_in\">require</span>(<span class=\"string\">'../rob3'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> BinarySearchTree = <span class=\"built_in\">require</span>(<span class=\"string\">'../../Tree/BinarySearchTree'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'rob3'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> binarySearchTree = <span class=\"keyword\">new</span> BinarySearchTree();</span><br><span class=\"line\"></span><br><span class=\"line\">  binarySearchTree.insert(<span class=\"number\">11</span>);</span><br><span class=\"line\">  binarySearchTree.insert(<span class=\"number\">7</span>);</span><br><span class=\"line\">  binarySearchTree.insert(<span class=\"number\">13</span>);</span><br><span class=\"line\">  binarySearchTree.insert(<span class=\"number\">5</span>);</span><br><span class=\"line\">  binarySearchTree.insert(<span class=\"number\">3</span>);</span><br><span class=\"line\">  binarySearchTree.insert(<span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  expect(rob(binarySearchTree.getRoot())).toBe(<span class=\"number\">27</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里使用了前面编写的数据结构 <code>BinarySearchTree</code>，它的实现代码和具体讲解可以参考前面的博文<a href=\"https://lewis617.github.io/2017/02/18/tree/\" target=\"_blank\" rel=\"noopener\">《JavaScript 版数据结构与算法（七）树》</a>。</p>\n<p>至此，“打家劫舍问题”就讲完了！其实，“打家劫舍问题”的本质在于使用“动态规划”，而“动态规划”的本质在于将大问题分解为相互依赖的子问题。看清问题本质，才能练好算法！加油吧！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>"},{"title":"如何在端对端测试中模拟 HTTP 请求","date":"2017-12-18T11:15:00.000Z","_content":"\n今天，我们要讲的是如何在端对端测试中模拟 HTTP 请求。这个技术在复杂系统中非常实用，让我们一睹为快。\n\n> 注意，本文是给有一定端对端测试经验的测试工程师或前端工程师看的，如果你对端对端测试一无所知，请先阅读我之前写的[关于端对端测试的文章](http://www.liuyiqi.cn/tags/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95/)。\n\n<!--more-->\n\n## 复杂系统中的端对端测试的问题\n\n最近想在公司内部一个非常复杂的后台系统中添加端对端测试。这个系统拥有很多页面，每个页面都有很多功能，在这些功能中，不仅涉及许多数据库操作，还包含一些对用户来说不可控的外部数据来源。给这样的系统添加端对端测试，我的内心是崩溃的，因为如果完全模拟用户操作，我会面临很多问题：\n\n- 把数据库搞得一团糟：添加很多乱数据，不小心删除一些关键数据（试想这些数据万一是巨额钱款呢？！）\n- 因为一些不可控的外部数据，我的测试脚本面对的场景可能每次都不一样，可我的脚本却只有一份，也许今天脚本能跑，明天脚本就出错了。\n- 在真实场景下，一些边界情况的逻辑往往测试不到，比如空数据，错误数据的处理等。\n\n## 是否应该简化或放弃端对端测试？\n\n面对这些问题，我当时冒出了放弃的想法，我咨询了一些同事，他们有的人让我评估可行性、必要性，有的人说让端对端测试测一些简单的跨页功能即可，把复杂逻辑留给人工或单元测试。他们说的都很 reasonable。但我认为端对端测试还是有必要的，一些国外的大公司的端对端测试真的是测试了软件中用户所可能用到的每个功能。这确实是可行，而且有意义的，我们不应该偷懒或者放弃。\n\n## 面向前端集成的端对端测试\n\n我第一次接触端对端测试是在 Angular 中，于是我看了很多 Angular 中端对端测试的例子，发现很多人面对和我一样问题时，所采取的办法是模拟 HTTP 请求。有人会说，这还算端对端测试吗？这已经不是在完全模拟真实的用户场景了！这种做法只有在后端没有任何 bug 的前提下才是有效的……这些说法都是对的，模拟 HTTP 请求确实是一种 trade off。但作为前端工程师，这样的做法至少能保证我负责的前端系统被测试到了，而且是集成测试，这就够了！后端完全可以另写针对后端的集成测试。当然，模拟 HTTP 请求是在那种迫不得已的情况下才做的，如果你的系统比较简单，比如这些类型：\n\n- 纯展示型的页面，只是“查找”数据，比较安全。\n- 通过用户操作或在你控制范围内的操作下，可以让数据形成闭环，比如你操作完后，所有的数据恢复如初，就像在沙盒里跑一样\n\n那么就无需模拟 HTTP 了，毕竟我们还是希望能尽量还原真实场景。\n\n## 端对端测试中模拟 HTTP 请求的几种方法\n\n好了，回归正题。那么如何在端对端测试中模拟 HTTP 请求？有几种方法：\n\n- 使用代理工具，比如 Charles 代理一些请求，进行模拟。这种方法太麻烦了，不仅要在浏览器上设置代理，还要在 Charles 中配置一堆东西。不推荐！\n- 如果使用 Puppeteer 的话，使用 `request.continue` 重写一些请求的 url，指向别的链接。你可以自己搭建一个测试服务器进行重写。简单好用，推荐！\n- 如果使用 Puppeteer 的话，使用 `request.respond` 拦截请求，并直接返回响应结果。简单好用，推荐！\n\n以上三种方法都是可行的，但是后两种更简单。其中，第二种适合那种拥有测试服务器的场景，你只需要对请求链接进行重定向即可。比如原来是 `a.com`，你将其改为 `b.com`。但这种方法还是不能非常灵活的模拟每个 case，这时候，第三种方法就更加推荐，你想返回什么都可以直接在函数中写出来。让我们快看看代码实现吧！\n\n## 真实例子\n\n介绍了背景和方法，我们来看下真实的例子！例子代码在这里：\n\n<https://github.com/lewis617/fe-test/tree/master/puppeteer-demo/mock-demo>\n\n先说下运行方法：将整个项目 clone 下来后在根目录（不是 mock-demo 这个目录哦）执行以下命令开启服务。\n\n```\nhttp-server -p 8081\n```\n\n然后就可以在 `http://localhost:8081/puppeteer-demo/mock-demo`，看到程序了。\n\n![](/css/images/5.jpg)\n\n这个程序的功能是这样的：\n\n1，在一个简单的 HTML 页面中进行 `data1.json` 这个文件的请求，并将 JSON 文件中的 `name` 字段的值显示在 `h1` 标签中。代码如下：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n\n<body>\n\n</body>\n<script>\n  fetch('http://localhost:8081/puppeteer-demo/mock-demo/data1.json')\n    .then(res => res.json())\n    .then(json => document.body.innerHTML = `<h1>${json.name}</h1>`)\n</script>\n\n</html>\n```\n\n2，我们要做的是，运行 puppeteer，打开页面，并进行请求劫持，将 data1.json 的数据换成 data2.json 的数据。\n\n另开一个终端，执行这些命令：\n\n```sh\nyarn\n\nnpm test -- mock-demo\n```\n然后就会发现 Puppeteer 中显示的数据是 `data2`。\n\n![](/css/images/6.jpg)\n\n我们看下测试脚本是如何进行拦截重写的：\n\n```js\nawait page.setRequestInterception(true);\npage.on('request', request => {\n  if (request.url.endsWith('data1.json')) {\n    request.continue({\n      url: 'http://localhost:8081/puppeteer-demo/mock-demo/data2.json'\n    });\n  }\n  else {\n    request.continue();\n  }\n});\n```\n\n上述代码，先设置可以进行请求拦截：`await page.setRequestInterception(true);`。然后在 `request` 事件中进行 url 改写。另外，还可以换成 `request.respond` 方法：\n\n```js\nawait page.setRequestInterception(true);\npage.on('request', request => {\n  if (request.url.endsWith('data1.json')) {\n    request.respond({\n      body: JSON.stringify({ name: 'data2' })\n    })\n  }\n  else {\n    request.continue();\n  }\n});\n```\n\n就是这么简单。这太好用了！我们甚至可以在日常开发中也使用 Puppeteer 来模拟请求，不需要等待后端的工作。\n\n\n## 测试金字塔\n\n最后再聊一下端对端测试和单元测试的比例问题。谷歌的测试团队曾经提出过一个[测试金字塔的概念](https://docs.google.com/presentation/d/15gNk21rjer3xo-b1ZqyQVGebOp_aPvHU3YH7YnOMxtE/edit#slide=id.g437663ce1_53_98)。大概就是单元测试应该最多，然后是集成测试（部分单元之间的集成，不像端对端那样完全黑盒），最少的应该是端对端测试：\n\n![](/css/images/7.jpg)\n\n为何会这样呢？因为他们认为端对端测试不能像单元测试那样快速的定位问题所在，端对端测试所发现的问题，可能存在系统中的任何位置，但单元测试的反馈定位就更加直接准确。另外，单元测试写起来更加简单快速，而端对端测试则需要整个系统部署好之后才能测试，这样比较慢，毕竟有时候开发周期还是很长的，人家开发一周前写完的代码，你现在才开始测试，有点拖后腿。以上说法非常有道理，我也认为单元测试非常好，但是端对端测试也是有意义的，它可以检测出所有单元连接后的问题，这些问题只能通过端对端测试才能测出来。所以，两者都要写，不要怕麻烦，后期的收益是很大的！\n\n## 更多测试文章：\n\n<http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/>","source":"_posts/how-to-mock-http-in-e2e-testing.md","raw":"---\ntitle: 如何在端对端测试中模拟 HTTP 请求\ndate: 2017-12-18 19:15:00\ntags: [测试, 端对端测试, e2e, Puppeteer]\n---\n\n今天，我们要讲的是如何在端对端测试中模拟 HTTP 请求。这个技术在复杂系统中非常实用，让我们一睹为快。\n\n> 注意，本文是给有一定端对端测试经验的测试工程师或前端工程师看的，如果你对端对端测试一无所知，请先阅读我之前写的[关于端对端测试的文章](http://www.liuyiqi.cn/tags/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95/)。\n\n<!--more-->\n\n## 复杂系统中的端对端测试的问题\n\n最近想在公司内部一个非常复杂的后台系统中添加端对端测试。这个系统拥有很多页面，每个页面都有很多功能，在这些功能中，不仅涉及许多数据库操作，还包含一些对用户来说不可控的外部数据来源。给这样的系统添加端对端测试，我的内心是崩溃的，因为如果完全模拟用户操作，我会面临很多问题：\n\n- 把数据库搞得一团糟：添加很多乱数据，不小心删除一些关键数据（试想这些数据万一是巨额钱款呢？！）\n- 因为一些不可控的外部数据，我的测试脚本面对的场景可能每次都不一样，可我的脚本却只有一份，也许今天脚本能跑，明天脚本就出错了。\n- 在真实场景下，一些边界情况的逻辑往往测试不到，比如空数据，错误数据的处理等。\n\n## 是否应该简化或放弃端对端测试？\n\n面对这些问题，我当时冒出了放弃的想法，我咨询了一些同事，他们有的人让我评估可行性、必要性，有的人说让端对端测试测一些简单的跨页功能即可，把复杂逻辑留给人工或单元测试。他们说的都很 reasonable。但我认为端对端测试还是有必要的，一些国外的大公司的端对端测试真的是测试了软件中用户所可能用到的每个功能。这确实是可行，而且有意义的，我们不应该偷懒或者放弃。\n\n## 面向前端集成的端对端测试\n\n我第一次接触端对端测试是在 Angular 中，于是我看了很多 Angular 中端对端测试的例子，发现很多人面对和我一样问题时，所采取的办法是模拟 HTTP 请求。有人会说，这还算端对端测试吗？这已经不是在完全模拟真实的用户场景了！这种做法只有在后端没有任何 bug 的前提下才是有效的……这些说法都是对的，模拟 HTTP 请求确实是一种 trade off。但作为前端工程师，这样的做法至少能保证我负责的前端系统被测试到了，而且是集成测试，这就够了！后端完全可以另写针对后端的集成测试。当然，模拟 HTTP 请求是在那种迫不得已的情况下才做的，如果你的系统比较简单，比如这些类型：\n\n- 纯展示型的页面，只是“查找”数据，比较安全。\n- 通过用户操作或在你控制范围内的操作下，可以让数据形成闭环，比如你操作完后，所有的数据恢复如初，就像在沙盒里跑一样\n\n那么就无需模拟 HTTP 了，毕竟我们还是希望能尽量还原真实场景。\n\n## 端对端测试中模拟 HTTP 请求的几种方法\n\n好了，回归正题。那么如何在端对端测试中模拟 HTTP 请求？有几种方法：\n\n- 使用代理工具，比如 Charles 代理一些请求，进行模拟。这种方法太麻烦了，不仅要在浏览器上设置代理，还要在 Charles 中配置一堆东西。不推荐！\n- 如果使用 Puppeteer 的话，使用 `request.continue` 重写一些请求的 url，指向别的链接。你可以自己搭建一个测试服务器进行重写。简单好用，推荐！\n- 如果使用 Puppeteer 的话，使用 `request.respond` 拦截请求，并直接返回响应结果。简单好用，推荐！\n\n以上三种方法都是可行的，但是后两种更简单。其中，第二种适合那种拥有测试服务器的场景，你只需要对请求链接进行重定向即可。比如原来是 `a.com`，你将其改为 `b.com`。但这种方法还是不能非常灵活的模拟每个 case，这时候，第三种方法就更加推荐，你想返回什么都可以直接在函数中写出来。让我们快看看代码实现吧！\n\n## 真实例子\n\n介绍了背景和方法，我们来看下真实的例子！例子代码在这里：\n\n<https://github.com/lewis617/fe-test/tree/master/puppeteer-demo/mock-demo>\n\n先说下运行方法：将整个项目 clone 下来后在根目录（不是 mock-demo 这个目录哦）执行以下命令开启服务。\n\n```\nhttp-server -p 8081\n```\n\n然后就可以在 `http://localhost:8081/puppeteer-demo/mock-demo`，看到程序了。\n\n![](/css/images/5.jpg)\n\n这个程序的功能是这样的：\n\n1，在一个简单的 HTML 页面中进行 `data1.json` 这个文件的请求，并将 JSON 文件中的 `name` 字段的值显示在 `h1` 标签中。代码如下：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n\n<body>\n\n</body>\n<script>\n  fetch('http://localhost:8081/puppeteer-demo/mock-demo/data1.json')\n    .then(res => res.json())\n    .then(json => document.body.innerHTML = `<h1>${json.name}</h1>`)\n</script>\n\n</html>\n```\n\n2，我们要做的是，运行 puppeteer，打开页面，并进行请求劫持，将 data1.json 的数据换成 data2.json 的数据。\n\n另开一个终端，执行这些命令：\n\n```sh\nyarn\n\nnpm test -- mock-demo\n```\n然后就会发现 Puppeteer 中显示的数据是 `data2`。\n\n![](/css/images/6.jpg)\n\n我们看下测试脚本是如何进行拦截重写的：\n\n```js\nawait page.setRequestInterception(true);\npage.on('request', request => {\n  if (request.url.endsWith('data1.json')) {\n    request.continue({\n      url: 'http://localhost:8081/puppeteer-demo/mock-demo/data2.json'\n    });\n  }\n  else {\n    request.continue();\n  }\n});\n```\n\n上述代码，先设置可以进行请求拦截：`await page.setRequestInterception(true);`。然后在 `request` 事件中进行 url 改写。另外，还可以换成 `request.respond` 方法：\n\n```js\nawait page.setRequestInterception(true);\npage.on('request', request => {\n  if (request.url.endsWith('data1.json')) {\n    request.respond({\n      body: JSON.stringify({ name: 'data2' })\n    })\n  }\n  else {\n    request.continue();\n  }\n});\n```\n\n就是这么简单。这太好用了！我们甚至可以在日常开发中也使用 Puppeteer 来模拟请求，不需要等待后端的工作。\n\n\n## 测试金字塔\n\n最后再聊一下端对端测试和单元测试的比例问题。谷歌的测试团队曾经提出过一个[测试金字塔的概念](https://docs.google.com/presentation/d/15gNk21rjer3xo-b1ZqyQVGebOp_aPvHU3YH7YnOMxtE/edit#slide=id.g437663ce1_53_98)。大概就是单元测试应该最多，然后是集成测试（部分单元之间的集成，不像端对端那样完全黑盒），最少的应该是端对端测试：\n\n![](/css/images/7.jpg)\n\n为何会这样呢？因为他们认为端对端测试不能像单元测试那样快速的定位问题所在，端对端测试所发现的问题，可能存在系统中的任何位置，但单元测试的反馈定位就更加直接准确。另外，单元测试写起来更加简单快速，而端对端测试则需要整个系统部署好之后才能测试，这样比较慢，毕竟有时候开发周期还是很长的，人家开发一周前写完的代码，你现在才开始测试，有点拖后腿。以上说法非常有道理，我也认为单元测试非常好，但是端对端测试也是有意义的，它可以检测出所有单元连接后的问题，这些问题只能通过端对端测试才能测出来。所以，两者都要写，不要怕麻烦，后期的收益是很大的！\n\n## 更多测试文章：\n\n<http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/>","slug":"how-to-mock-http-in-e2e-testing","published":1,"updated":"2019-05-01T08:10:29.519Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvlc000ptgytt770quys","content":"<p>今天，我们要讲的是如何在端对端测试中模拟 HTTP 请求。这个技术在复杂系统中非常实用，让我们一睹为快。</p>\n<blockquote>\n<p>注意，本文是给有一定端对端测试经验的测试工程师或前端工程师看的，如果你对端对端测试一无所知，请先阅读我之前写的<a href=\"http://www.liuyiqi.cn/tags/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95/\">关于端对端测试的文章</a>。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"复杂系统中的端对端测试的问题\"><a href=\"#复杂系统中的端对端测试的问题\" class=\"headerlink\" title=\"复杂系统中的端对端测试的问题\"></a>复杂系统中的端对端测试的问题</h2><p>最近想在公司内部一个非常复杂的后台系统中添加端对端测试。这个系统拥有很多页面，每个页面都有很多功能，在这些功能中，不仅涉及许多数据库操作，还包含一些对用户来说不可控的外部数据来源。给这样的系统添加端对端测试，我的内心是崩溃的，因为如果完全模拟用户操作，我会面临很多问题：</p>\n<ul>\n<li>把数据库搞得一团糟：添加很多乱数据，不小心删除一些关键数据（试想这些数据万一是巨额钱款呢？！）</li>\n<li>因为一些不可控的外部数据，我的测试脚本面对的场景可能每次都不一样，可我的脚本却只有一份，也许今天脚本能跑，明天脚本就出错了。</li>\n<li>在真实场景下，一些边界情况的逻辑往往测试不到，比如空数据，错误数据的处理等。</li>\n</ul>\n<h2 id=\"是否应该简化或放弃端对端测试？\"><a href=\"#是否应该简化或放弃端对端测试？\" class=\"headerlink\" title=\"是否应该简化或放弃端对端测试？\"></a>是否应该简化或放弃端对端测试？</h2><p>面对这些问题，我当时冒出了放弃的想法，我咨询了一些同事，他们有的人让我评估可行性、必要性，有的人说让端对端测试测一些简单的跨页功能即可，把复杂逻辑留给人工或单元测试。他们说的都很 reasonable。但我认为端对端测试还是有必要的，一些国外的大公司的端对端测试真的是测试了软件中用户所可能用到的每个功能。这确实是可行，而且有意义的，我们不应该偷懒或者放弃。</p>\n<h2 id=\"面向前端集成的端对端测试\"><a href=\"#面向前端集成的端对端测试\" class=\"headerlink\" title=\"面向前端集成的端对端测试\"></a>面向前端集成的端对端测试</h2><p>我第一次接触端对端测试是在 Angular 中，于是我看了很多 Angular 中端对端测试的例子，发现很多人面对和我一样问题时，所采取的办法是模拟 HTTP 请求。有人会说，这还算端对端测试吗？这已经不是在完全模拟真实的用户场景了！这种做法只有在后端没有任何 bug 的前提下才是有效的……这些说法都是对的，模拟 HTTP 请求确实是一种 trade off。但作为前端工程师，这样的做法至少能保证我负责的前端系统被测试到了，而且是集成测试，这就够了！后端完全可以另写针对后端的集成测试。当然，模拟 HTTP 请求是在那种迫不得已的情况下才做的，如果你的系统比较简单，比如这些类型：</p>\n<ul>\n<li>纯展示型的页面，只是“查找”数据，比较安全。</li>\n<li>通过用户操作或在你控制范围内的操作下，可以让数据形成闭环，比如你操作完后，所有的数据恢复如初，就像在沙盒里跑一样</li>\n</ul>\n<p>那么就无需模拟 HTTP 了，毕竟我们还是希望能尽量还原真实场景。</p>\n<h2 id=\"端对端测试中模拟-HTTP-请求的几种方法\"><a href=\"#端对端测试中模拟-HTTP-请求的几种方法\" class=\"headerlink\" title=\"端对端测试中模拟 HTTP 请求的几种方法\"></a>端对端测试中模拟 HTTP 请求的几种方法</h2><p>好了，回归正题。那么如何在端对端测试中模拟 HTTP 请求？有几种方法：</p>\n<ul>\n<li>使用代理工具，比如 Charles 代理一些请求，进行模拟。这种方法太麻烦了，不仅要在浏览器上设置代理，还要在 Charles 中配置一堆东西。不推荐！</li>\n<li>如果使用 Puppeteer 的话，使用 <code>request.continue</code> 重写一些请求的 url，指向别的链接。你可以自己搭建一个测试服务器进行重写。简单好用，推荐！</li>\n<li>如果使用 Puppeteer 的话，使用 <code>request.respond</code> 拦截请求，并直接返回响应结果。简单好用，推荐！</li>\n</ul>\n<p>以上三种方法都是可行的，但是后两种更简单。其中，第二种适合那种拥有测试服务器的场景，你只需要对请求链接进行重定向即可。比如原来是 <code>a.com</code>，你将其改为 <code>b.com</code>。但这种方法还是不能非常灵活的模拟每个 case，这时候，第三种方法就更加推荐，你想返回什么都可以直接在函数中写出来。让我们快看看代码实现吧！</p>\n<h2 id=\"真实例子\"><a href=\"#真实例子\" class=\"headerlink\" title=\"真实例子\"></a>真实例子</h2><p>介绍了背景和方法，我们来看下真实的例子！例子代码在这里：</p>\n<p><a href=\"https://github.com/lewis617/fe-test/tree/master/puppeteer-demo/mock-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/fe-test/tree/master/puppeteer-demo/mock-demo</a></p>\n<p>先说下运行方法：将整个项目 clone 下来后在根目录（不是 mock-demo 这个目录哦）执行以下命令开启服务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server -p 8081</span><br></pre></td></tr></table></figure>\n<p>然后就可以在 <code>http://localhost:8081/puppeteer-demo/mock-demo</code>，看到程序了。</p>\n<p><img src=\"/css/images/5.jpg\" alt=\"\"></p>\n<p>这个程序的功能是这样的：</p>\n<p>1，在一个简单的 HTML 页面中进行 <code>data1.json</code> 这个文件的请求，并将 JSON 文件中的 <code>name</code> 字段的值显示在 <code>h1</code> 标签中。代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  fetch(<span class=\"string\">'http://localhost:8081/puppeteer-demo/mock-demo/data1.json'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">    .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.json())</span></span><br><span class=\"line\"><span class=\"javascript\">    .then(<span class=\"function\"><span class=\"params\">json</span> =&gt;</span> <span class=\"built_in\">document</span>.body.innerHTML = <span class=\"string\">`&lt;h1&gt;<span class=\"subst\">$&#123;json.name&#125;</span>&lt;/h1&gt;`</span>)</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>2，我们要做的是，运行 puppeteer，打开页面，并进行请求劫持，将 data1.json 的数据换成 data2.json 的数据。</p>\n<p>另开一个终端，执行这些命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"built_in\">test</span> -- mock-demo</span><br></pre></td></tr></table></figure>\n<p>然后就会发现 Puppeteer 中显示的数据是 <code>data2</code>。</p>\n<p><img src=\"/css/images/6.jpg\" alt=\"\"></p>\n<p>我们看下测试脚本是如何进行拦截重写的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> page.setRequestInterception(<span class=\"literal\">true</span>);</span><br><span class=\"line\">page.on(<span class=\"string\">'request'</span>, request =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (request.url.endsWith(<span class=\"string\">'data1.json'</span>)) &#123;</span><br><span class=\"line\">    request.continue(&#123;</span><br><span class=\"line\">      url: <span class=\"string\">'http://localhost:8081/puppeteer-demo/mock-demo/data2.json'</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    request.continue();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码，先设置可以进行请求拦截：<code>await page.setRequestInterception(true);</code>。然后在 <code>request</code> 事件中进行 url 改写。另外，还可以换成 <code>request.respond</code> 方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> page.setRequestInterception(<span class=\"literal\">true</span>);</span><br><span class=\"line\">page.on(<span class=\"string\">'request'</span>, request =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (request.url.endsWith(<span class=\"string\">'data1.json'</span>)) &#123;</span><br><span class=\"line\">    request.respond(&#123;</span><br><span class=\"line\">      body: <span class=\"built_in\">JSON</span>.stringify(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'data2'</span> &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    request.continue();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>就是这么简单。这太好用了！我们甚至可以在日常开发中也使用 Puppeteer 来模拟请求，不需要等待后端的工作。</p>\n<h2 id=\"测试金字塔\"><a href=\"#测试金字塔\" class=\"headerlink\" title=\"测试金字塔\"></a>测试金字塔</h2><p>最后再聊一下端对端测试和单元测试的比例问题。谷歌的测试团队曾经提出过一个<a href=\"https://docs.google.com/presentation/d/15gNk21rjer3xo-b1ZqyQVGebOp_aPvHU3YH7YnOMxtE/edit#slide=id.g437663ce1_53_98\" target=\"_blank\" rel=\"noopener\">测试金字塔的概念</a>。大概就是单元测试应该最多，然后是集成测试（部分单元之间的集成，不像端对端那样完全黑盒），最少的应该是端对端测试：</p>\n<p><img src=\"/css/images/7.jpg\" alt=\"\"></p>\n<p>为何会这样呢？因为他们认为端对端测试不能像单元测试那样快速的定位问题所在，端对端测试所发现的问题，可能存在系统中的任何位置，但单元测试的反馈定位就更加直接准确。另外，单元测试写起来更加简单快速，而端对端测试则需要整个系统部署好之后才能测试，这样比较慢，毕竟有时候开发周期还是很长的，人家开发一周前写完的代码，你现在才开始测试，有点拖后腿。以上说法非常有道理，我也认为单元测试非常好，但是端对端测试也是有意义的，它可以检测出所有单元连接后的问题，这些问题只能通过端对端测试才能测出来。所以，两者都要写，不要怕麻烦，后期的收益是很大的！</p>\n<h2 id=\"更多测试文章：\"><a href=\"#更多测试文章：\" class=\"headerlink\" title=\"更多测试文章：\"></a>更多测试文章：</h2><p><a href=\"http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/\">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是如何在端对端测试中模拟 HTTP 请求。这个技术在复杂系统中非常实用，让我们一睹为快。</p>\n<blockquote>\n<p>注意，本文是给有一定端对端测试经验的测试工程师或前端工程师看的，如果你对端对端测试一无所知，请先阅读我之前写的<a href=\"http://www.liuyiqi.cn/tags/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95/\">关于端对端测试的文章</a>。</p>\n</blockquote>","more":"<h2 id=\"复杂系统中的端对端测试的问题\"><a href=\"#复杂系统中的端对端测试的问题\" class=\"headerlink\" title=\"复杂系统中的端对端测试的问题\"></a>复杂系统中的端对端测试的问题</h2><p>最近想在公司内部一个非常复杂的后台系统中添加端对端测试。这个系统拥有很多页面，每个页面都有很多功能，在这些功能中，不仅涉及许多数据库操作，还包含一些对用户来说不可控的外部数据来源。给这样的系统添加端对端测试，我的内心是崩溃的，因为如果完全模拟用户操作，我会面临很多问题：</p>\n<ul>\n<li>把数据库搞得一团糟：添加很多乱数据，不小心删除一些关键数据（试想这些数据万一是巨额钱款呢？！）</li>\n<li>因为一些不可控的外部数据，我的测试脚本面对的场景可能每次都不一样，可我的脚本却只有一份，也许今天脚本能跑，明天脚本就出错了。</li>\n<li>在真实场景下，一些边界情况的逻辑往往测试不到，比如空数据，错误数据的处理等。</li>\n</ul>\n<h2 id=\"是否应该简化或放弃端对端测试？\"><a href=\"#是否应该简化或放弃端对端测试？\" class=\"headerlink\" title=\"是否应该简化或放弃端对端测试？\"></a>是否应该简化或放弃端对端测试？</h2><p>面对这些问题，我当时冒出了放弃的想法，我咨询了一些同事，他们有的人让我评估可行性、必要性，有的人说让端对端测试测一些简单的跨页功能即可，把复杂逻辑留给人工或单元测试。他们说的都很 reasonable。但我认为端对端测试还是有必要的，一些国外的大公司的端对端测试真的是测试了软件中用户所可能用到的每个功能。这确实是可行，而且有意义的，我们不应该偷懒或者放弃。</p>\n<h2 id=\"面向前端集成的端对端测试\"><a href=\"#面向前端集成的端对端测试\" class=\"headerlink\" title=\"面向前端集成的端对端测试\"></a>面向前端集成的端对端测试</h2><p>我第一次接触端对端测试是在 Angular 中，于是我看了很多 Angular 中端对端测试的例子，发现很多人面对和我一样问题时，所采取的办法是模拟 HTTP 请求。有人会说，这还算端对端测试吗？这已经不是在完全模拟真实的用户场景了！这种做法只有在后端没有任何 bug 的前提下才是有效的……这些说法都是对的，模拟 HTTP 请求确实是一种 trade off。但作为前端工程师，这样的做法至少能保证我负责的前端系统被测试到了，而且是集成测试，这就够了！后端完全可以另写针对后端的集成测试。当然，模拟 HTTP 请求是在那种迫不得已的情况下才做的，如果你的系统比较简单，比如这些类型：</p>\n<ul>\n<li>纯展示型的页面，只是“查找”数据，比较安全。</li>\n<li>通过用户操作或在你控制范围内的操作下，可以让数据形成闭环，比如你操作完后，所有的数据恢复如初，就像在沙盒里跑一样</li>\n</ul>\n<p>那么就无需模拟 HTTP 了，毕竟我们还是希望能尽量还原真实场景。</p>\n<h2 id=\"端对端测试中模拟-HTTP-请求的几种方法\"><a href=\"#端对端测试中模拟-HTTP-请求的几种方法\" class=\"headerlink\" title=\"端对端测试中模拟 HTTP 请求的几种方法\"></a>端对端测试中模拟 HTTP 请求的几种方法</h2><p>好了，回归正题。那么如何在端对端测试中模拟 HTTP 请求？有几种方法：</p>\n<ul>\n<li>使用代理工具，比如 Charles 代理一些请求，进行模拟。这种方法太麻烦了，不仅要在浏览器上设置代理，还要在 Charles 中配置一堆东西。不推荐！</li>\n<li>如果使用 Puppeteer 的话，使用 <code>request.continue</code> 重写一些请求的 url，指向别的链接。你可以自己搭建一个测试服务器进行重写。简单好用，推荐！</li>\n<li>如果使用 Puppeteer 的话，使用 <code>request.respond</code> 拦截请求，并直接返回响应结果。简单好用，推荐！</li>\n</ul>\n<p>以上三种方法都是可行的，但是后两种更简单。其中，第二种适合那种拥有测试服务器的场景，你只需要对请求链接进行重定向即可。比如原来是 <code>a.com</code>，你将其改为 <code>b.com</code>。但这种方法还是不能非常灵活的模拟每个 case，这时候，第三种方法就更加推荐，你想返回什么都可以直接在函数中写出来。让我们快看看代码实现吧！</p>\n<h2 id=\"真实例子\"><a href=\"#真实例子\" class=\"headerlink\" title=\"真实例子\"></a>真实例子</h2><p>介绍了背景和方法，我们来看下真实的例子！例子代码在这里：</p>\n<p><a href=\"https://github.com/lewis617/fe-test/tree/master/puppeteer-demo/mock-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/fe-test/tree/master/puppeteer-demo/mock-demo</a></p>\n<p>先说下运行方法：将整个项目 clone 下来后在根目录（不是 mock-demo 这个目录哦）执行以下命令开启服务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server -p 8081</span><br></pre></td></tr></table></figure>\n<p>然后就可以在 <code>http://localhost:8081/puppeteer-demo/mock-demo</code>，看到程序了。</p>\n<p><img src=\"/css/images/5.jpg\" alt=\"\"></p>\n<p>这个程序的功能是这样的：</p>\n<p>1，在一个简单的 HTML 页面中进行 <code>data1.json</code> 这个文件的请求，并将 JSON 文件中的 <code>name</code> 字段的值显示在 <code>h1</code> 标签中。代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  fetch(<span class=\"string\">'http://localhost:8081/puppeteer-demo/mock-demo/data1.json'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">    .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.json())</span></span><br><span class=\"line\"><span class=\"javascript\">    .then(<span class=\"function\"><span class=\"params\">json</span> =&gt;</span> <span class=\"built_in\">document</span>.body.innerHTML = <span class=\"string\">`&lt;h1&gt;<span class=\"subst\">$&#123;json.name&#125;</span>&lt;/h1&gt;`</span>)</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>2，我们要做的是，运行 puppeteer，打开页面，并进行请求劫持，将 data1.json 的数据换成 data2.json 的数据。</p>\n<p>另开一个终端，执行这些命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn</span><br><span class=\"line\"></span><br><span class=\"line\">npm <span class=\"built_in\">test</span> -- mock-demo</span><br></pre></td></tr></table></figure>\n<p>然后就会发现 Puppeteer 中显示的数据是 <code>data2</code>。</p>\n<p><img src=\"/css/images/6.jpg\" alt=\"\"></p>\n<p>我们看下测试脚本是如何进行拦截重写的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> page.setRequestInterception(<span class=\"literal\">true</span>);</span><br><span class=\"line\">page.on(<span class=\"string\">'request'</span>, request =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (request.url.endsWith(<span class=\"string\">'data1.json'</span>)) &#123;</span><br><span class=\"line\">    request.continue(&#123;</span><br><span class=\"line\">      url: <span class=\"string\">'http://localhost:8081/puppeteer-demo/mock-demo/data2.json'</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    request.continue();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码，先设置可以进行请求拦截：<code>await page.setRequestInterception(true);</code>。然后在 <code>request</code> 事件中进行 url 改写。另外，还可以换成 <code>request.respond</code> 方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> page.setRequestInterception(<span class=\"literal\">true</span>);</span><br><span class=\"line\">page.on(<span class=\"string\">'request'</span>, request =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (request.url.endsWith(<span class=\"string\">'data1.json'</span>)) &#123;</span><br><span class=\"line\">    request.respond(&#123;</span><br><span class=\"line\">      body: <span class=\"built_in\">JSON</span>.stringify(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'data2'</span> &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    request.continue();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>就是这么简单。这太好用了！我们甚至可以在日常开发中也使用 Puppeteer 来模拟请求，不需要等待后端的工作。</p>\n<h2 id=\"测试金字塔\"><a href=\"#测试金字塔\" class=\"headerlink\" title=\"测试金字塔\"></a>测试金字塔</h2><p>最后再聊一下端对端测试和单元测试的比例问题。谷歌的测试团队曾经提出过一个<a href=\"https://docs.google.com/presentation/d/15gNk21rjer3xo-b1ZqyQVGebOp_aPvHU3YH7YnOMxtE/edit#slide=id.g437663ce1_53_98\" target=\"_blank\" rel=\"noopener\">测试金字塔的概念</a>。大概就是单元测试应该最多，然后是集成测试（部分单元之间的集成，不像端对端那样完全黑盒），最少的应该是端对端测试：</p>\n<p><img src=\"/css/images/7.jpg\" alt=\"\"></p>\n<p>为何会这样呢？因为他们认为端对端测试不能像单元测试那样快速的定位问题所在，端对端测试所发现的问题，可能存在系统中的任何位置，但单元测试的反馈定位就更加直接准确。另外，单元测试写起来更加简单快速，而端对端测试则需要整个系统部署好之后才能测试，这样比较慢，毕竟有时候开发周期还是很长的，人家开发一周前写完的代码，你现在才开始测试，有点拖后腿。以上说法非常有道理，我也认为单元测试非常好，但是端对端测试也是有意义的，它可以检测出所有单元连接后的问题，这些问题只能通过端对端测试才能测出来。所以，两者都要写，不要怕麻烦，后期的收益是很大的！</p>\n<h2 id=\"更多测试文章：\"><a href=\"#更多测试文章：\" class=\"headerlink\" title=\"更多测试文章：\"></a>更多测试文章：</h2><p><a href=\"http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/\">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>"},{"title":"如何测试 DOM 操作类的 JS 代码","date":"2017-11-09T03:05:00.000Z","_content":"\n前几天写了一篇博客：[《使用 JavaScript 批量获取微博评论》](http://www.liuyiqi.cn/2017/11/03/use-js-to-get-weibo-comments/)。今天我们来学习如何测试我们之前编写的代码。从本质上来说，我们今天要学习的是如何测试 DOM 操作类的 JS 代码。你可以在这里获取测试代码：\n\n<https://github.com/lewis617/practical-js/blob/master/src/weiboBackup.test.js>\n\n<!--more-->\n\n## 选择测试框架\n\n我使用过很多测试框架，比如 Karma、Mocha、Jest 等，但因为对 Facebook 开源项目的偏爱，我选择了 Jest 来测试，事实证明，Jest 确实最为简单，无需进行繁琐的浏览器\b环境模拟，就可以直接使用浏览器环境的各种 API，让我们一睹为快！不过\b先安装 \bJest：\n\n```sh\nyarn add --dev jest\n```\n\n\n## 处理被测试文件\n\n被测试文件原来是这样的：\n\nweiboBackup.js\n\n```js\n/**\n * 获取微博以及评论文字\n * 先打开微博页面，\n * 然后将下面的js拷贝到浏览器的console面板中\n */\n\nvar nodeArray = Array.from(document.querySelectorAll('.list_con .WB_text'));\n\nvar textArray = nodeArray.map(function (node) {\n  return Array.from(node.childNodes).map(function (childNode) {\n    var value;\n    // 文字的情况\n    if (childNode.nodeName === '#text') value = childNode.nodeValue;\n    // 图片表情的情况\n    else if (childNode.nodeName === 'IMG') value = childNode.alt;\n    // 链接的情况\n    else if (childNode.nodeName === 'A') value = childNode.lastChild.nodeValue;\n    return value.replace(/(\\s+$)|(^\\s+)/g, '');\n  }).join('');\n});\n\nconsole.log(textArray.join('\\n'));\n```\n\n为了方便测试，我们在底部添加一行代码，将其导出，\b方便测试。另外，为了让测试报告更纯净，我们把 console 注释掉：\n\n```js\n// console.log(textArray.join('\\n'));\n\n// 本行代码用于单元测试，请不要拷贝到浏览器的console中运行\nmodule.exports = textArray;\n```\n\n## 编写测试文件\n\n前面说了 Jest 自带浏览器模拟环境，无需手动\b配置。所以我们直接添加用于测试的 html 即可：\n\n> 这段 html 字符串相当于模拟数据，即假数据。\b在这里，相当于模拟一个微博评论。模拟数据你可以随意编写，但是通常需要和真实数据保持结构和规律上的一致，而且需要覆盖所有的情况，这样才能测试到所有的边界。\n\nweiboBackup.test.js\n\n```js\ndocument.body.innerHTML = '\\\n  <div class=\"list_con\">\\\n    <div class=\"WB_text\">\\\n      <a target=\"_blank\" href=\"//weibo.com/2809324184\" usercard=\"id=2809324184\">Geo橙子</a>：在过一阵子是不是要翻成英文，走出国门了\\\n    </div>\\\n    <div class=\"WB_text\">\\\n      <a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\">dev_zk</a>\\\n      <a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;value=feed_icon\" href=\"http://club.weibo.com/intro\">\\\n        <i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"></i>\\\n      </a>\\\n      ：现在好了\\\n      <img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\">\\\n      <img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\">\\\n    </div>\\\n    <div class=\"WB_text\">\\\n      <a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\">dev_zk</a>\\\n      <a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;value=feed_icon\" href=\"http://club.weibo.com/intro\">\\\n      <i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"></i>\\\n      </a>\\\n      ：哈哈\\\n    </div>\\\n  </div>';\n```\n\n然后直接调用被测试文件 weiboBackup.js，相当于运行了它：\n\n```js\nvar textArray = require('./weiboBackup');\n```\n\n现在评论文本已经被保存到\b数组 `textArray` 中了，然后我们直接编写断言即可：\n\n```js\nexpect(textArray).toEqual([\n    \"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\",\n    \"dev_zk：现在好了[太开心][太开心]\",\n    \"dev_zk：哈哈\",\n  ]);\n```\n\n> 关于断言等测试的基础知识，如果你不了解，请看我之前写的 [《Jest 单元测试入门》](http://www.liuyiqi.cn/2017/02/15/start-jest/)。\n\n最后我们将上述代码包在 `test` 函数中，这个函数用于打包一个测试用例，并附带测试用例说明：\n\n```js\ntest('getweiboBackup', () => {\n  document.body.innerHTML = '\\\n  <div class=\"list_con\">\\\n    <div class=\"WB_text\">\\\n      <a target=\"_blank\" href=\"//weibo.com/2809324184\" usercard=\"id=2809324184\">Geo橙子</a>：在过一阵子是不是要翻成英文，走出国门了\\\n    </div>\\\n    <div class=\"WB_text\">\\\n      <a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\">dev_zk</a>\\\n      <a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;value=feed_icon\" href=\"http://club.weibo.com/intro\">\\\n        <i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"></i>\\\n      </a>\\\n      ：现在好了\\\n      <img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\">\\\n      <img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\">\\\n    </div>\\\n    <div class=\"WB_text\">\\\n      <a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\">dev_zk</a>\\\n      <a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;value=feed_icon\" href=\"http://club.weibo.com/intro\">\\\n      <i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"></i>\\\n      </a>\\\n      ：哈哈\\\n    </div>\\\n  </div>';\n  var textArray = require('./weiboBackup');\n  expect(textArray).toEqual([\n    \"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\",\n    \"dev_zk：现在好了[太开心][太开心]\",\n    \"dev_zk：哈哈\",\n  ]);\n});\n```\n## 运行测试\n\n测试文件写好了，我们需要运行它，首先在 package.json 中添加：\n\n```json\n\"scripts\": {\n  \"test\": \"jest\"\n}\n```\n\n然后在命令行中运行：\n\n```sh\nnpm test\n```\n\n最后就会看测试报告了：\n\n```sh\n PASS  ./weiboBackup.test.js\n  ✓ getweiboBackup (27ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        0.907s, estimated 1s\n```\n\n尝试改变 html 中的\b测试文本，或断言中的预期文本，看看预期与结果不一致的情况。比如，将断言改为：\n\n```js\nexpect(textArray).toEqual([]);\n```\n\n结果测试报告变为这样：\n\n```sh\n FAIL  ./weiboBackup.test.js\n  ✕ getweiboBackup (310ms)\n\n  ● getweiboBackup\n\n    expect(received).toEqual(expected)\n\n    Expected value to equal:\n      []\n    Received:\n      [\"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\", \"dev_zk：现在好了[太开心][太开心]\", \"dev_zk：哈哈\"]\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\",\n    +   \"dev_zk：现在好了[太开心][太开心]\",\n    +   \"dev_zk：哈哈\",\n    + ]\n\n      at Object.<anonymous>.test (weiboBackup.test.js:25:21)\n          at new Promise (<anonymous>)\n          at <anonymous>\n      at process._tickCallback (internal/process/next_tick.js:188:7)\n\nTest Suites: 1 failed, 1 total\nTests:       1 failed, 1 total\nSnapshots:   0 total\nTime:        0.897s, estimated 1s\nRan all test suites.\nnpm ERR! Test failed.  See above for more details.\n```\n\n## 总结\n\n编写测试还是很重要的，可以保证你的代码质量，而你的代码质量关系到你的 KPI，所以\b我建议大家还是养成编写测试的好习惯。","source":"_posts/how-to-test-dom-manipulation.md","raw":"---\ntitle: 如何测试 DOM 操作类的 JS 代码\ndate: 2017-11-09 11:05:00\ntags: [DOM, 单元测试, 测试]\n---\n\n前几天写了一篇博客：[《使用 JavaScript 批量获取微博评论》](http://www.liuyiqi.cn/2017/11/03/use-js-to-get-weibo-comments/)。今天我们来学习如何测试我们之前编写的代码。从本质上来说，我们今天要学习的是如何测试 DOM 操作类的 JS 代码。你可以在这里获取测试代码：\n\n<https://github.com/lewis617/practical-js/blob/master/src/weiboBackup.test.js>\n\n<!--more-->\n\n## 选择测试框架\n\n我使用过很多测试框架，比如 Karma、Mocha、Jest 等，但因为对 Facebook 开源项目的偏爱，我选择了 Jest 来测试，事实证明，Jest 确实最为简单，无需进行繁琐的浏览器\b环境模拟，就可以直接使用浏览器环境的各种 API，让我们一睹为快！不过\b先安装 \bJest：\n\n```sh\nyarn add --dev jest\n```\n\n\n## 处理被测试文件\n\n被测试文件原来是这样的：\n\nweiboBackup.js\n\n```js\n/**\n * 获取微博以及评论文字\n * 先打开微博页面，\n * 然后将下面的js拷贝到浏览器的console面板中\n */\n\nvar nodeArray = Array.from(document.querySelectorAll('.list_con .WB_text'));\n\nvar textArray = nodeArray.map(function (node) {\n  return Array.from(node.childNodes).map(function (childNode) {\n    var value;\n    // 文字的情况\n    if (childNode.nodeName === '#text') value = childNode.nodeValue;\n    // 图片表情的情况\n    else if (childNode.nodeName === 'IMG') value = childNode.alt;\n    // 链接的情况\n    else if (childNode.nodeName === 'A') value = childNode.lastChild.nodeValue;\n    return value.replace(/(\\s+$)|(^\\s+)/g, '');\n  }).join('');\n});\n\nconsole.log(textArray.join('\\n'));\n```\n\n为了方便测试，我们在底部添加一行代码，将其导出，\b方便测试。另外，为了让测试报告更纯净，我们把 console 注释掉：\n\n```js\n// console.log(textArray.join('\\n'));\n\n// 本行代码用于单元测试，请不要拷贝到浏览器的console中运行\nmodule.exports = textArray;\n```\n\n## 编写测试文件\n\n前面说了 Jest 自带浏览器模拟环境，无需手动\b配置。所以我们直接添加用于测试的 html 即可：\n\n> 这段 html 字符串相当于模拟数据，即假数据。\b在这里，相当于模拟一个微博评论。模拟数据你可以随意编写，但是通常需要和真实数据保持结构和规律上的一致，而且需要覆盖所有的情况，这样才能测试到所有的边界。\n\nweiboBackup.test.js\n\n```js\ndocument.body.innerHTML = '\\\n  <div class=\"list_con\">\\\n    <div class=\"WB_text\">\\\n      <a target=\"_blank\" href=\"//weibo.com/2809324184\" usercard=\"id=2809324184\">Geo橙子</a>：在过一阵子是不是要翻成英文，走出国门了\\\n    </div>\\\n    <div class=\"WB_text\">\\\n      <a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\">dev_zk</a>\\\n      <a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;value=feed_icon\" href=\"http://club.weibo.com/intro\">\\\n        <i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"></i>\\\n      </a>\\\n      ：现在好了\\\n      <img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\">\\\n      <img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\">\\\n    </div>\\\n    <div class=\"WB_text\">\\\n      <a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\">dev_zk</a>\\\n      <a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;value=feed_icon\" href=\"http://club.weibo.com/intro\">\\\n      <i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"></i>\\\n      </a>\\\n      ：哈哈\\\n    </div>\\\n  </div>';\n```\n\n然后直接调用被测试文件 weiboBackup.js，相当于运行了它：\n\n```js\nvar textArray = require('./weiboBackup');\n```\n\n现在评论文本已经被保存到\b数组 `textArray` 中了，然后我们直接编写断言即可：\n\n```js\nexpect(textArray).toEqual([\n    \"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\",\n    \"dev_zk：现在好了[太开心][太开心]\",\n    \"dev_zk：哈哈\",\n  ]);\n```\n\n> 关于断言等测试的基础知识，如果你不了解，请看我之前写的 [《Jest 单元测试入门》](http://www.liuyiqi.cn/2017/02/15/start-jest/)。\n\n最后我们将上述代码包在 `test` 函数中，这个函数用于打包一个测试用例，并附带测试用例说明：\n\n```js\ntest('getweiboBackup', () => {\n  document.body.innerHTML = '\\\n  <div class=\"list_con\">\\\n    <div class=\"WB_text\">\\\n      <a target=\"_blank\" href=\"//weibo.com/2809324184\" usercard=\"id=2809324184\">Geo橙子</a>：在过一阵子是不是要翻成英文，走出国门了\\\n    </div>\\\n    <div class=\"WB_text\">\\\n      <a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\">dev_zk</a>\\\n      <a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;value=feed_icon\" href=\"http://club.weibo.com/intro\">\\\n        <i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"></i>\\\n      </a>\\\n      ：现在好了\\\n      <img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\">\\\n      <img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\">\\\n    </div>\\\n    <div class=\"WB_text\">\\\n      <a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\">dev_zk</a>\\\n      <a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;value=feed_icon\" href=\"http://club.weibo.com/intro\">\\\n      <i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"></i>\\\n      </a>\\\n      ：哈哈\\\n    </div>\\\n  </div>';\n  var textArray = require('./weiboBackup');\n  expect(textArray).toEqual([\n    \"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\",\n    \"dev_zk：现在好了[太开心][太开心]\",\n    \"dev_zk：哈哈\",\n  ]);\n});\n```\n## 运行测试\n\n测试文件写好了，我们需要运行它，首先在 package.json 中添加：\n\n```json\n\"scripts\": {\n  \"test\": \"jest\"\n}\n```\n\n然后在命令行中运行：\n\n```sh\nnpm test\n```\n\n最后就会看测试报告了：\n\n```sh\n PASS  ./weiboBackup.test.js\n  ✓ getweiboBackup (27ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        0.907s, estimated 1s\n```\n\n尝试改变 html 中的\b测试文本，或断言中的预期文本，看看预期与结果不一致的情况。比如，将断言改为：\n\n```js\nexpect(textArray).toEqual([]);\n```\n\n结果测试报告变为这样：\n\n```sh\n FAIL  ./weiboBackup.test.js\n  ✕ getweiboBackup (310ms)\n\n  ● getweiboBackup\n\n    expect(received).toEqual(expected)\n\n    Expected value to equal:\n      []\n    Received:\n      [\"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\", \"dev_zk：现在好了[太开心][太开心]\", \"dev_zk：哈哈\"]\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\",\n    +   \"dev_zk：现在好了[太开心][太开心]\",\n    +   \"dev_zk：哈哈\",\n    + ]\n\n      at Object.<anonymous>.test (weiboBackup.test.js:25:21)\n          at new Promise (<anonymous>)\n          at <anonymous>\n      at process._tickCallback (internal/process/next_tick.js:188:7)\n\nTest Suites: 1 failed, 1 total\nTests:       1 failed, 1 total\nSnapshots:   0 total\nTime:        0.897s, estimated 1s\nRan all test suites.\nnpm ERR! Test failed.  See above for more details.\n```\n\n## 总结\n\n编写测试还是很重要的，可以保证你的代码质量，而你的代码质量关系到你的 KPI，所以\b我建议大家还是养成编写测试的好习惯。","slug":"how-to-test-dom-manipulation","published":1,"updated":"2019-05-01T08:02:09.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvld000stgytxr4vebuy","content":"<p>前几天写了一篇博客：<a href=\"http://www.liuyiqi.cn/2017/11/03/use-js-to-get-weibo-comments/\">《使用 JavaScript 批量获取微博评论》</a>。今天我们来学习如何测试我们之前编写的代码。从本质上来说，我们今天要学习的是如何测试 DOM 操作类的 JS 代码。你可以在这里获取测试代码：</p>\n<p><a href=\"https://github.com/lewis617/practical-js/blob/master/src/weiboBackup.test.js\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/practical-js/blob/master/src/weiboBackup.test.js</a></p>\n<a id=\"more\"></a>\n<h2 id=\"选择测试框架\"><a href=\"#选择测试框架\" class=\"headerlink\" title=\"选择测试框架\"></a>选择测试框架</h2><p>我使用过很多测试框架，比如 Karma、Mocha、Jest 等，但因为对 Facebook 开源项目的偏爱，我选择了 Jest 来测试，事实证明，Jest 确实最为简单，无需进行繁琐的浏览器\b环境模拟，就可以直接使用浏览器环境的各种 API，让我们一睹为快！不过\b先安装 \bJest：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add --dev jest</span><br></pre></td></tr></table></figure>\n<h2 id=\"处理被测试文件\"><a href=\"#处理被测试文件\" class=\"headerlink\" title=\"处理被测试文件\"></a>处理被测试文件</h2><p>被测试文件原来是这样的：</p>\n<p>weiboBackup.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取微博以及评论文字</span></span><br><span class=\"line\"><span class=\"comment\"> * 先打开微博页面，</span></span><br><span class=\"line\"><span class=\"comment\"> * 然后将下面的js拷贝到浏览器的console面板中</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nodeArray = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'.list_con .WB_text'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> textArray = nodeArray.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(node.childNodes).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">childNode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">    <span class=\"comment\">// 文字的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'#text'</span>) value = childNode.nodeValue;</span><br><span class=\"line\">    <span class=\"comment\">// 图片表情的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'IMG'</span>) value = childNode.alt;</span><br><span class=\"line\">    <span class=\"comment\">// 链接的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'A'</span>) value = childNode.lastChild.nodeValue;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value.replace(<span class=\"regexp\">/(\\s+$)|(^\\s+)/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(textArray.join(<span class=\"string\">'\\n'</span>));</span><br></pre></td></tr></table></figure>\n<p>为了方便测试，我们在底部添加一行代码，将其导出，\b方便测试。另外，为了让测试报告更纯净，我们把 console 注释掉：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// console.log(textArray.join('\\n'));</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 本行代码用于单元测试，请不要拷贝到浏览器的console中运行</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = textArray;</span><br></pre></td></tr></table></figure>\n<h2 id=\"编写测试文件\"><a href=\"#编写测试文件\" class=\"headerlink\" title=\"编写测试文件\"></a>编写测试文件</h2><p>前面说了 Jest 自带浏览器模拟环境，无需手动\b配置。所以我们直接添加用于测试的 html 即可：</p>\n<blockquote>\n<p>这段 html 字符串相当于模拟数据，即假数据。\b在这里，相当于模拟一个微博评论。模拟数据你可以随意编写，但是通常需要和真实数据保持结构和规律上的一致，而且需要覆盖所有的情况，这样才能测试到所有的边界。</p>\n</blockquote>\n<p>weiboBackup.test.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.innerHTML = <span class=\"string\">'\\</span></span><br><span class=\"line\"><span class=\"string\">  &lt;div class=\"list_con\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=\"WB_text\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" href=\"//weibo.com/2809324184\" usercard=\"id=2809324184\"&gt;Geo橙子&lt;/a&gt;：在过一阵子是不是要翻成英文，走出国门了\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=\"WB_text\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\"&gt;dev_zk&lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;amp;value=feed_icon\" href=\"http://club.weibo.com/intro\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">        &lt;i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"&gt;&lt;/i&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      ：现在好了\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=\"WB_text\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\"&gt;dev_zk&lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;amp;value=feed_icon\" href=\"http://club.weibo.com/intro\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"&gt;&lt;/i&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      ：哈哈\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/div&gt;'</span>;</span><br></pre></td></tr></table></figure>\n<p>然后直接调用被测试文件 weiboBackup.js，相当于运行了它：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> textArray = <span class=\"built_in\">require</span>(<span class=\"string\">'./weiboBackup'</span>);</span><br></pre></td></tr></table></figure>\n<p>现在评论文本已经被保存到\b数组 <code>textArray</code> 中了，然后我们直接编写断言即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(textArray).toEqual([</span><br><span class=\"line\">    <span class=\"string\">\"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dev_zk：现在好了[太开心][太开心]\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dev_zk：哈哈\"</span>,</span><br><span class=\"line\">  ]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>关于断言等测试的基础知识，如果你不了解，请看我之前写的 <a href=\"http://www.liuyiqi.cn/2017/02/15/start-jest/\">《Jest 单元测试入门》</a>。</p>\n</blockquote>\n<p>最后我们将上述代码包在 <code>test</code> 函数中，这个函数用于打包一个测试用例，并附带测试用例说明：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">'getweiboBackup'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.innerHTML = <span class=\"string\">'\\</span></span><br><span class=\"line\"><span class=\"string\">  &lt;div class=\"list_con\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=\"WB_text\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" href=\"//weibo.com/2809324184\" usercard=\"id=2809324184\"&gt;Geo橙子&lt;/a&gt;：在过一阵子是不是要翻成英文，走出国门了\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=\"WB_text\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\"&gt;dev_zk&lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;amp;value=feed_icon\" href=\"http://club.weibo.com/intro\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">        &lt;i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"&gt;&lt;/i&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      ：现在好了\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=\"WB_text\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\"&gt;dev_zk&lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;amp;value=feed_icon\" href=\"http://club.weibo.com/intro\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"&gt;&lt;/i&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      ：哈哈\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/div&gt;'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> textArray = <span class=\"built_in\">require</span>(<span class=\"string\">'./weiboBackup'</span>);</span><br><span class=\"line\">  expect(textArray).toEqual([</span><br><span class=\"line\">    <span class=\"string\">\"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dev_zk：现在好了[太开心][太开心]\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dev_zk：哈哈\"</span>,</span><br><span class=\"line\">  ]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h2><p>测试文件写好了，我们需要运行它，首先在 package.json 中添加：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">  \"test\": \"jest\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在命令行中运行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>最后就会看测试报告了：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> PASS  ./weiboBackup.test.js</span><br><span class=\"line\">  ✓ getweiboBackup (27ms)</span><br><span class=\"line\"></span><br><span class=\"line\">Test Suites: 1 passed, 1 total</span><br><span class=\"line\">Tests:       1 passed, 1 total</span><br><span class=\"line\">Snapshots:   0 total</span><br><span class=\"line\">Time:        0.907s, estimated 1s</span><br></pre></td></tr></table></figure>\n<p>尝试改变 html 中的\b测试文本，或断言中的预期文本，看看预期与结果不一致的情况。比如，将断言改为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(textArray).toEqual([]);</span><br></pre></td></tr></table></figure>\n<p>结果测试报告变为这样：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> FAIL  ./weiboBackup.test.js</span><br><span class=\"line\">  ✕ getweiboBackup (310ms)</span><br><span class=\"line\"></span><br><span class=\"line\">  ● getweiboBackup</span><br><span class=\"line\"></span><br><span class=\"line\">    expect(received).toEqual(expected)</span><br><span class=\"line\"></span><br><span class=\"line\">    Expected value to equal:</span><br><span class=\"line\">      []</span><br><span class=\"line\">    Received:</span><br><span class=\"line\">      [<span class=\"string\">\"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\"</span>, <span class=\"string\">\"dev_zk：现在好了[太开心][太开心]\"</span>, <span class=\"string\">\"dev_zk：哈哈\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    Difference:</span><br><span class=\"line\"></span><br><span class=\"line\">    - Expected</span><br><span class=\"line\">    + Received</span><br><span class=\"line\"></span><br><span class=\"line\">    - Array []</span><br><span class=\"line\">    + Array [</span><br><span class=\"line\">    +   <span class=\"string\">\"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\"</span>,</span><br><span class=\"line\">    +   <span class=\"string\">\"dev_zk：现在好了[太开心][太开心]\"</span>,</span><br><span class=\"line\">    +   <span class=\"string\">\"dev_zk：哈哈\"</span>,</span><br><span class=\"line\">    + ]</span><br><span class=\"line\"></span><br><span class=\"line\">      at Object.&lt;anonymous&gt;.<span class=\"built_in\">test</span> (weiboBackup.test.js:25:21)</span><br><span class=\"line\">          at new Promise (&lt;anonymous&gt;)</span><br><span class=\"line\">          at &lt;anonymous&gt;</span><br><span class=\"line\">      at process._tickCallback (internal/process/next_tick.js:188:7)</span><br><span class=\"line\"></span><br><span class=\"line\">Test Suites: 1 failed, 1 total</span><br><span class=\"line\">Tests:       1 failed, 1 total</span><br><span class=\"line\">Snapshots:   0 total</span><br><span class=\"line\">Time:        0.897s, estimated 1s</span><br><span class=\"line\">Ran all <span class=\"built_in\">test</span> suites.</span><br><span class=\"line\">npm ERR! Test failed.  See above <span class=\"keyword\">for</span> more details.</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>编写测试还是很重要的，可以保证你的代码质量，而你的代码质量关系到你的 KPI，所以\b我建议大家还是养成编写测试的好习惯。</p>\n","site":{"data":{}},"excerpt":"<p>前几天写了一篇博客：<a href=\"http://www.liuyiqi.cn/2017/11/03/use-js-to-get-weibo-comments/\">《使用 JavaScript 批量获取微博评论》</a>。今天我们来学习如何测试我们之前编写的代码。从本质上来说，我们今天要学习的是如何测试 DOM 操作类的 JS 代码。你可以在这里获取测试代码：</p>\n<p><a href=\"https://github.com/lewis617/practical-js/blob/master/src/weiboBackup.test.js\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/practical-js/blob/master/src/weiboBackup.test.js</a></p>","more":"<h2 id=\"选择测试框架\"><a href=\"#选择测试框架\" class=\"headerlink\" title=\"选择测试框架\"></a>选择测试框架</h2><p>我使用过很多测试框架，比如 Karma、Mocha、Jest 等，但因为对 Facebook 开源项目的偏爱，我选择了 Jest 来测试，事实证明，Jest 确实最为简单，无需进行繁琐的浏览器\b环境模拟，就可以直接使用浏览器环境的各种 API，让我们一睹为快！不过\b先安装 \bJest：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add --dev jest</span><br></pre></td></tr></table></figure>\n<h2 id=\"处理被测试文件\"><a href=\"#处理被测试文件\" class=\"headerlink\" title=\"处理被测试文件\"></a>处理被测试文件</h2><p>被测试文件原来是这样的：</p>\n<p>weiboBackup.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取微博以及评论文字</span></span><br><span class=\"line\"><span class=\"comment\"> * 先打开微博页面，</span></span><br><span class=\"line\"><span class=\"comment\"> * 然后将下面的js拷贝到浏览器的console面板中</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nodeArray = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'.list_con .WB_text'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> textArray = nodeArray.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(node.childNodes).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">childNode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">    <span class=\"comment\">// 文字的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'#text'</span>) value = childNode.nodeValue;</span><br><span class=\"line\">    <span class=\"comment\">// 图片表情的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'IMG'</span>) value = childNode.alt;</span><br><span class=\"line\">    <span class=\"comment\">// 链接的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'A'</span>) value = childNode.lastChild.nodeValue;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value.replace(<span class=\"regexp\">/(\\s+$)|(^\\s+)/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(textArray.join(<span class=\"string\">'\\n'</span>));</span><br></pre></td></tr></table></figure>\n<p>为了方便测试，我们在底部添加一行代码，将其导出，\b方便测试。另外，为了让测试报告更纯净，我们把 console 注释掉：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// console.log(textArray.join('\\n'));</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 本行代码用于单元测试，请不要拷贝到浏览器的console中运行</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = textArray;</span><br></pre></td></tr></table></figure>\n<h2 id=\"编写测试文件\"><a href=\"#编写测试文件\" class=\"headerlink\" title=\"编写测试文件\"></a>编写测试文件</h2><p>前面说了 Jest 自带浏览器模拟环境，无需手动\b配置。所以我们直接添加用于测试的 html 即可：</p>\n<blockquote>\n<p>这段 html 字符串相当于模拟数据，即假数据。\b在这里，相当于模拟一个微博评论。模拟数据你可以随意编写，但是通常需要和真实数据保持结构和规律上的一致，而且需要覆盖所有的情况，这样才能测试到所有的边界。</p>\n</blockquote>\n<p>weiboBackup.test.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.innerHTML = <span class=\"string\">'\\</span></span><br><span class=\"line\"><span class=\"string\">  &lt;div class=\"list_con\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=\"WB_text\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" href=\"//weibo.com/2809324184\" usercard=\"id=2809324184\"&gt;Geo橙子&lt;/a&gt;：在过一阵子是不是要翻成英文，走出国门了\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=\"WB_text\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\"&gt;dev_zk&lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;amp;value=feed_icon\" href=\"http://club.weibo.com/intro\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">        &lt;i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"&gt;&lt;/i&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      ：现在好了\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=\"WB_text\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\"&gt;dev_zk&lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;amp;value=feed_icon\" href=\"http://club.weibo.com/intro\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"&gt;&lt;/i&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      ：哈哈\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/div&gt;'</span>;</span><br></pre></td></tr></table></figure>\n<p>然后直接调用被测试文件 weiboBackup.js，相当于运行了它：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> textArray = <span class=\"built_in\">require</span>(<span class=\"string\">'./weiboBackup'</span>);</span><br></pre></td></tr></table></figure>\n<p>现在评论文本已经被保存到\b数组 <code>textArray</code> 中了，然后我们直接编写断言即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(textArray).toEqual([</span><br><span class=\"line\">    <span class=\"string\">\"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dev_zk：现在好了[太开心][太开心]\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dev_zk：哈哈\"</span>,</span><br><span class=\"line\">  ]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>关于断言等测试的基础知识，如果你不了解，请看我之前写的 <a href=\"http://www.liuyiqi.cn/2017/02/15/start-jest/\">《Jest 单元测试入门》</a>。</p>\n</blockquote>\n<p>最后我们将上述代码包在 <code>test</code> 函数中，这个函数用于打包一个测试用例，并附带测试用例说明：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">'getweiboBackup'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.innerHTML = <span class=\"string\">'\\</span></span><br><span class=\"line\"><span class=\"string\">  &lt;div class=\"list_con\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=\"WB_text\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" href=\"//weibo.com/2809324184\" usercard=\"id=2809324184\"&gt;Geo橙子&lt;/a&gt;：在过一阵子是不是要翻成英文，走出国门了\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=\"WB_text\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\"&gt;dev_zk&lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;amp;value=feed_icon\" href=\"http://club.weibo.com/intro\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">        &lt;i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"&gt;&lt;/i&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      ：现在好了\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;img render=\"ext\" src=\"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif\" title=\"[太开心]\" alt=\"[太开心]\" type=\"face\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=\"WB_text\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" href=\"//weibo.com/2497287343\" usercard=\"id=2497287343\"&gt;dev_zk&lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a target=\"_blank\" suda-data=\"key=pc_apply_entry&amp;amp;value=feed_icon\" href=\"http://club.weibo.com/intro\"&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;i title=\"微博达人\" class=\"W_icon icon_club\" node-type=\"daren\"&gt;&lt;/i&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/a&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      ：哈哈\\</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/div&gt;'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> textArray = <span class=\"built_in\">require</span>(<span class=\"string\">'./weiboBackup'</span>);</span><br><span class=\"line\">  expect(textArray).toEqual([</span><br><span class=\"line\">    <span class=\"string\">\"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dev_zk：现在好了[太开心][太开心]\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"dev_zk：哈哈\"</span>,</span><br><span class=\"line\">  ]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h2><p>测试文件写好了，我们需要运行它，首先在 package.json 中添加：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">  \"test\": \"jest\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在命令行中运行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>最后就会看测试报告了：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> PASS  ./weiboBackup.test.js</span><br><span class=\"line\">  ✓ getweiboBackup (27ms)</span><br><span class=\"line\"></span><br><span class=\"line\">Test Suites: 1 passed, 1 total</span><br><span class=\"line\">Tests:       1 passed, 1 total</span><br><span class=\"line\">Snapshots:   0 total</span><br><span class=\"line\">Time:        0.907s, estimated 1s</span><br></pre></td></tr></table></figure>\n<p>尝试改变 html 中的\b测试文本，或断言中的预期文本，看看预期与结果不一致的情况。比如，将断言改为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(textArray).toEqual([]);</span><br></pre></td></tr></table></figure>\n<p>结果测试报告变为这样：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> FAIL  ./weiboBackup.test.js</span><br><span class=\"line\">  ✕ getweiboBackup (310ms)</span><br><span class=\"line\"></span><br><span class=\"line\">  ● getweiboBackup</span><br><span class=\"line\"></span><br><span class=\"line\">    expect(received).toEqual(expected)</span><br><span class=\"line\"></span><br><span class=\"line\">    Expected value to equal:</span><br><span class=\"line\">      []</span><br><span class=\"line\">    Received:</span><br><span class=\"line\">      [<span class=\"string\">\"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\"</span>, <span class=\"string\">\"dev_zk：现在好了[太开心][太开心]\"</span>, <span class=\"string\">\"dev_zk：哈哈\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    Difference:</span><br><span class=\"line\"></span><br><span class=\"line\">    - Expected</span><br><span class=\"line\">    + Received</span><br><span class=\"line\"></span><br><span class=\"line\">    - Array []</span><br><span class=\"line\">    + Array [</span><br><span class=\"line\">    +   <span class=\"string\">\"Geo橙子：在过一阵子是不是要翻成英文，走出国门了\"</span>,</span><br><span class=\"line\">    +   <span class=\"string\">\"dev_zk：现在好了[太开心][太开心]\"</span>,</span><br><span class=\"line\">    +   <span class=\"string\">\"dev_zk：哈哈\"</span>,</span><br><span class=\"line\">    + ]</span><br><span class=\"line\"></span><br><span class=\"line\">      at Object.&lt;anonymous&gt;.<span class=\"built_in\">test</span> (weiboBackup.test.js:25:21)</span><br><span class=\"line\">          at new Promise (&lt;anonymous&gt;)</span><br><span class=\"line\">          at &lt;anonymous&gt;</span><br><span class=\"line\">      at process._tickCallback (internal/process/next_tick.js:188:7)</span><br><span class=\"line\"></span><br><span class=\"line\">Test Suites: 1 failed, 1 total</span><br><span class=\"line\">Tests:       1 failed, 1 total</span><br><span class=\"line\">Snapshots:   0 total</span><br><span class=\"line\">Time:        0.897s, estimated 1s</span><br><span class=\"line\">Ran all <span class=\"built_in\">test</span> suites.</span><br><span class=\"line\">npm ERR! Test failed.  See above <span class=\"keyword\">for</span> more details.</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>编写测试还是很重要的，可以保证你的代码质量，而你的代码质量关系到你的 KPI，所以\b我建议大家还是养成编写测试的好习惯。</p>"},{"title":"JS 死循环的手动终止以及代码熔断方法","date":"2019-01-25T06:35:00.000Z","_content":"\n最近工作中遇到了一些死循环导致的页面卡死问题，经过 trouble shooting 和代码修复解决了问题，在此也顺便整理了一下 JS 死循环的手动终止以及代码熔断方法。\n\n<!--more-->\n\n## 被死循环卡死的页面\n\n你是否遇到这样的场景，在你执行了页面上某个动作后，一些怪异的事情发生了：\n\n- 页面卡死了，点击页面上任何按钮，或者是尝试滚动页面都没有任何反应。\n- 过了几秒后，电脑的风扇开始加速转动，声音变大。\n- 然后，你尝试关闭页面，发现连页面都关不了（刚卡死不太久时候其实还能关闭）。\n- 接着，你尝试关闭浏览器，但也没有任何反应。随着风扇转动地更快，你也开始焦急了。\n- 无奈，你打开任务管理器关闭了浏览器的进程。\n- 当你想再试试触发这一切的那个“动作”时候，上述事情还是如期而至。\n- ……\n[![kmNDsJ.png](https://s2.ax1x.com/2019/01/25/kmNDsJ.png)](https://imgchr.com/i/kmNDsJ)\n\n那么这时候很有可能，你的 JS 代码里出现了死循环（Infinite Loop）。\n\n死循环出现的原因很多：\n\n- 组件更新回调里再次调用了更新方法。\n- 表单项 A 和 B 相互联动。\n- 递归函数里忘记写了终止逻辑，或是终止逻辑有问题。\n- ……\n\n死循环严重影响用户体验，甚至伤机器，我们要尽力避免，但完全规避是不可能的，毕竟程序员也是人，也会犯错。所以，今天我们要介绍如何手动终止死循环，以及如何用代码熔断死循环。\n\n## 手动终止死循环\n\n如果你尝试调用任务管理器，关闭浏览器进程，这样的操作成本较高，你还要重新打开浏览器，打开页面。但是不这么做，页面就会卡死，你“什么也做不了”。其实，在 Chrome 67及以上版本中，还是有方法可以在不杀死浏览器进程的前提下终止死循环的。方法如下：\n\n- 打开开发者工具 DevTools（F12）。\n- 点开 **Sources** 面板，点击 “Pause script execution” 按钮，发现代码就暂停了。\n- 然后长按“Pause script execution” 按钮，并选择 “Stop” 图标，就终止死循环了。\n\n![手动终止](https://i.stack.imgur.com/iYiF1.png)\n\n## 代码熔断\n\n手动终止只是减少杀死浏览器进程重启的成本，我们最好还能用代码来熔断一些死循环。下面是熔断函数：\n\n```js\nconst loopBreaker = (function () {\n  let count = 0;\n  let startTime;\n  return function () {\n    startTime = startTime || (startTime = Date.now());\n    count += 1;\n    // 更改阈值为你想要的，这里是 10000\n    if (count > 10000 && (Date.now() - startTime > 1000)) {\n      throw new Error(\"Loop Broken!\");\n    }\n    // 一秒后清空\n    setTimeout(() => { count = 0; startTime = null; }, 1000);\n  };\n}());\n```\n\n上述函数中 `count` 是循环执行次数，`startTime` 是首次执行函数的时间。如果循环超过 10000 次，且循环时间超过 1000 毫秒，那么就熔断。\n\n使用方法：\n\n```js\nfor (var i = 0; i < 1000000; i--) {\n  loopBreaker();\n  console.log(i);\n}\n```\n\n还可以改写这个函数以支持更多的功能，如：日志格式、熔断阈值等，快去试试吧！\n\n## 结语\n\n本文介绍了 JS 死循环的手动终止以及代码熔断方法。但解决问题的方法肯定不止于此，比如一些 Babel 插件可以转换所有循环代码，但就不再赘述了。最后，希望可以本文给遇到死循环的读者一些参考。\n","source":"_posts/js-infinite-loop-breaker.md","raw":"---\n\ntitle: JS 死循环的手动终止以及代码熔断方法\n\ndate: 2019-01-25 14:35:00\n\ntags: [JS 调试]\n\n---\n\n最近工作中遇到了一些死循环导致的页面卡死问题，经过 trouble shooting 和代码修复解决了问题，在此也顺便整理了一下 JS 死循环的手动终止以及代码熔断方法。\n\n<!--more-->\n\n## 被死循环卡死的页面\n\n你是否遇到这样的场景，在你执行了页面上某个动作后，一些怪异的事情发生了：\n\n- 页面卡死了，点击页面上任何按钮，或者是尝试滚动页面都没有任何反应。\n- 过了几秒后，电脑的风扇开始加速转动，声音变大。\n- 然后，你尝试关闭页面，发现连页面都关不了（刚卡死不太久时候其实还能关闭）。\n- 接着，你尝试关闭浏览器，但也没有任何反应。随着风扇转动地更快，你也开始焦急了。\n- 无奈，你打开任务管理器关闭了浏览器的进程。\n- 当你想再试试触发这一切的那个“动作”时候，上述事情还是如期而至。\n- ……\n[![kmNDsJ.png](https://s2.ax1x.com/2019/01/25/kmNDsJ.png)](https://imgchr.com/i/kmNDsJ)\n\n那么这时候很有可能，你的 JS 代码里出现了死循环（Infinite Loop）。\n\n死循环出现的原因很多：\n\n- 组件更新回调里再次调用了更新方法。\n- 表单项 A 和 B 相互联动。\n- 递归函数里忘记写了终止逻辑，或是终止逻辑有问题。\n- ……\n\n死循环严重影响用户体验，甚至伤机器，我们要尽力避免，但完全规避是不可能的，毕竟程序员也是人，也会犯错。所以，今天我们要介绍如何手动终止死循环，以及如何用代码熔断死循环。\n\n## 手动终止死循环\n\n如果你尝试调用任务管理器，关闭浏览器进程，这样的操作成本较高，你还要重新打开浏览器，打开页面。但是不这么做，页面就会卡死，你“什么也做不了”。其实，在 Chrome 67及以上版本中，还是有方法可以在不杀死浏览器进程的前提下终止死循环的。方法如下：\n\n- 打开开发者工具 DevTools（F12）。\n- 点开 **Sources** 面板，点击 “Pause script execution” 按钮，发现代码就暂停了。\n- 然后长按“Pause script execution” 按钮，并选择 “Stop” 图标，就终止死循环了。\n\n![手动终止](https://i.stack.imgur.com/iYiF1.png)\n\n## 代码熔断\n\n手动终止只是减少杀死浏览器进程重启的成本，我们最好还能用代码来熔断一些死循环。下面是熔断函数：\n\n```js\nconst loopBreaker = (function () {\n  let count = 0;\n  let startTime;\n  return function () {\n    startTime = startTime || (startTime = Date.now());\n    count += 1;\n    // 更改阈值为你想要的，这里是 10000\n    if (count > 10000 && (Date.now() - startTime > 1000)) {\n      throw new Error(\"Loop Broken!\");\n    }\n    // 一秒后清空\n    setTimeout(() => { count = 0; startTime = null; }, 1000);\n  };\n}());\n```\n\n上述函数中 `count` 是循环执行次数，`startTime` 是首次执行函数的时间。如果循环超过 10000 次，且循环时间超过 1000 毫秒，那么就熔断。\n\n使用方法：\n\n```js\nfor (var i = 0; i < 1000000; i--) {\n  loopBreaker();\n  console.log(i);\n}\n```\n\n还可以改写这个函数以支持更多的功能，如：日志格式、熔断阈值等，快去试试吧！\n\n## 结语\n\n本文介绍了 JS 死循环的手动终止以及代码熔断方法。但解决问题的方法肯定不止于此，比如一些 Babel 插件可以转换所有循环代码，但就不再赘述了。最后，希望可以本文给遇到死循环的读者一些参考。\n","slug":"js-infinite-loop-breaker","published":1,"updated":"2019-05-01T08:02:09.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvle000utgytac6f35sw","content":"<p>最近工作中遇到了一些死循环导致的页面卡死问题，经过 trouble shooting 和代码修复解决了问题，在此也顺便整理了一下 JS 死循环的手动终止以及代码熔断方法。</p>\n<a id=\"more\"></a>\n<h2 id=\"被死循环卡死的页面\"><a href=\"#被死循环卡死的页面\" class=\"headerlink\" title=\"被死循环卡死的页面\"></a>被死循环卡死的页面</h2><p>你是否遇到这样的场景，在你执行了页面上某个动作后，一些怪异的事情发生了：</p>\n<ul>\n<li>页面卡死了，点击页面上任何按钮，或者是尝试滚动页面都没有任何反应。</li>\n<li>过了几秒后，电脑的风扇开始加速转动，声音变大。</li>\n<li>然后，你尝试关闭页面，发现连页面都关不了（刚卡死不太久时候其实还能关闭）。</li>\n<li>接着，你尝试关闭浏览器，但也没有任何反应。随着风扇转动地更快，你也开始焦急了。</li>\n<li>无奈，你打开任务管理器关闭了浏览器的进程。</li>\n<li>当你想再试试触发这一切的那个“动作”时候，上述事情还是如期而至。</li>\n<li>……<br><a href=\"https://imgchr.com/i/kmNDsJ\" target=\"_blank\" rel=\"noopener\"><img src=\"https://s2.ax1x.com/2019/01/25/kmNDsJ.png\" alt=\"kmNDsJ.png\"></a></li>\n</ul>\n<p>那么这时候很有可能，你的 JS 代码里出现了死循环（Infinite Loop）。</p>\n<p>死循环出现的原因很多：</p>\n<ul>\n<li>组件更新回调里再次调用了更新方法。</li>\n<li>表单项 A 和 B 相互联动。</li>\n<li>递归函数里忘记写了终止逻辑，或是终止逻辑有问题。</li>\n<li>……</li>\n</ul>\n<p>死循环严重影响用户体验，甚至伤机器，我们要尽力避免，但完全规避是不可能的，毕竟程序员也是人，也会犯错。所以，今天我们要介绍如何手动终止死循环，以及如何用代码熔断死循环。</p>\n<h2 id=\"手动终止死循环\"><a href=\"#手动终止死循环\" class=\"headerlink\" title=\"手动终止死循环\"></a>手动终止死循环</h2><p>如果你尝试调用任务管理器，关闭浏览器进程，这样的操作成本较高，你还要重新打开浏览器，打开页面。但是不这么做，页面就会卡死，你“什么也做不了”。其实，在 Chrome 67及以上版本中，还是有方法可以在不杀死浏览器进程的前提下终止死循环的。方法如下：</p>\n<ul>\n<li>打开开发者工具 DevTools（F12）。</li>\n<li>点开 <strong>Sources</strong> 面板，点击 “Pause script execution” 按钮，发现代码就暂停了。</li>\n<li>然后长按“Pause script execution” 按钮，并选择 “Stop” 图标，就终止死循环了。</li>\n</ul>\n<p><img src=\"https://i.stack.imgur.com/iYiF1.png\" alt=\"手动终止\"></p>\n<h2 id=\"代码熔断\"><a href=\"#代码熔断\" class=\"headerlink\" title=\"代码熔断\"></a>代码熔断</h2><p>手动终止只是减少杀死浏览器进程重启的成本，我们最好还能用代码来熔断一些死循环。下面是熔断函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> loopBreaker = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> startTime;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    startTime = startTime || (startTime = <span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">    count += <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 更改阈值为你想要的，这里是 10000</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">10000</span> &amp;&amp; (<span class=\"built_in\">Date</span>.now() - startTime &gt; <span class=\"number\">1000</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Loop Broken!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 一秒后清空</span></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; count = <span class=\"number\">0</span>; startTime = <span class=\"literal\">null</span>; &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<p>上述函数中 <code>count</code> 是循环执行次数，<code>startTime</code> 是首次执行函数的时间。如果循环超过 10000 次，且循环时间超过 1000 毫秒，那么就熔断。</p>\n<p>使用方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i--) &#123;</span><br><span class=\"line\">  loopBreaker();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还可以改写这个函数以支持更多的功能，如：日志格式、熔断阈值等，快去试试吧！</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本文介绍了 JS 死循环的手动终止以及代码熔断方法。但解决问题的方法肯定不止于此，比如一些 Babel 插件可以转换所有循环代码，但就不再赘述了。最后，希望可以本文给遇到死循环的读者一些参考。</p>\n","site":{"data":{}},"excerpt":"<p>最近工作中遇到了一些死循环导致的页面卡死问题，经过 trouble shooting 和代码修复解决了问题，在此也顺便整理了一下 JS 死循环的手动终止以及代码熔断方法。</p>","more":"<h2 id=\"被死循环卡死的页面\"><a href=\"#被死循环卡死的页面\" class=\"headerlink\" title=\"被死循环卡死的页面\"></a>被死循环卡死的页面</h2><p>你是否遇到这样的场景，在你执行了页面上某个动作后，一些怪异的事情发生了：</p>\n<ul>\n<li>页面卡死了，点击页面上任何按钮，或者是尝试滚动页面都没有任何反应。</li>\n<li>过了几秒后，电脑的风扇开始加速转动，声音变大。</li>\n<li>然后，你尝试关闭页面，发现连页面都关不了（刚卡死不太久时候其实还能关闭）。</li>\n<li>接着，你尝试关闭浏览器，但也没有任何反应。随着风扇转动地更快，你也开始焦急了。</li>\n<li>无奈，你打开任务管理器关闭了浏览器的进程。</li>\n<li>当你想再试试触发这一切的那个“动作”时候，上述事情还是如期而至。</li>\n<li>……<br><a href=\"https://imgchr.com/i/kmNDsJ\" target=\"_blank\" rel=\"noopener\"><img src=\"https://s2.ax1x.com/2019/01/25/kmNDsJ.png\" alt=\"kmNDsJ.png\"></a></li>\n</ul>\n<p>那么这时候很有可能，你的 JS 代码里出现了死循环（Infinite Loop）。</p>\n<p>死循环出现的原因很多：</p>\n<ul>\n<li>组件更新回调里再次调用了更新方法。</li>\n<li>表单项 A 和 B 相互联动。</li>\n<li>递归函数里忘记写了终止逻辑，或是终止逻辑有问题。</li>\n<li>……</li>\n</ul>\n<p>死循环严重影响用户体验，甚至伤机器，我们要尽力避免，但完全规避是不可能的，毕竟程序员也是人，也会犯错。所以，今天我们要介绍如何手动终止死循环，以及如何用代码熔断死循环。</p>\n<h2 id=\"手动终止死循环\"><a href=\"#手动终止死循环\" class=\"headerlink\" title=\"手动终止死循环\"></a>手动终止死循环</h2><p>如果你尝试调用任务管理器，关闭浏览器进程，这样的操作成本较高，你还要重新打开浏览器，打开页面。但是不这么做，页面就会卡死，你“什么也做不了”。其实，在 Chrome 67及以上版本中，还是有方法可以在不杀死浏览器进程的前提下终止死循环的。方法如下：</p>\n<ul>\n<li>打开开发者工具 DevTools（F12）。</li>\n<li>点开 <strong>Sources</strong> 面板，点击 “Pause script execution” 按钮，发现代码就暂停了。</li>\n<li>然后长按“Pause script execution” 按钮，并选择 “Stop” 图标，就终止死循环了。</li>\n</ul>\n<p><img src=\"https://i.stack.imgur.com/iYiF1.png\" alt=\"手动终止\"></p>\n<h2 id=\"代码熔断\"><a href=\"#代码熔断\" class=\"headerlink\" title=\"代码熔断\"></a>代码熔断</h2><p>手动终止只是减少杀死浏览器进程重启的成本，我们最好还能用代码来熔断一些死循环。下面是熔断函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> loopBreaker = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> startTime;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    startTime = startTime || (startTime = <span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">    count += <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 更改阈值为你想要的，这里是 10000</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">10000</span> &amp;&amp; (<span class=\"built_in\">Date</span>.now() - startTime &gt; <span class=\"number\">1000</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Loop Broken!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 一秒后清空</span></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; count = <span class=\"number\">0</span>; startTime = <span class=\"literal\">null</span>; &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<p>上述函数中 <code>count</code> 是循环执行次数，<code>startTime</code> 是首次执行函数的时间。如果循环超过 10000 次，且循环时间超过 1000 毫秒，那么就熔断。</p>\n<p>使用方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i--) &#123;</span><br><span class=\"line\">  loopBreaker();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还可以改写这个函数以支持更多的功能，如：日志格式、熔断阈值等，快去试试吧！</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本文介绍了 JS 死循环的手动终止以及代码熔断方法。但解决问题的方法肯定不止于此，比如一些 Babel 插件可以转换所有循环代码，但就不再赘述了。最后，希望可以本文给遇到死循环的读者一些参考。</p>"},{"title":"Anjana Vakil：函数式 JS 中的不可变数据结构（译）","date":"2017-10-22T09:32:00.000Z","_content":"\n本文翻译整理自 YouTube 视频：\n\nhttps://www.youtube.com/watch?v=Wo0qiGPSV-s\n\n![](/css/images/8.jpg)\n\n<!--more-->\n\n## 开场白\n\n嗨，各位。大家好吗？我是 Anjana Vakil ，你们可以在推特上通过这个名字找到我。今天，我想讲的是，函数式 JS 中的不可变数据结构。我们将要看一下：什么是不可变数据结构？为何它能很好地处理我们经常在函数式编程中使用的不可变特性？以及我们如何在 JavaScript 中使用不可变数据结构（既然你们都喜欢 JavaScript）\n\n## 自我介绍\n\n简单介绍一下我吧，我可能是这个屋里唯一的非 web 开发者。我是 Uber Research 的一个工程师。我和同事一起为科研资金领域的数据开发一种自定义查询语言。我也曾是 Recurse Center 的一个成员，Recurse Center 是纽约的一个很棒的编程社区。我也曾是 Outreach 项目的一个成员，如果你没听过 Outreach，（那么我可以告诉你）这个项目（做的事情是）通过给一些女性和亲属一些 Mozilla 的实习机会，来让他们参与到开源项目中来。所以，如果你想在讲座后找我聊这些事，我会很愿意。\n\n![](/css/images/9.jpg)\n\n\n## 函数式编程与纯函数\n\n你们或许知道我很喜欢函数式编程，我认为它很赞。有其他人同意我的想法嘛？（观众开始呼应）其他编程范式比如命令式或面向对象编程都会有一些令人头疼的缺点，而函数式编程则是避开这些缺点的较好方式。在函数式编程中，我们通常做的就是把我们的程序设想为一系列纯函数。这意味着，它们（指的是一系列纯函数）只是把输入转换为输出，这就是它们所做的所有事了，没有任何副作用，比如，在命令行中打印一些东东，改变一些全局变量等。 所以，我们的函数就成了“纯的”数据输入和数据输出，就像是一个数据转换器。另外一个“和纯函数手牵手”的，用来避免副作用的法宝是——不可变数据。\n\n![](/css/images/10.jpg)\n\n## 不可变数据简介\n\n不可变数据指的是，一旦创建就不会改变的数据。所以，这是一个很好的，避免意外在函数外面改变数据的方式。 如果一切都是不可变的， 你不能改变任何东西。 不可变性是另外一个很赞的概念。为什么说它很赞，我们等会再看。说到了“赞”这个词（英文是 Rock），我们先来说下石头（英文也是 Rock）。\n\n![](/css/images/11.jpg)\n\n## 用石头类比不可变数据\n\n这是个石头，不可变性和石头赞的方式很像。我最近参加了不少技术会议，我感觉技术会议上没有太多诗，所以我打算为大家读一首诗。\n\n> Nobody sits like this rock sits. You rock, rock. The rock just sits and is. You show us how to just sit here and that's what we need.\n> 诗词大意：无人能像这块巨石般岿然不动，你，巨石，岿然不动，好样的，你为我们证明坚持的力量，而这是我们全部所需。\n\n![](/css/images/12.jpg)\n\n这首诗很有道理，很有深意啊！它来自于《I heart Huckabees》。（下面开始鼓掌）别谢我，谢谢《I heart Huckabees》，一部很好的电影，去看看吧，很有趣。\n\n> 《I Heart Huckabees》，（中文名： 我爱哈克比），是一部喜剧、哲理电影，由詹森·舒瓦兹曼领衔主演。\n\n所以，这就是为何不可变数据很赞！它就是“坐在那里”，即坚持不变。一旦我们创建了它， 它从不改变。这很棒，因为这帮我们避免了一些变化的“头疼之处”。使用不可变数据，一些事情变得简单，而另外一些事情变得复杂。让我们一睹为快！\n\n## 可变性的缺点\n\n假如我们有个数组叫 `foo`，里面有一些数字。\n\n![](/css/images/13.jpg)\n\n这太无聊了，让我们把它变得更有趣一些。假如我们有一个动物园，里面有一些动物，这就比较有趣了。\n\n![](/css/images/14.jpg)\n\n我决定要改变一下这个动物园，我想把兔子换成外星人，这很酷。 我很开心，因为我想让这个动物园更加具有外太空感觉。 除了兔子那个位置，我没有改变这个动物园数组的其他任何地方。我觉得很棒，但我的同事觉得动物园里应该是地球上的动物，他无法统计外星人，他估计会说：“谁特么把外星人放到这里了？！我的程序都没法工作了！”\n\n![](/css/images/15.jpg)\n\n所以，可变性具有一系列的问题，我们不得不管理谁，改变了什么，在什么时间，谁在动物园放了什么动物。 我们不得不管理很多状态，这太头疼了！不管是个人还是一个团队。我们还会从代码中得到很多 bug，比如我同事只考虑了地球生物，没有把外星生物的情况考虑进去，所以程序就崩溃了。这是可变性的副作用让我们不开心的地方。让我们尝试用一下不可变的方式。\n\n![](/css/images/16.jpg)\n\n## 不可变的优缺点\n\n在不可变的世界，我的数组，我的动物园，一旦创建就永远不会变了，我也不能改变它。如果我想要个具有外星感觉的动物园，那么我需要拷贝一份相同尺寸的，作为我的原始数组。接下来，我就可以做一些修改了，比如把兔子换为外星人。然后，我把其他没变的项都拷贝过来。\n\n![](/css/images/17.jpg)\n\n这很棒，我的同事会很开心，因为程序没有崩溃，动物园里仍然是地球生物。但我得拷贝整个数组。我不得不为整个数组（甚至包括那些没有改变的项）分配一些空间。 这意味着，我的代码运行速度很慢，也消耗了很多内存。这些复杂的事很糟糕，因为拷贝浪费了大量的空间和时间，这让我们很难过，我们不想这样。\n\n![](/css/images/18.jpg)\n\n所以，如果我们想使用不可变，我们必须找到更好的方式。 幸运的是，很多聪明人很努力去思考解决这个问题，他们也找到一些很好的解决方案，来让我们更高效地使用不可变——不可变数据结构。\n\n## 不可变数据结构\n\n或许你之前听过不可变数据结构这个概念，特别是使用过函数式编程或者 React 的人。从技术层面上来讲，不可变数据结构就像是石头一样， 一旦你创建了它，它就不会变了。或许你也听过持久化数据结构。有时候，这两个数据结构具有互换性，但是，两者还是稍有不同。如果说不可变数据是永不改变的数据，那么持久化数据就是一种可以获取老版本数据的数据。我们创建了一个更改过的新数据，我让老数据就在新数据附近（指的是你可以通过一些方法获取到老数据）。\n\n![](/css/images/19.jpg)\n\n你或许听说过，不完全持久化数据结构可以让我们看到老数据，获取到老数据。但我们无法回去并更新任何老数据。我们能更新的就是当前的数据。 你或许还听说过，完全持久化数据结构。我们可以完全地进行时间旅行，我们可以回到过去，更新任何老数据。 这跟一些版本控制系统比如 Git 有异曲同工之妙。\n\n## 持久化不可变数据结构\n\n接下来，我们要讨论持久化不可变数据结构，它既持久化还不可变。让我们看它如何运作。这一切的关键在于，我们想让原始数据（比如最初的动物园）保存下来，但同时创建新数据也非常高效。\n\n![](/css/images/20.jpg)\n\n所以是什么魔法让这一切成为可能？ 我们需要让函数调用向空间时间复杂度之神跳舞祈祷吗？（小姐姐太文艺了）\n\n![](/css/images/21.jpg)\n\n## 树和共享\n\n不！其实非常简单——Trees & sharing（树和共享，这里的树就是数据结构中的树）。这很可爱吧！这两个简单的概念将会让我们得到一种很高效的不可变数据。\n\n![](/css/images/22.jpg)\n\n如何得到？让我们先来看看“树”，因为“树”也很酷，但不幸的是，我没有相关的诗词，抱歉。\n\n![](/css/images/23.jpg)\n\n想象我们能用“树”这种数据结构来表示动物园数组。我能做的一件事就是把所有的动物，即所有的值都放在叶子节点上，保持一个叶子节点两个值，这样它们才不会孤单。然后我们使用一个中间节点将它们连接起来，再用新的中间节点把这些中间节点也连接起来，一直往上直到根节点。这个根节点就是我们当前的“数组”，当然这个“数组”是用树这种数据结构来表示的。\n\n![](/css/images/24.jpg)\n\n\n## 如何更新\n\n有了这种类型的数据结构，我们如何更新一些值呢？\n\n![](/css/images/25.jpg)\n\n 假设我的动物园是不可变的，那么我如何得到一个新版本的动物园，里面有外星人呢？我需要的就是，找到包含我想改变的值的节点，拷贝这个节点，然后在新节点中进行值的修改，最后把相关的一系列中间节点也拷贝过来，那么新的根节点就是新版本的数据 。\n\n![](/css/images/26.jpg)\n\n这种通过拷贝路径（即一系列中间节点）来进行更新的技术叫——路径拷贝（path copying）。这个技术很酷，因为现在我不再需要去拷贝整个数组了，只需要拷贝要改变的节点和该节点到根节点的一系列中间节点，即路径。这样相当于我们把某种线性的算法转换成了对数型的，如此一来，性能就好多了。\n\n![](/css/images/27.jpg)\n\n另外还有一个好处就是，新旧两个版本的树之间有大量的共享节点，这节约了很多空间。我们复用了老版本中的很多没有改变的部分，然而在之前，我们是需要去拷贝这部分的。这意味着，大量的内存消耗不复存在，因为我不需要再去存储很多没有改变的拷贝了。这叫结构共享，因为我们在两个版本之间共享了树的很多结构。\n\n![](/css/images/28.jpg)\n\n\n## 如何查找\n\n我们已经讨论很多关于更新的技术，那么我们如何得到某个值呢？从结果来看，目前这个数据结构已经不只是个简单的树了，而是一种特殊的树，叫——[Trie 树](https://baike.baidu.com/item/Trie%E6%A0%91)。Trie 来自“retrieval”（取回）这个词。\n\n![](/css/images/29.jpg)\n\n在 Trie 树中，叶子节点存储值，路径代表键。你经常会看到 Trie 树被用来把单词作为键来存储。比如，我有一个 “tea” 作为键来存储，为了得到这个单词对应的值，我要做的就是从根节点遍历树，先到 “t”，再到 “e”，再到“a”。结果得到了3。\n\n![](/css/images/30.jpg)\n\n这很酷，但在我们的数据结构中，我们不会使用单词作为键，而会选择更有数组风格的index，也就是索引。\n\n![](/css/images/31.jpg)\n\n如果我们把索引当作二进制数字，我们可以假装那是单词，然后我们逐个比特向下遍历树，就像是先前的字母那样。让我们看看这如何运作。如果我想从数组中得到5，即索引为5的动物。我就把它转换为二进制，也就是101。然后我逐个比特查找它。先从根节点开始，然后进入分支1，然后分支0，最后分支1，得到了青蛙。\n\n![](/css/images/32.jpg)\n\n这很简单，但却非常强大。因为它让我们在这种树状数据结构很快地进行查找，而这个树状数据结构则让我们使用结构共享来更高效的描述不可变数据结构的新拷贝。另外，值得一提的是，我们没必要非使用二叉树来表示，二叉树很适合在幻灯片上展示，但在实际中通常都是32叉树。\n\n![](/css/images/33.jpg)\n\n在我们刚才看的那棵树中，每一层只有一个比特的信息，我们需要向下逐个比特查找。但是，如果我们有一颗32叉树，那么每一层将会有5个比特的信息（2^5=32）。举个例子吧！如果我们有个更大的数字，比如18977。如果每层只有一个比特，那么这将是个很深的树，一共有15层，太多，太长了 。如果我在每层创建更多的叉，那么我就可以把它变为5比特，进而也就只需要3层就可以了。其实这是个权衡问题，看你是想要更深的树，还是更多叉叉的树。通常，32叉树是个很好的权衡。\n\n![](/css/images/34.jpg)\n\n我们刚才看见的其实就是 Bitmapped Vector Trie。这是行话，你可以自行谷歌这种数据结构。\n\n![](/css/images/35.jpg)\n\n\n## 对象的情况\n\n对于数组来说，这很酷，有个索引，然后跳转过去。但是，对于对象呢？我们也想能够把对象和一些随意的键关联起来，不只是索引，我们想要非整型的键。这该如何工作呢？比如，M 对应 Monkey，P 对应 panda等。我们能做的就是把字母键使用哈希算法变为数字来表示键。所以每个键都有一个数字，也不需要有序什么的，因为对象本来就是无序的。然后我们就可以像先前一样用数字来进行查找了。\n\n![](/css/images/36.jpg)\n\n如果我想查找键为 F 的值，那么我就先对 F 进行哈希运算，然后得到一些数字，比如5吧！5的二进制就是101，然后像之前那样逐个比特来查找，最后得到了我们想要的动物，也就是青蛙。\n\n![](/css/images/37.jpg)\n\n其实，这是个 [Hash Array Mapped Trie](https://en.wikipedia.org/wiki/Hash_array_mapped_trie)。这个数据结构由 Phil Bagwell 和 Rich Hickey 发明，最初用在 Clojure 这门语言中来提升一些数据的运算效率。\n\n![](/css/images/38.jpg)\n\n关于该数据结构，还有很多优化方法，可以让它变得超级快，很多细节，我们今天就不一一说了。但是，这是个基本概念：树代表数据，结构共享让我们可以在新老版本之间复用更多信息，使用二进制代表键去向下查找指定值。\n\n## 概括\n\n概括一下：可变性引出很多问题。这些问题需要被解决，尤其是在函数式编程中，因为函数式编程的基本思想就是不能有副作用，只能用纯函数。纯函数不能改变任何数据，它只对输入做计算，然后返回全新的输出。另一方面，不可变则很棒。因为如果我用了不可变数据，我就不会把我同事的程序搞挂掉。但是，拷贝是个处理不可变数据的糟糕的方式，因为它不高效，不管是时间层面还是空间层面，而新老版本树中的结构共享是个高效的方法。\n\n![](/css/images/39.jpg)\n\n## Mori 和 Immutable.js 简介\n\n这些数据结构很酷，但是，我应该怎么用它们？在 JavaScript 中，有一些很棒的库帮你立马用上这些数据结构。有很多不同的方案，但我将会介绍其中几个。有一个库叫 Mori。基本来说，Mori 是个 ClojureScript 的一个 JavaScript 接口。它能让你使用上 ClojureScript 中的一些数据结构。这个库很有 Clojure 的感觉，很有函数式编程的感觉。API 是函数式的，我们等会看看。但这也使得这个库比较冷门。\n\n![](/css/images/40.jpg)\n\n另一个是 Immutable.js。这是 Facebook 出的一个库，由 Lee Byron建立。这是（刚才讨论的）那些数据结构的 JavaScript 实现。这个库很有原生 JavaScript 的感觉，没有任何 Clojure 背景。这意味着，它也有点面向对象风格的 API，尽管它仍然是返回新的数据结构，而不是改变可变的数据结构。\n\n![](/css/images/41.jpg)\n\n## Mori 和 Immutable.js 代码片段\n\n让我们看看它们长啥样。 这是 Mori。`vector` 就像是数组，`conj` 就像是 `push` 方法。从结果看，`a` 没有变化，而 `a2` 则是新的数据。\n\n![](/css/images/42.jpg)\n\n这是相同算法的 Immutable.js 版本。\n\n![](/css/images/43.jpg)\n\n刚才是数组，现在看看 map 这个数据结构。 这是 Mori 版本。\n\n![](/css/images/44.jpg)\n\n这是 Immutable.js 版本。\n\n![](/css/images/45.jpg)\n\n这是真正的不可变数据结构，如果你在命令行中查看它们，就会发现它们非常奇怪。非常建议大家使用这些库，看看效果如何。\n\n## Mori 和 Immutable.js 简单对比\n\n我可以在结束前简单对比一下它们。Mori 来自 Clojure 世界，它是 ClojureScript（的 JavaScript 接口）。但是 Immutable.js 则拥有更多像 `o.get()` 这样（面向对象风格的）方法，如果你喜欢在 JavaScript 中这么写。然而对我来说，Immutable.js 的这种写法会让我感到不和谐，因为这看起来很像是可变的写法，但实际并不是。为了获取更多的函数式编程的感觉，我更喜欢 Mori，因为我更喜欢所有都是纯函数，接受输入，返回输出，仅此而已。这里也提供了一些次要的性能对比，Mori 稍微快一些，而 Immutable.js 则相对小一点。它们都是好选择，试试吧！ 希望其中一个适合你。\n\n![](/css/images/46.jpg)\n\n这就是我的演讲，希望对大家有用。 加油向前，不要改变数据！（鼓掌）\n\n![](/css/images/47.jpg)\n\n\n","source":"_posts/immutable-data-structures-for-functional-js.md","raw":"---\ntitle: Anjana Vakil：函数式 JS 中的不可变数据结构（译）\ndate: 2017-10-22 17:32:00\ntags: [技术讲座, 函数式编程, 不可变数据结构, 数据结构与算法, 纯函数, Trie 树, Mori, Immutable.js, Clojure]\n---\n\n本文翻译整理自 YouTube 视频：\n\nhttps://www.youtube.com/watch?v=Wo0qiGPSV-s\n\n![](/css/images/8.jpg)\n\n<!--more-->\n\n## 开场白\n\n嗨，各位。大家好吗？我是 Anjana Vakil ，你们可以在推特上通过这个名字找到我。今天，我想讲的是，函数式 JS 中的不可变数据结构。我们将要看一下：什么是不可变数据结构？为何它能很好地处理我们经常在函数式编程中使用的不可变特性？以及我们如何在 JavaScript 中使用不可变数据结构（既然你们都喜欢 JavaScript）\n\n## 自我介绍\n\n简单介绍一下我吧，我可能是这个屋里唯一的非 web 开发者。我是 Uber Research 的一个工程师。我和同事一起为科研资金领域的数据开发一种自定义查询语言。我也曾是 Recurse Center 的一个成员，Recurse Center 是纽约的一个很棒的编程社区。我也曾是 Outreach 项目的一个成员，如果你没听过 Outreach，（那么我可以告诉你）这个项目（做的事情是）通过给一些女性和亲属一些 Mozilla 的实习机会，来让他们参与到开源项目中来。所以，如果你想在讲座后找我聊这些事，我会很愿意。\n\n![](/css/images/9.jpg)\n\n\n## 函数式编程与纯函数\n\n你们或许知道我很喜欢函数式编程，我认为它很赞。有其他人同意我的想法嘛？（观众开始呼应）其他编程范式比如命令式或面向对象编程都会有一些令人头疼的缺点，而函数式编程则是避开这些缺点的较好方式。在函数式编程中，我们通常做的就是把我们的程序设想为一系列纯函数。这意味着，它们（指的是一系列纯函数）只是把输入转换为输出，这就是它们所做的所有事了，没有任何副作用，比如，在命令行中打印一些东东，改变一些全局变量等。 所以，我们的函数就成了“纯的”数据输入和数据输出，就像是一个数据转换器。另外一个“和纯函数手牵手”的，用来避免副作用的法宝是——不可变数据。\n\n![](/css/images/10.jpg)\n\n## 不可变数据简介\n\n不可变数据指的是，一旦创建就不会改变的数据。所以，这是一个很好的，避免意外在函数外面改变数据的方式。 如果一切都是不可变的， 你不能改变任何东西。 不可变性是另外一个很赞的概念。为什么说它很赞，我们等会再看。说到了“赞”这个词（英文是 Rock），我们先来说下石头（英文也是 Rock）。\n\n![](/css/images/11.jpg)\n\n## 用石头类比不可变数据\n\n这是个石头，不可变性和石头赞的方式很像。我最近参加了不少技术会议，我感觉技术会议上没有太多诗，所以我打算为大家读一首诗。\n\n> Nobody sits like this rock sits. You rock, rock. The rock just sits and is. You show us how to just sit here and that's what we need.\n> 诗词大意：无人能像这块巨石般岿然不动，你，巨石，岿然不动，好样的，你为我们证明坚持的力量，而这是我们全部所需。\n\n![](/css/images/12.jpg)\n\n这首诗很有道理，很有深意啊！它来自于《I heart Huckabees》。（下面开始鼓掌）别谢我，谢谢《I heart Huckabees》，一部很好的电影，去看看吧，很有趣。\n\n> 《I Heart Huckabees》，（中文名： 我爱哈克比），是一部喜剧、哲理电影，由詹森·舒瓦兹曼领衔主演。\n\n所以，这就是为何不可变数据很赞！它就是“坐在那里”，即坚持不变。一旦我们创建了它， 它从不改变。这很棒，因为这帮我们避免了一些变化的“头疼之处”。使用不可变数据，一些事情变得简单，而另外一些事情变得复杂。让我们一睹为快！\n\n## 可变性的缺点\n\n假如我们有个数组叫 `foo`，里面有一些数字。\n\n![](/css/images/13.jpg)\n\n这太无聊了，让我们把它变得更有趣一些。假如我们有一个动物园，里面有一些动物，这就比较有趣了。\n\n![](/css/images/14.jpg)\n\n我决定要改变一下这个动物园，我想把兔子换成外星人，这很酷。 我很开心，因为我想让这个动物园更加具有外太空感觉。 除了兔子那个位置，我没有改变这个动物园数组的其他任何地方。我觉得很棒，但我的同事觉得动物园里应该是地球上的动物，他无法统计外星人，他估计会说：“谁特么把外星人放到这里了？！我的程序都没法工作了！”\n\n![](/css/images/15.jpg)\n\n所以，可变性具有一系列的问题，我们不得不管理谁，改变了什么，在什么时间，谁在动物园放了什么动物。 我们不得不管理很多状态，这太头疼了！不管是个人还是一个团队。我们还会从代码中得到很多 bug，比如我同事只考虑了地球生物，没有把外星生物的情况考虑进去，所以程序就崩溃了。这是可变性的副作用让我们不开心的地方。让我们尝试用一下不可变的方式。\n\n![](/css/images/16.jpg)\n\n## 不可变的优缺点\n\n在不可变的世界，我的数组，我的动物园，一旦创建就永远不会变了，我也不能改变它。如果我想要个具有外星感觉的动物园，那么我需要拷贝一份相同尺寸的，作为我的原始数组。接下来，我就可以做一些修改了，比如把兔子换为外星人。然后，我把其他没变的项都拷贝过来。\n\n![](/css/images/17.jpg)\n\n这很棒，我的同事会很开心，因为程序没有崩溃，动物园里仍然是地球生物。但我得拷贝整个数组。我不得不为整个数组（甚至包括那些没有改变的项）分配一些空间。 这意味着，我的代码运行速度很慢，也消耗了很多内存。这些复杂的事很糟糕，因为拷贝浪费了大量的空间和时间，这让我们很难过，我们不想这样。\n\n![](/css/images/18.jpg)\n\n所以，如果我们想使用不可变，我们必须找到更好的方式。 幸运的是，很多聪明人很努力去思考解决这个问题，他们也找到一些很好的解决方案，来让我们更高效地使用不可变——不可变数据结构。\n\n## 不可变数据结构\n\n或许你之前听过不可变数据结构这个概念，特别是使用过函数式编程或者 React 的人。从技术层面上来讲，不可变数据结构就像是石头一样， 一旦你创建了它，它就不会变了。或许你也听过持久化数据结构。有时候，这两个数据结构具有互换性，但是，两者还是稍有不同。如果说不可变数据是永不改变的数据，那么持久化数据就是一种可以获取老版本数据的数据。我们创建了一个更改过的新数据，我让老数据就在新数据附近（指的是你可以通过一些方法获取到老数据）。\n\n![](/css/images/19.jpg)\n\n你或许听说过，不完全持久化数据结构可以让我们看到老数据，获取到老数据。但我们无法回去并更新任何老数据。我们能更新的就是当前的数据。 你或许还听说过，完全持久化数据结构。我们可以完全地进行时间旅行，我们可以回到过去，更新任何老数据。 这跟一些版本控制系统比如 Git 有异曲同工之妙。\n\n## 持久化不可变数据结构\n\n接下来，我们要讨论持久化不可变数据结构，它既持久化还不可变。让我们看它如何运作。这一切的关键在于，我们想让原始数据（比如最初的动物园）保存下来，但同时创建新数据也非常高效。\n\n![](/css/images/20.jpg)\n\n所以是什么魔法让这一切成为可能？ 我们需要让函数调用向空间时间复杂度之神跳舞祈祷吗？（小姐姐太文艺了）\n\n![](/css/images/21.jpg)\n\n## 树和共享\n\n不！其实非常简单——Trees & sharing（树和共享，这里的树就是数据结构中的树）。这很可爱吧！这两个简单的概念将会让我们得到一种很高效的不可变数据。\n\n![](/css/images/22.jpg)\n\n如何得到？让我们先来看看“树”，因为“树”也很酷，但不幸的是，我没有相关的诗词，抱歉。\n\n![](/css/images/23.jpg)\n\n想象我们能用“树”这种数据结构来表示动物园数组。我能做的一件事就是把所有的动物，即所有的值都放在叶子节点上，保持一个叶子节点两个值，这样它们才不会孤单。然后我们使用一个中间节点将它们连接起来，再用新的中间节点把这些中间节点也连接起来，一直往上直到根节点。这个根节点就是我们当前的“数组”，当然这个“数组”是用树这种数据结构来表示的。\n\n![](/css/images/24.jpg)\n\n\n## 如何更新\n\n有了这种类型的数据结构，我们如何更新一些值呢？\n\n![](/css/images/25.jpg)\n\n 假设我的动物园是不可变的，那么我如何得到一个新版本的动物园，里面有外星人呢？我需要的就是，找到包含我想改变的值的节点，拷贝这个节点，然后在新节点中进行值的修改，最后把相关的一系列中间节点也拷贝过来，那么新的根节点就是新版本的数据 。\n\n![](/css/images/26.jpg)\n\n这种通过拷贝路径（即一系列中间节点）来进行更新的技术叫——路径拷贝（path copying）。这个技术很酷，因为现在我不再需要去拷贝整个数组了，只需要拷贝要改变的节点和该节点到根节点的一系列中间节点，即路径。这样相当于我们把某种线性的算法转换成了对数型的，如此一来，性能就好多了。\n\n![](/css/images/27.jpg)\n\n另外还有一个好处就是，新旧两个版本的树之间有大量的共享节点，这节约了很多空间。我们复用了老版本中的很多没有改变的部分，然而在之前，我们是需要去拷贝这部分的。这意味着，大量的内存消耗不复存在，因为我不需要再去存储很多没有改变的拷贝了。这叫结构共享，因为我们在两个版本之间共享了树的很多结构。\n\n![](/css/images/28.jpg)\n\n\n## 如何查找\n\n我们已经讨论很多关于更新的技术，那么我们如何得到某个值呢？从结果来看，目前这个数据结构已经不只是个简单的树了，而是一种特殊的树，叫——[Trie 树](https://baike.baidu.com/item/Trie%E6%A0%91)。Trie 来自“retrieval”（取回）这个词。\n\n![](/css/images/29.jpg)\n\n在 Trie 树中，叶子节点存储值，路径代表键。你经常会看到 Trie 树被用来把单词作为键来存储。比如，我有一个 “tea” 作为键来存储，为了得到这个单词对应的值，我要做的就是从根节点遍历树，先到 “t”，再到 “e”，再到“a”。结果得到了3。\n\n![](/css/images/30.jpg)\n\n这很酷，但在我们的数据结构中，我们不会使用单词作为键，而会选择更有数组风格的index，也就是索引。\n\n![](/css/images/31.jpg)\n\n如果我们把索引当作二进制数字，我们可以假装那是单词，然后我们逐个比特向下遍历树，就像是先前的字母那样。让我们看看这如何运作。如果我想从数组中得到5，即索引为5的动物。我就把它转换为二进制，也就是101。然后我逐个比特查找它。先从根节点开始，然后进入分支1，然后分支0，最后分支1，得到了青蛙。\n\n![](/css/images/32.jpg)\n\n这很简单，但却非常强大。因为它让我们在这种树状数据结构很快地进行查找，而这个树状数据结构则让我们使用结构共享来更高效的描述不可变数据结构的新拷贝。另外，值得一提的是，我们没必要非使用二叉树来表示，二叉树很适合在幻灯片上展示，但在实际中通常都是32叉树。\n\n![](/css/images/33.jpg)\n\n在我们刚才看的那棵树中，每一层只有一个比特的信息，我们需要向下逐个比特查找。但是，如果我们有一颗32叉树，那么每一层将会有5个比特的信息（2^5=32）。举个例子吧！如果我们有个更大的数字，比如18977。如果每层只有一个比特，那么这将是个很深的树，一共有15层，太多，太长了 。如果我在每层创建更多的叉，那么我就可以把它变为5比特，进而也就只需要3层就可以了。其实这是个权衡问题，看你是想要更深的树，还是更多叉叉的树。通常，32叉树是个很好的权衡。\n\n![](/css/images/34.jpg)\n\n我们刚才看见的其实就是 Bitmapped Vector Trie。这是行话，你可以自行谷歌这种数据结构。\n\n![](/css/images/35.jpg)\n\n\n## 对象的情况\n\n对于数组来说，这很酷，有个索引，然后跳转过去。但是，对于对象呢？我们也想能够把对象和一些随意的键关联起来，不只是索引，我们想要非整型的键。这该如何工作呢？比如，M 对应 Monkey，P 对应 panda等。我们能做的就是把字母键使用哈希算法变为数字来表示键。所以每个键都有一个数字，也不需要有序什么的，因为对象本来就是无序的。然后我们就可以像先前一样用数字来进行查找了。\n\n![](/css/images/36.jpg)\n\n如果我想查找键为 F 的值，那么我就先对 F 进行哈希运算，然后得到一些数字，比如5吧！5的二进制就是101，然后像之前那样逐个比特来查找，最后得到了我们想要的动物，也就是青蛙。\n\n![](/css/images/37.jpg)\n\n其实，这是个 [Hash Array Mapped Trie](https://en.wikipedia.org/wiki/Hash_array_mapped_trie)。这个数据结构由 Phil Bagwell 和 Rich Hickey 发明，最初用在 Clojure 这门语言中来提升一些数据的运算效率。\n\n![](/css/images/38.jpg)\n\n关于该数据结构，还有很多优化方法，可以让它变得超级快，很多细节，我们今天就不一一说了。但是，这是个基本概念：树代表数据，结构共享让我们可以在新老版本之间复用更多信息，使用二进制代表键去向下查找指定值。\n\n## 概括\n\n概括一下：可变性引出很多问题。这些问题需要被解决，尤其是在函数式编程中，因为函数式编程的基本思想就是不能有副作用，只能用纯函数。纯函数不能改变任何数据，它只对输入做计算，然后返回全新的输出。另一方面，不可变则很棒。因为如果我用了不可变数据，我就不会把我同事的程序搞挂掉。但是，拷贝是个处理不可变数据的糟糕的方式，因为它不高效，不管是时间层面还是空间层面，而新老版本树中的结构共享是个高效的方法。\n\n![](/css/images/39.jpg)\n\n## Mori 和 Immutable.js 简介\n\n这些数据结构很酷，但是，我应该怎么用它们？在 JavaScript 中，有一些很棒的库帮你立马用上这些数据结构。有很多不同的方案，但我将会介绍其中几个。有一个库叫 Mori。基本来说，Mori 是个 ClojureScript 的一个 JavaScript 接口。它能让你使用上 ClojureScript 中的一些数据结构。这个库很有 Clojure 的感觉，很有函数式编程的感觉。API 是函数式的，我们等会看看。但这也使得这个库比较冷门。\n\n![](/css/images/40.jpg)\n\n另一个是 Immutable.js。这是 Facebook 出的一个库，由 Lee Byron建立。这是（刚才讨论的）那些数据结构的 JavaScript 实现。这个库很有原生 JavaScript 的感觉，没有任何 Clojure 背景。这意味着，它也有点面向对象风格的 API，尽管它仍然是返回新的数据结构，而不是改变可变的数据结构。\n\n![](/css/images/41.jpg)\n\n## Mori 和 Immutable.js 代码片段\n\n让我们看看它们长啥样。 这是 Mori。`vector` 就像是数组，`conj` 就像是 `push` 方法。从结果看，`a` 没有变化，而 `a2` 则是新的数据。\n\n![](/css/images/42.jpg)\n\n这是相同算法的 Immutable.js 版本。\n\n![](/css/images/43.jpg)\n\n刚才是数组，现在看看 map 这个数据结构。 这是 Mori 版本。\n\n![](/css/images/44.jpg)\n\n这是 Immutable.js 版本。\n\n![](/css/images/45.jpg)\n\n这是真正的不可变数据结构，如果你在命令行中查看它们，就会发现它们非常奇怪。非常建议大家使用这些库，看看效果如何。\n\n## Mori 和 Immutable.js 简单对比\n\n我可以在结束前简单对比一下它们。Mori 来自 Clojure 世界，它是 ClojureScript（的 JavaScript 接口）。但是 Immutable.js 则拥有更多像 `o.get()` 这样（面向对象风格的）方法，如果你喜欢在 JavaScript 中这么写。然而对我来说，Immutable.js 的这种写法会让我感到不和谐，因为这看起来很像是可变的写法，但实际并不是。为了获取更多的函数式编程的感觉，我更喜欢 Mori，因为我更喜欢所有都是纯函数，接受输入，返回输出，仅此而已。这里也提供了一些次要的性能对比，Mori 稍微快一些，而 Immutable.js 则相对小一点。它们都是好选择，试试吧！ 希望其中一个适合你。\n\n![](/css/images/46.jpg)\n\n这就是我的演讲，希望对大家有用。 加油向前，不要改变数据！（鼓掌）\n\n![](/css/images/47.jpg)\n\n\n","slug":"immutable-data-structures-for-functional-js","published":1,"updated":"2019-05-01T08:10:29.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvli000xtgytp8mmn6yn","content":"<p>本文翻译整理自 YouTube 视频：</p>\n<p><a href=\"https://www.youtube.com/watch?v=Wo0qiGPSV-s\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=Wo0qiGPSV-s</a></p>\n<p><img src=\"/css/images/8.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"开场白\"><a href=\"#开场白\" class=\"headerlink\" title=\"开场白\"></a>开场白</h2><p>嗨，各位。大家好吗？我是 Anjana Vakil ，你们可以在推特上通过这个名字找到我。今天，我想讲的是，函数式 JS 中的不可变数据结构。我们将要看一下：什么是不可变数据结构？为何它能很好地处理我们经常在函数式编程中使用的不可变特性？以及我们如何在 JavaScript 中使用不可变数据结构（既然你们都喜欢 JavaScript）</p>\n<h2 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h2><p>简单介绍一下我吧，我可能是这个屋里唯一的非 web 开发者。我是 Uber Research 的一个工程师。我和同事一起为科研资金领域的数据开发一种自定义查询语言。我也曾是 Recurse Center 的一个成员，Recurse Center 是纽约的一个很棒的编程社区。我也曾是 Outreach 项目的一个成员，如果你没听过 Outreach，（那么我可以告诉你）这个项目（做的事情是）通过给一些女性和亲属一些 Mozilla 的实习机会，来让他们参与到开源项目中来。所以，如果你想在讲座后找我聊这些事，我会很愿意。</p>\n<p><img src=\"/css/images/9.jpg\" alt=\"\"></p>\n<h2 id=\"函数式编程与纯函数\"><a href=\"#函数式编程与纯函数\" class=\"headerlink\" title=\"函数式编程与纯函数\"></a>函数式编程与纯函数</h2><p>你们或许知道我很喜欢函数式编程，我认为它很赞。有其他人同意我的想法嘛？（观众开始呼应）其他编程范式比如命令式或面向对象编程都会有一些令人头疼的缺点，而函数式编程则是避开这些缺点的较好方式。在函数式编程中，我们通常做的就是把我们的程序设想为一系列纯函数。这意味着，它们（指的是一系列纯函数）只是把输入转换为输出，这就是它们所做的所有事了，没有任何副作用，比如，在命令行中打印一些东东，改变一些全局变量等。 所以，我们的函数就成了“纯的”数据输入和数据输出，就像是一个数据转换器。另外一个“和纯函数手牵手”的，用来避免副作用的法宝是——不可变数据。</p>\n<p><img src=\"/css/images/10.jpg\" alt=\"\"></p>\n<h2 id=\"不可变数据简介\"><a href=\"#不可变数据简介\" class=\"headerlink\" title=\"不可变数据简介\"></a>不可变数据简介</h2><p>不可变数据指的是，一旦创建就不会改变的数据。所以，这是一个很好的，避免意外在函数外面改变数据的方式。 如果一切都是不可变的， 你不能改变任何东西。 不可变性是另外一个很赞的概念。为什么说它很赞，我们等会再看。说到了“赞”这个词（英文是 Rock），我们先来说下石头（英文也是 Rock）。</p>\n<p><img src=\"/css/images/11.jpg\" alt=\"\"></p>\n<h2 id=\"用石头类比不可变数据\"><a href=\"#用石头类比不可变数据\" class=\"headerlink\" title=\"用石头类比不可变数据\"></a>用石头类比不可变数据</h2><p>这是个石头，不可变性和石头赞的方式很像。我最近参加了不少技术会议，我感觉技术会议上没有太多诗，所以我打算为大家读一首诗。</p>\n<blockquote>\n<p>Nobody sits like this rock sits. You rock, rock. The rock just sits and is. You show us how to just sit here and that’s what we need.<br>诗词大意：无人能像这块巨石般岿然不动，你，巨石，岿然不动，好样的，你为我们证明坚持的力量，而这是我们全部所需。</p>\n</blockquote>\n<p><img src=\"/css/images/12.jpg\" alt=\"\"></p>\n<p>这首诗很有道理，很有深意啊！它来自于《I heart Huckabees》。（下面开始鼓掌）别谢我，谢谢《I heart Huckabees》，一部很好的电影，去看看吧，很有趣。</p>\n<blockquote>\n<p>《I Heart Huckabees》，（中文名： 我爱哈克比），是一部喜剧、哲理电影，由詹森·舒瓦兹曼领衔主演。</p>\n</blockquote>\n<p>所以，这就是为何不可变数据很赞！它就是“坐在那里”，即坚持不变。一旦我们创建了它， 它从不改变。这很棒，因为这帮我们避免了一些变化的“头疼之处”。使用不可变数据，一些事情变得简单，而另外一些事情变得复杂。让我们一睹为快！</p>\n<h2 id=\"可变性的缺点\"><a href=\"#可变性的缺点\" class=\"headerlink\" title=\"可变性的缺点\"></a>可变性的缺点</h2><p>假如我们有个数组叫 <code>foo</code>，里面有一些数字。</p>\n<p><img src=\"/css/images/13.jpg\" alt=\"\"></p>\n<p>这太无聊了，让我们把它变得更有趣一些。假如我们有一个动物园，里面有一些动物，这就比较有趣了。</p>\n<p><img src=\"/css/images/14.jpg\" alt=\"\"></p>\n<p>我决定要改变一下这个动物园，我想把兔子换成外星人，这很酷。 我很开心，因为我想让这个动物园更加具有外太空感觉。 除了兔子那个位置，我没有改变这个动物园数组的其他任何地方。我觉得很棒，但我的同事觉得动物园里应该是地球上的动物，他无法统计外星人，他估计会说：“谁特么把外星人放到这里了？！我的程序都没法工作了！”</p>\n<p><img src=\"/css/images/15.jpg\" alt=\"\"></p>\n<p>所以，可变性具有一系列的问题，我们不得不管理谁，改变了什么，在什么时间，谁在动物园放了什么动物。 我们不得不管理很多状态，这太头疼了！不管是个人还是一个团队。我们还会从代码中得到很多 bug，比如我同事只考虑了地球生物，没有把外星生物的情况考虑进去，所以程序就崩溃了。这是可变性的副作用让我们不开心的地方。让我们尝试用一下不可变的方式。</p>\n<p><img src=\"/css/images/16.jpg\" alt=\"\"></p>\n<h2 id=\"不可变的优缺点\"><a href=\"#不可变的优缺点\" class=\"headerlink\" title=\"不可变的优缺点\"></a>不可变的优缺点</h2><p>在不可变的世界，我的数组，我的动物园，一旦创建就永远不会变了，我也不能改变它。如果我想要个具有外星感觉的动物园，那么我需要拷贝一份相同尺寸的，作为我的原始数组。接下来，我就可以做一些修改了，比如把兔子换为外星人。然后，我把其他没变的项都拷贝过来。</p>\n<p><img src=\"/css/images/17.jpg\" alt=\"\"></p>\n<p>这很棒，我的同事会很开心，因为程序没有崩溃，动物园里仍然是地球生物。但我得拷贝整个数组。我不得不为整个数组（甚至包括那些没有改变的项）分配一些空间。 这意味着，我的代码运行速度很慢，也消耗了很多内存。这些复杂的事很糟糕，因为拷贝浪费了大量的空间和时间，这让我们很难过，我们不想这样。</p>\n<p><img src=\"/css/images/18.jpg\" alt=\"\"></p>\n<p>所以，如果我们想使用不可变，我们必须找到更好的方式。 幸运的是，很多聪明人很努力去思考解决这个问题，他们也找到一些很好的解决方案，来让我们更高效地使用不可变——不可变数据结构。</p>\n<h2 id=\"不可变数据结构\"><a href=\"#不可变数据结构\" class=\"headerlink\" title=\"不可变数据结构\"></a>不可变数据结构</h2><p>或许你之前听过不可变数据结构这个概念，特别是使用过函数式编程或者 React 的人。从技术层面上来讲，不可变数据结构就像是石头一样， 一旦你创建了它，它就不会变了。或许你也听过持久化数据结构。有时候，这两个数据结构具有互换性，但是，两者还是稍有不同。如果说不可变数据是永不改变的数据，那么持久化数据就是一种可以获取老版本数据的数据。我们创建了一个更改过的新数据，我让老数据就在新数据附近（指的是你可以通过一些方法获取到老数据）。</p>\n<p><img src=\"/css/images/19.jpg\" alt=\"\"></p>\n<p>你或许听说过，不完全持久化数据结构可以让我们看到老数据，获取到老数据。但我们无法回去并更新任何老数据。我们能更新的就是当前的数据。 你或许还听说过，完全持久化数据结构。我们可以完全地进行时间旅行，我们可以回到过去，更新任何老数据。 这跟一些版本控制系统比如 Git 有异曲同工之妙。</p>\n<h2 id=\"持久化不可变数据结构\"><a href=\"#持久化不可变数据结构\" class=\"headerlink\" title=\"持久化不可变数据结构\"></a>持久化不可变数据结构</h2><p>接下来，我们要讨论持久化不可变数据结构，它既持久化还不可变。让我们看它如何运作。这一切的关键在于，我们想让原始数据（比如最初的动物园）保存下来，但同时创建新数据也非常高效。</p>\n<p><img src=\"/css/images/20.jpg\" alt=\"\"></p>\n<p>所以是什么魔法让这一切成为可能？ 我们需要让函数调用向空间时间复杂度之神跳舞祈祷吗？（小姐姐太文艺了）</p>\n<p><img src=\"/css/images/21.jpg\" alt=\"\"></p>\n<h2 id=\"树和共享\"><a href=\"#树和共享\" class=\"headerlink\" title=\"树和共享\"></a>树和共享</h2><p>不！其实非常简单——Trees &amp; sharing（树和共享，这里的树就是数据结构中的树）。这很可爱吧！这两个简单的概念将会让我们得到一种很高效的不可变数据。</p>\n<p><img src=\"/css/images/22.jpg\" alt=\"\"></p>\n<p>如何得到？让我们先来看看“树”，因为“树”也很酷，但不幸的是，我没有相关的诗词，抱歉。</p>\n<p><img src=\"/css/images/23.jpg\" alt=\"\"></p>\n<p>想象我们能用“树”这种数据结构来表示动物园数组。我能做的一件事就是把所有的动物，即所有的值都放在叶子节点上，保持一个叶子节点两个值，这样它们才不会孤单。然后我们使用一个中间节点将它们连接起来，再用新的中间节点把这些中间节点也连接起来，一直往上直到根节点。这个根节点就是我们当前的“数组”，当然这个“数组”是用树这种数据结构来表示的。</p>\n<p><img src=\"/css/images/24.jpg\" alt=\"\"></p>\n<h2 id=\"如何更新\"><a href=\"#如何更新\" class=\"headerlink\" title=\"如何更新\"></a>如何更新</h2><p>有了这种类型的数据结构，我们如何更新一些值呢？</p>\n<p><img src=\"/css/images/25.jpg\" alt=\"\"></p>\n<p> 假设我的动物园是不可变的，那么我如何得到一个新版本的动物园，里面有外星人呢？我需要的就是，找到包含我想改变的值的节点，拷贝这个节点，然后在新节点中进行值的修改，最后把相关的一系列中间节点也拷贝过来，那么新的根节点就是新版本的数据 。</p>\n<p><img src=\"/css/images/26.jpg\" alt=\"\"></p>\n<p>这种通过拷贝路径（即一系列中间节点）来进行更新的技术叫——路径拷贝（path copying）。这个技术很酷，因为现在我不再需要去拷贝整个数组了，只需要拷贝要改变的节点和该节点到根节点的一系列中间节点，即路径。这样相当于我们把某种线性的算法转换成了对数型的，如此一来，性能就好多了。</p>\n<p><img src=\"/css/images/27.jpg\" alt=\"\"></p>\n<p>另外还有一个好处就是，新旧两个版本的树之间有大量的共享节点，这节约了很多空间。我们复用了老版本中的很多没有改变的部分，然而在之前，我们是需要去拷贝这部分的。这意味着，大量的内存消耗不复存在，因为我不需要再去存储很多没有改变的拷贝了。这叫结构共享，因为我们在两个版本之间共享了树的很多结构。</p>\n<p><img src=\"/css/images/28.jpg\" alt=\"\"></p>\n<h2 id=\"如何查找\"><a href=\"#如何查找\" class=\"headerlink\" title=\"如何查找\"></a>如何查找</h2><p>我们已经讨论很多关于更新的技术，那么我们如何得到某个值呢？从结果来看，目前这个数据结构已经不只是个简单的树了，而是一种特殊的树，叫——<a href=\"https://baike.baidu.com/item/Trie%E6%A0%91\" target=\"_blank\" rel=\"noopener\">Trie 树</a>。Trie 来自“retrieval”（取回）这个词。</p>\n<p><img src=\"/css/images/29.jpg\" alt=\"\"></p>\n<p>在 Trie 树中，叶子节点存储值，路径代表键。你经常会看到 Trie 树被用来把单词作为键来存储。比如，我有一个 “tea” 作为键来存储，为了得到这个单词对应的值，我要做的就是从根节点遍历树，先到 “t”，再到 “e”，再到“a”。结果得到了3。</p>\n<p><img src=\"/css/images/30.jpg\" alt=\"\"></p>\n<p>这很酷，但在我们的数据结构中，我们不会使用单词作为键，而会选择更有数组风格的index，也就是索引。</p>\n<p><img src=\"/css/images/31.jpg\" alt=\"\"></p>\n<p>如果我们把索引当作二进制数字，我们可以假装那是单词，然后我们逐个比特向下遍历树，就像是先前的字母那样。让我们看看这如何运作。如果我想从数组中得到5，即索引为5的动物。我就把它转换为二进制，也就是101。然后我逐个比特查找它。先从根节点开始，然后进入分支1，然后分支0，最后分支1，得到了青蛙。</p>\n<p><img src=\"/css/images/32.jpg\" alt=\"\"></p>\n<p>这很简单，但却非常强大。因为它让我们在这种树状数据结构很快地进行查找，而这个树状数据结构则让我们使用结构共享来更高效的描述不可变数据结构的新拷贝。另外，值得一提的是，我们没必要非使用二叉树来表示，二叉树很适合在幻灯片上展示，但在实际中通常都是32叉树。</p>\n<p><img src=\"/css/images/33.jpg\" alt=\"\"></p>\n<p>在我们刚才看的那棵树中，每一层只有一个比特的信息，我们需要向下逐个比特查找。但是，如果我们有一颗32叉树，那么每一层将会有5个比特的信息（2^5=32）。举个例子吧！如果我们有个更大的数字，比如18977。如果每层只有一个比特，那么这将是个很深的树，一共有15层，太多，太长了 。如果我在每层创建更多的叉，那么我就可以把它变为5比特，进而也就只需要3层就可以了。其实这是个权衡问题，看你是想要更深的树，还是更多叉叉的树。通常，32叉树是个很好的权衡。</p>\n<p><img src=\"/css/images/34.jpg\" alt=\"\"></p>\n<p>我们刚才看见的其实就是 Bitmapped Vector Trie。这是行话，你可以自行谷歌这种数据结构。</p>\n<p><img src=\"/css/images/35.jpg\" alt=\"\"></p>\n<h2 id=\"对象的情况\"><a href=\"#对象的情况\" class=\"headerlink\" title=\"对象的情况\"></a>对象的情况</h2><p>对于数组来说，这很酷，有个索引，然后跳转过去。但是，对于对象呢？我们也想能够把对象和一些随意的键关联起来，不只是索引，我们想要非整型的键。这该如何工作呢？比如，M 对应 Monkey，P 对应 panda等。我们能做的就是把字母键使用哈希算法变为数字来表示键。所以每个键都有一个数字，也不需要有序什么的，因为对象本来就是无序的。然后我们就可以像先前一样用数字来进行查找了。</p>\n<p><img src=\"/css/images/36.jpg\" alt=\"\"></p>\n<p>如果我想查找键为 F 的值，那么我就先对 F 进行哈希运算，然后得到一些数字，比如5吧！5的二进制就是101，然后像之前那样逐个比特来查找，最后得到了我们想要的动物，也就是青蛙。</p>\n<p><img src=\"/css/images/37.jpg\" alt=\"\"></p>\n<p>其实，这是个 <a href=\"https://en.wikipedia.org/wiki/Hash_array_mapped_trie\" target=\"_blank\" rel=\"noopener\">Hash Array Mapped Trie</a>。这个数据结构由 Phil Bagwell 和 Rich Hickey 发明，最初用在 Clojure 这门语言中来提升一些数据的运算效率。</p>\n<p><img src=\"/css/images/38.jpg\" alt=\"\"></p>\n<p>关于该数据结构，还有很多优化方法，可以让它变得超级快，很多细节，我们今天就不一一说了。但是，这是个基本概念：树代表数据，结构共享让我们可以在新老版本之间复用更多信息，使用二进制代表键去向下查找指定值。</p>\n<h2 id=\"概括\"><a href=\"#概括\" class=\"headerlink\" title=\"概括\"></a>概括</h2><p>概括一下：可变性引出很多问题。这些问题需要被解决，尤其是在函数式编程中，因为函数式编程的基本思想就是不能有副作用，只能用纯函数。纯函数不能改变任何数据，它只对输入做计算，然后返回全新的输出。另一方面，不可变则很棒。因为如果我用了不可变数据，我就不会把我同事的程序搞挂掉。但是，拷贝是个处理不可变数据的糟糕的方式，因为它不高效，不管是时间层面还是空间层面，而新老版本树中的结构共享是个高效的方法。</p>\n<p><img src=\"/css/images/39.jpg\" alt=\"\"></p>\n<h2 id=\"Mori-和-Immutable-js-简介\"><a href=\"#Mori-和-Immutable-js-简介\" class=\"headerlink\" title=\"Mori 和 Immutable.js 简介\"></a>Mori 和 Immutable.js 简介</h2><p>这些数据结构很酷，但是，我应该怎么用它们？在 JavaScript 中，有一些很棒的库帮你立马用上这些数据结构。有很多不同的方案，但我将会介绍其中几个。有一个库叫 Mori。基本来说，Mori 是个 ClojureScript 的一个 JavaScript 接口。它能让你使用上 ClojureScript 中的一些数据结构。这个库很有 Clojure 的感觉，很有函数式编程的感觉。API 是函数式的，我们等会看看。但这也使得这个库比较冷门。</p>\n<p><img src=\"/css/images/40.jpg\" alt=\"\"></p>\n<p>另一个是 Immutable.js。这是 Facebook 出的一个库，由 Lee Byron建立。这是（刚才讨论的）那些数据结构的 JavaScript 实现。这个库很有原生 JavaScript 的感觉，没有任何 Clojure 背景。这意味着，它也有点面向对象风格的 API，尽管它仍然是返回新的数据结构，而不是改变可变的数据结构。</p>\n<p><img src=\"/css/images/41.jpg\" alt=\"\"></p>\n<h2 id=\"Mori-和-Immutable-js-代码片段\"><a href=\"#Mori-和-Immutable-js-代码片段\" class=\"headerlink\" title=\"Mori 和 Immutable.js 代码片段\"></a>Mori 和 Immutable.js 代码片段</h2><p>让我们看看它们长啥样。 这是 Mori。<code>vector</code> 就像是数组，<code>conj</code> 就像是 <code>push</code> 方法。从结果看，<code>a</code> 没有变化，而 <code>a2</code> 则是新的数据。</p>\n<p><img src=\"/css/images/42.jpg\" alt=\"\"></p>\n<p>这是相同算法的 Immutable.js 版本。</p>\n<p><img src=\"/css/images/43.jpg\" alt=\"\"></p>\n<p>刚才是数组，现在看看 map 这个数据结构。 这是 Mori 版本。</p>\n<p><img src=\"/css/images/44.jpg\" alt=\"\"></p>\n<p>这是 Immutable.js 版本。</p>\n<p><img src=\"/css/images/45.jpg\" alt=\"\"></p>\n<p>这是真正的不可变数据结构，如果你在命令行中查看它们，就会发现它们非常奇怪。非常建议大家使用这些库，看看效果如何。</p>\n<h2 id=\"Mori-和-Immutable-js-简单对比\"><a href=\"#Mori-和-Immutable-js-简单对比\" class=\"headerlink\" title=\"Mori 和 Immutable.js 简单对比\"></a>Mori 和 Immutable.js 简单对比</h2><p>我可以在结束前简单对比一下它们。Mori 来自 Clojure 世界，它是 ClojureScript（的 JavaScript 接口）。但是 Immutable.js 则拥有更多像 <code>o.get()</code> 这样（面向对象风格的）方法，如果你喜欢在 JavaScript 中这么写。然而对我来说，Immutable.js 的这种写法会让我感到不和谐，因为这看起来很像是可变的写法，但实际并不是。为了获取更多的函数式编程的感觉，我更喜欢 Mori，因为我更喜欢所有都是纯函数，接受输入，返回输出，仅此而已。这里也提供了一些次要的性能对比，Mori 稍微快一些，而 Immutable.js 则相对小一点。它们都是好选择，试试吧！ 希望其中一个适合你。</p>\n<p><img src=\"/css/images/46.jpg\" alt=\"\"></p>\n<p>这就是我的演讲，希望对大家有用。 加油向前，不要改变数据！（鼓掌）</p>\n<p><img src=\"/css/images/47.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>本文翻译整理自 YouTube 视频：</p>\n<p><a href=\"https://www.youtube.com/watch?v=Wo0qiGPSV-s\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=Wo0qiGPSV-s</a></p>\n<p><img src=\"/css/images/8.jpg\" alt=\"\"></p>","more":"<h2 id=\"开场白\"><a href=\"#开场白\" class=\"headerlink\" title=\"开场白\"></a>开场白</h2><p>嗨，各位。大家好吗？我是 Anjana Vakil ，你们可以在推特上通过这个名字找到我。今天，我想讲的是，函数式 JS 中的不可变数据结构。我们将要看一下：什么是不可变数据结构？为何它能很好地处理我们经常在函数式编程中使用的不可变特性？以及我们如何在 JavaScript 中使用不可变数据结构（既然你们都喜欢 JavaScript）</p>\n<h2 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h2><p>简单介绍一下我吧，我可能是这个屋里唯一的非 web 开发者。我是 Uber Research 的一个工程师。我和同事一起为科研资金领域的数据开发一种自定义查询语言。我也曾是 Recurse Center 的一个成员，Recurse Center 是纽约的一个很棒的编程社区。我也曾是 Outreach 项目的一个成员，如果你没听过 Outreach，（那么我可以告诉你）这个项目（做的事情是）通过给一些女性和亲属一些 Mozilla 的实习机会，来让他们参与到开源项目中来。所以，如果你想在讲座后找我聊这些事，我会很愿意。</p>\n<p><img src=\"/css/images/9.jpg\" alt=\"\"></p>\n<h2 id=\"函数式编程与纯函数\"><a href=\"#函数式编程与纯函数\" class=\"headerlink\" title=\"函数式编程与纯函数\"></a>函数式编程与纯函数</h2><p>你们或许知道我很喜欢函数式编程，我认为它很赞。有其他人同意我的想法嘛？（观众开始呼应）其他编程范式比如命令式或面向对象编程都会有一些令人头疼的缺点，而函数式编程则是避开这些缺点的较好方式。在函数式编程中，我们通常做的就是把我们的程序设想为一系列纯函数。这意味着，它们（指的是一系列纯函数）只是把输入转换为输出，这就是它们所做的所有事了，没有任何副作用，比如，在命令行中打印一些东东，改变一些全局变量等。 所以，我们的函数就成了“纯的”数据输入和数据输出，就像是一个数据转换器。另外一个“和纯函数手牵手”的，用来避免副作用的法宝是——不可变数据。</p>\n<p><img src=\"/css/images/10.jpg\" alt=\"\"></p>\n<h2 id=\"不可变数据简介\"><a href=\"#不可变数据简介\" class=\"headerlink\" title=\"不可变数据简介\"></a>不可变数据简介</h2><p>不可变数据指的是，一旦创建就不会改变的数据。所以，这是一个很好的，避免意外在函数外面改变数据的方式。 如果一切都是不可变的， 你不能改变任何东西。 不可变性是另外一个很赞的概念。为什么说它很赞，我们等会再看。说到了“赞”这个词（英文是 Rock），我们先来说下石头（英文也是 Rock）。</p>\n<p><img src=\"/css/images/11.jpg\" alt=\"\"></p>\n<h2 id=\"用石头类比不可变数据\"><a href=\"#用石头类比不可变数据\" class=\"headerlink\" title=\"用石头类比不可变数据\"></a>用石头类比不可变数据</h2><p>这是个石头，不可变性和石头赞的方式很像。我最近参加了不少技术会议，我感觉技术会议上没有太多诗，所以我打算为大家读一首诗。</p>\n<blockquote>\n<p>Nobody sits like this rock sits. You rock, rock. The rock just sits and is. You show us how to just sit here and that’s what we need.<br>诗词大意：无人能像这块巨石般岿然不动，你，巨石，岿然不动，好样的，你为我们证明坚持的力量，而这是我们全部所需。</p>\n</blockquote>\n<p><img src=\"/css/images/12.jpg\" alt=\"\"></p>\n<p>这首诗很有道理，很有深意啊！它来自于《I heart Huckabees》。（下面开始鼓掌）别谢我，谢谢《I heart Huckabees》，一部很好的电影，去看看吧，很有趣。</p>\n<blockquote>\n<p>《I Heart Huckabees》，（中文名： 我爱哈克比），是一部喜剧、哲理电影，由詹森·舒瓦兹曼领衔主演。</p>\n</blockquote>\n<p>所以，这就是为何不可变数据很赞！它就是“坐在那里”，即坚持不变。一旦我们创建了它， 它从不改变。这很棒，因为这帮我们避免了一些变化的“头疼之处”。使用不可变数据，一些事情变得简单，而另外一些事情变得复杂。让我们一睹为快！</p>\n<h2 id=\"可变性的缺点\"><a href=\"#可变性的缺点\" class=\"headerlink\" title=\"可变性的缺点\"></a>可变性的缺点</h2><p>假如我们有个数组叫 <code>foo</code>，里面有一些数字。</p>\n<p><img src=\"/css/images/13.jpg\" alt=\"\"></p>\n<p>这太无聊了，让我们把它变得更有趣一些。假如我们有一个动物园，里面有一些动物，这就比较有趣了。</p>\n<p><img src=\"/css/images/14.jpg\" alt=\"\"></p>\n<p>我决定要改变一下这个动物园，我想把兔子换成外星人，这很酷。 我很开心，因为我想让这个动物园更加具有外太空感觉。 除了兔子那个位置，我没有改变这个动物园数组的其他任何地方。我觉得很棒，但我的同事觉得动物园里应该是地球上的动物，他无法统计外星人，他估计会说：“谁特么把外星人放到这里了？！我的程序都没法工作了！”</p>\n<p><img src=\"/css/images/15.jpg\" alt=\"\"></p>\n<p>所以，可变性具有一系列的问题，我们不得不管理谁，改变了什么，在什么时间，谁在动物园放了什么动物。 我们不得不管理很多状态，这太头疼了！不管是个人还是一个团队。我们还会从代码中得到很多 bug，比如我同事只考虑了地球生物，没有把外星生物的情况考虑进去，所以程序就崩溃了。这是可变性的副作用让我们不开心的地方。让我们尝试用一下不可变的方式。</p>\n<p><img src=\"/css/images/16.jpg\" alt=\"\"></p>\n<h2 id=\"不可变的优缺点\"><a href=\"#不可变的优缺点\" class=\"headerlink\" title=\"不可变的优缺点\"></a>不可变的优缺点</h2><p>在不可变的世界，我的数组，我的动物园，一旦创建就永远不会变了，我也不能改变它。如果我想要个具有外星感觉的动物园，那么我需要拷贝一份相同尺寸的，作为我的原始数组。接下来，我就可以做一些修改了，比如把兔子换为外星人。然后，我把其他没变的项都拷贝过来。</p>\n<p><img src=\"/css/images/17.jpg\" alt=\"\"></p>\n<p>这很棒，我的同事会很开心，因为程序没有崩溃，动物园里仍然是地球生物。但我得拷贝整个数组。我不得不为整个数组（甚至包括那些没有改变的项）分配一些空间。 这意味着，我的代码运行速度很慢，也消耗了很多内存。这些复杂的事很糟糕，因为拷贝浪费了大量的空间和时间，这让我们很难过，我们不想这样。</p>\n<p><img src=\"/css/images/18.jpg\" alt=\"\"></p>\n<p>所以，如果我们想使用不可变，我们必须找到更好的方式。 幸运的是，很多聪明人很努力去思考解决这个问题，他们也找到一些很好的解决方案，来让我们更高效地使用不可变——不可变数据结构。</p>\n<h2 id=\"不可变数据结构\"><a href=\"#不可变数据结构\" class=\"headerlink\" title=\"不可变数据结构\"></a>不可变数据结构</h2><p>或许你之前听过不可变数据结构这个概念，特别是使用过函数式编程或者 React 的人。从技术层面上来讲，不可变数据结构就像是石头一样， 一旦你创建了它，它就不会变了。或许你也听过持久化数据结构。有时候，这两个数据结构具有互换性，但是，两者还是稍有不同。如果说不可变数据是永不改变的数据，那么持久化数据就是一种可以获取老版本数据的数据。我们创建了一个更改过的新数据，我让老数据就在新数据附近（指的是你可以通过一些方法获取到老数据）。</p>\n<p><img src=\"/css/images/19.jpg\" alt=\"\"></p>\n<p>你或许听说过，不完全持久化数据结构可以让我们看到老数据，获取到老数据。但我们无法回去并更新任何老数据。我们能更新的就是当前的数据。 你或许还听说过，完全持久化数据结构。我们可以完全地进行时间旅行，我们可以回到过去，更新任何老数据。 这跟一些版本控制系统比如 Git 有异曲同工之妙。</p>\n<h2 id=\"持久化不可变数据结构\"><a href=\"#持久化不可变数据结构\" class=\"headerlink\" title=\"持久化不可变数据结构\"></a>持久化不可变数据结构</h2><p>接下来，我们要讨论持久化不可变数据结构，它既持久化还不可变。让我们看它如何运作。这一切的关键在于，我们想让原始数据（比如最初的动物园）保存下来，但同时创建新数据也非常高效。</p>\n<p><img src=\"/css/images/20.jpg\" alt=\"\"></p>\n<p>所以是什么魔法让这一切成为可能？ 我们需要让函数调用向空间时间复杂度之神跳舞祈祷吗？（小姐姐太文艺了）</p>\n<p><img src=\"/css/images/21.jpg\" alt=\"\"></p>\n<h2 id=\"树和共享\"><a href=\"#树和共享\" class=\"headerlink\" title=\"树和共享\"></a>树和共享</h2><p>不！其实非常简单——Trees &amp; sharing（树和共享，这里的树就是数据结构中的树）。这很可爱吧！这两个简单的概念将会让我们得到一种很高效的不可变数据。</p>\n<p><img src=\"/css/images/22.jpg\" alt=\"\"></p>\n<p>如何得到？让我们先来看看“树”，因为“树”也很酷，但不幸的是，我没有相关的诗词，抱歉。</p>\n<p><img src=\"/css/images/23.jpg\" alt=\"\"></p>\n<p>想象我们能用“树”这种数据结构来表示动物园数组。我能做的一件事就是把所有的动物，即所有的值都放在叶子节点上，保持一个叶子节点两个值，这样它们才不会孤单。然后我们使用一个中间节点将它们连接起来，再用新的中间节点把这些中间节点也连接起来，一直往上直到根节点。这个根节点就是我们当前的“数组”，当然这个“数组”是用树这种数据结构来表示的。</p>\n<p><img src=\"/css/images/24.jpg\" alt=\"\"></p>\n<h2 id=\"如何更新\"><a href=\"#如何更新\" class=\"headerlink\" title=\"如何更新\"></a>如何更新</h2><p>有了这种类型的数据结构，我们如何更新一些值呢？</p>\n<p><img src=\"/css/images/25.jpg\" alt=\"\"></p>\n<p> 假设我的动物园是不可变的，那么我如何得到一个新版本的动物园，里面有外星人呢？我需要的就是，找到包含我想改变的值的节点，拷贝这个节点，然后在新节点中进行值的修改，最后把相关的一系列中间节点也拷贝过来，那么新的根节点就是新版本的数据 。</p>\n<p><img src=\"/css/images/26.jpg\" alt=\"\"></p>\n<p>这种通过拷贝路径（即一系列中间节点）来进行更新的技术叫——路径拷贝（path copying）。这个技术很酷，因为现在我不再需要去拷贝整个数组了，只需要拷贝要改变的节点和该节点到根节点的一系列中间节点，即路径。这样相当于我们把某种线性的算法转换成了对数型的，如此一来，性能就好多了。</p>\n<p><img src=\"/css/images/27.jpg\" alt=\"\"></p>\n<p>另外还有一个好处就是，新旧两个版本的树之间有大量的共享节点，这节约了很多空间。我们复用了老版本中的很多没有改变的部分，然而在之前，我们是需要去拷贝这部分的。这意味着，大量的内存消耗不复存在，因为我不需要再去存储很多没有改变的拷贝了。这叫结构共享，因为我们在两个版本之间共享了树的很多结构。</p>\n<p><img src=\"/css/images/28.jpg\" alt=\"\"></p>\n<h2 id=\"如何查找\"><a href=\"#如何查找\" class=\"headerlink\" title=\"如何查找\"></a>如何查找</h2><p>我们已经讨论很多关于更新的技术，那么我们如何得到某个值呢？从结果来看，目前这个数据结构已经不只是个简单的树了，而是一种特殊的树，叫——<a href=\"https://baike.baidu.com/item/Trie%E6%A0%91\" target=\"_blank\" rel=\"noopener\">Trie 树</a>。Trie 来自“retrieval”（取回）这个词。</p>\n<p><img src=\"/css/images/29.jpg\" alt=\"\"></p>\n<p>在 Trie 树中，叶子节点存储值，路径代表键。你经常会看到 Trie 树被用来把单词作为键来存储。比如，我有一个 “tea” 作为键来存储，为了得到这个单词对应的值，我要做的就是从根节点遍历树，先到 “t”，再到 “e”，再到“a”。结果得到了3。</p>\n<p><img src=\"/css/images/30.jpg\" alt=\"\"></p>\n<p>这很酷，但在我们的数据结构中，我们不会使用单词作为键，而会选择更有数组风格的index，也就是索引。</p>\n<p><img src=\"/css/images/31.jpg\" alt=\"\"></p>\n<p>如果我们把索引当作二进制数字，我们可以假装那是单词，然后我们逐个比特向下遍历树，就像是先前的字母那样。让我们看看这如何运作。如果我想从数组中得到5，即索引为5的动物。我就把它转换为二进制，也就是101。然后我逐个比特查找它。先从根节点开始，然后进入分支1，然后分支0，最后分支1，得到了青蛙。</p>\n<p><img src=\"/css/images/32.jpg\" alt=\"\"></p>\n<p>这很简单，但却非常强大。因为它让我们在这种树状数据结构很快地进行查找，而这个树状数据结构则让我们使用结构共享来更高效的描述不可变数据结构的新拷贝。另外，值得一提的是，我们没必要非使用二叉树来表示，二叉树很适合在幻灯片上展示，但在实际中通常都是32叉树。</p>\n<p><img src=\"/css/images/33.jpg\" alt=\"\"></p>\n<p>在我们刚才看的那棵树中，每一层只有一个比特的信息，我们需要向下逐个比特查找。但是，如果我们有一颗32叉树，那么每一层将会有5个比特的信息（2^5=32）。举个例子吧！如果我们有个更大的数字，比如18977。如果每层只有一个比特，那么这将是个很深的树，一共有15层，太多，太长了 。如果我在每层创建更多的叉，那么我就可以把它变为5比特，进而也就只需要3层就可以了。其实这是个权衡问题，看你是想要更深的树，还是更多叉叉的树。通常，32叉树是个很好的权衡。</p>\n<p><img src=\"/css/images/34.jpg\" alt=\"\"></p>\n<p>我们刚才看见的其实就是 Bitmapped Vector Trie。这是行话，你可以自行谷歌这种数据结构。</p>\n<p><img src=\"/css/images/35.jpg\" alt=\"\"></p>\n<h2 id=\"对象的情况\"><a href=\"#对象的情况\" class=\"headerlink\" title=\"对象的情况\"></a>对象的情况</h2><p>对于数组来说，这很酷，有个索引，然后跳转过去。但是，对于对象呢？我们也想能够把对象和一些随意的键关联起来，不只是索引，我们想要非整型的键。这该如何工作呢？比如，M 对应 Monkey，P 对应 panda等。我们能做的就是把字母键使用哈希算法变为数字来表示键。所以每个键都有一个数字，也不需要有序什么的，因为对象本来就是无序的。然后我们就可以像先前一样用数字来进行查找了。</p>\n<p><img src=\"/css/images/36.jpg\" alt=\"\"></p>\n<p>如果我想查找键为 F 的值，那么我就先对 F 进行哈希运算，然后得到一些数字，比如5吧！5的二进制就是101，然后像之前那样逐个比特来查找，最后得到了我们想要的动物，也就是青蛙。</p>\n<p><img src=\"/css/images/37.jpg\" alt=\"\"></p>\n<p>其实，这是个 <a href=\"https://en.wikipedia.org/wiki/Hash_array_mapped_trie\" target=\"_blank\" rel=\"noopener\">Hash Array Mapped Trie</a>。这个数据结构由 Phil Bagwell 和 Rich Hickey 发明，最初用在 Clojure 这门语言中来提升一些数据的运算效率。</p>\n<p><img src=\"/css/images/38.jpg\" alt=\"\"></p>\n<p>关于该数据结构，还有很多优化方法，可以让它变得超级快，很多细节，我们今天就不一一说了。但是，这是个基本概念：树代表数据，结构共享让我们可以在新老版本之间复用更多信息，使用二进制代表键去向下查找指定值。</p>\n<h2 id=\"概括\"><a href=\"#概括\" class=\"headerlink\" title=\"概括\"></a>概括</h2><p>概括一下：可变性引出很多问题。这些问题需要被解决，尤其是在函数式编程中，因为函数式编程的基本思想就是不能有副作用，只能用纯函数。纯函数不能改变任何数据，它只对输入做计算，然后返回全新的输出。另一方面，不可变则很棒。因为如果我用了不可变数据，我就不会把我同事的程序搞挂掉。但是，拷贝是个处理不可变数据的糟糕的方式，因为它不高效，不管是时间层面还是空间层面，而新老版本树中的结构共享是个高效的方法。</p>\n<p><img src=\"/css/images/39.jpg\" alt=\"\"></p>\n<h2 id=\"Mori-和-Immutable-js-简介\"><a href=\"#Mori-和-Immutable-js-简介\" class=\"headerlink\" title=\"Mori 和 Immutable.js 简介\"></a>Mori 和 Immutable.js 简介</h2><p>这些数据结构很酷，但是，我应该怎么用它们？在 JavaScript 中，有一些很棒的库帮你立马用上这些数据结构。有很多不同的方案，但我将会介绍其中几个。有一个库叫 Mori。基本来说，Mori 是个 ClojureScript 的一个 JavaScript 接口。它能让你使用上 ClojureScript 中的一些数据结构。这个库很有 Clojure 的感觉，很有函数式编程的感觉。API 是函数式的，我们等会看看。但这也使得这个库比较冷门。</p>\n<p><img src=\"/css/images/40.jpg\" alt=\"\"></p>\n<p>另一个是 Immutable.js。这是 Facebook 出的一个库，由 Lee Byron建立。这是（刚才讨论的）那些数据结构的 JavaScript 实现。这个库很有原生 JavaScript 的感觉，没有任何 Clojure 背景。这意味着，它也有点面向对象风格的 API，尽管它仍然是返回新的数据结构，而不是改变可变的数据结构。</p>\n<p><img src=\"/css/images/41.jpg\" alt=\"\"></p>\n<h2 id=\"Mori-和-Immutable-js-代码片段\"><a href=\"#Mori-和-Immutable-js-代码片段\" class=\"headerlink\" title=\"Mori 和 Immutable.js 代码片段\"></a>Mori 和 Immutable.js 代码片段</h2><p>让我们看看它们长啥样。 这是 Mori。<code>vector</code> 就像是数组，<code>conj</code> 就像是 <code>push</code> 方法。从结果看，<code>a</code> 没有变化，而 <code>a2</code> 则是新的数据。</p>\n<p><img src=\"/css/images/42.jpg\" alt=\"\"></p>\n<p>这是相同算法的 Immutable.js 版本。</p>\n<p><img src=\"/css/images/43.jpg\" alt=\"\"></p>\n<p>刚才是数组，现在看看 map 这个数据结构。 这是 Mori 版本。</p>\n<p><img src=\"/css/images/44.jpg\" alt=\"\"></p>\n<p>这是 Immutable.js 版本。</p>\n<p><img src=\"/css/images/45.jpg\" alt=\"\"></p>\n<p>这是真正的不可变数据结构，如果你在命令行中查看它们，就会发现它们非常奇怪。非常建议大家使用这些库，看看效果如何。</p>\n<h2 id=\"Mori-和-Immutable-js-简单对比\"><a href=\"#Mori-和-Immutable-js-简单对比\" class=\"headerlink\" title=\"Mori 和 Immutable.js 简单对比\"></a>Mori 和 Immutable.js 简单对比</h2><p>我可以在结束前简单对比一下它们。Mori 来自 Clojure 世界，它是 ClojureScript（的 JavaScript 接口）。但是 Immutable.js 则拥有更多像 <code>o.get()</code> 这样（面向对象风格的）方法，如果你喜欢在 JavaScript 中这么写。然而对我来说，Immutable.js 的这种写法会让我感到不和谐，因为这看起来很像是可变的写法，但实际并不是。为了获取更多的函数式编程的感觉，我更喜欢 Mori，因为我更喜欢所有都是纯函数，接受输入，返回输出，仅此而已。这里也提供了一些次要的性能对比，Mori 稍微快一些，而 Immutable.js 则相对小一点。它们都是好选择，试试吧！ 希望其中一个适合你。</p>\n<p><img src=\"/css/images/46.jpg\" alt=\"\"></p>\n<p>这就是我的演讲，希望对大家有用。 加油向前，不要改变数据！（鼓掌）</p>\n<p><img src=\"/css/images/47.jpg\" alt=\"\"></p>"},{"title":"karma单元测试入门","date":"2015-10-12T06:07:00.000Z","_content":"\n学习Angularjs，都会遇到Karma单元测试，可是初学者面对复杂的测试配置往往不知从何入手，下面我们将抛开Angularjs，单独使用两个js文件，完成一次测试入门。\n\n<!--more-->\n\n## 0，Karma原理\n\n![](/css/images/48.jpg)\n\n## 1，文件目录\n\n![](/css/images/49.jpg)\n\n两个js文件，一个package.json\n\n## 2，生成步骤\n\n（1）生成package.json，在文件夹下运行\n\n```sh\nnpm init\n```\n\n（2）安装karma依赖，在文件夹下运行\n\n```sh\nnpm install karma karma-jasmine karma-chrome-launcher --save-dev\n```\n\n局部安装 karma karma-jasmine karma-chrome-launcher ，并保存到package.json中。这三个包缺一不可，\n\n有些同学，是全局安装karma，那么请把karma-jasmine karma-chrome-launcher 也全局安装，否则会出现no provider jasmine的bug。至少在ubuntu 中是如此。\n\n全局安装命令\n\n```sh\nnpm install -g karma karma-jasmine karma-chrome-launcher \n```\n\n（3）配置karma，在文件夹下运行\n\n```sh\n karma init karma.conf.js\n```\n\n![](/css/images/50.jpg)\n\n（4），编写demo.js\n\n```js\ndescribe('A spec suite', function() {\n    it('contains a passing spec', function() {\n        expect(true).toBe(true);\n    });\n});\n```\n\ndescribe负责打包it()，测试时候会在console中打印'A spec suite'，没别的作用;\n\nit()负责单个测试，测试时候会在console中打印'contains a passing spec'，没别的作用;\n\nexpect(a).tobe(b)负责测试a是否等于b，测试时候会在console中打印对错;\n\n还有很多其他的函数，将来再学，个人不建议初学者一口吃个大胖子。\n\n## 3，运行测试\n\n在根目录下运行\n\n```sh\nkarma start karma.conf.js\n```\n\n效果：\n\n![](/css/images/51.jpg)\n\n## 更多测试文章：\n\n<http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/>\n","source":"_posts/karma-start.md","raw":"---\ntitle: karma单元测试入门\ndate: 2015-10-12 14:07:00\ntags: [Karma, 单元测试, 测试]\n---\n\n学习Angularjs，都会遇到Karma单元测试，可是初学者面对复杂的测试配置往往不知从何入手，下面我们将抛开Angularjs，单独使用两个js文件，完成一次测试入门。\n\n<!--more-->\n\n## 0，Karma原理\n\n![](/css/images/48.jpg)\n\n## 1，文件目录\n\n![](/css/images/49.jpg)\n\n两个js文件，一个package.json\n\n## 2，生成步骤\n\n（1）生成package.json，在文件夹下运行\n\n```sh\nnpm init\n```\n\n（2）安装karma依赖，在文件夹下运行\n\n```sh\nnpm install karma karma-jasmine karma-chrome-launcher --save-dev\n```\n\n局部安装 karma karma-jasmine karma-chrome-launcher ，并保存到package.json中。这三个包缺一不可，\n\n有些同学，是全局安装karma，那么请把karma-jasmine karma-chrome-launcher 也全局安装，否则会出现no provider jasmine的bug。至少在ubuntu 中是如此。\n\n全局安装命令\n\n```sh\nnpm install -g karma karma-jasmine karma-chrome-launcher \n```\n\n（3）配置karma，在文件夹下运行\n\n```sh\n karma init karma.conf.js\n```\n\n![](/css/images/50.jpg)\n\n（4），编写demo.js\n\n```js\ndescribe('A spec suite', function() {\n    it('contains a passing spec', function() {\n        expect(true).toBe(true);\n    });\n});\n```\n\ndescribe负责打包it()，测试时候会在console中打印'A spec suite'，没别的作用;\n\nit()负责单个测试，测试时候会在console中打印'contains a passing spec'，没别的作用;\n\nexpect(a).tobe(b)负责测试a是否等于b，测试时候会在console中打印对错;\n\n还有很多其他的函数，将来再学，个人不建议初学者一口吃个大胖子。\n\n## 3，运行测试\n\n在根目录下运行\n\n```sh\nkarma start karma.conf.js\n```\n\n效果：\n\n![](/css/images/51.jpg)\n\n## 更多测试文章：\n\n<http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/>\n","slug":"karma-start","published":1,"updated":"2019-05-01T08:10:29.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvlj000ztgytugiwdp1s","content":"<p>学习Angularjs，都会遇到Karma单元测试，可是初学者面对复杂的测试配置往往不知从何入手，下面我们将抛开Angularjs，单独使用两个js文件，完成一次测试入门。</p>\n<a id=\"more\"></a>\n<h2 id=\"0，Karma原理\"><a href=\"#0，Karma原理\" class=\"headerlink\" title=\"0，Karma原理\"></a>0，Karma原理</h2><p><img src=\"/css/images/48.jpg\" alt=\"\"></p>\n<h2 id=\"1，文件目录\"><a href=\"#1，文件目录\" class=\"headerlink\" title=\"1，文件目录\"></a>1，文件目录</h2><p><img src=\"/css/images/49.jpg\" alt=\"\"></p>\n<p>两个js文件，一个package.json</p>\n<h2 id=\"2，生成步骤\"><a href=\"#2，生成步骤\" class=\"headerlink\" title=\"2，生成步骤\"></a>2，生成步骤</h2><p>（1）生成package.json，在文件夹下运行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init</span><br></pre></td></tr></table></figure>\n<p>（2）安装karma依赖，在文件夹下运行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install karma karma-jasmine karma-chrome-launcher --save-dev</span><br></pre></td></tr></table></figure>\n<p>局部安装 karma karma-jasmine karma-chrome-launcher ，并保存到package.json中。这三个包缺一不可，</p>\n<p>有些同学，是全局安装karma，那么请把karma-jasmine karma-chrome-launcher 也全局安装，否则会出现no provider jasmine的bug。至少在ubuntu 中是如此。</p>\n<p>全局安装命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g karma karma-jasmine karma-chrome-launcher</span><br></pre></td></tr></table></figure>\n<p>（3）配置karma，在文件夹下运行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">karma init karma.conf.js</span><br></pre></td></tr></table></figure>\n<p><img src=\"/css/images/50.jpg\" alt=\"\"></p>\n<p>（4），编写demo.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">'A spec suite'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    it(<span class=\"string\">'contains a passing spec'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        expect(<span class=\"literal\">true</span>).toBe(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>describe负责打包it()，测试时候会在console中打印’A spec suite’，没别的作用;</p>\n<p>it()负责单个测试，测试时候会在console中打印’contains a passing spec’，没别的作用;</p>\n<p>expect(a).tobe(b)负责测试a是否等于b，测试时候会在console中打印对错;</p>\n<p>还有很多其他的函数，将来再学，个人不建议初学者一口吃个大胖子。</p>\n<h2 id=\"3，运行测试\"><a href=\"#3，运行测试\" class=\"headerlink\" title=\"3，运行测试\"></a>3，运行测试</h2><p>在根目录下运行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">karma start karma.conf.js</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><img src=\"/css/images/51.jpg\" alt=\"\"></p>\n<h2 id=\"更多测试文章：\"><a href=\"#更多测试文章：\" class=\"headerlink\" title=\"更多测试文章：\"></a>更多测试文章：</h2><p><a href=\"http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/\">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>\n","site":{"data":{}},"excerpt":"<p>学习Angularjs，都会遇到Karma单元测试，可是初学者面对复杂的测试配置往往不知从何入手，下面我们将抛开Angularjs，单独使用两个js文件，完成一次测试入门。</p>","more":"<h2 id=\"0，Karma原理\"><a href=\"#0，Karma原理\" class=\"headerlink\" title=\"0，Karma原理\"></a>0，Karma原理</h2><p><img src=\"/css/images/48.jpg\" alt=\"\"></p>\n<h2 id=\"1，文件目录\"><a href=\"#1，文件目录\" class=\"headerlink\" title=\"1，文件目录\"></a>1，文件目录</h2><p><img src=\"/css/images/49.jpg\" alt=\"\"></p>\n<p>两个js文件，一个package.json</p>\n<h2 id=\"2，生成步骤\"><a href=\"#2，生成步骤\" class=\"headerlink\" title=\"2，生成步骤\"></a>2，生成步骤</h2><p>（1）生成package.json，在文件夹下运行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init</span><br></pre></td></tr></table></figure>\n<p>（2）安装karma依赖，在文件夹下运行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install karma karma-jasmine karma-chrome-launcher --save-dev</span><br></pre></td></tr></table></figure>\n<p>局部安装 karma karma-jasmine karma-chrome-launcher ，并保存到package.json中。这三个包缺一不可，</p>\n<p>有些同学，是全局安装karma，那么请把karma-jasmine karma-chrome-launcher 也全局安装，否则会出现no provider jasmine的bug。至少在ubuntu 中是如此。</p>\n<p>全局安装命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g karma karma-jasmine karma-chrome-launcher</span><br></pre></td></tr></table></figure>\n<p>（3）配置karma，在文件夹下运行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">karma init karma.conf.js</span><br></pre></td></tr></table></figure>\n<p><img src=\"/css/images/50.jpg\" alt=\"\"></p>\n<p>（4），编写demo.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">'A spec suite'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    it(<span class=\"string\">'contains a passing spec'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        expect(<span class=\"literal\">true</span>).toBe(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>describe负责打包it()，测试时候会在console中打印’A spec suite’，没别的作用;</p>\n<p>it()负责单个测试，测试时候会在console中打印’contains a passing spec’，没别的作用;</p>\n<p>expect(a).tobe(b)负责测试a是否等于b，测试时候会在console中打印对错;</p>\n<p>还有很多其他的函数，将来再学，个人不建议初学者一口吃个大胖子。</p>\n<h2 id=\"3，运行测试\"><a href=\"#3，运行测试\" class=\"headerlink\" title=\"3，运行测试\"></a>3，运行测试</h2><p>在根目录下运行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">karma start karma.conf.js</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><img src=\"/css/images/51.jpg\" alt=\"\"></p>\n<h2 id=\"更多测试文章：\"><a href=\"#更多测试文章：\" class=\"headerlink\" title=\"更多测试文章：\"></a>更多测试文章：</h2><p><a href=\"http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/\">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>"},{"title":"利用机器学习进行整张设计稿多组件识别的探索","date":"2018-07-25T07:00:00.000Z","_content":"\n前不久，在集团内部做了一个 CR 系统，可以从设计稿上截图识别某个组件并给出代码。\n\n![](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/253b2a3479efb954c13d29c33ebde193.gif)\n\n但是，我不想只是识别单个组件，最好能识别整张设计稿的多个组件。于是，花了两三天进行了这项技术的探索调研，并将过程记录下来。\n\n<!--more-->\n\n## 技术选型\n\n### 二值化处理\n\n识别多个组件的本质是定位，我首先想到的是像车牌定位，或者跳一跳外挂那样的利用颜色，进行二值化等处理进行识别，但设计稿中的组件并没有非常明显的边界，这种方法显然是不可行的。\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/92540cd6fba715d2f87569ee4178045a.png)\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/327680fc4bbd5694af00345eff985b28.png)\n\n### TensorFlow Object Detection API\n\n后来发现了谷歌开放的 TensorFlow Object Detection API，顿时看到了希望。TensorFlow Object Detection API 可以创建一个精确的机器学习模型，该模型能够在单张图片中对多个物体进行定位、分类。看了几张效果图，认为应该有戏：\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b0d53971daa00b7368ce102128808ce2.png)\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/18885ecc69b4d3d41ba09b174b414653.png)\n## 机器选择\n\nTensorFlow 可以在各个系统上跑，甚至可以在浏览器里运行和 retrain。但是如果要有更好的速度，最好选择可以用 GPU 的系统，由于 OSX 系统的在显卡方面的封闭性，TensorFlow 不支持在 OSX 上跑 GPU 版本，所以剩下的选择是：\n\n- WIndows 或者 Linux 系统的电脑\n- 谷歌云\n- 集团的 PAI 平台\n- 其他云平台\n\n由于云平台对我来说会增加一些熟悉成本，而我目前又只是急于知道多组件识别的可行性，所以就借了部门实习生的台式机来训练，正好这位实习生不习惯用 Windows 系统，自己带了 Macbook，所以就很爽快地借给我了。不过，不得不说集团给实习同学配置的电脑配置确实很基础，8g内存，Nvidia GeForce GT 730 的显卡，再差一点就跑不动 GPU 版本的 Tensorflow 了。\n\n## 模型选择\n\nTensorFlow Object Detection API 提供了一些[现成的模型](https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/detection_model_zoo.md)来让你直接用或者重新训练，它们的区别在速度和精确度上。因为我的台式机配置较低，所以选择了速度较快，精度较低的模型（ssd_mobilenet_v1_coco）来重新训练。\n\n## 训练图片选择\n\n我们要进行的是整张设计稿的识别，所以最初我用的训练图片是整张设计稿，但训练下来，发现根本识别不出来什么。\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/7b973e2b8ba9e2444738610724a8f391.png)\n\n思考了一下，发现是因为：\n\n- 图片尺寸太大\n- 而上步选择的模型只支持小尺寸的图片（毕竟那个模型是给移动端用的）\n\n于是我打算缩小图片尺寸，换成了表单项的识别，即在一个表单上识别出输入框、下拉框、文本框等。将尺寸缩小后，我在那台低配的台式机上训练了半个小时（没跑完），最终识别效果图如下：\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/2d708f7fec32820d1daec8087053804f.png)\n\n至少证明是可行的了。但是还有一些表单项没有识别出来，所以我继续缩小训练图片的尺寸，将七个表单项的识别换成三个，训练了一个小时（也是没跑完），测试了一下，可以全部识别出来了：\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/a3090c496957287e049199bd5110e939.png)\n\n## 最终结论\n\n首先，整张设计稿的多组件识别是可行的，但是需要几个前提条件：\n\n- 有充足的 GPU 资源：如果你像我一样只有一台低配机器，那么精度高的模型，你跑都跑不动，显卡内存直接占满，程序崩溃。\n\n- 有充足的设计稿素材：由于只是验证可行性，所以我只训练了十张图片，但是要达到很好的效果，至少得有一百张图片来训练，所以你得有足够多的设计稿素材。\n\n- 有充足的人手和时间：训练 Object Detection 模型不像 Image Classification 那样简单，需要你手动标注位置，生成 xml 文件来给机器学习，这个工作非常无聊繁琐，所以如果要做，必须有足够多的人和时间。\n\n暂时就写这么多了，笔者研究较浅，请多多批评！","source":"_posts/ml-component-recognition.md","raw":"---\ntitle: 利用机器学习进行整张设计稿多组件识别的探索\ndate: 2018-07-25 15:00:00\ntags: [机器学习, TensorFlow, Object Detection API, 二值化]\n---\n\n前不久，在集团内部做了一个 CR 系统，可以从设计稿上截图识别某个组件并给出代码。\n\n![](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/253b2a3479efb954c13d29c33ebde193.gif)\n\n但是，我不想只是识别单个组件，最好能识别整张设计稿的多个组件。于是，花了两三天进行了这项技术的探索调研，并将过程记录下来。\n\n<!--more-->\n\n## 技术选型\n\n### 二值化处理\n\n识别多个组件的本质是定位，我首先想到的是像车牌定位，或者跳一跳外挂那样的利用颜色，进行二值化等处理进行识别，但设计稿中的组件并没有非常明显的边界，这种方法显然是不可行的。\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/92540cd6fba715d2f87569ee4178045a.png)\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/327680fc4bbd5694af00345eff985b28.png)\n\n### TensorFlow Object Detection API\n\n后来发现了谷歌开放的 TensorFlow Object Detection API，顿时看到了希望。TensorFlow Object Detection API 可以创建一个精确的机器学习模型，该模型能够在单张图片中对多个物体进行定位、分类。看了几张效果图，认为应该有戏：\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b0d53971daa00b7368ce102128808ce2.png)\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/18885ecc69b4d3d41ba09b174b414653.png)\n## 机器选择\n\nTensorFlow 可以在各个系统上跑，甚至可以在浏览器里运行和 retrain。但是如果要有更好的速度，最好选择可以用 GPU 的系统，由于 OSX 系统的在显卡方面的封闭性，TensorFlow 不支持在 OSX 上跑 GPU 版本，所以剩下的选择是：\n\n- WIndows 或者 Linux 系统的电脑\n- 谷歌云\n- 集团的 PAI 平台\n- 其他云平台\n\n由于云平台对我来说会增加一些熟悉成本，而我目前又只是急于知道多组件识别的可行性，所以就借了部门实习生的台式机来训练，正好这位实习生不习惯用 Windows 系统，自己带了 Macbook，所以就很爽快地借给我了。不过，不得不说集团给实习同学配置的电脑配置确实很基础，8g内存，Nvidia GeForce GT 730 的显卡，再差一点就跑不动 GPU 版本的 Tensorflow 了。\n\n## 模型选择\n\nTensorFlow Object Detection API 提供了一些[现成的模型](https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/detection_model_zoo.md)来让你直接用或者重新训练，它们的区别在速度和精确度上。因为我的台式机配置较低，所以选择了速度较快，精度较低的模型（ssd_mobilenet_v1_coco）来重新训练。\n\n## 训练图片选择\n\n我们要进行的是整张设计稿的识别，所以最初我用的训练图片是整张设计稿，但训练下来，发现根本识别不出来什么。\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/7b973e2b8ba9e2444738610724a8f391.png)\n\n思考了一下，发现是因为：\n\n- 图片尺寸太大\n- 而上步选择的模型只支持小尺寸的图片（毕竟那个模型是给移动端用的）\n\n于是我打算缩小图片尺寸，换成了表单项的识别，即在一个表单上识别出输入框、下拉框、文本框等。将尺寸缩小后，我在那台低配的台式机上训练了半个小时（没跑完），最终识别效果图如下：\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/2d708f7fec32820d1daec8087053804f.png)\n\n至少证明是可行的了。但是还有一些表单项没有识别出来，所以我继续缩小训练图片的尺寸，将七个表单项的识别换成三个，训练了一个小时（也是没跑完），测试了一下，可以全部识别出来了：\n\n![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/a3090c496957287e049199bd5110e939.png)\n\n## 最终结论\n\n首先，整张设计稿的多组件识别是可行的，但是需要几个前提条件：\n\n- 有充足的 GPU 资源：如果你像我一样只有一台低配机器，那么精度高的模型，你跑都跑不动，显卡内存直接占满，程序崩溃。\n\n- 有充足的设计稿素材：由于只是验证可行性，所以我只训练了十张图片，但是要达到很好的效果，至少得有一百张图片来训练，所以你得有足够多的设计稿素材。\n\n- 有充足的人手和时间：训练 Object Detection 模型不像 Image Classification 那样简单，需要你手动标注位置，生成 xml 文件来给机器学习，这个工作非常无聊繁琐，所以如果要做，必须有足够多的人和时间。\n\n暂时就写这么多了，笔者研究较浅，请多多批评！","slug":"ml-component-recognition","published":1,"updated":"2019-05-01T08:02:10.221Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvll0012tgyttufavdv8","content":"<p>前不久，在集团内部做了一个 CR 系统，可以从设计稿上截图识别某个组件并给出代码。</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/253b2a3479efb954c13d29c33ebde193.gif\" alt=\"\"></p>\n<p>但是，我不想只是识别单个组件，最好能识别整张设计稿的多个组件。于是，花了两三天进行了这项技术的探索调研，并将过程记录下来。</p>\n<a id=\"more\"></a>\n<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><h3 id=\"二值化处理\"><a href=\"#二值化处理\" class=\"headerlink\" title=\"二值化处理\"></a>二值化处理</h3><p>识别多个组件的本质是定位，我首先想到的是像车牌定位，或者跳一跳外挂那样的利用颜色，进行二值化等处理进行识别，但设计稿中的组件并没有非常明显的边界，这种方法显然是不可行的。</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/92540cd6fba715d2f87569ee4178045a.png\" alt=\"image.png\"></p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/327680fc4bbd5694af00345eff985b28.png\" alt=\"image.png\"></p>\n<h3 id=\"TensorFlow-Object-Detection-API\"><a href=\"#TensorFlow-Object-Detection-API\" class=\"headerlink\" title=\"TensorFlow Object Detection API\"></a>TensorFlow Object Detection API</h3><p>后来发现了谷歌开放的 TensorFlow Object Detection API，顿时看到了希望。TensorFlow Object Detection API 可以创建一个精确的机器学习模型，该模型能够在单张图片中对多个物体进行定位、分类。看了几张效果图，认为应该有戏：</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b0d53971daa00b7368ce102128808ce2.png\" alt=\"image.png\"></p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/18885ecc69b4d3d41ba09b174b414653.png\" alt=\"image.png\"></p>\n<h2 id=\"机器选择\"><a href=\"#机器选择\" class=\"headerlink\" title=\"机器选择\"></a>机器选择</h2><p>TensorFlow 可以在各个系统上跑，甚至可以在浏览器里运行和 retrain。但是如果要有更好的速度，最好选择可以用 GPU 的系统，由于 OSX 系统的在显卡方面的封闭性，TensorFlow 不支持在 OSX 上跑 GPU 版本，所以剩下的选择是：</p>\n<ul>\n<li>WIndows 或者 Linux 系统的电脑</li>\n<li>谷歌云</li>\n<li>集团的 PAI 平台</li>\n<li>其他云平台</li>\n</ul>\n<p>由于云平台对我来说会增加一些熟悉成本，而我目前又只是急于知道多组件识别的可行性，所以就借了部门实习生的台式机来训练，正好这位实习生不习惯用 Windows 系统，自己带了 Macbook，所以就很爽快地借给我了。不过，不得不说集团给实习同学配置的电脑配置确实很基础，8g内存，Nvidia GeForce GT 730 的显卡，再差一点就跑不动 GPU 版本的 Tensorflow 了。</p>\n<h2 id=\"模型选择\"><a href=\"#模型选择\" class=\"headerlink\" title=\"模型选择\"></a>模型选择</h2><p>TensorFlow Object Detection API 提供了一些<a href=\"https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/detection_model_zoo.md\" target=\"_blank\" rel=\"noopener\">现成的模型</a>来让你直接用或者重新训练，它们的区别在速度和精确度上。因为我的台式机配置较低，所以选择了速度较快，精度较低的模型（ssd_mobilenet_v1_coco）来重新训练。</p>\n<h2 id=\"训练图片选择\"><a href=\"#训练图片选择\" class=\"headerlink\" title=\"训练图片选择\"></a>训练图片选择</h2><p>我们要进行的是整张设计稿的识别，所以最初我用的训练图片是整张设计稿，但训练下来，发现根本识别不出来什么。</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/7b973e2b8ba9e2444738610724a8f391.png\" alt=\"image.png\"></p>\n<p>思考了一下，发现是因为：</p>\n<ul>\n<li>图片尺寸太大</li>\n<li>而上步选择的模型只支持小尺寸的图片（毕竟那个模型是给移动端用的）</li>\n</ul>\n<p>于是我打算缩小图片尺寸，换成了表单项的识别，即在一个表单上识别出输入框、下拉框、文本框等。将尺寸缩小后，我在那台低配的台式机上训练了半个小时（没跑完），最终识别效果图如下：</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/2d708f7fec32820d1daec8087053804f.png\" alt=\"image.png\"></p>\n<p>至少证明是可行的了。但是还有一些表单项没有识别出来，所以我继续缩小训练图片的尺寸，将七个表单项的识别换成三个，训练了一个小时（也是没跑完），测试了一下，可以全部识别出来了：</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/a3090c496957287e049199bd5110e939.png\" alt=\"image.png\"></p>\n<h2 id=\"最终结论\"><a href=\"#最终结论\" class=\"headerlink\" title=\"最终结论\"></a>最终结论</h2><p>首先，整张设计稿的多组件识别是可行的，但是需要几个前提条件：</p>\n<ul>\n<li><p>有充足的 GPU 资源：如果你像我一样只有一台低配机器，那么精度高的模型，你跑都跑不动，显卡内存直接占满，程序崩溃。</p>\n</li>\n<li><p>有充足的设计稿素材：由于只是验证可行性，所以我只训练了十张图片，但是要达到很好的效果，至少得有一百张图片来训练，所以你得有足够多的设计稿素材。</p>\n</li>\n<li><p>有充足的人手和时间：训练 Object Detection 模型不像 Image Classification 那样简单，需要你手动标注位置，生成 xml 文件来给机器学习，这个工作非常无聊繁琐，所以如果要做，必须有足够多的人和时间。</p>\n</li>\n</ul>\n<p>暂时就写这么多了，笔者研究较浅，请多多批评！</p>\n","site":{"data":{}},"excerpt":"<p>前不久，在集团内部做了一个 CR 系统，可以从设计稿上截图识别某个组件并给出代码。</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/253b2a3479efb954c13d29c33ebde193.gif\" alt=\"\"></p>\n<p>但是，我不想只是识别单个组件，最好能识别整张设计稿的多个组件。于是，花了两三天进行了这项技术的探索调研，并将过程记录下来。</p>","more":"<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><h3 id=\"二值化处理\"><a href=\"#二值化处理\" class=\"headerlink\" title=\"二值化处理\"></a>二值化处理</h3><p>识别多个组件的本质是定位，我首先想到的是像车牌定位，或者跳一跳外挂那样的利用颜色，进行二值化等处理进行识别，但设计稿中的组件并没有非常明显的边界，这种方法显然是不可行的。</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/92540cd6fba715d2f87569ee4178045a.png\" alt=\"image.png\"></p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/327680fc4bbd5694af00345eff985b28.png\" alt=\"image.png\"></p>\n<h3 id=\"TensorFlow-Object-Detection-API\"><a href=\"#TensorFlow-Object-Detection-API\" class=\"headerlink\" title=\"TensorFlow Object Detection API\"></a>TensorFlow Object Detection API</h3><p>后来发现了谷歌开放的 TensorFlow Object Detection API，顿时看到了希望。TensorFlow Object Detection API 可以创建一个精确的机器学习模型，该模型能够在单张图片中对多个物体进行定位、分类。看了几张效果图，认为应该有戏：</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b0d53971daa00b7368ce102128808ce2.png\" alt=\"image.png\"></p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/18885ecc69b4d3d41ba09b174b414653.png\" alt=\"image.png\"></p>\n<h2 id=\"机器选择\"><a href=\"#机器选择\" class=\"headerlink\" title=\"机器选择\"></a>机器选择</h2><p>TensorFlow 可以在各个系统上跑，甚至可以在浏览器里运行和 retrain。但是如果要有更好的速度，最好选择可以用 GPU 的系统，由于 OSX 系统的在显卡方面的封闭性，TensorFlow 不支持在 OSX 上跑 GPU 版本，所以剩下的选择是：</p>\n<ul>\n<li>WIndows 或者 Linux 系统的电脑</li>\n<li>谷歌云</li>\n<li>集团的 PAI 平台</li>\n<li>其他云平台</li>\n</ul>\n<p>由于云平台对我来说会增加一些熟悉成本，而我目前又只是急于知道多组件识别的可行性，所以就借了部门实习生的台式机来训练，正好这位实习生不习惯用 Windows 系统，自己带了 Macbook，所以就很爽快地借给我了。不过，不得不说集团给实习同学配置的电脑配置确实很基础，8g内存，Nvidia GeForce GT 730 的显卡，再差一点就跑不动 GPU 版本的 Tensorflow 了。</p>\n<h2 id=\"模型选择\"><a href=\"#模型选择\" class=\"headerlink\" title=\"模型选择\"></a>模型选择</h2><p>TensorFlow Object Detection API 提供了一些<a href=\"https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/detection_model_zoo.md\" target=\"_blank\" rel=\"noopener\">现成的模型</a>来让你直接用或者重新训练，它们的区别在速度和精确度上。因为我的台式机配置较低，所以选择了速度较快，精度较低的模型（ssd_mobilenet_v1_coco）来重新训练。</p>\n<h2 id=\"训练图片选择\"><a href=\"#训练图片选择\" class=\"headerlink\" title=\"训练图片选择\"></a>训练图片选择</h2><p>我们要进行的是整张设计稿的识别，所以最初我用的训练图片是整张设计稿，但训练下来，发现根本识别不出来什么。</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/7b973e2b8ba9e2444738610724a8f391.png\" alt=\"image.png\"></p>\n<p>思考了一下，发现是因为：</p>\n<ul>\n<li>图片尺寸太大</li>\n<li>而上步选择的模型只支持小尺寸的图片（毕竟那个模型是给移动端用的）</li>\n</ul>\n<p>于是我打算缩小图片尺寸，换成了表单项的识别，即在一个表单上识别出输入框、下拉框、文本框等。将尺寸缩小后，我在那台低配的台式机上训练了半个小时（没跑完），最终识别效果图如下：</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/2d708f7fec32820d1daec8087053804f.png\" alt=\"image.png\"></p>\n<p>至少证明是可行的了。但是还有一些表单项没有识别出来，所以我继续缩小训练图片的尺寸，将七个表单项的识别换成三个，训练了一个小时（也是没跑完），测试了一下，可以全部识别出来了：</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/a3090c496957287e049199bd5110e939.png\" alt=\"image.png\"></p>\n<h2 id=\"最终结论\"><a href=\"#最终结论\" class=\"headerlink\" title=\"最终结论\"></a>最终结论</h2><p>首先，整张设计稿的多组件识别是可行的，但是需要几个前提条件：</p>\n<ul>\n<li><p>有充足的 GPU 资源：如果你像我一样只有一台低配机器，那么精度高的模型，你跑都跑不动，显卡内存直接占满，程序崩溃。</p>\n</li>\n<li><p>有充足的设计稿素材：由于只是验证可行性，所以我只训练了十张图片，但是要达到很好的效果，至少得有一百张图片来训练，所以你得有足够多的设计稿素材。</p>\n</li>\n<li><p>有充足的人手和时间：训练 Object Detection 模型不像 Image Classification 那样简单，需要你手动标注位置，生成 xml 文件来给机器学习，这个工作非常无聊繁琐，所以如果要做，必须有足够多的人和时间。</p>\n</li>\n</ul>\n<p>暂时就写这么多了，笔者研究较浅，请多多批评！</p>"},{"title":"JavaScript 版数据结构与算法（三）链表","date":"2017-02-15T10:35:00.000Z","_content":"\n今天，我们要讲的是数据结构与算法中的链表。\n\n<!--more-->\n\n## 链表简介\n\n链表是什么？链表是一种动态的数据结构，这意味着我们可以任意增删元素，它会按需扩容。为何要使用链表？下面列举一些链表的用途：\n\n- 因为数组的存储有缺陷：增删元素时往往需要移动元素。而链表在内存中的放置并不是连续的，元素通过 next 属性指向下个元素，所以链表增删元素，不需要移动元素，只需要更改 next 的指向即可。\n- 在生活中，最形象的链表莫过于火车了，车头是 head，每一节车厢都有一个 next 用于连接后面的车厢，想增删车厢，只需要更改 next 即可。\n- 在使用分离链接法解决散列表冲突时，我们也会用链表存储位置冲突的元素。\n- 在 JavaScript 这门语言中有两个非常重要的**链**：作用域链和原型链。学习链表对于理解 JavaScript 的这两个特性也非常有帮助。\n\n![](https://ws1.sinaimg.cn/mw690/83900b4egy1fcrboyt21qj20ic041q2q)\n\n## 使用 JavaScript 编写链表类\n\n与前面两节课相同，编写链表类，我们仍然使用构造器函数的方法。\n\n```js\nfunction LinkedList() {\n  ...\n}\n\nmodule.exports = LinkedList;\n```\n\n### 私有变量\n\n与栈和队列不同，链表类的私有变量不是一个数组，而是一个指针 `head`。这个指针其实就是指向某个对象的普通变量而已。除此之外，我们还要定义私有变量 `length` 来记录链表的长度和一个私有的构造器函数 `Node` 来构建包含 next 属性的链表元素。\n\n```js\nfunction LinkedList() {\n  var Node = function (element) {\n    this.element = element;\n    this.next = null;\n  };\n\n  var length = 0;\n  var head = null;\n}\n\n```\n\n那么链表元素究竟在代码中长什么样呢？假设一个链表先后有 `15，10` 两个元素，那么这个链表其实就长这样：\n\n```js\n{\n  element: 15,\n  next: {\n    element : 10,\n    next: null\n  }\n}\n```\n\n私有变量 `head` 就指向 `element` 为 `15` 的那个对象，`length` 就是 `2`，构造器函数 `Node` 仅仅用来创建链表元素。\n\n### 实现 append 和 toString 方法\n\n了解了私有变量，我们来实现各种类方法。我们期望链表类拥有 `append` 和 `toString` 方法，即追加元素和转为字符串，可以跑通下面的测试：\n\n```js\nvar linkedList = new LinkedList();\n// 添加15\nlinkedList.append(15);\n// 添加10\nlinkedList.append(10);\n// 转化为字符串\nexpect(linkedList.toString()).toBe('15,10');\n```\n\n如果仅仅是为了跑通上述测试，那么非常简单，只需要用数组即可，但是注意我们是给链表类实现方法，所用的数据结构必须为链表才行，所以当 `append(15)` 时，`head` 应该为：\n\n```js\n{\n  element: 15,\n  next: null\n}\n```\n当 `append(10)` 时，`head` 应该为：\n\n```js\n{\n  element: 15,\n  next: {\n    element : 10,\n    next: null\n  }\n}\n```\n\n所以，我们编写的代码如下：\n\n```js\nthis.append = function (element) {\n  var node = new Node(element),\n    current;\n  \n  // 链表为空直接将 head 指向新元素\n  if (head === null) {\n    head = node;\n  } else {\n    // 链表不为空需要将 current 移动到最后一个元素\n    current = head;\n    while (current.next) {\n      current = current.next;\n    }\n    // 然后将最后一个元素的 next 属性指向新元素\n    current.next = node;\n  }\n  length++;\n};\n\n...\n\nthis.toString = function () {\n\n  var current = head,\n    string = '';\n\n  while (current) {\n    string += current.element + (current.next ? ',' : '');\n    current = current.next;\n  }\n  return string;\n\n};\n```\n\n上述两个方法都遍历了链表：\n\n```js\nwhile (current) {\n  // 此处编写循环中的逻辑\n  ...\n  current = current.next;\n}\n```\n看到这里，很多不熟悉 JavaScript 的同学可能会问：`current = cuuren.next` 是什么？让我慢慢解释一下。在 JavaScript 中，变量分为基本类型和引用类型，其中对象类型是引用类型的，也就是说创建一个对象时，在内存开辟了一块地方，后续无论你将这个变量传给多少个其他变量，这些变量都指向同一块内存：\n\n```js\nvar a = { name: 'lewis' };\nb = a;\nb.name = 'susan';\nconsole.log(a); // { name: 'susan' }\n```\n所以在链表中，我们可以使用 `head`、`current` 等变量来指向某个存在内存中的变量：\n\n```js\n{\n  element: 15,   // head 指向 element 为 15 的对象\n  next: {\n    element : 10, // current 是个临时变量，可以更改它的指向来遍历链表\n    next: null\n  }\n}\n```\n所以 `current = current.next` 就相当于 `current` 原来指向 element 为 15 的对象，后来指向了 element 为 10 的对象，因为后者挂在前者的 next 属性上，就像上述代码中的那样。现在你应该明白了吧！更详细的引用类型的知识可以自行谷歌。\n\n### 实现 removeAt 方法\n\n实现 `removeAt` 方法，即删除指定位置的元素，可以跑通如下测试：\n\n```js\nvar linkedList = new LinkedList();\nlinkedList.append(15);\nlinkedList.append(10);\n// 删除位置小于0的元素时返回 null\nexpect(linkedList.removeAt(-1)).toBe(null); // 断言一\n// 删除位置大于链表长度的元素时返回 null\nexpect(linkedList.removeAt(3)).toBe(null); // 断言二\n// 删除位置为1的元素并返回\nexpect(linkedList.removeAt(1)).toBe(10); // 断言三\n// 删除位置为0的元素并返回\nexpect(linkedList.removeAt(0)).toBe(15); // 断言四\n// 链表现在没有元素了\nexpect(linkedList.toString()).toBe('');\n```\n\n断言一、二都是异常情况，应该使用条件语句来判断并跳过，断言三、四是正常情况，应该删除元素并返回。\n\n> 不了解断言和单元测试的同学，可以先看[《Jest 单元测试入门》](https://lewis617.github.io/2017/02/15/start-jest/)这篇博客。\n\n实现代码如下：\n\n```js\nthis.removeAt = function (position) {\n  // 用于跳过异常情况\n  if (position > -1 && position < length) {\n    var current = head,\n      previous,\n      index = 0;\n    // 删除头部元素\n    if (position === 0) {\n      head = current.next;\n    } else {\n      // 找出指定位置元素，并让它的前一个元素连接它的后一个元素\n      while (index < position) {\n        previous = current;\n        current = current.next;\n        index++;\n      }\n      previous.next = current.next;\n    }\n\n    length--;\n    return current.element;\n\n  }\n  return null;\n};\n```\n\n这个方法的技巧是找出指定位置元素，但本质还是遍历链表，只是终止条件有差别而已：\n\n```js\nwhile (index < position) {\n  // 代码逻辑\n  ...\n  current = current.next;\n  index++;\n}\n```\n\n### 实现 insert 方法\n\n实现 `insert` 方法，即向指定位置插入指定元素，跑通如下测试：\n\n```js\nvar linkedList = new LinkedList();\nexpect(linkedList.insert(0, 15)); // 断言一\nexpect(linkedList.insert(1, 12)); // 断言二\nexpect(linkedList.insert(0, 10)); // 断言三\nexpect(linkedList.insert(-1, 8)); // 断言四\nexpect(linkedList.insert(4, 8)); // 断言五\nexpect(linkedList.toString()).toBe('10,15,12');\n```\n\n断言一、三是往头部插入，断言二是往非头部插入，断言四、五都是异常非法输入。实现代码如下：\n\n```js\nthis.insert = function (position, element) {\n  // 用于跳过非法输入，对应第四个和第五个断言\n  if (position > -1 && position <= length) {\n    var node = new Node(element),\n      current = head,\n      previous,\n      index = 0;\n    // 往头部插入，对应第一个和第三个断言\n    if (position === 0) {\n      node.next = current;\n      head = node;\n    } else {\n      // 往非头部插入，对应第二个断言\n      while (index < position) {\n        previous = current;\n        current = current.next;\n        index++;\n      }\n      node.next = current;\n      previous.next = node;\n    }\n\n    length++;\n\n    return true;\n  }\n  return false;\n};\n```\n\n这个方法的技巧也是在链表中查找指定元素，其他都是无聊的边界判断。\n\n### 实现 indexOf 方法\n\n实现 `indexOf` 方法，即返回指定位置的元素，跑通如下测试。\n\n```js\nvar linkedList = new LinkedList();\nlinkedList.append(15);\nlinkedList.append(10);\nexpect(linkedList.indexOf(12)).toBe(2); // 断言一\nexpect(linkedList.indexOf(8)).toBe(-1); // 断言二\n```\n\n断言一是正常情况，返回 `position`，断言二没有该元素返回 `-1` 。技巧还是在链表中遍历查找元素。\n\n```js\nthis.indexOf = function (element) {\n  var current = head,\n    index = 0;\n\n  while (current) {\n    if (element === current.element) {\n      return index;\n    }\n    index++;\n    current = current.next;\n  }\n  return -1;\n};\n```\n\n其他方法比较简单不再赘述。\n\n## 总结\n\n玩转链表，有以下技巧：\n\n- 确定私有变量和元素结构，主要包括一个 head 指针，一个构造器函数 Node，用于生成包含 next 属性的对象。\n- 掌握遍历链表的方法，即使用 while 循环，通过 `current = curren.next`来遍历。\n- 学习在遍历链表时使用 `previous` 来记录当前节点的上一个节点。\n- 考虑各种边界情况：空链表、在查找范围外等情况。\n\n除了掌握上述技巧，动手写代码也是很重要的！今天，就到此为止。\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","source":"_posts/linked-list.md","raw":"---\ntitle: JavaScript 版数据结构与算法（三）链表\ndate: 2017-02-15 18:35:00\ntags: [数据结构与算法]\n---\n\n今天，我们要讲的是数据结构与算法中的链表。\n\n<!--more-->\n\n## 链表简介\n\n链表是什么？链表是一种动态的数据结构，这意味着我们可以任意增删元素，它会按需扩容。为何要使用链表？下面列举一些链表的用途：\n\n- 因为数组的存储有缺陷：增删元素时往往需要移动元素。而链表在内存中的放置并不是连续的，元素通过 next 属性指向下个元素，所以链表增删元素，不需要移动元素，只需要更改 next 的指向即可。\n- 在生活中，最形象的链表莫过于火车了，车头是 head，每一节车厢都有一个 next 用于连接后面的车厢，想增删车厢，只需要更改 next 即可。\n- 在使用分离链接法解决散列表冲突时，我们也会用链表存储位置冲突的元素。\n- 在 JavaScript 这门语言中有两个非常重要的**链**：作用域链和原型链。学习链表对于理解 JavaScript 的这两个特性也非常有帮助。\n\n![](https://ws1.sinaimg.cn/mw690/83900b4egy1fcrboyt21qj20ic041q2q)\n\n## 使用 JavaScript 编写链表类\n\n与前面两节课相同，编写链表类，我们仍然使用构造器函数的方法。\n\n```js\nfunction LinkedList() {\n  ...\n}\n\nmodule.exports = LinkedList;\n```\n\n### 私有变量\n\n与栈和队列不同，链表类的私有变量不是一个数组，而是一个指针 `head`。这个指针其实就是指向某个对象的普通变量而已。除此之外，我们还要定义私有变量 `length` 来记录链表的长度和一个私有的构造器函数 `Node` 来构建包含 next 属性的链表元素。\n\n```js\nfunction LinkedList() {\n  var Node = function (element) {\n    this.element = element;\n    this.next = null;\n  };\n\n  var length = 0;\n  var head = null;\n}\n\n```\n\n那么链表元素究竟在代码中长什么样呢？假设一个链表先后有 `15，10` 两个元素，那么这个链表其实就长这样：\n\n```js\n{\n  element: 15,\n  next: {\n    element : 10,\n    next: null\n  }\n}\n```\n\n私有变量 `head` 就指向 `element` 为 `15` 的那个对象，`length` 就是 `2`，构造器函数 `Node` 仅仅用来创建链表元素。\n\n### 实现 append 和 toString 方法\n\n了解了私有变量，我们来实现各种类方法。我们期望链表类拥有 `append` 和 `toString` 方法，即追加元素和转为字符串，可以跑通下面的测试：\n\n```js\nvar linkedList = new LinkedList();\n// 添加15\nlinkedList.append(15);\n// 添加10\nlinkedList.append(10);\n// 转化为字符串\nexpect(linkedList.toString()).toBe('15,10');\n```\n\n如果仅仅是为了跑通上述测试，那么非常简单，只需要用数组即可，但是注意我们是给链表类实现方法，所用的数据结构必须为链表才行，所以当 `append(15)` 时，`head` 应该为：\n\n```js\n{\n  element: 15,\n  next: null\n}\n```\n当 `append(10)` 时，`head` 应该为：\n\n```js\n{\n  element: 15,\n  next: {\n    element : 10,\n    next: null\n  }\n}\n```\n\n所以，我们编写的代码如下：\n\n```js\nthis.append = function (element) {\n  var node = new Node(element),\n    current;\n  \n  // 链表为空直接将 head 指向新元素\n  if (head === null) {\n    head = node;\n  } else {\n    // 链表不为空需要将 current 移动到最后一个元素\n    current = head;\n    while (current.next) {\n      current = current.next;\n    }\n    // 然后将最后一个元素的 next 属性指向新元素\n    current.next = node;\n  }\n  length++;\n};\n\n...\n\nthis.toString = function () {\n\n  var current = head,\n    string = '';\n\n  while (current) {\n    string += current.element + (current.next ? ',' : '');\n    current = current.next;\n  }\n  return string;\n\n};\n```\n\n上述两个方法都遍历了链表：\n\n```js\nwhile (current) {\n  // 此处编写循环中的逻辑\n  ...\n  current = current.next;\n}\n```\n看到这里，很多不熟悉 JavaScript 的同学可能会问：`current = cuuren.next` 是什么？让我慢慢解释一下。在 JavaScript 中，变量分为基本类型和引用类型，其中对象类型是引用类型的，也就是说创建一个对象时，在内存开辟了一块地方，后续无论你将这个变量传给多少个其他变量，这些变量都指向同一块内存：\n\n```js\nvar a = { name: 'lewis' };\nb = a;\nb.name = 'susan';\nconsole.log(a); // { name: 'susan' }\n```\n所以在链表中，我们可以使用 `head`、`current` 等变量来指向某个存在内存中的变量：\n\n```js\n{\n  element: 15,   // head 指向 element 为 15 的对象\n  next: {\n    element : 10, // current 是个临时变量，可以更改它的指向来遍历链表\n    next: null\n  }\n}\n```\n所以 `current = current.next` 就相当于 `current` 原来指向 element 为 15 的对象，后来指向了 element 为 10 的对象，因为后者挂在前者的 next 属性上，就像上述代码中的那样。现在你应该明白了吧！更详细的引用类型的知识可以自行谷歌。\n\n### 实现 removeAt 方法\n\n实现 `removeAt` 方法，即删除指定位置的元素，可以跑通如下测试：\n\n```js\nvar linkedList = new LinkedList();\nlinkedList.append(15);\nlinkedList.append(10);\n// 删除位置小于0的元素时返回 null\nexpect(linkedList.removeAt(-1)).toBe(null); // 断言一\n// 删除位置大于链表长度的元素时返回 null\nexpect(linkedList.removeAt(3)).toBe(null); // 断言二\n// 删除位置为1的元素并返回\nexpect(linkedList.removeAt(1)).toBe(10); // 断言三\n// 删除位置为0的元素并返回\nexpect(linkedList.removeAt(0)).toBe(15); // 断言四\n// 链表现在没有元素了\nexpect(linkedList.toString()).toBe('');\n```\n\n断言一、二都是异常情况，应该使用条件语句来判断并跳过，断言三、四是正常情况，应该删除元素并返回。\n\n> 不了解断言和单元测试的同学，可以先看[《Jest 单元测试入门》](https://lewis617.github.io/2017/02/15/start-jest/)这篇博客。\n\n实现代码如下：\n\n```js\nthis.removeAt = function (position) {\n  // 用于跳过异常情况\n  if (position > -1 && position < length) {\n    var current = head,\n      previous,\n      index = 0;\n    // 删除头部元素\n    if (position === 0) {\n      head = current.next;\n    } else {\n      // 找出指定位置元素，并让它的前一个元素连接它的后一个元素\n      while (index < position) {\n        previous = current;\n        current = current.next;\n        index++;\n      }\n      previous.next = current.next;\n    }\n\n    length--;\n    return current.element;\n\n  }\n  return null;\n};\n```\n\n这个方法的技巧是找出指定位置元素，但本质还是遍历链表，只是终止条件有差别而已：\n\n```js\nwhile (index < position) {\n  // 代码逻辑\n  ...\n  current = current.next;\n  index++;\n}\n```\n\n### 实现 insert 方法\n\n实现 `insert` 方法，即向指定位置插入指定元素，跑通如下测试：\n\n```js\nvar linkedList = new LinkedList();\nexpect(linkedList.insert(0, 15)); // 断言一\nexpect(linkedList.insert(1, 12)); // 断言二\nexpect(linkedList.insert(0, 10)); // 断言三\nexpect(linkedList.insert(-1, 8)); // 断言四\nexpect(linkedList.insert(4, 8)); // 断言五\nexpect(linkedList.toString()).toBe('10,15,12');\n```\n\n断言一、三是往头部插入，断言二是往非头部插入，断言四、五都是异常非法输入。实现代码如下：\n\n```js\nthis.insert = function (position, element) {\n  // 用于跳过非法输入，对应第四个和第五个断言\n  if (position > -1 && position <= length) {\n    var node = new Node(element),\n      current = head,\n      previous,\n      index = 0;\n    // 往头部插入，对应第一个和第三个断言\n    if (position === 0) {\n      node.next = current;\n      head = node;\n    } else {\n      // 往非头部插入，对应第二个断言\n      while (index < position) {\n        previous = current;\n        current = current.next;\n        index++;\n      }\n      node.next = current;\n      previous.next = node;\n    }\n\n    length++;\n\n    return true;\n  }\n  return false;\n};\n```\n\n这个方法的技巧也是在链表中查找指定元素，其他都是无聊的边界判断。\n\n### 实现 indexOf 方法\n\n实现 `indexOf` 方法，即返回指定位置的元素，跑通如下测试。\n\n```js\nvar linkedList = new LinkedList();\nlinkedList.append(15);\nlinkedList.append(10);\nexpect(linkedList.indexOf(12)).toBe(2); // 断言一\nexpect(linkedList.indexOf(8)).toBe(-1); // 断言二\n```\n\n断言一是正常情况，返回 `position`，断言二没有该元素返回 `-1` 。技巧还是在链表中遍历查找元素。\n\n```js\nthis.indexOf = function (element) {\n  var current = head,\n    index = 0;\n\n  while (current) {\n    if (element === current.element) {\n      return index;\n    }\n    index++;\n    current = current.next;\n  }\n  return -1;\n};\n```\n\n其他方法比较简单不再赘述。\n\n## 总结\n\n玩转链表，有以下技巧：\n\n- 确定私有变量和元素结构，主要包括一个 head 指针，一个构造器函数 Node，用于生成包含 next 属性的对象。\n- 掌握遍历链表的方法，即使用 while 循环，通过 `current = curren.next`来遍历。\n- 学习在遍历链表时使用 `previous` 来记录当前节点的上一个节点。\n- 考虑各种边界情况：空链表、在查找范围外等情况。\n\n除了掌握上述技巧，动手写代码也是很重要的！今天，就到此为止。\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","slug":"linked-list","published":1,"updated":"2019-05-01T08:02:10.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvlm0014tgytc4v6h6pp","content":"<p>今天，我们要讲的是数据结构与算法中的链表。</p>\n<a id=\"more\"></a>\n<h2 id=\"链表简介\"><a href=\"#链表简介\" class=\"headerlink\" title=\"链表简介\"></a>链表简介</h2><p>链表是什么？链表是一种动态的数据结构，这意味着我们可以任意增删元素，它会按需扩容。为何要使用链表？下面列举一些链表的用途：</p>\n<ul>\n<li>因为数组的存储有缺陷：增删元素时往往需要移动元素。而链表在内存中的放置并不是连续的，元素通过 next 属性指向下个元素，所以链表增删元素，不需要移动元素，只需要更改 next 的指向即可。</li>\n<li>在生活中，最形象的链表莫过于火车了，车头是 head，每一节车厢都有一个 next 用于连接后面的车厢，想增删车厢，只需要更改 next 即可。</li>\n<li>在使用分离链接法解决散列表冲突时，我们也会用链表存储位置冲突的元素。</li>\n<li>在 JavaScript 这门语言中有两个非常重要的<strong>链</strong>：作用域链和原型链。学习链表对于理解 JavaScript 的这两个特性也非常有帮助。</li>\n</ul>\n<p><img src=\"https://ws1.sinaimg.cn/mw690/83900b4egy1fcrboyt21qj20ic041q2q\" alt=\"\"></p>\n<h2 id=\"使用-JavaScript-编写链表类\"><a href=\"#使用-JavaScript-编写链表类\" class=\"headerlink\" title=\"使用 JavaScript 编写链表类\"></a>使用 JavaScript 编写链表类</h2><p>与前面两节课相同，编写链表类，我们仍然使用构造器函数的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LinkedList</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = LinkedList;</span><br></pre></td></tr></table></figure>\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>与栈和队列不同，链表类的私有变量不是一个数组，而是一个指针 <code>head</code>。这个指针其实就是指向某个对象的普通变量而已。除此之外，我们还要定义私有变量 <code>length</code> 来记录链表的长度和一个私有的构造器函数 <code>Node</code> 来构建包含 next 属性的链表元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LinkedList</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Node = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element = element;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> head = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么链表元素究竟在代码中长什么样呢？假设一个链表先后有 <code>15，10</code> 两个元素，那么这个链表其实就长这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  element: <span class=\"number\">15</span>,</span><br><span class=\"line\">  next: &#123;</span><br><span class=\"line\">    element : <span class=\"number\">10</span>,</span><br><span class=\"line\">    next: <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>私有变量 <code>head</code> 就指向 <code>element</code> 为 <code>15</code> 的那个对象，<code>length</code> 就是 <code>2</code>，构造器函数 <code>Node</code> 仅仅用来创建链表元素。</p>\n<h3 id=\"实现-append-和-toString-方法\"><a href=\"#实现-append-和-toString-方法\" class=\"headerlink\" title=\"实现 append 和 toString 方法\"></a>实现 append 和 toString 方法</h3><p>了解了私有变量，我们来实现各种类方法。我们期望链表类拥有 <code>append</code> 和 <code>toString</code> 方法，即追加元素和转为字符串，可以跑通下面的测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> linkedList = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\"><span class=\"comment\">// 添加15</span></span><br><span class=\"line\">linkedList.append(<span class=\"number\">15</span>);</span><br><span class=\"line\"><span class=\"comment\">// 添加10</span></span><br><span class=\"line\">linkedList.append(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"comment\">// 转化为字符串</span></span><br><span class=\"line\">expect(linkedList.toString()).toBe(<span class=\"string\">'15,10'</span>);</span><br></pre></td></tr></table></figure>\n<p>如果仅仅是为了跑通上述测试，那么非常简单，只需要用数组即可，但是注意我们是给链表类实现方法，所用的数据结构必须为链表才行，所以当 <code>append(15)</code> 时，<code>head</code> 应该为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  element: <span class=\"number\">15</span>,</span><br><span class=\"line\">  next: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 <code>append(10)</code> 时，<code>head</code> 应该为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  element: <span class=\"number\">15</span>,</span><br><span class=\"line\">  next: &#123;</span><br><span class=\"line\">    element : <span class=\"number\">10</span>,</span><br><span class=\"line\">    next: <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，我们编写的代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.append = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> node = <span class=\"keyword\">new</span> Node(element),</span><br><span class=\"line\">    current;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 链表为空直接将 head 指向新元素</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (head === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    head = node;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 链表不为空需要将 current 移动到最后一个元素</span></span><br><span class=\"line\">    current = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current.next) &#123;</span><br><span class=\"line\">      current = current.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 然后将最后一个元素的 next 属性指向新元素</span></span><br><span class=\"line\">    current.next = node;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  length++;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> current = head,</span><br><span class=\"line\">    string = <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (current) &#123;</span><br><span class=\"line\">    string += current.element + (current.next ? <span class=\"string\">','</span> : <span class=\"string\">''</span>);</span><br><span class=\"line\">    current = current.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> string;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上述两个方法都遍历了链表：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (current) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 此处编写循环中的逻辑</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  current = current.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到这里，很多不熟悉 JavaScript 的同学可能会问：<code>current = cuuren.next</code> 是什么？让我慢慢解释一下。在 JavaScript 中，变量分为基本类型和引用类型，其中对象类型是引用类型的，也就是说创建一个对象时，在内存开辟了一块地方，后续无论你将这个变量传给多少个其他变量，这些变量都指向同一块内存：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'lewis'</span> &#125;;</span><br><span class=\"line\">b = a;</span><br><span class=\"line\">b.name = <span class=\"string\">'susan'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// &#123; name: 'susan' &#125;</span></span><br></pre></td></tr></table></figure>\n<p>所以在链表中，我们可以使用 <code>head</code>、<code>current</code> 等变量来指向某个存在内存中的变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  element: <span class=\"number\">15</span>,   <span class=\"comment\">// head 指向 element 为 15 的对象</span></span><br><span class=\"line\">  next: &#123;</span><br><span class=\"line\">    element : <span class=\"number\">10</span>, <span class=\"comment\">// current 是个临时变量，可以更改它的指向来遍历链表</span></span><br><span class=\"line\">    next: <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以 <code>current = current.next</code> 就相当于 <code>current</code> 原来指向 element 为 15 的对象，后来指向了 element 为 10 的对象，因为后者挂在前者的 next 属性上，就像上述代码中的那样。现在你应该明白了吧！更详细的引用类型的知识可以自行谷歌。</p>\n<h3 id=\"实现-removeAt-方法\"><a href=\"#实现-removeAt-方法\" class=\"headerlink\" title=\"实现 removeAt 方法\"></a>实现 removeAt 方法</h3><p>实现 <code>removeAt</code> 方法，即删除指定位置的元素，可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> linkedList = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">linkedList.append(<span class=\"number\">15</span>);</span><br><span class=\"line\">linkedList.append(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"comment\">// 删除位置小于0的元素时返回 null</span></span><br><span class=\"line\">expect(linkedList.removeAt(<span class=\"number\">-1</span>)).toBe(<span class=\"literal\">null</span>); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\"><span class=\"comment\">// 删除位置大于链表长度的元素时返回 null</span></span><br><span class=\"line\">expect(linkedList.removeAt(<span class=\"number\">3</span>)).toBe(<span class=\"literal\">null</span>); <span class=\"comment\">// 断言二</span></span><br><span class=\"line\"><span class=\"comment\">// 删除位置为1的元素并返回</span></span><br><span class=\"line\">expect(linkedList.removeAt(<span class=\"number\">1</span>)).toBe(<span class=\"number\">10</span>); <span class=\"comment\">// 断言三</span></span><br><span class=\"line\"><span class=\"comment\">// 删除位置为0的元素并返回</span></span><br><span class=\"line\">expect(linkedList.removeAt(<span class=\"number\">0</span>)).toBe(<span class=\"number\">15</span>); <span class=\"comment\">// 断言四</span></span><br><span class=\"line\"><span class=\"comment\">// 链表现在没有元素了</span></span><br><span class=\"line\">expect(linkedList.toString()).toBe(<span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n<p>断言一、二都是异常情况，应该使用条件语句来判断并跳过，断言三、四是正常情况，应该删除元素并返回。</p>\n<blockquote>\n<p>不了解断言和单元测试的同学，可以先看<a href=\"https://lewis617.github.io/2017/02/15/start-jest/\" target=\"_blank\" rel=\"noopener\">《Jest 单元测试入门》</a>这篇博客。</p>\n</blockquote>\n<p>实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.removeAt = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">position</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 用于跳过异常情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (position &gt; <span class=\"number\">-1</span> &amp;&amp; position &lt; length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = head,</span><br><span class=\"line\">      previous,</span><br><span class=\"line\">      index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 删除头部元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      head = current.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 找出指定位置元素，并让它的前一个元素连接它的后一个元素</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (index &lt; position) &#123;</span><br><span class=\"line\">        previous = current;</span><br><span class=\"line\">        current = current.next;</span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      previous.next = current.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    length--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current.element;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个方法的技巧是找出指定位置元素，但本质还是遍历链表，只是终止条件有差别而已：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (index &lt; position) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 代码逻辑</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  current = current.next;</span><br><span class=\"line\">  index++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-insert-方法\"><a href=\"#实现-insert-方法\" class=\"headerlink\" title=\"实现 insert 方法\"></a>实现 insert 方法</h3><p>实现 <code>insert</code> 方法，即向指定位置插入指定元素，跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> linkedList = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">expect(linkedList.insert(<span class=\"number\">0</span>, <span class=\"number\">15</span>)); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">expect(linkedList.insert(<span class=\"number\">1</span>, <span class=\"number\">12</span>)); <span class=\"comment\">// 断言二</span></span><br><span class=\"line\">expect(linkedList.insert(<span class=\"number\">0</span>, <span class=\"number\">10</span>)); <span class=\"comment\">// 断言三</span></span><br><span class=\"line\">expect(linkedList.insert(<span class=\"number\">-1</span>, <span class=\"number\">8</span>)); <span class=\"comment\">// 断言四</span></span><br><span class=\"line\">expect(linkedList.insert(<span class=\"number\">4</span>, <span class=\"number\">8</span>)); <span class=\"comment\">// 断言五</span></span><br><span class=\"line\">expect(linkedList.toString()).toBe(<span class=\"string\">'10,15,12'</span>);</span><br></pre></td></tr></table></figure>\n<p>断言一、三是往头部插入，断言二是往非头部插入，断言四、五都是异常非法输入。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.insert = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">position, element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 用于跳过非法输入，对应第四个和第五个断言</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (position &gt; <span class=\"number\">-1</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> node = <span class=\"keyword\">new</span> Node(element),</span><br><span class=\"line\">      current = head,</span><br><span class=\"line\">      previous,</span><br><span class=\"line\">      index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 往头部插入，对应第一个和第三个断言</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      node.next = current;</span><br><span class=\"line\">      head = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 往非头部插入，对应第二个断言</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (index &lt; position) &#123;</span><br><span class=\"line\">        previous = current;</span><br><span class=\"line\">        current = current.next;</span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      node.next = current;</span><br><span class=\"line\">      previous.next = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    length++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个方法的技巧也是在链表中查找指定元素，其他都是无聊的边界判断。</p>\n<h3 id=\"实现-indexOf-方法\"><a href=\"#实现-indexOf-方法\" class=\"headerlink\" title=\"实现 indexOf 方法\"></a>实现 indexOf 方法</h3><p>实现 <code>indexOf</code> 方法，即返回指定位置的元素，跑通如下测试。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> linkedList = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">linkedList.append(<span class=\"number\">15</span>);</span><br><span class=\"line\">linkedList.append(<span class=\"number\">10</span>);</span><br><span class=\"line\">expect(linkedList.indexOf(<span class=\"number\">12</span>)).toBe(<span class=\"number\">2</span>); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">expect(linkedList.indexOf(<span class=\"number\">8</span>)).toBe(<span class=\"number\">-1</span>); <span class=\"comment\">// 断言二</span></span><br></pre></td></tr></table></figure>\n<p>断言一是正常情况，返回 <code>position</code>，断言二没有该元素返回 <code>-1</code> 。技巧还是在链表中遍历查找元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.indexOf = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> current = head,</span><br><span class=\"line\">    index = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (current) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element === current.element) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    index++;</span><br><span class=\"line\">    current = current.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其他方法比较简单不再赘述。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>玩转链表，有以下技巧：</p>\n<ul>\n<li>确定私有变量和元素结构，主要包括一个 head 指针，一个构造器函数 Node，用于生成包含 next 属性的对象。</li>\n<li>掌握遍历链表的方法，即使用 while 循环，通过 <code>current = curren.next</code>来遍历。</li>\n<li>学习在遍历链表时使用 <code>previous</code> 来记录当前节点的上一个节点。</li>\n<li>考虑各种边界情况：空链表、在查找范围外等情况。</li>\n</ul>\n<p>除了掌握上述技巧，动手写代码也是很重要的！今天，就到此为止。</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是数据结构与算法中的链表。</p>","more":"<h2 id=\"链表简介\"><a href=\"#链表简介\" class=\"headerlink\" title=\"链表简介\"></a>链表简介</h2><p>链表是什么？链表是一种动态的数据结构，这意味着我们可以任意增删元素，它会按需扩容。为何要使用链表？下面列举一些链表的用途：</p>\n<ul>\n<li>因为数组的存储有缺陷：增删元素时往往需要移动元素。而链表在内存中的放置并不是连续的，元素通过 next 属性指向下个元素，所以链表增删元素，不需要移动元素，只需要更改 next 的指向即可。</li>\n<li>在生活中，最形象的链表莫过于火车了，车头是 head，每一节车厢都有一个 next 用于连接后面的车厢，想增删车厢，只需要更改 next 即可。</li>\n<li>在使用分离链接法解决散列表冲突时，我们也会用链表存储位置冲突的元素。</li>\n<li>在 JavaScript 这门语言中有两个非常重要的<strong>链</strong>：作用域链和原型链。学习链表对于理解 JavaScript 的这两个特性也非常有帮助。</li>\n</ul>\n<p><img src=\"https://ws1.sinaimg.cn/mw690/83900b4egy1fcrboyt21qj20ic041q2q\" alt=\"\"></p>\n<h2 id=\"使用-JavaScript-编写链表类\"><a href=\"#使用-JavaScript-编写链表类\" class=\"headerlink\" title=\"使用 JavaScript 编写链表类\"></a>使用 JavaScript 编写链表类</h2><p>与前面两节课相同，编写链表类，我们仍然使用构造器函数的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LinkedList</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = LinkedList;</span><br></pre></td></tr></table></figure>\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>与栈和队列不同，链表类的私有变量不是一个数组，而是一个指针 <code>head</code>。这个指针其实就是指向某个对象的普通变量而已。除此之外，我们还要定义私有变量 <code>length</code> 来记录链表的长度和一个私有的构造器函数 <code>Node</code> 来构建包含 next 属性的链表元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LinkedList</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Node = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element = element;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> head = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么链表元素究竟在代码中长什么样呢？假设一个链表先后有 <code>15，10</code> 两个元素，那么这个链表其实就长这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  element: <span class=\"number\">15</span>,</span><br><span class=\"line\">  next: &#123;</span><br><span class=\"line\">    element : <span class=\"number\">10</span>,</span><br><span class=\"line\">    next: <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>私有变量 <code>head</code> 就指向 <code>element</code> 为 <code>15</code> 的那个对象，<code>length</code> 就是 <code>2</code>，构造器函数 <code>Node</code> 仅仅用来创建链表元素。</p>\n<h3 id=\"实现-append-和-toString-方法\"><a href=\"#实现-append-和-toString-方法\" class=\"headerlink\" title=\"实现 append 和 toString 方法\"></a>实现 append 和 toString 方法</h3><p>了解了私有变量，我们来实现各种类方法。我们期望链表类拥有 <code>append</code> 和 <code>toString</code> 方法，即追加元素和转为字符串，可以跑通下面的测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> linkedList = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\"><span class=\"comment\">// 添加15</span></span><br><span class=\"line\">linkedList.append(<span class=\"number\">15</span>);</span><br><span class=\"line\"><span class=\"comment\">// 添加10</span></span><br><span class=\"line\">linkedList.append(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"comment\">// 转化为字符串</span></span><br><span class=\"line\">expect(linkedList.toString()).toBe(<span class=\"string\">'15,10'</span>);</span><br></pre></td></tr></table></figure>\n<p>如果仅仅是为了跑通上述测试，那么非常简单，只需要用数组即可，但是注意我们是给链表类实现方法，所用的数据结构必须为链表才行，所以当 <code>append(15)</code> 时，<code>head</code> 应该为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  element: <span class=\"number\">15</span>,</span><br><span class=\"line\">  next: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 <code>append(10)</code> 时，<code>head</code> 应该为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  element: <span class=\"number\">15</span>,</span><br><span class=\"line\">  next: &#123;</span><br><span class=\"line\">    element : <span class=\"number\">10</span>,</span><br><span class=\"line\">    next: <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，我们编写的代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.append = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> node = <span class=\"keyword\">new</span> Node(element),</span><br><span class=\"line\">    current;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 链表为空直接将 head 指向新元素</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (head === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    head = node;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 链表不为空需要将 current 移动到最后一个元素</span></span><br><span class=\"line\">    current = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current.next) &#123;</span><br><span class=\"line\">      current = current.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 然后将最后一个元素的 next 属性指向新元素</span></span><br><span class=\"line\">    current.next = node;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  length++;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> current = head,</span><br><span class=\"line\">    string = <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (current) &#123;</span><br><span class=\"line\">    string += current.element + (current.next ? <span class=\"string\">','</span> : <span class=\"string\">''</span>);</span><br><span class=\"line\">    current = current.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> string;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上述两个方法都遍历了链表：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (current) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 此处编写循环中的逻辑</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  current = current.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到这里，很多不熟悉 JavaScript 的同学可能会问：<code>current = cuuren.next</code> 是什么？让我慢慢解释一下。在 JavaScript 中，变量分为基本类型和引用类型，其中对象类型是引用类型的，也就是说创建一个对象时，在内存开辟了一块地方，后续无论你将这个变量传给多少个其他变量，这些变量都指向同一块内存：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'lewis'</span> &#125;;</span><br><span class=\"line\">b = a;</span><br><span class=\"line\">b.name = <span class=\"string\">'susan'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// &#123; name: 'susan' &#125;</span></span><br></pre></td></tr></table></figure>\n<p>所以在链表中，我们可以使用 <code>head</code>、<code>current</code> 等变量来指向某个存在内存中的变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  element: <span class=\"number\">15</span>,   <span class=\"comment\">// head 指向 element 为 15 的对象</span></span><br><span class=\"line\">  next: &#123;</span><br><span class=\"line\">    element : <span class=\"number\">10</span>, <span class=\"comment\">// current 是个临时变量，可以更改它的指向来遍历链表</span></span><br><span class=\"line\">    next: <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以 <code>current = current.next</code> 就相当于 <code>current</code> 原来指向 element 为 15 的对象，后来指向了 element 为 10 的对象，因为后者挂在前者的 next 属性上，就像上述代码中的那样。现在你应该明白了吧！更详细的引用类型的知识可以自行谷歌。</p>\n<h3 id=\"实现-removeAt-方法\"><a href=\"#实现-removeAt-方法\" class=\"headerlink\" title=\"实现 removeAt 方法\"></a>实现 removeAt 方法</h3><p>实现 <code>removeAt</code> 方法，即删除指定位置的元素，可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> linkedList = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">linkedList.append(<span class=\"number\">15</span>);</span><br><span class=\"line\">linkedList.append(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"comment\">// 删除位置小于0的元素时返回 null</span></span><br><span class=\"line\">expect(linkedList.removeAt(<span class=\"number\">-1</span>)).toBe(<span class=\"literal\">null</span>); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\"><span class=\"comment\">// 删除位置大于链表长度的元素时返回 null</span></span><br><span class=\"line\">expect(linkedList.removeAt(<span class=\"number\">3</span>)).toBe(<span class=\"literal\">null</span>); <span class=\"comment\">// 断言二</span></span><br><span class=\"line\"><span class=\"comment\">// 删除位置为1的元素并返回</span></span><br><span class=\"line\">expect(linkedList.removeAt(<span class=\"number\">1</span>)).toBe(<span class=\"number\">10</span>); <span class=\"comment\">// 断言三</span></span><br><span class=\"line\"><span class=\"comment\">// 删除位置为0的元素并返回</span></span><br><span class=\"line\">expect(linkedList.removeAt(<span class=\"number\">0</span>)).toBe(<span class=\"number\">15</span>); <span class=\"comment\">// 断言四</span></span><br><span class=\"line\"><span class=\"comment\">// 链表现在没有元素了</span></span><br><span class=\"line\">expect(linkedList.toString()).toBe(<span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n<p>断言一、二都是异常情况，应该使用条件语句来判断并跳过，断言三、四是正常情况，应该删除元素并返回。</p>\n<blockquote>\n<p>不了解断言和单元测试的同学，可以先看<a href=\"https://lewis617.github.io/2017/02/15/start-jest/\" target=\"_blank\" rel=\"noopener\">《Jest 单元测试入门》</a>这篇博客。</p>\n</blockquote>\n<p>实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.removeAt = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">position</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 用于跳过异常情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (position &gt; <span class=\"number\">-1</span> &amp;&amp; position &lt; length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = head,</span><br><span class=\"line\">      previous,</span><br><span class=\"line\">      index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 删除头部元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      head = current.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 找出指定位置元素，并让它的前一个元素连接它的后一个元素</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (index &lt; position) &#123;</span><br><span class=\"line\">        previous = current;</span><br><span class=\"line\">        current = current.next;</span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      previous.next = current.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    length--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current.element;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个方法的技巧是找出指定位置元素，但本质还是遍历链表，只是终止条件有差别而已：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (index &lt; position) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 代码逻辑</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  current = current.next;</span><br><span class=\"line\">  index++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-insert-方法\"><a href=\"#实现-insert-方法\" class=\"headerlink\" title=\"实现 insert 方法\"></a>实现 insert 方法</h3><p>实现 <code>insert</code> 方法，即向指定位置插入指定元素，跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> linkedList = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">expect(linkedList.insert(<span class=\"number\">0</span>, <span class=\"number\">15</span>)); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">expect(linkedList.insert(<span class=\"number\">1</span>, <span class=\"number\">12</span>)); <span class=\"comment\">// 断言二</span></span><br><span class=\"line\">expect(linkedList.insert(<span class=\"number\">0</span>, <span class=\"number\">10</span>)); <span class=\"comment\">// 断言三</span></span><br><span class=\"line\">expect(linkedList.insert(<span class=\"number\">-1</span>, <span class=\"number\">8</span>)); <span class=\"comment\">// 断言四</span></span><br><span class=\"line\">expect(linkedList.insert(<span class=\"number\">4</span>, <span class=\"number\">8</span>)); <span class=\"comment\">// 断言五</span></span><br><span class=\"line\">expect(linkedList.toString()).toBe(<span class=\"string\">'10,15,12'</span>);</span><br></pre></td></tr></table></figure>\n<p>断言一、三是往头部插入，断言二是往非头部插入，断言四、五都是异常非法输入。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.insert = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">position, element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 用于跳过非法输入，对应第四个和第五个断言</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (position &gt; <span class=\"number\">-1</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> node = <span class=\"keyword\">new</span> Node(element),</span><br><span class=\"line\">      current = head,</span><br><span class=\"line\">      previous,</span><br><span class=\"line\">      index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 往头部插入，对应第一个和第三个断言</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      node.next = current;</span><br><span class=\"line\">      head = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 往非头部插入，对应第二个断言</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (index &lt; position) &#123;</span><br><span class=\"line\">        previous = current;</span><br><span class=\"line\">        current = current.next;</span><br><span class=\"line\">        index++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      node.next = current;</span><br><span class=\"line\">      previous.next = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    length++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个方法的技巧也是在链表中查找指定元素，其他都是无聊的边界判断。</p>\n<h3 id=\"实现-indexOf-方法\"><a href=\"#实现-indexOf-方法\" class=\"headerlink\" title=\"实现 indexOf 方法\"></a>实现 indexOf 方法</h3><p>实现 <code>indexOf</code> 方法，即返回指定位置的元素，跑通如下测试。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> linkedList = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">linkedList.append(<span class=\"number\">15</span>);</span><br><span class=\"line\">linkedList.append(<span class=\"number\">10</span>);</span><br><span class=\"line\">expect(linkedList.indexOf(<span class=\"number\">12</span>)).toBe(<span class=\"number\">2</span>); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">expect(linkedList.indexOf(<span class=\"number\">8</span>)).toBe(<span class=\"number\">-1</span>); <span class=\"comment\">// 断言二</span></span><br></pre></td></tr></table></figure>\n<p>断言一是正常情况，返回 <code>position</code>，断言二没有该元素返回 <code>-1</code> 。技巧还是在链表中遍历查找元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.indexOf = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> current = head,</span><br><span class=\"line\">    index = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (current) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element === current.element) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    index++;</span><br><span class=\"line\">    current = current.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其他方法比较简单不再赘述。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>玩转链表，有以下技巧：</p>\n<ul>\n<li>确定私有变量和元素结构，主要包括一个 head 指针，一个构造器函数 Node，用于生成包含 next 属性的对象。</li>\n<li>掌握遍历链表的方法，即使用 while 循环，通过 <code>current = curren.next</code>来遍历。</li>\n<li>学习在遍历链表时使用 <code>previous</code> 来记录当前节点的上一个节点。</li>\n<li>考虑各种边界情况：空链表、在查找范围外等情况。</li>\n</ul>\n<p>除了掌握上述技巧，动手写代码也是很重要的！今天，就到此为止。</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>"},{"title":"使用Karma测试平时写的小demo（arguments为例）","date":"2015-12-08T17:51:00.000Z","_content":"\n有人说前端自动化测试非常困难，我觉得确实如此。在项目中，我个人也不放心写的测试，还是要手动测试。但是我们平时写demo学习时，完全可以使用自动化测试。\n\n<!--more-->\n\n## 传统demo\n\n1，新建一个html\n\n2，写入js脚本\n\n3，运行html\n\n平时写demo，大家伙恐怕都是这个步骤吧，其实我们可以使用karma自动化这个过程。\n\n## 自动化demo（使用karma）\n\n假设已经安装好Karma，如果不会，请看本人的这篇博客 [Karma单元测试入门](https://lewis617.github.io/2015/10/12/karma-start/)\n\n1，在根目录运行\n\n```sh\nkarma init\n```\n\n一路空格选择默认，在`What is the location of your source and test files ?`这一项输入 `*.js`，其他默认\n\n![](/css/images/52.jpg)\n\n2，在根目录新建js文件demo.js\n\n如网友某个例子：\n\n```sh\nfunction f(a, b, c){\n    alert(arguments.length); // result: \"2\"\n    a = 100;\n    alert(arguments[0]);       // result: \"100\"\n    arguments[0] = \"qqyumidi\";\n    alert(a); // result: \"qqyumidi\"\n    alert(c);                  // result: \"undefined\"\n    c = 2012;\n    alert(arguments[2]);       // result: \"undefined\"\n}\n\nf(1, 2);\n```\n\n3，运行\n\n```sh\nkarma start\n```\n\n在命令行就可以看见运行结果啦：\n\n![](/css/images/53.jpg)\n\n## 觉得麻烦？\n\n这是我在教学，所以写的比较罗嗦，我自己在测试时候各种快捷！\n\n## Jasmine的语法你怎么不用？\n\n那些describe的语法当然可以用，这个例子只是为了教学，所以尽量避免干扰因素。\n\n## 更多测试文章：\n\n<http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/>\n","source":"_posts/karma-test-demo.md","raw":"---\ntitle: 使用Karma测试平时写的小demo（arguments为例）\ndate: 2015-12-09 01:51:00\ntags: [Karma, 单元测试, 测试]\n---\n\n有人说前端自动化测试非常困难，我觉得确实如此。在项目中，我个人也不放心写的测试，还是要手动测试。但是我们平时写demo学习时，完全可以使用自动化测试。\n\n<!--more-->\n\n## 传统demo\n\n1，新建一个html\n\n2，写入js脚本\n\n3，运行html\n\n平时写demo，大家伙恐怕都是这个步骤吧，其实我们可以使用karma自动化这个过程。\n\n## 自动化demo（使用karma）\n\n假设已经安装好Karma，如果不会，请看本人的这篇博客 [Karma单元测试入门](https://lewis617.github.io/2015/10/12/karma-start/)\n\n1，在根目录运行\n\n```sh\nkarma init\n```\n\n一路空格选择默认，在`What is the location of your source and test files ?`这一项输入 `*.js`，其他默认\n\n![](/css/images/52.jpg)\n\n2，在根目录新建js文件demo.js\n\n如网友某个例子：\n\n```sh\nfunction f(a, b, c){\n    alert(arguments.length); // result: \"2\"\n    a = 100;\n    alert(arguments[0]);       // result: \"100\"\n    arguments[0] = \"qqyumidi\";\n    alert(a); // result: \"qqyumidi\"\n    alert(c);                  // result: \"undefined\"\n    c = 2012;\n    alert(arguments[2]);       // result: \"undefined\"\n}\n\nf(1, 2);\n```\n\n3，运行\n\n```sh\nkarma start\n```\n\n在命令行就可以看见运行结果啦：\n\n![](/css/images/53.jpg)\n\n## 觉得麻烦？\n\n这是我在教学，所以写的比较罗嗦，我自己在测试时候各种快捷！\n\n## Jasmine的语法你怎么不用？\n\n那些describe的语法当然可以用，这个例子只是为了教学，所以尽量避免干扰因素。\n\n## 更多测试文章：\n\n<http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/>\n","slug":"karma-test-demo","published":1,"updated":"2019-05-01T08:10:29.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvln0017tgytaza9k50e","content":"<p>有人说前端自动化测试非常困难，我觉得确实如此。在项目中，我个人也不放心写的测试，还是要手动测试。但是我们平时写demo学习时，完全可以使用自动化测试。</p>\n<a id=\"more\"></a>\n<h2 id=\"传统demo\"><a href=\"#传统demo\" class=\"headerlink\" title=\"传统demo\"></a>传统demo</h2><p>1，新建一个html</p>\n<p>2，写入js脚本</p>\n<p>3，运行html</p>\n<p>平时写demo，大家伙恐怕都是这个步骤吧，其实我们可以使用karma自动化这个过程。</p>\n<h2 id=\"自动化demo（使用karma）\"><a href=\"#自动化demo（使用karma）\" class=\"headerlink\" title=\"自动化demo（使用karma）\"></a>自动化demo（使用karma）</h2><p>假设已经安装好Karma，如果不会，请看本人的这篇博客 <a href=\"https://lewis617.github.io/2015/10/12/karma-start/\" target=\"_blank\" rel=\"noopener\">Karma单元测试入门</a></p>\n<p>1，在根目录运行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">karma init</span><br></pre></td></tr></table></figure>\n<p>一路空格选择默认，在<code>What is the location of your source and test files ?</code>这一项输入 <code>*.js</code>，其他默认</p>\n<p><img src=\"/css/images/52.jpg\" alt=\"\"></p>\n<p>2，在根目录新建js文件demo.js</p>\n<p>如网友某个例子：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> f(a, b, c)&#123;</span><br><span class=\"line\">    alert(arguments.length); // result: <span class=\"string\">\"2\"</span></span><br><span class=\"line\">    a = 100;</span><br><span class=\"line\">    alert(arguments[0]);       // result: <span class=\"string\">\"100\"</span></span><br><span class=\"line\">    arguments[0] = <span class=\"string\">\"qqyumidi\"</span>;</span><br><span class=\"line\">    alert(a); // result: <span class=\"string\">\"qqyumidi\"</span></span><br><span class=\"line\">    alert(c);                  // result: <span class=\"string\">\"undefined\"</span></span><br><span class=\"line\">    c = 2012;</span><br><span class=\"line\">    alert(arguments[2]);       // result: <span class=\"string\">\"undefined\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 2);</span><br></pre></td></tr></table></figure>\n<p>3，运行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">karma start</span><br></pre></td></tr></table></figure>\n<p>在命令行就可以看见运行结果啦：</p>\n<p><img src=\"/css/images/53.jpg\" alt=\"\"></p>\n<h2 id=\"觉得麻烦？\"><a href=\"#觉得麻烦？\" class=\"headerlink\" title=\"觉得麻烦？\"></a>觉得麻烦？</h2><p>这是我在教学，所以写的比较罗嗦，我自己在测试时候各种快捷！</p>\n<h2 id=\"Jasmine的语法你怎么不用？\"><a href=\"#Jasmine的语法你怎么不用？\" class=\"headerlink\" title=\"Jasmine的语法你怎么不用？\"></a>Jasmine的语法你怎么不用？</h2><p>那些describe的语法当然可以用，这个例子只是为了教学，所以尽量避免干扰因素。</p>\n<h2 id=\"更多测试文章：\"><a href=\"#更多测试文章：\" class=\"headerlink\" title=\"更多测试文章：\"></a>更多测试文章：</h2><p><a href=\"http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/\">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>\n","site":{"data":{}},"excerpt":"<p>有人说前端自动化测试非常困难，我觉得确实如此。在项目中，我个人也不放心写的测试，还是要手动测试。但是我们平时写demo学习时，完全可以使用自动化测试。</p>","more":"<h2 id=\"传统demo\"><a href=\"#传统demo\" class=\"headerlink\" title=\"传统demo\"></a>传统demo</h2><p>1，新建一个html</p>\n<p>2，写入js脚本</p>\n<p>3，运行html</p>\n<p>平时写demo，大家伙恐怕都是这个步骤吧，其实我们可以使用karma自动化这个过程。</p>\n<h2 id=\"自动化demo（使用karma）\"><a href=\"#自动化demo（使用karma）\" class=\"headerlink\" title=\"自动化demo（使用karma）\"></a>自动化demo（使用karma）</h2><p>假设已经安装好Karma，如果不会，请看本人的这篇博客 <a href=\"https://lewis617.github.io/2015/10/12/karma-start/\" target=\"_blank\" rel=\"noopener\">Karma单元测试入门</a></p>\n<p>1，在根目录运行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">karma init</span><br></pre></td></tr></table></figure>\n<p>一路空格选择默认，在<code>What is the location of your source and test files ?</code>这一项输入 <code>*.js</code>，其他默认</p>\n<p><img src=\"/css/images/52.jpg\" alt=\"\"></p>\n<p>2，在根目录新建js文件demo.js</p>\n<p>如网友某个例子：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> f(a, b, c)&#123;</span><br><span class=\"line\">    alert(arguments.length); // result: <span class=\"string\">\"2\"</span></span><br><span class=\"line\">    a = 100;</span><br><span class=\"line\">    alert(arguments[0]);       // result: <span class=\"string\">\"100\"</span></span><br><span class=\"line\">    arguments[0] = <span class=\"string\">\"qqyumidi\"</span>;</span><br><span class=\"line\">    alert(a); // result: <span class=\"string\">\"qqyumidi\"</span></span><br><span class=\"line\">    alert(c);                  // result: <span class=\"string\">\"undefined\"</span></span><br><span class=\"line\">    c = 2012;</span><br><span class=\"line\">    alert(arguments[2]);       // result: <span class=\"string\">\"undefined\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 2);</span><br></pre></td></tr></table></figure>\n<p>3，运行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">karma start</span><br></pre></td></tr></table></figure>\n<p>在命令行就可以看见运行结果啦：</p>\n<p><img src=\"/css/images/53.jpg\" alt=\"\"></p>\n<h2 id=\"觉得麻烦？\"><a href=\"#觉得麻烦？\" class=\"headerlink\" title=\"觉得麻烦？\"></a>觉得麻烦？</h2><p>这是我在教学，所以写的比较罗嗦，我自己在测试时候各种快捷！</p>\n<h2 id=\"Jasmine的语法你怎么不用？\"><a href=\"#Jasmine的语法你怎么不用？\" class=\"headerlink\" title=\"Jasmine的语法你怎么不用？\"></a>Jasmine的语法你怎么不用？</h2><p>那些describe的语法当然可以用，这个例子只是为了教学，所以尽量避免干扰因素。</p>\n<h2 id=\"更多测试文章：\"><a href=\"#更多测试文章：\" class=\"headerlink\" title=\"更多测试文章：\"></a>更多测试文章：</h2><p><a href=\"http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/\">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>"},{"title":"Angular开发者吐槽React+Redux的复杂：“一个demo证明你的开发效率低下”","date":"2016-01-12T20:02:00.000Z","_content":"\n曾经看到一篇文章，写的是jQuery开发者吐槽Angular的复杂。作为一个Angular开发者，我来吐槽一下React+Redux的复杂。\n\n<!--more-->\n\n## 例子\n\n为了让大家看得舒服，我用最简单的一个demo来展示React+Redux的“弯弯绕”，下面这个程序就是我用React和Redux写的。然而这个程序在Angular中一行js都不用写！！！\n\n![](/css/images/54.gif)\n\n## 展示组件\n\nApp.js\n\n```js\nimport React, { findDOMNode, Component } from 'react';\nimport ReactDOM from 'react-dom';\nimport { connect } from 'react-redux';\nimport * as action from './actions' class App extends Component {\n  render() { return ( <div>\n        <input type='text' value={this.props.propsValue} onChange={this.changeHandle.bind(this)} ref=\"input\"/>\n        {this.props.propsValue} </div>\n );\n  }\n  changeHandle(){\n    const node = ReactDOM.findDOMNode(this.refs.input);\n    const value = node.value.trim(); this.props.change(value);\n  }\n} function mapStateToProps(state) { return {\n    propsValue: state.value\n  }\n} //将state的指定值映射在props上，将action的所有方法映射在props上\nexport default connect(mapStateToProps,action)(App);\n```\n\n没有玩过Redux的同学们可能已经看得有点晕了，Redux的设计是这样的：\n\n ![](/css/images/55.jpg)\n\nstate就是数据，组件就是数据的呈现形式，action是动作，action是通过reducer来更新state的。\n\n上述代码，我们干了三件事：\n\n1.  编写一个可视化组件（其实就是个input）;\n2.  将state的value属性绑定在组件的props上;\n3.  将action的所有方法绑定在组件的props上。\n\n## action和reducer两个好基友负责更新state\n\n actions.js\n\n```\n//定义一个change方法，将来把它绑定到props上\nexport function change(value){ return{\n        type:\"change\",\n        value:value\n    }\n}\n```\n\nreducers.js\n\n```\n//reducer就是个function,名字随便你起，功能就是在action触发后，返回一个新的state(就是个对象)\nexport default function change(state,action){ if(action.type==\"change\")return{value:action.value}; return {value:'default'};\n}\n```\n\n 上述代码我们就干了一件事：用户触发action后，更新状态。\n\n因为状态和组件的props是绑定的，所以，组件也跟着变化了！\n\n## store出场，将reducer注入组件\n\nindex.js\n\n```\nimport React from 'react' import { render } from 'react-dom' import { createStore } from 'redux' import { Provider } from 'react-redux' import App from './App' import inputApp from './reducers' let store = createStore(inputApp);\n\nrender( <Provider store={store}>\n    <App />\n  </Provider>,\n  document.querySelector(\"#app\")\n);\n```\n\n`Provider`是组件顶层，用来乘放`store`。\n\n上述代码，我们干了三件事：\n\n1.  将`reducer`放进`store`\n2.  将`store`放进`Provider`\n3.  将`Provider`放在组件顶层，并渲染\n\n## 最后用Webpack编译运行\n\nwebpack.config.js\n\n```js\nvar path = require('path'); var webpack = require('webpack');\n\nmodule.exports = {\n    entry: {\n        app:path.join(__dirname, 'src'),\n        vendors: ['react','redux']\n    },\n    output: {\n        path: path.join(__dirname, 'dist'),\n        filename: '[name].js' },\n    module: {\n        loaders: [\n            {\n                test:/\\.js?$/,\n                exclude:/node_modules/,\n                loader:'babel',\n                query:{\n                    presets:['react','es2015']\n                }\n            }\n        ]\n    },\n    plugins: [ new webpack.optimize.CommonsChunkPlugin('vendors', 'vendors.js')\n    ]\n};\n```\n\n## 好了，开始吐槽\n\n槽点如下：\n\n1.  概念太多，props,state,action,reducer,store,provider,就这还没引入router呢,对新手而言，无法在脑海中立马形成一个清晰的流程\n2.  很多概念冗余，比如reducer和store\n3.  很简单一个功能，写了这么多代码，如果用Angular一行代码都不用写\n4.  看看我们为了虚拟dom的高性能以及服务器渲染，牺牲了多少，虚拟dom的设计如果被Angular引入，那么React的优点何在？\n5.  看看React所谓的简单，平滑的学习曲线，在引入某种框架后，还不是照样复杂。React本身非常简单，可是又有什么用呢？我们绝大多数人，还不是得结合Backbone或者Angular或者Flux，Reflux,Redux来用。这样看来还简单吗？\n6.  更新太快，如果我不列出package.json清单，几个月后你能运行这个程序吗？\n7.  一个页面的HTML模板被完全碎片化了，Angular的指令虽说也有此嫌疑，但是Angular旨在”拓展html的能力“，并没有完全碎片化模板。\n8.  ……\n\n这些想法，我想对于Angular开发者来说，都是有共鸣的。\n\n没有用过Angular的React开发者觉得react好，可能是因为他们没有用过Angular，拿React和jQuery对比得出的结论。\n\n用过Angular的React开发者觉得React好，无非就是因为\n\n1.  React牛逼的服务器渲染\n2.  Diff算法带来的高性能。\n\n但是，不考虑性能和SEO，单从开发效率上来讲，Angular以及mvvm的其他框架相对优秀一点！\n\n当然这里还有适用场景的问题，因为我们研究所目前在做的是大数据平台，全是CRUD和表单，使用Angular开发会非常合适。\n\n## 一定要看\n\n最后，我想说这篇文章中的demo有一定的局限性。因为Redux是用来管理状态的框架，通常在大型复杂的项目中会发挥优势，而我用这样一个简单的demo来说明问题，有点以管窥豹的意思。\n\n在大型项目中，单一数据源以及只读的state，会让你的程序的状态管理非常清晰。为什么？因为我们要更改state，只能通过action，action是我们自己定义的，我们可以预测这个action将带来怎样的改变，而且会留下痕迹，便于管理和掌控程序数据流程。\n\n当然初学者也可以通过这篇文章来学习React+Redux。\n\n示例代码：\n\n[https://github.com/lewis617/react-redux-tutorial/tree/master/input-redux](https://github.com/lewis617/react-redux-tutorial/tree/master/input-redux)\n\n运行方法：\n\n```sh\nnpm install\n\nnpm run build\n```\n手动打开index.html","source":"_posts/ng-complain-r2.md","raw":"---\ntitle: Angular开发者吐槽React+Redux的复杂：“一个demo证明你的开发效率低下”\ndate: 2016-01-13 04:02:00\ntags: [Angular, React, Redux]\n---\n\n曾经看到一篇文章，写的是jQuery开发者吐槽Angular的复杂。作为一个Angular开发者，我来吐槽一下React+Redux的复杂。\n\n<!--more-->\n\n## 例子\n\n为了让大家看得舒服，我用最简单的一个demo来展示React+Redux的“弯弯绕”，下面这个程序就是我用React和Redux写的。然而这个程序在Angular中一行js都不用写！！！\n\n![](/css/images/54.gif)\n\n## 展示组件\n\nApp.js\n\n```js\nimport React, { findDOMNode, Component } from 'react';\nimport ReactDOM from 'react-dom';\nimport { connect } from 'react-redux';\nimport * as action from './actions' class App extends Component {\n  render() { return ( <div>\n        <input type='text' value={this.props.propsValue} onChange={this.changeHandle.bind(this)} ref=\"input\"/>\n        {this.props.propsValue} </div>\n );\n  }\n  changeHandle(){\n    const node = ReactDOM.findDOMNode(this.refs.input);\n    const value = node.value.trim(); this.props.change(value);\n  }\n} function mapStateToProps(state) { return {\n    propsValue: state.value\n  }\n} //将state的指定值映射在props上，将action的所有方法映射在props上\nexport default connect(mapStateToProps,action)(App);\n```\n\n没有玩过Redux的同学们可能已经看得有点晕了，Redux的设计是这样的：\n\n ![](/css/images/55.jpg)\n\nstate就是数据，组件就是数据的呈现形式，action是动作，action是通过reducer来更新state的。\n\n上述代码，我们干了三件事：\n\n1.  编写一个可视化组件（其实就是个input）;\n2.  将state的value属性绑定在组件的props上;\n3.  将action的所有方法绑定在组件的props上。\n\n## action和reducer两个好基友负责更新state\n\n actions.js\n\n```\n//定义一个change方法，将来把它绑定到props上\nexport function change(value){ return{\n        type:\"change\",\n        value:value\n    }\n}\n```\n\nreducers.js\n\n```\n//reducer就是个function,名字随便你起，功能就是在action触发后，返回一个新的state(就是个对象)\nexport default function change(state,action){ if(action.type==\"change\")return{value:action.value}; return {value:'default'};\n}\n```\n\n 上述代码我们就干了一件事：用户触发action后，更新状态。\n\n因为状态和组件的props是绑定的，所以，组件也跟着变化了！\n\n## store出场，将reducer注入组件\n\nindex.js\n\n```\nimport React from 'react' import { render } from 'react-dom' import { createStore } from 'redux' import { Provider } from 'react-redux' import App from './App' import inputApp from './reducers' let store = createStore(inputApp);\n\nrender( <Provider store={store}>\n    <App />\n  </Provider>,\n  document.querySelector(\"#app\")\n);\n```\n\n`Provider`是组件顶层，用来乘放`store`。\n\n上述代码，我们干了三件事：\n\n1.  将`reducer`放进`store`\n2.  将`store`放进`Provider`\n3.  将`Provider`放在组件顶层，并渲染\n\n## 最后用Webpack编译运行\n\nwebpack.config.js\n\n```js\nvar path = require('path'); var webpack = require('webpack');\n\nmodule.exports = {\n    entry: {\n        app:path.join(__dirname, 'src'),\n        vendors: ['react','redux']\n    },\n    output: {\n        path: path.join(__dirname, 'dist'),\n        filename: '[name].js' },\n    module: {\n        loaders: [\n            {\n                test:/\\.js?$/,\n                exclude:/node_modules/,\n                loader:'babel',\n                query:{\n                    presets:['react','es2015']\n                }\n            }\n        ]\n    },\n    plugins: [ new webpack.optimize.CommonsChunkPlugin('vendors', 'vendors.js')\n    ]\n};\n```\n\n## 好了，开始吐槽\n\n槽点如下：\n\n1.  概念太多，props,state,action,reducer,store,provider,就这还没引入router呢,对新手而言，无法在脑海中立马形成一个清晰的流程\n2.  很多概念冗余，比如reducer和store\n3.  很简单一个功能，写了这么多代码，如果用Angular一行代码都不用写\n4.  看看我们为了虚拟dom的高性能以及服务器渲染，牺牲了多少，虚拟dom的设计如果被Angular引入，那么React的优点何在？\n5.  看看React所谓的简单，平滑的学习曲线，在引入某种框架后，还不是照样复杂。React本身非常简单，可是又有什么用呢？我们绝大多数人，还不是得结合Backbone或者Angular或者Flux，Reflux,Redux来用。这样看来还简单吗？\n6.  更新太快，如果我不列出package.json清单，几个月后你能运行这个程序吗？\n7.  一个页面的HTML模板被完全碎片化了，Angular的指令虽说也有此嫌疑，但是Angular旨在”拓展html的能力“，并没有完全碎片化模板。\n8.  ……\n\n这些想法，我想对于Angular开发者来说，都是有共鸣的。\n\n没有用过Angular的React开发者觉得react好，可能是因为他们没有用过Angular，拿React和jQuery对比得出的结论。\n\n用过Angular的React开发者觉得React好，无非就是因为\n\n1.  React牛逼的服务器渲染\n2.  Diff算法带来的高性能。\n\n但是，不考虑性能和SEO，单从开发效率上来讲，Angular以及mvvm的其他框架相对优秀一点！\n\n当然这里还有适用场景的问题，因为我们研究所目前在做的是大数据平台，全是CRUD和表单，使用Angular开发会非常合适。\n\n## 一定要看\n\n最后，我想说这篇文章中的demo有一定的局限性。因为Redux是用来管理状态的框架，通常在大型复杂的项目中会发挥优势，而我用这样一个简单的demo来说明问题，有点以管窥豹的意思。\n\n在大型项目中，单一数据源以及只读的state，会让你的程序的状态管理非常清晰。为什么？因为我们要更改state，只能通过action，action是我们自己定义的，我们可以预测这个action将带来怎样的改变，而且会留下痕迹，便于管理和掌控程序数据流程。\n\n当然初学者也可以通过这篇文章来学习React+Redux。\n\n示例代码：\n\n[https://github.com/lewis617/react-redux-tutorial/tree/master/input-redux](https://github.com/lewis617/react-redux-tutorial/tree/master/input-redux)\n\n运行方法：\n\n```sh\nnpm install\n\nnpm run build\n```\n手动打开index.html","slug":"ng-complain-r2","published":1,"updated":"2019-05-01T08:10:29.724Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvlp0019tgyt4qbp3m47","content":"<p>曾经看到一篇文章，写的是jQuery开发者吐槽Angular的复杂。作为一个Angular开发者，我来吐槽一下React+Redux的复杂。</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>为了让大家看得舒服，我用最简单的一个demo来展示React+Redux的“弯弯绕”，下面这个程序就是我用React和Redux写的。然而这个程序在Angular中一行js都不用写！！！</p>\n<p><img src=\"/css/images/54.gif\" alt=\"\"></p>\n<h2 id=\"展示组件\"><a href=\"#展示组件\" class=\"headerlink\" title=\"展示组件\"></a>展示组件</h2><p>App.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; findDOMNode, Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> action <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123; <span class=\"keyword\">return</span> ( <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">        &lt;input type='text' value=&#123;this.props.propsValue&#125; onChange=&#123;this.changeHandle.bind(this)&#125; ref=\"input\"/&gt;</span><br><span class=\"line\"><span class=\"xml\">        &#123;this.props.propsValue&#125; <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"> );</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">  changeHandle()&#123;</span></span><br><span class=\"line\"><span class=\"xml\">    const node = ReactDOM.findDOMNode(this.refs.input);</span></span><br><span class=\"line\"><span class=\"xml\">    const value = node.value.trim(); this.props.change(value);</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125; function mapStateToProps(state) &#123; return &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    propsValue: state.value</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125; //将state的指定值映射在props上，将action的所有方法映射在props上</span></span><br><span class=\"line\"><span class=\"xml\">export default connect(mapStateToProps,action)(App);</span></span><br></pre></td></tr></table></figure>\n<p>没有玩过Redux的同学们可能已经看得有点晕了，Redux的设计是这样的：</p>\n<p> <img src=\"/css/images/55.jpg\" alt=\"\"></p>\n<p>state就是数据，组件就是数据的呈现形式，action是动作，action是通过reducer来更新state的。</p>\n<p>上述代码，我们干了三件事：</p>\n<ol>\n<li>编写一个可视化组件（其实就是个input）;</li>\n<li>将state的value属性绑定在组件的props上;</li>\n<li>将action的所有方法绑定在组件的props上。</li>\n</ol>\n<h2 id=\"action和reducer两个好基友负责更新state\"><a href=\"#action和reducer两个好基友负责更新state\" class=\"headerlink\" title=\"action和reducer两个好基友负责更新state\"></a>action和reducer两个好基友负责更新state</h2><p> actions.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义一个change方法，将来把它绑定到props上</span><br><span class=\"line\">export function change(value)&#123; return&#123;</span><br><span class=\"line\">        type:&quot;change&quot;,</span><br><span class=\"line\">        value:value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>reducers.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//reducer就是个function,名字随便你起，功能就是在action触发后，返回一个新的state(就是个对象)</span><br><span class=\"line\">export default function change(state,action)&#123; if(action.type==&quot;change&quot;)return&#123;value:action.value&#125;; return &#123;value:&apos;default&apos;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 上述代码我们就干了一件事：用户触发action后，更新状态。</p>\n<p>因为状态和组件的props是绑定的，所以，组件也跟着变化了！</p>\n<h2 id=\"store出场，将reducer注入组件\"><a href=\"#store出场，将reducer注入组件\" class=\"headerlink\" title=\"store出场，将reducer注入组件\"></a>store出场，将reducer注入组件</h2><p>index.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos; import &#123; render &#125; from &apos;react-dom&apos; import &#123; createStore &#125; from &apos;redux&apos; import &#123; Provider &#125; from &apos;react-redux&apos; import App from &apos;./App&apos; import inputApp from &apos;./reducers&apos; let store = createStore(inputApp);</span><br><span class=\"line\"></span><br><span class=\"line\">render( &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App /&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  document.querySelector(&quot;#app&quot;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><code>Provider</code>是组件顶层，用来乘放<code>store</code>。</p>\n<p>上述代码，我们干了三件事：</p>\n<ol>\n<li>将<code>reducer</code>放进<code>store</code></li>\n<li>将<code>store</code>放进<code>Provider</code></li>\n<li>将<code>Provider</code>放在组件顶层，并渲染</li>\n</ol>\n<h2 id=\"最后用Webpack编译运行\"><a href=\"#最后用Webpack编译运行\" class=\"headerlink\" title=\"最后用Webpack编译运行\"></a>最后用Webpack编译运行</h2><p>webpack.config.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>); <span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        app:path.join(__dirname, <span class=\"string\">'src'</span>),</span><br><span class=\"line\">        vendors: [<span class=\"string\">'react'</span>,<span class=\"string\">'redux'</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: path.join(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">        filename: <span class=\"string\">'[name].js'</span> &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test:<span class=\"regexp\">/\\.js?$/</span>,</span><br><span class=\"line\">                exclude:<span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">                loader:<span class=\"string\">'babel'</span>,</span><br><span class=\"line\">                query:&#123;</span><br><span class=\"line\">                    presets:[<span class=\"string\">'react'</span>,<span class=\"string\">'es2015'</span>]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins: [ <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(<span class=\"string\">'vendors'</span>, <span class=\"string\">'vendors.js'</span>)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"好了，开始吐槽\"><a href=\"#好了，开始吐槽\" class=\"headerlink\" title=\"好了，开始吐槽\"></a>好了，开始吐槽</h2><p>槽点如下：</p>\n<ol>\n<li>概念太多，props,state,action,reducer,store,provider,就这还没引入router呢,对新手而言，无法在脑海中立马形成一个清晰的流程</li>\n<li>很多概念冗余，比如reducer和store</li>\n<li>很简单一个功能，写了这么多代码，如果用Angular一行代码都不用写</li>\n<li>看看我们为了虚拟dom的高性能以及服务器渲染，牺牲了多少，虚拟dom的设计如果被Angular引入，那么React的优点何在？</li>\n<li>看看React所谓的简单，平滑的学习曲线，在引入某种框架后，还不是照样复杂。React本身非常简单，可是又有什么用呢？我们绝大多数人，还不是得结合Backbone或者Angular或者Flux，Reflux,Redux来用。这样看来还简单吗？</li>\n<li>更新太快，如果我不列出package.json清单，几个月后你能运行这个程序吗？</li>\n<li>一个页面的HTML模板被完全碎片化了，Angular的指令虽说也有此嫌疑，但是Angular旨在”拓展html的能力“，并没有完全碎片化模板。</li>\n<li>……</li>\n</ol>\n<p>这些想法，我想对于Angular开发者来说，都是有共鸣的。</p>\n<p>没有用过Angular的React开发者觉得react好，可能是因为他们没有用过Angular，拿React和jQuery对比得出的结论。</p>\n<p>用过Angular的React开发者觉得React好，无非就是因为</p>\n<ol>\n<li>React牛逼的服务器渲染</li>\n<li>Diff算法带来的高性能。</li>\n</ol>\n<p>但是，不考虑性能和SEO，单从开发效率上来讲，Angular以及mvvm的其他框架相对优秀一点！</p>\n<p>当然这里还有适用场景的问题，因为我们研究所目前在做的是大数据平台，全是CRUD和表单，使用Angular开发会非常合适。</p>\n<h2 id=\"一定要看\"><a href=\"#一定要看\" class=\"headerlink\" title=\"一定要看\"></a>一定要看</h2><p>最后，我想说这篇文章中的demo有一定的局限性。因为Redux是用来管理状态的框架，通常在大型复杂的项目中会发挥优势，而我用这样一个简单的demo来说明问题，有点以管窥豹的意思。</p>\n<p>在大型项目中，单一数据源以及只读的state，会让你的程序的状态管理非常清晰。为什么？因为我们要更改state，只能通过action，action是我们自己定义的，我们可以预测这个action将带来怎样的改变，而且会留下痕迹，便于管理和掌控程序数据流程。</p>\n<p>当然初学者也可以通过这篇文章来学习React+Redux。</p>\n<p>示例代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/input-redux\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/input-redux</a></p>\n<p>运行方法：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n<p>手动打开index.html</p>\n","site":{"data":{}},"excerpt":"<p>曾经看到一篇文章，写的是jQuery开发者吐槽Angular的复杂。作为一个Angular开发者，我来吐槽一下React+Redux的复杂。</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>为了让大家看得舒服，我用最简单的一个demo来展示React+Redux的“弯弯绕”，下面这个程序就是我用React和Redux写的。然而这个程序在Angular中一行js都不用写！！！</p>\n<p><img src=\"/css/images/54.gif\" alt=\"\"></p>\n<h2 id=\"展示组件\"><a href=\"#展示组件\" class=\"headerlink\" title=\"展示组件\"></a>展示组件</h2><p>App.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; findDOMNode, Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> action <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123; <span class=\"keyword\">return</span> ( <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">        &lt;input type='text' value=&#123;this.props.propsValue&#125; onChange=&#123;this.changeHandle.bind(this)&#125; ref=\"input\"/&gt;</span><br><span class=\"line\"><span class=\"xml\">        &#123;this.props.propsValue&#125; <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"> );</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">  changeHandle()&#123;</span></span><br><span class=\"line\"><span class=\"xml\">    const node = ReactDOM.findDOMNode(this.refs.input);</span></span><br><span class=\"line\"><span class=\"xml\">    const value = node.value.trim(); this.props.change(value);</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125; function mapStateToProps(state) &#123; return &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    propsValue: state.value</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125; //将state的指定值映射在props上，将action的所有方法映射在props上</span></span><br><span class=\"line\"><span class=\"xml\">export default connect(mapStateToProps,action)(App);</span></span><br></pre></td></tr></table></figure>\n<p>没有玩过Redux的同学们可能已经看得有点晕了，Redux的设计是这样的：</p>\n<p> <img src=\"/css/images/55.jpg\" alt=\"\"></p>\n<p>state就是数据，组件就是数据的呈现形式，action是动作，action是通过reducer来更新state的。</p>\n<p>上述代码，我们干了三件事：</p>\n<ol>\n<li>编写一个可视化组件（其实就是个input）;</li>\n<li>将state的value属性绑定在组件的props上;</li>\n<li>将action的所有方法绑定在组件的props上。</li>\n</ol>\n<h2 id=\"action和reducer两个好基友负责更新state\"><a href=\"#action和reducer两个好基友负责更新state\" class=\"headerlink\" title=\"action和reducer两个好基友负责更新state\"></a>action和reducer两个好基友负责更新state</h2><p> actions.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义一个change方法，将来把它绑定到props上</span><br><span class=\"line\">export function change(value)&#123; return&#123;</span><br><span class=\"line\">        type:&quot;change&quot;,</span><br><span class=\"line\">        value:value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>reducers.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//reducer就是个function,名字随便你起，功能就是在action触发后，返回一个新的state(就是个对象)</span><br><span class=\"line\">export default function change(state,action)&#123; if(action.type==&quot;change&quot;)return&#123;value:action.value&#125;; return &#123;value:&apos;default&apos;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 上述代码我们就干了一件事：用户触发action后，更新状态。</p>\n<p>因为状态和组件的props是绑定的，所以，组件也跟着变化了！</p>\n<h2 id=\"store出场，将reducer注入组件\"><a href=\"#store出场，将reducer注入组件\" class=\"headerlink\" title=\"store出场，将reducer注入组件\"></a>store出场，将reducer注入组件</h2><p>index.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos; import &#123; render &#125; from &apos;react-dom&apos; import &#123; createStore &#125; from &apos;redux&apos; import &#123; Provider &#125; from &apos;react-redux&apos; import App from &apos;./App&apos; import inputApp from &apos;./reducers&apos; let store = createStore(inputApp);</span><br><span class=\"line\"></span><br><span class=\"line\">render( &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App /&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  document.querySelector(&quot;#app&quot;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><code>Provider</code>是组件顶层，用来乘放<code>store</code>。</p>\n<p>上述代码，我们干了三件事：</p>\n<ol>\n<li>将<code>reducer</code>放进<code>store</code></li>\n<li>将<code>store</code>放进<code>Provider</code></li>\n<li>将<code>Provider</code>放在组件顶层，并渲染</li>\n</ol>\n<h2 id=\"最后用Webpack编译运行\"><a href=\"#最后用Webpack编译运行\" class=\"headerlink\" title=\"最后用Webpack编译运行\"></a>最后用Webpack编译运行</h2><p>webpack.config.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>); <span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        app:path.join(__dirname, <span class=\"string\">'src'</span>),</span><br><span class=\"line\">        vendors: [<span class=\"string\">'react'</span>,<span class=\"string\">'redux'</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: path.join(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">        filename: <span class=\"string\">'[name].js'</span> &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test:<span class=\"regexp\">/\\.js?$/</span>,</span><br><span class=\"line\">                exclude:<span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">                loader:<span class=\"string\">'babel'</span>,</span><br><span class=\"line\">                query:&#123;</span><br><span class=\"line\">                    presets:[<span class=\"string\">'react'</span>,<span class=\"string\">'es2015'</span>]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins: [ <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(<span class=\"string\">'vendors'</span>, <span class=\"string\">'vendors.js'</span>)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"好了，开始吐槽\"><a href=\"#好了，开始吐槽\" class=\"headerlink\" title=\"好了，开始吐槽\"></a>好了，开始吐槽</h2><p>槽点如下：</p>\n<ol>\n<li>概念太多，props,state,action,reducer,store,provider,就这还没引入router呢,对新手而言，无法在脑海中立马形成一个清晰的流程</li>\n<li>很多概念冗余，比如reducer和store</li>\n<li>很简单一个功能，写了这么多代码，如果用Angular一行代码都不用写</li>\n<li>看看我们为了虚拟dom的高性能以及服务器渲染，牺牲了多少，虚拟dom的设计如果被Angular引入，那么React的优点何在？</li>\n<li>看看React所谓的简单，平滑的学习曲线，在引入某种框架后，还不是照样复杂。React本身非常简单，可是又有什么用呢？我们绝大多数人，还不是得结合Backbone或者Angular或者Flux，Reflux,Redux来用。这样看来还简单吗？</li>\n<li>更新太快，如果我不列出package.json清单，几个月后你能运行这个程序吗？</li>\n<li>一个页面的HTML模板被完全碎片化了，Angular的指令虽说也有此嫌疑，但是Angular旨在”拓展html的能力“，并没有完全碎片化模板。</li>\n<li>……</li>\n</ol>\n<p>这些想法，我想对于Angular开发者来说，都是有共鸣的。</p>\n<p>没有用过Angular的React开发者觉得react好，可能是因为他们没有用过Angular，拿React和jQuery对比得出的结论。</p>\n<p>用过Angular的React开发者觉得React好，无非就是因为</p>\n<ol>\n<li>React牛逼的服务器渲染</li>\n<li>Diff算法带来的高性能。</li>\n</ol>\n<p>但是，不考虑性能和SEO，单从开发效率上来讲，Angular以及mvvm的其他框架相对优秀一点！</p>\n<p>当然这里还有适用场景的问题，因为我们研究所目前在做的是大数据平台，全是CRUD和表单，使用Angular开发会非常合适。</p>\n<h2 id=\"一定要看\"><a href=\"#一定要看\" class=\"headerlink\" title=\"一定要看\"></a>一定要看</h2><p>最后，我想说这篇文章中的demo有一定的局限性。因为Redux是用来管理状态的框架，通常在大型复杂的项目中会发挥优势，而我用这样一个简单的demo来说明问题，有点以管窥豹的意思。</p>\n<p>在大型项目中，单一数据源以及只读的state，会让你的程序的状态管理非常清晰。为什么？因为我们要更改state，只能通过action，action是我们自己定义的，我们可以预测这个action将带来怎样的改变，而且会留下痕迹，便于管理和掌控程序数据流程。</p>\n<p>当然初学者也可以通过这篇文章来学习React+Redux。</p>\n<p>示例代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/input-redux\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/input-redux</a></p>\n<p>运行方法：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n<p>手动打开index.html</p>"},{"title":"Angular 结合RequireJs实现模块化开发","date":"2015-10-01T08:56:00.000Z","_content":"\nAngular的指令是模块化很好的一个体现，下面我将只使用指令（不用控制器），结合Requirejs，实现模块化开发。\n\n<!--more-->\n\n模块化关系图：\n\n![](/css/images/58.jpg)\n\n# 传统开发方式\n\n```html\n<!--aaa模块-->\n<div>\n    <h3>this is aaa</h3>\n    <input type=\"text\" ng-model=\"asd\">{{asd}} <button ng-click=\"submit()\">submit</button>\n</div>\n<!--bbb模块-->\n<div>\n    <h3>this is bbb</h3>\n    <ul>\n        <li ng-repeat=\"el in list\">{{el}}</li>\n    </ul>\n    <!--ccc模块-->\n    <div>\n        <h3>this is ccc</h3>\n    </div>\n</div>\n```\n\n把所有模块写在一起，可读性差，耦合度高，难以维护。\n\n# requires+angular模块化开发方式\n\nindex.html:\n\n```html\n<aaa></aaa>\n<bbb>\n    <ccc></ccc>\n</bbb>\n```\n\n主页面干干净净。\n\n## aaa\n\naaa模块包括aaa.js和aaa.html\n\naaa.html\n\n```html\n<div>\n    <h3>this is aaa</h3>\n    <input type=\"text\" ng-model=\"asd\">{{asd}} <button ng-click=\"submit()\">submit</button>\n</div>\n```\n\naaa.js（引入aaa.html，放入模板中，在link中写业务逻辑，service是用来通信的）\n\n```js\ndefine(['app','text!./aaa.html'],function(app,aaa){\n    app.directive(\"aaa\", function(service) { return {\n            restrict: 'AE',\n            template: aaa,\n            replace: true,\n            scope:true,\n            link:function(scope,element,attrs){\n                scope.submit=function() {\n                    service.updateName(scope.asd);\n                };\n            }\n        }\n    });\n});\n```\n\n封装在一个文件夹里面，随时调用复用：\n\n![](/css/images/59.jpg)\n\n`require(['./aaa/aaa'])`即可调用aaa模块;\n\n## bbb\n\nbbb模块也是两个文件：\n\nbbb.html\n\n```html\n<div>\n    <h3>this is bbb</h3>\n    <ul>\n        <li ng-repeat=\"el in list\">{{el}}</li>\n    </ul>\n    <div ng-transclude></div>\n</div>\n```\n\nbbb.js\n\n```js\ndefine(['app','text!./bbb.html'],function(app,bbb){\n    app.directive('bbb',function(service){ return{\n            restrict:'AE',\n            template:bbb,\n            replace:'true',\n            scope:true,\n            transclude:true,\n            link: function (scope,element,attrs) {\n                scope.list=[1,2,3,4];\n                scope.$on('nameUpdated', function() {\n                    scope.list.push(service.name);\n                });\n            }\n        }\n    });\n});\n```\n\nbbb可以和aaa模块通过service通信，bbb还包含ccc（通过transclude嵌入）\n\n## ccc\n\nccc模块也是两个文件：\n\nccc.html\n\n```html\n<div>\n    <h3>this is ccc</h3>\n</div>\n```\n\nccc.js\n\n```js\ndefine(['app','text!./ccc.html'],function(app,ccc){\n    app.directive('ccc',function(){ return{\n            restrict:'AE',\n            template:ccc,\n            replace:'true',\n            scope:true,\n            link: function (scope,element,attrs) {\n            }\n        }\n    });\n});\n```\n\n三个模块解耦后，很好维护，因为一个文件的代码量不会超过20行，而且还便于复用。可以称为组件式开发。不要小看这个例子，并非玩玩而已，而是真正的工程化开发思路！\n\n最后一起调用（只调用了aaa,bbb，ccc已经在bbb里调用过了），并启动app：\n\n```js\nrequire(['angular','./aaa/aaa','./bbb/bbb','./ccc/ccc','service'],function(angular){\n        angular.bootstrap(document,['app']);\n    });\n```\n\n最后看下总体目录：\n\n![](/css/images/60.jpg)","source":"_posts/ng-requirejs-module.md","raw":"---\ntitle: Angular 结合RequireJs实现模块化开发\ndate: 2015-10-01 16:56:00\ntags: [Angular, RequireJs]\n---\n\nAngular的指令是模块化很好的一个体现，下面我将只使用指令（不用控制器），结合Requirejs，实现模块化开发。\n\n<!--more-->\n\n模块化关系图：\n\n![](/css/images/58.jpg)\n\n# 传统开发方式\n\n```html\n<!--aaa模块-->\n<div>\n    <h3>this is aaa</h3>\n    <input type=\"text\" ng-model=\"asd\">{{asd}} <button ng-click=\"submit()\">submit</button>\n</div>\n<!--bbb模块-->\n<div>\n    <h3>this is bbb</h3>\n    <ul>\n        <li ng-repeat=\"el in list\">{{el}}</li>\n    </ul>\n    <!--ccc模块-->\n    <div>\n        <h3>this is ccc</h3>\n    </div>\n</div>\n```\n\n把所有模块写在一起，可读性差，耦合度高，难以维护。\n\n# requires+angular模块化开发方式\n\nindex.html:\n\n```html\n<aaa></aaa>\n<bbb>\n    <ccc></ccc>\n</bbb>\n```\n\n主页面干干净净。\n\n## aaa\n\naaa模块包括aaa.js和aaa.html\n\naaa.html\n\n```html\n<div>\n    <h3>this is aaa</h3>\n    <input type=\"text\" ng-model=\"asd\">{{asd}} <button ng-click=\"submit()\">submit</button>\n</div>\n```\n\naaa.js（引入aaa.html，放入模板中，在link中写业务逻辑，service是用来通信的）\n\n```js\ndefine(['app','text!./aaa.html'],function(app,aaa){\n    app.directive(\"aaa\", function(service) { return {\n            restrict: 'AE',\n            template: aaa,\n            replace: true,\n            scope:true,\n            link:function(scope,element,attrs){\n                scope.submit=function() {\n                    service.updateName(scope.asd);\n                };\n            }\n        }\n    });\n});\n```\n\n封装在一个文件夹里面，随时调用复用：\n\n![](/css/images/59.jpg)\n\n`require(['./aaa/aaa'])`即可调用aaa模块;\n\n## bbb\n\nbbb模块也是两个文件：\n\nbbb.html\n\n```html\n<div>\n    <h3>this is bbb</h3>\n    <ul>\n        <li ng-repeat=\"el in list\">{{el}}</li>\n    </ul>\n    <div ng-transclude></div>\n</div>\n```\n\nbbb.js\n\n```js\ndefine(['app','text!./bbb.html'],function(app,bbb){\n    app.directive('bbb',function(service){ return{\n            restrict:'AE',\n            template:bbb,\n            replace:'true',\n            scope:true,\n            transclude:true,\n            link: function (scope,element,attrs) {\n                scope.list=[1,2,3,4];\n                scope.$on('nameUpdated', function() {\n                    scope.list.push(service.name);\n                });\n            }\n        }\n    });\n});\n```\n\nbbb可以和aaa模块通过service通信，bbb还包含ccc（通过transclude嵌入）\n\n## ccc\n\nccc模块也是两个文件：\n\nccc.html\n\n```html\n<div>\n    <h3>this is ccc</h3>\n</div>\n```\n\nccc.js\n\n```js\ndefine(['app','text!./ccc.html'],function(app,ccc){\n    app.directive('ccc',function(){ return{\n            restrict:'AE',\n            template:ccc,\n            replace:'true',\n            scope:true,\n            link: function (scope,element,attrs) {\n            }\n        }\n    });\n});\n```\n\n三个模块解耦后，很好维护，因为一个文件的代码量不会超过20行，而且还便于复用。可以称为组件式开发。不要小看这个例子，并非玩玩而已，而是真正的工程化开发思路！\n\n最后一起调用（只调用了aaa,bbb，ccc已经在bbb里调用过了），并启动app：\n\n```js\nrequire(['angular','./aaa/aaa','./bbb/bbb','./ccc/ccc','service'],function(angular){\n        angular.bootstrap(document,['app']);\n    });\n```\n\n最后看下总体目录：\n\n![](/css/images/60.jpg)","slug":"ng-requirejs-module","published":1,"updated":"2019-05-01T08:10:29.752Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvlq001btgytxhr3mleh","content":"<p>Angular的指令是模块化很好的一个体现，下面我将只使用指令（不用控制器），结合Requirejs，实现模块化开发。</p>\n<a id=\"more\"></a>\n<p>模块化关系图：</p>\n<p><img src=\"/css/images/58.jpg\" alt=\"\"></p>\n<h1 id=\"传统开发方式\"><a href=\"#传统开发方式\" class=\"headerlink\" title=\"传统开发方式\"></a>传统开发方式</h1><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--aaa模块--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>this is aaa<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">ng-model</span>=<span class=\"string\">\"asd\"</span>&gt;</span>&#123;&#123;asd&#125;&#125; <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"submit()\"</span>&gt;</span>submit<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--bbb模块--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>this is bbb<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">ng-repeat</span>=<span class=\"string\">\"el in list\"</span>&gt;</span>&#123;&#123;el&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--ccc模块--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>this is ccc<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>把所有模块写在一起，可读性差，耦合度高，难以维护。</p>\n<h1 id=\"requires-angular模块化开发方式\"><a href=\"#requires-angular模块化开发方式\" class=\"headerlink\" title=\"requires+angular模块化开发方式\"></a>requires+angular模块化开发方式</h1><p>index.html:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aaa</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">aaa</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bbb</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ccc</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ccc</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bbb</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>主页面干干净净。</p>\n<h2 id=\"aaa\"><a href=\"#aaa\" class=\"headerlink\" title=\"aaa\"></a>aaa</h2><p>aaa模块包括aaa.js和aaa.html</p>\n<p>aaa.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>this is aaa<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">ng-model</span>=<span class=\"string\">\"asd\"</span>&gt;</span>&#123;&#123;asd&#125;&#125; <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"submit()\"</span>&gt;</span>submit<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>aaa.js（引入aaa.html，放入模板中，在link中写业务逻辑，service是用来通信的）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'app'</span>,<span class=\"string\">'text!./aaa.html'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">app,aaa</span>)</span>&#123;</span><br><span class=\"line\">    app.directive(<span class=\"string\">\"aaa\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service</span>) </span>&#123; <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            restrict: <span class=\"string\">'AE'</span>,</span><br><span class=\"line\">            template: aaa,</span><br><span class=\"line\">            replace: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            scope:<span class=\"literal\">true</span>,</span><br><span class=\"line\">            link:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope,element,attrs</span>)</span>&#123;</span><br><span class=\"line\">                scope.submit=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    service.updateName(scope.asd);</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>封装在一个文件夹里面，随时调用复用：</p>\n<p><img src=\"/css/images/59.jpg\" alt=\"\"></p>\n<p><code>require([&#39;./aaa/aaa&#39;])</code>即可调用aaa模块;</p>\n<h2 id=\"bbb\"><a href=\"#bbb\" class=\"headerlink\" title=\"bbb\"></a>bbb</h2><p>bbb模块也是两个文件：</p>\n<p>bbb.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>this is bbb<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">ng-repeat</span>=<span class=\"string\">\"el in list\"</span>&gt;</span>&#123;&#123;el&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ng-transclude</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>bbb.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'app'</span>,<span class=\"string\">'text!./bbb.html'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">app,bbb</span>)</span>&#123;</span><br><span class=\"line\">    app.directive(<span class=\"string\">'bbb'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service</span>)</span>&#123; <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">            restrict:<span class=\"string\">'AE'</span>,</span><br><span class=\"line\">            template:bbb,</span><br><span class=\"line\">            replace:<span class=\"string\">'true'</span>,</span><br><span class=\"line\">            scope:<span class=\"literal\">true</span>,</span><br><span class=\"line\">            transclude:<span class=\"literal\">true</span>,</span><br><span class=\"line\">            link: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">scope,element,attrs</span>) </span>&#123;</span><br><span class=\"line\">                scope.list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\">                scope.$on(<span class=\"string\">'nameUpdated'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    scope.list.push(service.name);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>bbb可以和aaa模块通过service通信，bbb还包含ccc（通过transclude嵌入）</p>\n<h2 id=\"ccc\"><a href=\"#ccc\" class=\"headerlink\" title=\"ccc\"></a>ccc</h2><p>ccc模块也是两个文件：</p>\n<p>ccc.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>this is ccc<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>ccc.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'app'</span>,<span class=\"string\">'text!./ccc.html'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">app,ccc</span>)</span>&#123;</span><br><span class=\"line\">    app.directive(<span class=\"string\">'ccc'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">            restrict:<span class=\"string\">'AE'</span>,</span><br><span class=\"line\">            template:ccc,</span><br><span class=\"line\">            replace:<span class=\"string\">'true'</span>,</span><br><span class=\"line\">            scope:<span class=\"literal\">true</span>,</span><br><span class=\"line\">            link: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">scope,element,attrs</span>) </span>&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>三个模块解耦后，很好维护，因为一个文件的代码量不会超过20行，而且还便于复用。可以称为组件式开发。不要小看这个例子，并非玩玩而已，而是真正的工程化开发思路！</p>\n<p>最后一起调用（只调用了aaa,bbb，ccc已经在bbb里调用过了），并启动app：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'angular'</span>,<span class=\"string\">'./aaa/aaa'</span>,<span class=\"string\">'./bbb/bbb'</span>,<span class=\"string\">'./ccc/ccc'</span>,<span class=\"string\">'service'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">angular</span>)</span>&#123;</span><br><span class=\"line\">        angular.bootstrap(<span class=\"built_in\">document</span>,[<span class=\"string\">'app'</span>]);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>最后看下总体目录：</p>\n<p><img src=\"/css/images/60.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>Angular的指令是模块化很好的一个体现，下面我将只使用指令（不用控制器），结合Requirejs，实现模块化开发。</p>","more":"<p>模块化关系图：</p>\n<p><img src=\"/css/images/58.jpg\" alt=\"\"></p>\n<h1 id=\"传统开发方式\"><a href=\"#传统开发方式\" class=\"headerlink\" title=\"传统开发方式\"></a>传统开发方式</h1><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--aaa模块--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>this is aaa<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">ng-model</span>=<span class=\"string\">\"asd\"</span>&gt;</span>&#123;&#123;asd&#125;&#125; <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"submit()\"</span>&gt;</span>submit<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--bbb模块--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>this is bbb<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">ng-repeat</span>=<span class=\"string\">\"el in list\"</span>&gt;</span>&#123;&#123;el&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--ccc模块--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>this is ccc<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>把所有模块写在一起，可读性差，耦合度高，难以维护。</p>\n<h1 id=\"requires-angular模块化开发方式\"><a href=\"#requires-angular模块化开发方式\" class=\"headerlink\" title=\"requires+angular模块化开发方式\"></a>requires+angular模块化开发方式</h1><p>index.html:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aaa</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">aaa</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bbb</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ccc</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ccc</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bbb</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>主页面干干净净。</p>\n<h2 id=\"aaa\"><a href=\"#aaa\" class=\"headerlink\" title=\"aaa\"></a>aaa</h2><p>aaa模块包括aaa.js和aaa.html</p>\n<p>aaa.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>this is aaa<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">ng-model</span>=<span class=\"string\">\"asd\"</span>&gt;</span>&#123;&#123;asd&#125;&#125; <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"submit()\"</span>&gt;</span>submit<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>aaa.js（引入aaa.html，放入模板中，在link中写业务逻辑，service是用来通信的）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'app'</span>,<span class=\"string\">'text!./aaa.html'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">app,aaa</span>)</span>&#123;</span><br><span class=\"line\">    app.directive(<span class=\"string\">\"aaa\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service</span>) </span>&#123; <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            restrict: <span class=\"string\">'AE'</span>,</span><br><span class=\"line\">            template: aaa,</span><br><span class=\"line\">            replace: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            scope:<span class=\"literal\">true</span>,</span><br><span class=\"line\">            link:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope,element,attrs</span>)</span>&#123;</span><br><span class=\"line\">                scope.submit=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    service.updateName(scope.asd);</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>封装在一个文件夹里面，随时调用复用：</p>\n<p><img src=\"/css/images/59.jpg\" alt=\"\"></p>\n<p><code>require([&#39;./aaa/aaa&#39;])</code>即可调用aaa模块;</p>\n<h2 id=\"bbb\"><a href=\"#bbb\" class=\"headerlink\" title=\"bbb\"></a>bbb</h2><p>bbb模块也是两个文件：</p>\n<p>bbb.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>this is bbb<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">ng-repeat</span>=<span class=\"string\">\"el in list\"</span>&gt;</span>&#123;&#123;el&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ng-transclude</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>bbb.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'app'</span>,<span class=\"string\">'text!./bbb.html'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">app,bbb</span>)</span>&#123;</span><br><span class=\"line\">    app.directive(<span class=\"string\">'bbb'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service</span>)</span>&#123; <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">            restrict:<span class=\"string\">'AE'</span>,</span><br><span class=\"line\">            template:bbb,</span><br><span class=\"line\">            replace:<span class=\"string\">'true'</span>,</span><br><span class=\"line\">            scope:<span class=\"literal\">true</span>,</span><br><span class=\"line\">            transclude:<span class=\"literal\">true</span>,</span><br><span class=\"line\">            link: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">scope,element,attrs</span>) </span>&#123;</span><br><span class=\"line\">                scope.list=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\">                scope.$on(<span class=\"string\">'nameUpdated'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    scope.list.push(service.name);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>bbb可以和aaa模块通过service通信，bbb还包含ccc（通过transclude嵌入）</p>\n<h2 id=\"ccc\"><a href=\"#ccc\" class=\"headerlink\" title=\"ccc\"></a>ccc</h2><p>ccc模块也是两个文件：</p>\n<p>ccc.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>this is ccc<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>ccc.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'app'</span>,<span class=\"string\">'text!./ccc.html'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">app,ccc</span>)</span>&#123;</span><br><span class=\"line\">    app.directive(<span class=\"string\">'ccc'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">            restrict:<span class=\"string\">'AE'</span>,</span><br><span class=\"line\">            template:ccc,</span><br><span class=\"line\">            replace:<span class=\"string\">'true'</span>,</span><br><span class=\"line\">            scope:<span class=\"literal\">true</span>,</span><br><span class=\"line\">            link: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">scope,element,attrs</span>) </span>&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>三个模块解耦后，很好维护，因为一个文件的代码量不会超过20行，而且还便于复用。可以称为组件式开发。不要小看这个例子，并非玩玩而已，而是真正的工程化开发思路！</p>\n<p>最后一起调用（只调用了aaa,bbb，ccc已经在bbb里调用过了），并启动app：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'angular'</span>,<span class=\"string\">'./aaa/aaa'</span>,<span class=\"string\">'./bbb/bbb'</span>,<span class=\"string\">'./ccc/ccc'</span>,<span class=\"string\">'service'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">angular</span>)</span>&#123;</span><br><span class=\"line\">        angular.bootstrap(<span class=\"built_in\">document</span>,[<span class=\"string\">'app'</span>]);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>最后看下总体目录：</p>\n<p><img src=\"/css/images/60.jpg\" alt=\"\"></p>"},{"title":"AngularJs与jQuery特效slidetoggle结合","date":"2015-09-29T09:10:00.000Z","_content":"\n之前使用jQuery的`slidetoggle`方法，可以轻易的实现元素的收缩展开；使用Angularjs后，没有找到相关的方法，通过多方面查资料，自己写了个demo，展示`slidetoggle`的Angularjs写法：\n\n<!--more-->\n\nhtml\n\n```html\n<div ng-controller=\"ctrl_main\">\n    <li ng-repeat-start=\"el in list\" ng-click=\"$index=!$index\">{{el.name}}</li>\n    <li ng-repeat-end slide-toggle=\"$index\">{{$index}}</li>\n</div>\n```\n\n控制器ctrl_main\n\n```js\napp.controller('ctrl_main', function ($scope) {\n        $scope.list=[{name:'lewis'},{name:'susan'},{name:'alice'},{name:'jay'}]\n    });\n```\n\n指令drtv_slidetoggle\n\n```js\n app.directive('slideToggle', function() { return {\n            restrict: 'A',\n            scope:{\n                isOpen: \"=slideToggle\" },\n            link: function(scope, element, attr) {\n                scope.$watch('isOpen', function(newVal,oldVal){ if(newVal !== oldVal){\n                        element.stop().slideToggle('slow');\n                    }\n                });\n            }\n        };\n    });\n```\n\n运行效果：\n\n![](/css/images/56.jpg)\n\n点击其他人名，也是一样的。\n\n总体思路就是编写指令，通过改变指令的值![](/css/images/57.jpg)，来控制当前元素的收缩展开。\n\n===不用Requirejs的同学就可以不往下看了===\n\n【PS】将该指令用Requirejs封装成指令模块，引用就可以在你的项目中使用了；\n\nRequirejs封装的指令模块，新建js, 命名为drtv_slidetoggle.js：\n\n```js\ndefine(['app','jquery'], function (app) {\n    app.directive('slideToggle', function() { return {\n            restrict: 'A',\n            scope:{\n                isOpen: \"=slideToggle\" },\n            link: function(scope, element, attr) {\n                scope.$watch('isOpen', function(newVal,oldVal){ if(newVal !== oldVal){\n                        element.stop().slideToggle('slow');\n                    }\n                });\n            }\n        };\n    });\n});\n```\n\n在启动app时候调用：\n\n```js\n require(['angular','domReady!','ctrl_main','drtv_slidetoggle'], function (angular) {\n            angular.bootstrap(document, ['app'])\n        });\n```","source":"_posts/ng-jq-toggle.md","raw":"---\ntitle: AngularJs与jQuery特效slidetoggle结合\ndate: 2015-09-29 17:10:00\ntags: [Angular, jQuery]\n---\n\n之前使用jQuery的`slidetoggle`方法，可以轻易的实现元素的收缩展开；使用Angularjs后，没有找到相关的方法，通过多方面查资料，自己写了个demo，展示`slidetoggle`的Angularjs写法：\n\n<!--more-->\n\nhtml\n\n```html\n<div ng-controller=\"ctrl_main\">\n    <li ng-repeat-start=\"el in list\" ng-click=\"$index=!$index\">{{el.name}}</li>\n    <li ng-repeat-end slide-toggle=\"$index\">{{$index}}</li>\n</div>\n```\n\n控制器ctrl_main\n\n```js\napp.controller('ctrl_main', function ($scope) {\n        $scope.list=[{name:'lewis'},{name:'susan'},{name:'alice'},{name:'jay'}]\n    });\n```\n\n指令drtv_slidetoggle\n\n```js\n app.directive('slideToggle', function() { return {\n            restrict: 'A',\n            scope:{\n                isOpen: \"=slideToggle\" },\n            link: function(scope, element, attr) {\n                scope.$watch('isOpen', function(newVal,oldVal){ if(newVal !== oldVal){\n                        element.stop().slideToggle('slow');\n                    }\n                });\n            }\n        };\n    });\n```\n\n运行效果：\n\n![](/css/images/56.jpg)\n\n点击其他人名，也是一样的。\n\n总体思路就是编写指令，通过改变指令的值![](/css/images/57.jpg)，来控制当前元素的收缩展开。\n\n===不用Requirejs的同学就可以不往下看了===\n\n【PS】将该指令用Requirejs封装成指令模块，引用就可以在你的项目中使用了；\n\nRequirejs封装的指令模块，新建js, 命名为drtv_slidetoggle.js：\n\n```js\ndefine(['app','jquery'], function (app) {\n    app.directive('slideToggle', function() { return {\n            restrict: 'A',\n            scope:{\n                isOpen: \"=slideToggle\" },\n            link: function(scope, element, attr) {\n                scope.$watch('isOpen', function(newVal,oldVal){ if(newVal !== oldVal){\n                        element.stop().slideToggle('slow');\n                    }\n                });\n            }\n        };\n    });\n});\n```\n\n在启动app时候调用：\n\n```js\n require(['angular','domReady!','ctrl_main','drtv_slidetoggle'], function (angular) {\n            angular.bootstrap(document, ['app'])\n        });\n```","slug":"ng-jq-toggle","published":1,"updated":"2019-05-01T08:10:29.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvlr001ctgyt9eevwxhv","content":"<p>之前使用jQuery的<code>slidetoggle</code>方法，可以轻易的实现元素的收缩展开；使用Angularjs后，没有找到相关的方法，通过多方面查资料，自己写了个demo，展示<code>slidetoggle</code>的Angularjs写法：</p>\n<a id=\"more\"></a>\n<p>html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"ctrl_main\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">ng-repeat-start</span>=<span class=\"string\">\"el in list\"</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"$index=!$index\"</span>&gt;</span>&#123;&#123;el.name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">ng-repeat-end</span> <span class=\"attr\">slide-toggle</span>=<span class=\"string\">\"$index\"</span>&gt;</span>&#123;&#123;$index&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>控制器ctrl_main</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.controller(<span class=\"string\">'ctrl_main'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">$scope</span>) </span>&#123;</span><br><span class=\"line\">        $scope.list=[&#123;<span class=\"attr\">name</span>:<span class=\"string\">'lewis'</span>&#125;,&#123;<span class=\"attr\">name</span>:<span class=\"string\">'susan'</span>&#125;,&#123;<span class=\"attr\">name</span>:<span class=\"string\">'alice'</span>&#125;,&#123;<span class=\"attr\">name</span>:<span class=\"string\">'jay'</span>&#125;]</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>指令drtv_slidetoggle</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.directive(<span class=\"string\">'slideToggle'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">           restrict: <span class=\"string\">'A'</span>,</span><br><span class=\"line\">           scope:&#123;</span><br><span class=\"line\">               isOpen: <span class=\"string\">\"=slideToggle\"</span> &#125;,</span><br><span class=\"line\">           link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope, element, attr</span>) </span>&#123;</span><br><span class=\"line\">               scope.$watch(<span class=\"string\">'isOpen'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newVal,oldVal</span>)</span>&#123; <span class=\"keyword\">if</span>(newVal !== oldVal)&#123;</span><br><span class=\"line\">                       element.stop().slideToggle(<span class=\"string\">'slow'</span>);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n<p>运行效果：</p>\n<p><img src=\"/css/images/56.jpg\" alt=\"\"></p>\n<p>点击其他人名，也是一样的。</p>\n<p>总体思路就是编写指令，通过改变指令的值<img src=\"/css/images/57.jpg\" alt=\"\">，来控制当前元素的收缩展开。</p>\n<p>===不用Requirejs的同学就可以不往下看了===</p>\n<p>【PS】将该指令用Requirejs封装成指令模块，引用就可以在你的项目中使用了；</p>\n<p>Requirejs封装的指令模块，新建js, 命名为drtv_slidetoggle.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'app'</span>,<span class=\"string\">'jquery'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">app</span>) </span>&#123;</span><br><span class=\"line\">    app.directive(<span class=\"string\">'slideToggle'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            restrict: <span class=\"string\">'A'</span>,</span><br><span class=\"line\">            scope:&#123;</span><br><span class=\"line\">                isOpen: <span class=\"string\">\"=slideToggle\"</span> &#125;,</span><br><span class=\"line\">            link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope, element, attr</span>) </span>&#123;</span><br><span class=\"line\">                scope.$watch(<span class=\"string\">'isOpen'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newVal,oldVal</span>)</span>&#123; <span class=\"keyword\">if</span>(newVal !== oldVal)&#123;</span><br><span class=\"line\">                        element.stop().slideToggle(<span class=\"string\">'slow'</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在启动app时候调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'angular'</span>,<span class=\"string\">'domReady!'</span>,<span class=\"string\">'ctrl_main'</span>,<span class=\"string\">'drtv_slidetoggle'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">angular</span>) </span>&#123;</span><br><span class=\"line\">           angular.bootstrap(<span class=\"built_in\">document</span>, [<span class=\"string\">'app'</span>])</span><br><span class=\"line\">       &#125;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>之前使用jQuery的<code>slidetoggle</code>方法，可以轻易的实现元素的收缩展开；使用Angularjs后，没有找到相关的方法，通过多方面查资料，自己写了个demo，展示<code>slidetoggle</code>的Angularjs写法：</p>","more":"<p>html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"ctrl_main\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">ng-repeat-start</span>=<span class=\"string\">\"el in list\"</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"$index=!$index\"</span>&gt;</span>&#123;&#123;el.name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">ng-repeat-end</span> <span class=\"attr\">slide-toggle</span>=<span class=\"string\">\"$index\"</span>&gt;</span>&#123;&#123;$index&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>控制器ctrl_main</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.controller(<span class=\"string\">'ctrl_main'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">$scope</span>) </span>&#123;</span><br><span class=\"line\">        $scope.list=[&#123;<span class=\"attr\">name</span>:<span class=\"string\">'lewis'</span>&#125;,&#123;<span class=\"attr\">name</span>:<span class=\"string\">'susan'</span>&#125;,&#123;<span class=\"attr\">name</span>:<span class=\"string\">'alice'</span>&#125;,&#123;<span class=\"attr\">name</span>:<span class=\"string\">'jay'</span>&#125;]</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>指令drtv_slidetoggle</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.directive(<span class=\"string\">'slideToggle'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">           restrict: <span class=\"string\">'A'</span>,</span><br><span class=\"line\">           scope:&#123;</span><br><span class=\"line\">               isOpen: <span class=\"string\">\"=slideToggle\"</span> &#125;,</span><br><span class=\"line\">           link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope, element, attr</span>) </span>&#123;</span><br><span class=\"line\">               scope.$watch(<span class=\"string\">'isOpen'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newVal,oldVal</span>)</span>&#123; <span class=\"keyword\">if</span>(newVal !== oldVal)&#123;</span><br><span class=\"line\">                       element.stop().slideToggle(<span class=\"string\">'slow'</span>);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n<p>运行效果：</p>\n<p><img src=\"/css/images/56.jpg\" alt=\"\"></p>\n<p>点击其他人名，也是一样的。</p>\n<p>总体思路就是编写指令，通过改变指令的值<img src=\"/css/images/57.jpg\" alt=\"\">，来控制当前元素的收缩展开。</p>\n<p>===不用Requirejs的同学就可以不往下看了===</p>\n<p>【PS】将该指令用Requirejs封装成指令模块，引用就可以在你的项目中使用了；</p>\n<p>Requirejs封装的指令模块，新建js, 命名为drtv_slidetoggle.js：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'app'</span>,<span class=\"string\">'jquery'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">app</span>) </span>&#123;</span><br><span class=\"line\">    app.directive(<span class=\"string\">'slideToggle'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            restrict: <span class=\"string\">'A'</span>,</span><br><span class=\"line\">            scope:&#123;</span><br><span class=\"line\">                isOpen: <span class=\"string\">\"=slideToggle\"</span> &#125;,</span><br><span class=\"line\">            link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope, element, attr</span>) </span>&#123;</span><br><span class=\"line\">                scope.$watch(<span class=\"string\">'isOpen'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newVal,oldVal</span>)</span>&#123; <span class=\"keyword\">if</span>(newVal !== oldVal)&#123;</span><br><span class=\"line\">                        element.stop().slideToggle(<span class=\"string\">'slow'</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在启动app时候调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'angular'</span>,<span class=\"string\">'domReady!'</span>,<span class=\"string\">'ctrl_main'</span>,<span class=\"string\">'drtv_slidetoggle'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">angular</span>) </span>&#123;</span><br><span class=\"line\">           angular.bootstrap(<span class=\"built_in\">document</span>, [<span class=\"string\">'app'</span>])</span><br><span class=\"line\">       &#125;);</span><br></pre></td></tr></table></figure>"},{"title":"JavaScript 版数组搜索算法题：求和为定值的多个数","date":"2017-03-09T10:06:00.000Z","_content":"\n今天，我们要讲的是**求和为定值的多个数**。这个算法题有很多版本，它们都来自于 LeetCode：\n\nhttps://leetcode.com/problems/two-sum\n\nhttps://leetcode.com/problems/3sum\n\nhttps://leetcode.com/problems/4sum\n\n<!--more-->\n\n\n## 和为定值的两个数\n\n在求和为定值的多个数之前，我们先来求和为定值的两个数。对于数组搜索算法而言，如果搜索一个数，那么方法就是前面讲的：\n\n- 顺序搜索\n- 二分搜索\n\n这非常简单，那么如果搜索和为定值两个数呢？其实也可以是顺序搜索或二分搜索，只不过需要遍历数组，先拿到一个值，然后对另一个值进行顺序搜索或二分搜索，比如 `[1, 3, 5, 4, 2]`，求和为6的两个数，那么：\n\n- 第一轮取1，对 `[3, 5, 4, 2]` 进行顺序搜索或二分搜索\n- 第二轮取3，对 `[5, 4, 2]`  进行顺序搜索或二分搜索\n- ……\n\n使用顺序搜索查找两个数的时间复杂度为O(n^2)，空间复杂度为O(1)。使用二分搜索的时间复杂度为O(nlogn)，空间复杂度为O(1)。\n\n那么除了顺序搜索和二分搜索，还有别的方法吗？答案是肯定的。其他方法列举如下：\n\n1，**借助散列表**：先构建一个散列表，存储数组每个值。然后遍历数组，查看 `target` 与每项的差是否在散列表中，如果在就返回两个值。这个方法的时间复杂度和空间复杂度均为O(n)。代码示例如下：\n\nLeetCode/001-twoSum.js\n\n```js\n/**\n * You may assume that each input would have exactly one solution, \n * and you may not use the same element twice.\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function (nums, target) {\n  var map = {};\n\n  for (var i = 0; i < nums.length; i++) {\n    if (nums[i] in map) {\n      return [map[nums[i]], i];\n    } else {\n      map[target - nums[i]] = i;\n    }\n  }\n};\n```\n测试代码如下：\n\n```js\nexpect(twoSum([2, 7, 11, 15], 9)).toEqual([0, 1]);\n```\n\n> 注意， `twoSum` 输出的结果是数组项的索引，而后面的 `threeSum` 和 `fourSum` 输出的则是数组项的值。\n\n2，**双指针两端扫描**：若数组无序，就先排序后扫描。扫描方法是用两个指针 `i` 和 `j`，先放在数组首尾，如果指向的两个数之和大于 `target` ，就 `j--`，否则 `i++`，直到两个数之和为 `target`，然后返回这两个数。该方法的时间复杂度最后为：有序O(n)，无序O(nlogn + n)=O(nlogn)，空间复杂度都为O(1)。代码示例如下：\n\nLeetCode/001-twoSum.js\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum2 = function (nums, target) {\n  var l = 0,\n    r = nums.length - 1,\n    results = [];\n  while (l < r) {\n    var s = nums[l] + nums[r];\n    if (s === target) {\n      results.push([l, r]);\n      while (l < r && nums[l] === nums[l + 1]) {\n        l++;\n      }\n      while (r > l && nums[r] === nums[r - 1]) {\n        r++;\n      }\n      l++;\n      r--;\n    } else if (s < target) {\n      l++;\n    } else {\n      r--;\n    }\n  }\n  return results\n};\n```\n\n测试代码如下：\n\n```js\nexpect(twoSum2([-2, -1, -1, 1, 1], 0)).toEqual([[1, 4]]);\n```\n\n## 和为定值的三个数\n\n了解了和为定值的两个数的搜索方法，那么和为定值的三个数的搜索方法呢？这里需要用到**遍历**+**求和为定值的两个数**。先举个例子吧！比如数组为 `[1, 3, 5, 4, 2]` ，求和为7的三个数。那么整个流程如下：\n\n- 第一轮取1，对 `[3, 5, 4, 2]` 进行和为7-1的两个数搜索。\n- 第二轮取3，对 `[5, 4, 2]` 进行和为7-3的两个数搜索。\n- ……\n\n当问题变为两个数的搜索时，那么我们就可以用前面介绍的方法了！示例代码如下：\n\nLeetCode/015-threeSum.js\n\n```js\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar threeSum = function (nums) {\n  var res = [];\n  nums.sort(function (a, b) {\n    return a - b;\n  });\n\n  for (var i = 0; i < nums.length - 1; i++) {\n    if (i > 0 && nums[i] === nums[i - 1]) {\n      continue;\n    }\n    var l = i + 1;\n    var r = nums.length - 1;\n    while (l < r) {\n      var s = nums[i] + nums[l] + nums[r];\n      if (s < 0) {\n        l++;\n      } else if (s > 0) {\n        r--;\n      } else {\n        res.push([nums[i], nums[l], nums[r]]);\n        while (l < r && nums[l] === nums[l + 1]) {\n          l++;\n        }\n        while (r > l && nums[r] === nums[r - 1]) {\n          r++;\n        }\n        l++;\n        r--;\n      }\n    }\n  }\n  return res;\n};\n```\n\n测试代码如下：\n\n```js\nexpect(threeSum([-2, -1, -1, 1, 1, 2, 2])).toEqual([[-2, 1, 1], [-1, -1, 2]]);\n```\n\n\n## 和为定值的四个数\n\n如果 `N`（`N` 代表和为定值的 `N` 个数） 为更大的值，那么就使用**递归**，一直到 `N` 为2时终结掉。这里我们来求一下和为定值的四个数，示例代码如下：\n\nLeetCode/018-fourSum.js\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nvar fourSum = function (nums, target) {\n  var findNSum = function (nums, target, N, result, results) {\n    if (nums.length < N || target < nums[0] * N || target > nums[-1] * N) {\n      return;\n    }\n    if (N === 2) {\n      var l = 0,\n        r = nums.length - 1;\n      while (l < r) {\n        var s = nums[l] + nums[r];\n        if (s === target) {\n          results.push(result.concat([nums[l], nums[r]]));\n          while (l < r && nums[l] === nums[l + 1]) {\n            l++;\n          }\n          while (r > l && nums[r] === nums[r - 1]) {\n            r++;\n          }\n          l++;\n          r--;\n        } else if (s < target) {\n          l++;\n        } else {\n          r--;\n        }\n      }\n    } else {\n      for (var i = 0; i < nums.length - N + 1; i++) {\n        if (i === 0 || (i > 0 && nums[i - 1] !== nums[i])) {\n          findNSum(nums.slice(i + 1), target - nums[i], N - 1, result.concat([nums[i]]), results);\n        }\n\n      }\n    }\n  };\n  var results = [];\n  nums.sort(function (a, b) {\n    return a - b;\n  });\n  findNSum(nums, target, 4, [], results);\n  return results;\n};\n\n```\n\n测试代码如下：\n\n```js\nexpect(fourSum([-2, -1, -1, 1, 1, 2, 2], 0)).toEqual([[-2, -1, 1, 2], [-1, -1, 1, 1]]);\n```\n当 `N` 为更大的数，只需要更改 `findSum` 的第三个参数即可。练习算法光说不练可不行，赶快打开 LeetCode 进行练习吧！\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","source":"_posts/n-sum.md","raw":"---\ntitle: JavaScript 版数组搜索算法题：求和为定值的多个数\ndate: 2017-03-09 18:06:00\ntags: [数据结构与算法, LeetCode]\n---\n\n今天，我们要讲的是**求和为定值的多个数**。这个算法题有很多版本，它们都来自于 LeetCode：\n\nhttps://leetcode.com/problems/two-sum\n\nhttps://leetcode.com/problems/3sum\n\nhttps://leetcode.com/problems/4sum\n\n<!--more-->\n\n\n## 和为定值的两个数\n\n在求和为定值的多个数之前，我们先来求和为定值的两个数。对于数组搜索算法而言，如果搜索一个数，那么方法就是前面讲的：\n\n- 顺序搜索\n- 二分搜索\n\n这非常简单，那么如果搜索和为定值两个数呢？其实也可以是顺序搜索或二分搜索，只不过需要遍历数组，先拿到一个值，然后对另一个值进行顺序搜索或二分搜索，比如 `[1, 3, 5, 4, 2]`，求和为6的两个数，那么：\n\n- 第一轮取1，对 `[3, 5, 4, 2]` 进行顺序搜索或二分搜索\n- 第二轮取3，对 `[5, 4, 2]`  进行顺序搜索或二分搜索\n- ……\n\n使用顺序搜索查找两个数的时间复杂度为O(n^2)，空间复杂度为O(1)。使用二分搜索的时间复杂度为O(nlogn)，空间复杂度为O(1)。\n\n那么除了顺序搜索和二分搜索，还有别的方法吗？答案是肯定的。其他方法列举如下：\n\n1，**借助散列表**：先构建一个散列表，存储数组每个值。然后遍历数组，查看 `target` 与每项的差是否在散列表中，如果在就返回两个值。这个方法的时间复杂度和空间复杂度均为O(n)。代码示例如下：\n\nLeetCode/001-twoSum.js\n\n```js\n/**\n * You may assume that each input would have exactly one solution, \n * and you may not use the same element twice.\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function (nums, target) {\n  var map = {};\n\n  for (var i = 0; i < nums.length; i++) {\n    if (nums[i] in map) {\n      return [map[nums[i]], i];\n    } else {\n      map[target - nums[i]] = i;\n    }\n  }\n};\n```\n测试代码如下：\n\n```js\nexpect(twoSum([2, 7, 11, 15], 9)).toEqual([0, 1]);\n```\n\n> 注意， `twoSum` 输出的结果是数组项的索引，而后面的 `threeSum` 和 `fourSum` 输出的则是数组项的值。\n\n2，**双指针两端扫描**：若数组无序，就先排序后扫描。扫描方法是用两个指针 `i` 和 `j`，先放在数组首尾，如果指向的两个数之和大于 `target` ，就 `j--`，否则 `i++`，直到两个数之和为 `target`，然后返回这两个数。该方法的时间复杂度最后为：有序O(n)，无序O(nlogn + n)=O(nlogn)，空间复杂度都为O(1)。代码示例如下：\n\nLeetCode/001-twoSum.js\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum2 = function (nums, target) {\n  var l = 0,\n    r = nums.length - 1,\n    results = [];\n  while (l < r) {\n    var s = nums[l] + nums[r];\n    if (s === target) {\n      results.push([l, r]);\n      while (l < r && nums[l] === nums[l + 1]) {\n        l++;\n      }\n      while (r > l && nums[r] === nums[r - 1]) {\n        r++;\n      }\n      l++;\n      r--;\n    } else if (s < target) {\n      l++;\n    } else {\n      r--;\n    }\n  }\n  return results\n};\n```\n\n测试代码如下：\n\n```js\nexpect(twoSum2([-2, -1, -1, 1, 1], 0)).toEqual([[1, 4]]);\n```\n\n## 和为定值的三个数\n\n了解了和为定值的两个数的搜索方法，那么和为定值的三个数的搜索方法呢？这里需要用到**遍历**+**求和为定值的两个数**。先举个例子吧！比如数组为 `[1, 3, 5, 4, 2]` ，求和为7的三个数。那么整个流程如下：\n\n- 第一轮取1，对 `[3, 5, 4, 2]` 进行和为7-1的两个数搜索。\n- 第二轮取3，对 `[5, 4, 2]` 进行和为7-3的两个数搜索。\n- ……\n\n当问题变为两个数的搜索时，那么我们就可以用前面介绍的方法了！示例代码如下：\n\nLeetCode/015-threeSum.js\n\n```js\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar threeSum = function (nums) {\n  var res = [];\n  nums.sort(function (a, b) {\n    return a - b;\n  });\n\n  for (var i = 0; i < nums.length - 1; i++) {\n    if (i > 0 && nums[i] === nums[i - 1]) {\n      continue;\n    }\n    var l = i + 1;\n    var r = nums.length - 1;\n    while (l < r) {\n      var s = nums[i] + nums[l] + nums[r];\n      if (s < 0) {\n        l++;\n      } else if (s > 0) {\n        r--;\n      } else {\n        res.push([nums[i], nums[l], nums[r]]);\n        while (l < r && nums[l] === nums[l + 1]) {\n          l++;\n        }\n        while (r > l && nums[r] === nums[r - 1]) {\n          r++;\n        }\n        l++;\n        r--;\n      }\n    }\n  }\n  return res;\n};\n```\n\n测试代码如下：\n\n```js\nexpect(threeSum([-2, -1, -1, 1, 1, 2, 2])).toEqual([[-2, 1, 1], [-1, -1, 2]]);\n```\n\n\n## 和为定值的四个数\n\n如果 `N`（`N` 代表和为定值的 `N` 个数） 为更大的值，那么就使用**递归**，一直到 `N` 为2时终结掉。这里我们来求一下和为定值的四个数，示例代码如下：\n\nLeetCode/018-fourSum.js\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nvar fourSum = function (nums, target) {\n  var findNSum = function (nums, target, N, result, results) {\n    if (nums.length < N || target < nums[0] * N || target > nums[-1] * N) {\n      return;\n    }\n    if (N === 2) {\n      var l = 0,\n        r = nums.length - 1;\n      while (l < r) {\n        var s = nums[l] + nums[r];\n        if (s === target) {\n          results.push(result.concat([nums[l], nums[r]]));\n          while (l < r && nums[l] === nums[l + 1]) {\n            l++;\n          }\n          while (r > l && nums[r] === nums[r - 1]) {\n            r++;\n          }\n          l++;\n          r--;\n        } else if (s < target) {\n          l++;\n        } else {\n          r--;\n        }\n      }\n    } else {\n      for (var i = 0; i < nums.length - N + 1; i++) {\n        if (i === 0 || (i > 0 && nums[i - 1] !== nums[i])) {\n          findNSum(nums.slice(i + 1), target - nums[i], N - 1, result.concat([nums[i]]), results);\n        }\n\n      }\n    }\n  };\n  var results = [];\n  nums.sort(function (a, b) {\n    return a - b;\n  });\n  findNSum(nums, target, 4, [], results);\n  return results;\n};\n\n```\n\n测试代码如下：\n\n```js\nexpect(fourSum([-2, -1, -1, 1, 1, 2, 2], 0)).toEqual([[-2, -1, 1, 2], [-1, -1, 1, 1]]);\n```\n当 `N` 为更大的数，只需要更改 `findSum` 的第三个参数即可。练习算法光说不练可不行，赶快打开 LeetCode 进行练习吧！\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","slug":"n-sum","published":1,"updated":"2019-05-01T08:02:10.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvls001etgyt4pcsd5y1","content":"<p>今天，我们要讲的是<strong>求和为定值的多个数</strong>。这个算法题有很多版本，它们都来自于 LeetCode：</p>\n<p><a href=\"https://leetcode.com/problems/two-sum\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/two-sum</a></p>\n<p><a href=\"https://leetcode.com/problems/3sum\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/3sum</a></p>\n<p><a href=\"https://leetcode.com/problems/4sum\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/4sum</a></p>\n<a id=\"more\"></a>\n<h2 id=\"和为定值的两个数\"><a href=\"#和为定值的两个数\" class=\"headerlink\" title=\"和为定值的两个数\"></a>和为定值的两个数</h2><p>在求和为定值的多个数之前，我们先来求和为定值的两个数。对于数组搜索算法而言，如果搜索一个数，那么方法就是前面讲的：</p>\n<ul>\n<li>顺序搜索</li>\n<li>二分搜索</li>\n</ul>\n<p>这非常简单，那么如果搜索和为定值两个数呢？其实也可以是顺序搜索或二分搜索，只不过需要遍历数组，先拿到一个值，然后对另一个值进行顺序搜索或二分搜索，比如 <code>[1, 3, 5, 4, 2]</code>，求和为6的两个数，那么：</p>\n<ul>\n<li>第一轮取1，对 <code>[3, 5, 4, 2]</code> 进行顺序搜索或二分搜索</li>\n<li>第二轮取3，对 <code>[5, 4, 2]</code>  进行顺序搜索或二分搜索</li>\n<li>……</li>\n</ul>\n<p>使用顺序搜索查找两个数的时间复杂度为O(n^2)，空间复杂度为O(1)。使用二分搜索的时间复杂度为O(nlogn)，空间复杂度为O(1)。</p>\n<p>那么除了顺序搜索和二分搜索，还有别的方法吗？答案是肯定的。其他方法列举如下：</p>\n<p>1，<strong>借助散列表</strong>：先构建一个散列表，存储数组每个值。然后遍历数组，查看 <code>target</code> 与每项的差是否在散列表中，如果在就返回两个值。这个方法的时间复杂度和空间复杂度均为O(n)。代码示例如下：</p>\n<p>LeetCode/001-twoSum.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * You may assume that each input would have exactly one solution, </span></span><br><span class=\"line\"><span class=\"comment\"> * and you may not use the same element twice.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; nums</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; target</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number[]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> twoSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> map = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] <span class=\"keyword\">in</span> map) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [map[nums[i]], i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      map[target - nums[i]] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(twoSum([<span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>], <span class=\"number\">9</span>)).toEqual([<span class=\"number\">0</span>, <span class=\"number\">1</span>]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意， <code>twoSum</code> 输出的结果是数组项的索引，而后面的 <code>threeSum</code> 和 <code>fourSum</code> 输出的则是数组项的值。</p>\n</blockquote>\n<p>2，<strong>双指针两端扫描</strong>：若数组无序，就先排序后扫描。扫描方法是用两个指针 <code>i</code> 和 <code>j</code>，先放在数组首尾，如果指向的两个数之和大于 <code>target</code> ，就 <code>j--</code>，否则 <code>i++</code>，直到两个数之和为 <code>target</code>，然后返回这两个数。该方法的时间复杂度最后为：有序O(n)，无序O(nlogn + n)=O(nlogn)，空间复杂度都为O(1)。代码示例如下：</p>\n<p>LeetCode/001-twoSum.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; nums</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; target</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number[]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> twoSum2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> l = <span class=\"number\">0</span>,</span><br><span class=\"line\">    r = nums.length - <span class=\"number\">1</span>,</span><br><span class=\"line\">    results = [];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = nums[l] + nums[r];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s === target) &#123;</span><br><span class=\"line\">      results.push([l, r]);</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (l &lt; r &amp;&amp; nums[l] === nums[l + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        l++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (r &gt; l &amp;&amp; nums[r] === nums[r - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        r++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      l++;</span><br><span class=\"line\">      r--;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s &lt; target) &#123;</span><br><span class=\"line\">      l++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      r--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> results</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(twoSum2([<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>], <span class=\"number\">0</span>)).toEqual([[<span class=\"number\">1</span>, <span class=\"number\">4</span>]]);</span><br></pre></td></tr></table></figure>\n<h2 id=\"和为定值的三个数\"><a href=\"#和为定值的三个数\" class=\"headerlink\" title=\"和为定值的三个数\"></a>和为定值的三个数</h2><p>了解了和为定值的两个数的搜索方法，那么和为定值的三个数的搜索方法呢？这里需要用到<strong>遍历</strong>+<strong>求和为定值的两个数</strong>。先举个例子吧！比如数组为 <code>[1, 3, 5, 4, 2]</code> ，求和为7的三个数。那么整个流程如下：</p>\n<ul>\n<li>第一轮取1，对 <code>[3, 5, 4, 2]</code> 进行和为7-1的两个数搜索。</li>\n<li>第二轮取3，对 <code>[5, 4, 2]</code> 进行和为7-3的两个数搜索。</li>\n<li>……</li>\n</ul>\n<p>当问题变为两个数的搜索时，那么我们就可以用前面介绍的方法了！示例代码如下：</p>\n<p>LeetCode/015-threeSum.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; nums</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number[][]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> threeSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\">  nums.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; nums.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] === nums[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> l = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> r = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> s = nums[i] + nums[l] + nums[r];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (s &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        l++;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        r--;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        res.push([nums[i], nums[l], nums[r]]);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r &amp;&amp; nums[l] === nums[l + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">          l++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (r &gt; l &amp;&amp; nums[r] === nums[r - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">          r++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        l++;</span><br><span class=\"line\">        r--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(threeSum([<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>])).toEqual([[<span class=\"number\">-2</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>], [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">2</span>]]);</span><br></pre></td></tr></table></figure>\n<h2 id=\"和为定值的四个数\"><a href=\"#和为定值的四个数\" class=\"headerlink\" title=\"和为定值的四个数\"></a>和为定值的四个数</h2><p>如果 <code>N</code>（<code>N</code> 代表和为定值的 <code>N</code> 个数） 为更大的值，那么就使用<strong>递归</strong>，一直到 <code>N</code> 为2时终结掉。这里我们来求一下和为定值的四个数，示例代码如下：</p>\n<p>LeetCode/018-fourSum.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; nums</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; target</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number[][]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fourSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> findNSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target, N, result, results</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.length &lt; N || target &lt; nums[<span class=\"number\">0</span>] * N || target &gt; nums[<span class=\"number\">-1</span>] * N) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> l = <span class=\"number\">0</span>,</span><br><span class=\"line\">        r = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> s = nums[l] + nums[r];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s === target) &#123;</span><br><span class=\"line\">          results.push(result.concat([nums[l], nums[r]]));</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (l &lt; r &amp;&amp; nums[l] === nums[l + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            l++;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (r &gt; l &amp;&amp; nums[r] === nums[r - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            r++;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          l++;</span><br><span class=\"line\">          r--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s &lt; target) &#123;</span><br><span class=\"line\">          l++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          r--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; nums.length - N + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i === <span class=\"number\">0</span> || (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i - <span class=\"number\">1</span>] !== nums[i])) &#123;</span><br><span class=\"line\">          findNSum(nums.slice(i + <span class=\"number\">1</span>), target - nums[i], N - <span class=\"number\">1</span>, result.concat([nums[i]]), results);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> results = [];</span><br><span class=\"line\">  nums.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  findNSum(nums, target, <span class=\"number\">4</span>, [], results);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(fourSum([<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>], <span class=\"number\">0</span>)).toEqual([[<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]]);</span><br></pre></td></tr></table></figure>\n<p>当 <code>N</code> 为更大的数，只需要更改 <code>findSum</code> 的第三个参数即可。练习算法光说不练可不行，赶快打开 LeetCode 进行练习吧！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是<strong>求和为定值的多个数</strong>。这个算法题有很多版本，它们都来自于 LeetCode：</p>\n<p><a href=\"https://leetcode.com/problems/two-sum\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/two-sum</a></p>\n<p><a href=\"https://leetcode.com/problems/3sum\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/3sum</a></p>\n<p><a href=\"https://leetcode.com/problems/4sum\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/4sum</a></p>","more":"<h2 id=\"和为定值的两个数\"><a href=\"#和为定值的两个数\" class=\"headerlink\" title=\"和为定值的两个数\"></a>和为定值的两个数</h2><p>在求和为定值的多个数之前，我们先来求和为定值的两个数。对于数组搜索算法而言，如果搜索一个数，那么方法就是前面讲的：</p>\n<ul>\n<li>顺序搜索</li>\n<li>二分搜索</li>\n</ul>\n<p>这非常简单，那么如果搜索和为定值两个数呢？其实也可以是顺序搜索或二分搜索，只不过需要遍历数组，先拿到一个值，然后对另一个值进行顺序搜索或二分搜索，比如 <code>[1, 3, 5, 4, 2]</code>，求和为6的两个数，那么：</p>\n<ul>\n<li>第一轮取1，对 <code>[3, 5, 4, 2]</code> 进行顺序搜索或二分搜索</li>\n<li>第二轮取3，对 <code>[5, 4, 2]</code>  进行顺序搜索或二分搜索</li>\n<li>……</li>\n</ul>\n<p>使用顺序搜索查找两个数的时间复杂度为O(n^2)，空间复杂度为O(1)。使用二分搜索的时间复杂度为O(nlogn)，空间复杂度为O(1)。</p>\n<p>那么除了顺序搜索和二分搜索，还有别的方法吗？答案是肯定的。其他方法列举如下：</p>\n<p>1，<strong>借助散列表</strong>：先构建一个散列表，存储数组每个值。然后遍历数组，查看 <code>target</code> 与每项的差是否在散列表中，如果在就返回两个值。这个方法的时间复杂度和空间复杂度均为O(n)。代码示例如下：</p>\n<p>LeetCode/001-twoSum.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * You may assume that each input would have exactly one solution, </span></span><br><span class=\"line\"><span class=\"comment\"> * and you may not use the same element twice.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; nums</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; target</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number[]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> twoSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> map = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] <span class=\"keyword\">in</span> map) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [map[nums[i]], i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      map[target - nums[i]] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(twoSum([<span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>], <span class=\"number\">9</span>)).toEqual([<span class=\"number\">0</span>, <span class=\"number\">1</span>]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意， <code>twoSum</code> 输出的结果是数组项的索引，而后面的 <code>threeSum</code> 和 <code>fourSum</code> 输出的则是数组项的值。</p>\n</blockquote>\n<p>2，<strong>双指针两端扫描</strong>：若数组无序，就先排序后扫描。扫描方法是用两个指针 <code>i</code> 和 <code>j</code>，先放在数组首尾，如果指向的两个数之和大于 <code>target</code> ，就 <code>j--</code>，否则 <code>i++</code>，直到两个数之和为 <code>target</code>，然后返回这两个数。该方法的时间复杂度最后为：有序O(n)，无序O(nlogn + n)=O(nlogn)，空间复杂度都为O(1)。代码示例如下：</p>\n<p>LeetCode/001-twoSum.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; nums</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; target</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number[]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> twoSum2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> l = <span class=\"number\">0</span>,</span><br><span class=\"line\">    r = nums.length - <span class=\"number\">1</span>,</span><br><span class=\"line\">    results = [];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = nums[l] + nums[r];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s === target) &#123;</span><br><span class=\"line\">      results.push([l, r]);</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (l &lt; r &amp;&amp; nums[l] === nums[l + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        l++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (r &gt; l &amp;&amp; nums[r] === nums[r - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        r++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      l++;</span><br><span class=\"line\">      r--;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s &lt; target) &#123;</span><br><span class=\"line\">      l++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      r--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> results</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(twoSum2([<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>], <span class=\"number\">0</span>)).toEqual([[<span class=\"number\">1</span>, <span class=\"number\">4</span>]]);</span><br></pre></td></tr></table></figure>\n<h2 id=\"和为定值的三个数\"><a href=\"#和为定值的三个数\" class=\"headerlink\" title=\"和为定值的三个数\"></a>和为定值的三个数</h2><p>了解了和为定值的两个数的搜索方法，那么和为定值的三个数的搜索方法呢？这里需要用到<strong>遍历</strong>+<strong>求和为定值的两个数</strong>。先举个例子吧！比如数组为 <code>[1, 3, 5, 4, 2]</code> ，求和为7的三个数。那么整个流程如下：</p>\n<ul>\n<li>第一轮取1，对 <code>[3, 5, 4, 2]</code> 进行和为7-1的两个数搜索。</li>\n<li>第二轮取3，对 <code>[5, 4, 2]</code> 进行和为7-3的两个数搜索。</li>\n<li>……</li>\n</ul>\n<p>当问题变为两个数的搜索时，那么我们就可以用前面介绍的方法了！示例代码如下：</p>\n<p>LeetCode/015-threeSum.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; nums</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number[][]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> threeSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\">  nums.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; nums.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] === nums[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> l = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> r = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> s = nums[i] + nums[l] + nums[r];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (s &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        l++;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        r--;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        res.push([nums[i], nums[l], nums[r]]);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r &amp;&amp; nums[l] === nums[l + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">          l++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (r &gt; l &amp;&amp; nums[r] === nums[r - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">          r++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        l++;</span><br><span class=\"line\">        r--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(threeSum([<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>])).toEqual([[<span class=\"number\">-2</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>], [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">2</span>]]);</span><br></pre></td></tr></table></figure>\n<h2 id=\"和为定值的四个数\"><a href=\"#和为定值的四个数\" class=\"headerlink\" title=\"和为定值的四个数\"></a>和为定值的四个数</h2><p>如果 <code>N</code>（<code>N</code> 代表和为定值的 <code>N</code> 个数） 为更大的值，那么就使用<strong>递归</strong>，一直到 <code>N</code> 为2时终结掉。这里我们来求一下和为定值的四个数，示例代码如下：</p>\n<p>LeetCode/018-fourSum.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; nums</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; target</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number[][]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fourSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> findNSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target, N, result, results</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.length &lt; N || target &lt; nums[<span class=\"number\">0</span>] * N || target &gt; nums[<span class=\"number\">-1</span>] * N) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> l = <span class=\"number\">0</span>,</span><br><span class=\"line\">        r = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> s = nums[l] + nums[r];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s === target) &#123;</span><br><span class=\"line\">          results.push(result.concat([nums[l], nums[r]]));</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (l &lt; r &amp;&amp; nums[l] === nums[l + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            l++;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (r &gt; l &amp;&amp; nums[r] === nums[r - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            r++;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          l++;</span><br><span class=\"line\">          r--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s &lt; target) &#123;</span><br><span class=\"line\">          l++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          r--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; nums.length - N + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i === <span class=\"number\">0</span> || (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i - <span class=\"number\">1</span>] !== nums[i])) &#123;</span><br><span class=\"line\">          findNSum(nums.slice(i + <span class=\"number\">1</span>), target - nums[i], N - <span class=\"number\">1</span>, result.concat([nums[i]]), results);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> results = [];</span><br><span class=\"line\">  nums.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  findNSum(nums, target, <span class=\"number\">4</span>, [], results);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(fourSum([<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>], <span class=\"number\">0</span>)).toEqual([[<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]]);</span><br></pre></td></tr></table></figure>\n<p>当 <code>N</code> 为更大的数，只需要更改 <code>findSum</code> 的第三个参数即可。练习算法光说不练可不行，赶快打开 LeetCode 进行练习吧！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>"},{"title":"Angular2 系列教程（一）hello world","date":"2016-02-15T01:38:00.000Z","_content":"\n今天我们要讲的是Angular2 系列教程的第一篇，主要是学习Angular2的运行，以及感受Angular2的Components以及模板语法。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/63.jpg)\n\n这个例子非常简单，是个双向数据绑定。我使用了官网上最简单的方法来启动这个程序，并且去除 CDN 使用本地加载，保证长期可以运行（因为文件都在本地，我们不用担心版本更新的问题。）\n\n[源代码](https://github.com/lewis617/angular2-tutorial/tree/gh-pages/hellowold)\n\n运行方法：\n\n全局安装http-server\n\n```sh \nnpm install -g http-server\n```\n\n在根目录（hellowold）运行服务\n\n```sh    \nhttp-server\n```\n根据提示打开相应的端口（一般是8080）。\n\n也可以直接看我的[github pages](http://lewis617.github.io/angular2-tutorial/hellowold/) 。\n\n## 公共部分\n\n公共部分就是你可以直接复制粘贴拿去用的部分，包括\n\n  1. index.html\n  2. lib（文件夹以及里面所有的js文件）\n  3. app/main.ts\n\n这些文件都是完全不用修改的，还有一个文件需要部分修改：\n\n  1. app/app.ts\n\n这个文件必须导出App组件。其他文件都是需要自己编写的。\n\n## lib简介\n\n  1. 前三个文件是ie的polyfill，其他浏览器是不需要的\n\t  * `<script src=\"lib/es6-shim.min.js\"></script>` \n\t  * `<script src=\"lib/system-polyfills.js\"></script>` \n\t  * `<script src=\"lib/shims_for_IE.js\"></script>`  \n\n  2.  第四个文件包含了zone和reflect-metadata。zone告诉angular2何时更新视图？还记的ng1的脏检查以及$apply吧，zone就是用来取代这些恶心的东西的！reflect-metadata也是为了使用 ES7风格的装饰器准备的，就像`@Component` 和 `@View` 。这在ng2里面重度使用！\n\t  * `<script src=\"lib/angular2-polyfills.js\"></script>`\n  4.  这三个文件分别用于模块系统、ts编译、响应式编程（增强处理异步的能力）\n\t  * `<script src=\"lib/system.js\"></script>`  \n\t  * `<script src=\"lib/typescript.js\"></script>`  \n\t  * `<script src=\"lib/Rx.js\"></script>`   \n\n  5.  最后是ng2的库文件\n\t  * `<script src=\"lib/angular2.dev.js\"></script>`\n\n## 组件\n\n其实这个程序就一个ts文件，还特别短！\n\napp/app.ts\n\n```ts\nimport {Component} from 'angular2/core';  \n  \n@Component({  \n    selector: 'app',  \n    template: `  \n        <h1>Hello, {{name}}!</h1>  \n        Say hello to: <input [value]=\"name\" (input)=\"name = $event.target.value\">  \n    `  \n})  \nexport class App {  \n    name: string = 'World';  \n}\n```\n\n定义一个类，给它装饰一个组件，组件是什么？就是ng1里面的指令，react中的组件，就是样子，看得见摸得着的东西。\n\n这里我不得不夸一下ng2，实在改进太多了，所有的东西包括组件、服务、过滤器等都是一个类，然后用各自相关的@装饰器，装饰一下就可以了，非常简单明了！\n\n## 模板语法\n\n我们先来感受下ng2的模板语法，后面我会单独拿出来讲这个知识点。\n\n值得高兴的是双花括号依然存在\n\n```html\n<h1>Hello, {{name}}!</h1>\n```\n\n`ng-model`变成了`[value]`，属性绑定用了`[value]`。\n\n```html\n<input [value]=\"name\" (input)=\"name = $event.target.value\">\n```\n\n事件绑定变成了`()`，里面是所有html5的事件比如，`click`,`hover`,`input`等等。ng2终于拥抱html5原生方法了！\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>","source":"_posts/ng2-hello.md","raw":"---\ntitle: Angular2 系列教程（一）hello world\ndate: 2016-02-15 09:38:00\ntags: [Angular2]\n---\n\n今天我们要讲的是Angular2 系列教程的第一篇，主要是学习Angular2的运行，以及感受Angular2的Components以及模板语法。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/63.jpg)\n\n这个例子非常简单，是个双向数据绑定。我使用了官网上最简单的方法来启动这个程序，并且去除 CDN 使用本地加载，保证长期可以运行（因为文件都在本地，我们不用担心版本更新的问题。）\n\n[源代码](https://github.com/lewis617/angular2-tutorial/tree/gh-pages/hellowold)\n\n运行方法：\n\n全局安装http-server\n\n```sh \nnpm install -g http-server\n```\n\n在根目录（hellowold）运行服务\n\n```sh    \nhttp-server\n```\n根据提示打开相应的端口（一般是8080）。\n\n也可以直接看我的[github pages](http://lewis617.github.io/angular2-tutorial/hellowold/) 。\n\n## 公共部分\n\n公共部分就是你可以直接复制粘贴拿去用的部分，包括\n\n  1. index.html\n  2. lib（文件夹以及里面所有的js文件）\n  3. app/main.ts\n\n这些文件都是完全不用修改的，还有一个文件需要部分修改：\n\n  1. app/app.ts\n\n这个文件必须导出App组件。其他文件都是需要自己编写的。\n\n## lib简介\n\n  1. 前三个文件是ie的polyfill，其他浏览器是不需要的\n\t  * `<script src=\"lib/es6-shim.min.js\"></script>` \n\t  * `<script src=\"lib/system-polyfills.js\"></script>` \n\t  * `<script src=\"lib/shims_for_IE.js\"></script>`  \n\n  2.  第四个文件包含了zone和reflect-metadata。zone告诉angular2何时更新视图？还记的ng1的脏检查以及$apply吧，zone就是用来取代这些恶心的东西的！reflect-metadata也是为了使用 ES7风格的装饰器准备的，就像`@Component` 和 `@View` 。这在ng2里面重度使用！\n\t  * `<script src=\"lib/angular2-polyfills.js\"></script>`\n  4.  这三个文件分别用于模块系统、ts编译、响应式编程（增强处理异步的能力）\n\t  * `<script src=\"lib/system.js\"></script>`  \n\t  * `<script src=\"lib/typescript.js\"></script>`  \n\t  * `<script src=\"lib/Rx.js\"></script>`   \n\n  5.  最后是ng2的库文件\n\t  * `<script src=\"lib/angular2.dev.js\"></script>`\n\n## 组件\n\n其实这个程序就一个ts文件，还特别短！\n\napp/app.ts\n\n```ts\nimport {Component} from 'angular2/core';  \n  \n@Component({  \n    selector: 'app',  \n    template: `  \n        <h1>Hello, {{name}}!</h1>  \n        Say hello to: <input [value]=\"name\" (input)=\"name = $event.target.value\">  \n    `  \n})  \nexport class App {  \n    name: string = 'World';  \n}\n```\n\n定义一个类，给它装饰一个组件，组件是什么？就是ng1里面的指令，react中的组件，就是样子，看得见摸得着的东西。\n\n这里我不得不夸一下ng2，实在改进太多了，所有的东西包括组件、服务、过滤器等都是一个类，然后用各自相关的@装饰器，装饰一下就可以了，非常简单明了！\n\n## 模板语法\n\n我们先来感受下ng2的模板语法，后面我会单独拿出来讲这个知识点。\n\n值得高兴的是双花括号依然存在\n\n```html\n<h1>Hello, {{name}}!</h1>\n```\n\n`ng-model`变成了`[value]`，属性绑定用了`[value]`。\n\n```html\n<input [value]=\"name\" (input)=\"name = $event.target.value\">\n```\n\n事件绑定变成了`()`，里面是所有html5的事件比如，`click`,`hover`,`input`等等。ng2终于拥抱html5原生方法了！\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>","slug":"ng2-hello","published":1,"updated":"2019-05-01T08:10:29.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvlt001gtgytcahle8ii","content":"<p>今天我们要讲的是Angular2 系列教程的第一篇，主要是学习Angular2的运行，以及感受Angular2的Components以及模板语法。</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/63.jpg\" alt=\"\"></p>\n<p>这个例子非常简单，是个双向数据绑定。我使用了官网上最简单的方法来启动这个程序，并且去除 CDN 使用本地加载，保证长期可以运行（因为文件都在本地，我们不用担心版本更新的问题。）</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/hellowold\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<p>运行方法：</p>\n<p>全局安装http-server</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g http-server</span><br></pre></td></tr></table></figure>\n<p>在根目录（hellowold）运行服务</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server</span><br></pre></td></tr></table></figure>\n<p>根据提示打开相应的端口（一般是8080）。</p>\n<p>也可以直接看我的<a href=\"http://lewis617.github.io/angular2-tutorial/hellowold/\" target=\"_blank\" rel=\"noopener\">github pages</a> 。</p>\n<h2 id=\"公共部分\"><a href=\"#公共部分\" class=\"headerlink\" title=\"公共部分\"></a>公共部分</h2><p>公共部分就是你可以直接复制粘贴拿去用的部分，包括</p>\n<ol>\n<li>index.html</li>\n<li>lib（文件夹以及里面所有的js文件）</li>\n<li>app/main.ts</li>\n</ol>\n<p>这些文件都是完全不用修改的，还有一个文件需要部分修改：</p>\n<ol>\n<li>app/app.ts</li>\n</ol>\n<p>这个文件必须导出App组件。其他文件都是需要自己编写的。</p>\n<h2 id=\"lib简介\"><a href=\"#lib简介\" class=\"headerlink\" title=\"lib简介\"></a>lib简介</h2><ol>\n<li><p>前三个文件是ie的polyfill，其他浏览器是不需要的</p>\n<ul>\n<li><code>&lt;script src=&quot;lib/es6-shim.min.js&quot;&gt;&lt;/script&gt;</code> </li>\n<li><code>&lt;script src=&quot;lib/system-polyfills.js&quot;&gt;&lt;/script&gt;</code> </li>\n<li><code>&lt;script src=&quot;lib/shims_for_IE.js&quot;&gt;&lt;/script&gt;</code>  </li>\n</ul>\n</li>\n<li><p>第四个文件包含了zone和reflect-metadata。zone告诉angular2何时更新视图？还记的ng1的脏检查以及$apply吧，zone就是用来取代这些恶心的东西的！reflect-metadata也是为了使用 ES7风格的装饰器准备的，就像<code>@Component</code> 和 <code>@View</code> 。这在ng2里面重度使用！</p>\n<ul>\n<li><code>&lt;script src=&quot;lib/angular2-polyfills.js&quot;&gt;&lt;/script&gt;</code></li>\n</ul>\n</li>\n<li><p>这三个文件分别用于模块系统、ts编译、响应式编程（增强处理异步的能力）</p>\n<ul>\n<li><code>&lt;script src=&quot;lib/system.js&quot;&gt;&lt;/script&gt;</code>  </li>\n<li><code>&lt;script src=&quot;lib/typescript.js&quot;&gt;&lt;/script&gt;</code>  </li>\n<li><code>&lt;script src=&quot;lib/Rx.js&quot;&gt;&lt;/script&gt;</code>   </li>\n</ul>\n</li>\n<li><p>最后是ng2的库文件</p>\n<ul>\n<li><code>&lt;script src=&quot;lib/angular2.dev.js&quot;&gt;&lt;/script&gt;</code></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><p>其实这个程序就一个ts文件，还特别短！</p>\n<p>app/app.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;  </span><br><span class=\"line\">    selector: <span class=\"string\">'app'</span>,  </span><br><span class=\"line\">    template: <span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">        &lt;h1&gt;Hello, &#123;&#123;name&#125;&#125;!&lt;/h1&gt;  </span></span><br><span class=\"line\"><span class=\"string\">        Say hello to: &lt;input [value]=\"name\" (input)=\"name = $event.target.value\"&gt;  </span></span><br><span class=\"line\"><span class=\"string\">    `</span>  </span><br><span class=\"line\">&#125;)  </span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> App &#123;  </span><br><span class=\"line\">    name: <span class=\"built_in\">string</span> = <span class=\"string\">'World'</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义一个类，给它装饰一个组件，组件是什么？就是ng1里面的指令，react中的组件，就是样子，看得见摸得着的东西。</p>\n<p>这里我不得不夸一下ng2，实在改进太多了，所有的东西包括组件、服务、过滤器等都是一个类，然后用各自相关的@装饰器，装饰一下就可以了，非常简单明了！</p>\n<h2 id=\"模板语法\"><a href=\"#模板语法\" class=\"headerlink\" title=\"模板语法\"></a>模板语法</h2><p>我们先来感受下ng2的模板语法，后面我会单独拿出来讲这个知识点。</p>\n<p>值得高兴的是双花括号依然存在</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;&#123;name&#125;&#125;!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>ng-model</code>变成了<code>[value]</code>，属性绑定用了<code>[value]</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> [<span class=\"attr\">value</span>]=<span class=\"string\">\"name\"</span> (<span class=\"attr\">input</span>)=<span class=\"string\">\"name = $event.target.value\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>事件绑定变成了<code>()</code>，里面是所有html5的事件比如，<code>click</code>,<code>hover</code>,<code>input</code>等等。ng2终于拥抱html5原生方法了！</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天我们要讲的是Angular2 系列教程的第一篇，主要是学习Angular2的运行，以及感受Angular2的Components以及模板语法。</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/63.jpg\" alt=\"\"></p>\n<p>这个例子非常简单，是个双向数据绑定。我使用了官网上最简单的方法来启动这个程序，并且去除 CDN 使用本地加载，保证长期可以运行（因为文件都在本地，我们不用担心版本更新的问题。）</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/hellowold\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<p>运行方法：</p>\n<p>全局安装http-server</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g http-server</span><br></pre></td></tr></table></figure>\n<p>在根目录（hellowold）运行服务</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server</span><br></pre></td></tr></table></figure>\n<p>根据提示打开相应的端口（一般是8080）。</p>\n<p>也可以直接看我的<a href=\"http://lewis617.github.io/angular2-tutorial/hellowold/\" target=\"_blank\" rel=\"noopener\">github pages</a> 。</p>\n<h2 id=\"公共部分\"><a href=\"#公共部分\" class=\"headerlink\" title=\"公共部分\"></a>公共部分</h2><p>公共部分就是你可以直接复制粘贴拿去用的部分，包括</p>\n<ol>\n<li>index.html</li>\n<li>lib（文件夹以及里面所有的js文件）</li>\n<li>app/main.ts</li>\n</ol>\n<p>这些文件都是完全不用修改的，还有一个文件需要部分修改：</p>\n<ol>\n<li>app/app.ts</li>\n</ol>\n<p>这个文件必须导出App组件。其他文件都是需要自己编写的。</p>\n<h2 id=\"lib简介\"><a href=\"#lib简介\" class=\"headerlink\" title=\"lib简介\"></a>lib简介</h2><ol>\n<li><p>前三个文件是ie的polyfill，其他浏览器是不需要的</p>\n<ul>\n<li><code>&lt;script src=&quot;lib/es6-shim.min.js&quot;&gt;&lt;/script&gt;</code> </li>\n<li><code>&lt;script src=&quot;lib/system-polyfills.js&quot;&gt;&lt;/script&gt;</code> </li>\n<li><code>&lt;script src=&quot;lib/shims_for_IE.js&quot;&gt;&lt;/script&gt;</code>  </li>\n</ul>\n</li>\n<li><p>第四个文件包含了zone和reflect-metadata。zone告诉angular2何时更新视图？还记的ng1的脏检查以及$apply吧，zone就是用来取代这些恶心的东西的！reflect-metadata也是为了使用 ES7风格的装饰器准备的，就像<code>@Component</code> 和 <code>@View</code> 。这在ng2里面重度使用！</p>\n<ul>\n<li><code>&lt;script src=&quot;lib/angular2-polyfills.js&quot;&gt;&lt;/script&gt;</code></li>\n</ul>\n</li>\n<li><p>这三个文件分别用于模块系统、ts编译、响应式编程（增强处理异步的能力）</p>\n<ul>\n<li><code>&lt;script src=&quot;lib/system.js&quot;&gt;&lt;/script&gt;</code>  </li>\n<li><code>&lt;script src=&quot;lib/typescript.js&quot;&gt;&lt;/script&gt;</code>  </li>\n<li><code>&lt;script src=&quot;lib/Rx.js&quot;&gt;&lt;/script&gt;</code>   </li>\n</ul>\n</li>\n<li><p>最后是ng2的库文件</p>\n<ul>\n<li><code>&lt;script src=&quot;lib/angular2.dev.js&quot;&gt;&lt;/script&gt;</code></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><p>其实这个程序就一个ts文件，还特别短！</p>\n<p>app/app.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;  </span><br><span class=\"line\">    selector: <span class=\"string\">'app'</span>,  </span><br><span class=\"line\">    template: <span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">        &lt;h1&gt;Hello, &#123;&#123;name&#125;&#125;!&lt;/h1&gt;  </span></span><br><span class=\"line\"><span class=\"string\">        Say hello to: &lt;input [value]=\"name\" (input)=\"name = $event.target.value\"&gt;  </span></span><br><span class=\"line\"><span class=\"string\">    `</span>  </span><br><span class=\"line\">&#125;)  </span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> App &#123;  </span><br><span class=\"line\">    name: <span class=\"built_in\">string</span> = <span class=\"string\">'World'</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义一个类，给它装饰一个组件，组件是什么？就是ng1里面的指令，react中的组件，就是样子，看得见摸得着的东西。</p>\n<p>这里我不得不夸一下ng2，实在改进太多了，所有的东西包括组件、服务、过滤器等都是一个类，然后用各自相关的@装饰器，装饰一下就可以了，非常简单明了！</p>\n<h2 id=\"模板语法\"><a href=\"#模板语法\" class=\"headerlink\" title=\"模板语法\"></a>模板语法</h2><p>我们先来感受下ng2的模板语法，后面我会单独拿出来讲这个知识点。</p>\n<p>值得高兴的是双花括号依然存在</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;&#123;name&#125;&#125;!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>ng-model</code>变成了<code>[value]</code>，属性绑定用了<code>[value]</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> [<span class=\"attr\">value</span>]=<span class=\"string\">\"name\"</span> (<span class=\"attr\">input</span>)=<span class=\"string\">\"name = $event.target.value\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>事件绑定变成了<code>()</code>，里面是所有html5的事件比如，<code>click</code>,<code>hover</code>,<code>input</code>等等。ng2终于拥抱html5原生方法了！</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>"},{"title":"Angular2 系列教程（三）Components","date":"2016-02-16T22:28:00.000Z","_content":"\n今天，我们要讲的是ng2的Components。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/62.jpg)\n\n这个例子是个老外写的，我将其迁移到ng2 beta版本，想了解迁移的同学可以参考我的做法。\n\n[源代码](https://github.com/lewis617/angular2-tutorial/tree/gh-pages/componnets)\n\n## 消失的控制器\n\nng2的组件就是ng1中的指令。它包含模板、样式、注入、和选择器。\n\n组件嵌套组件可以实现类似react的模块化，我曾经也用ng1做过类似的事情\n\n[Angular 结合RequireJs实现模块化开发](https://lewis617.github.io/2015/10/01/ng-requirejs-module/)\n\n我当时就想，既然有了指令（ng1）还要什么控制器（ng1）啊！果不其然ng2中移除了控制器，直接用指令也就是ng2的组件来展示界面：\n\napp/navbar.ts\n\n```ts\nimport { Component} from 'angular2/core';\nimport {NgFor} from 'angular2/common'\n\n@Component({\n    selector: \"navbar\",\n    directives: [NgFor],\n    styles: [`\n        li{\n          color: gray;\n        }\n    `],\n    template: `\n        <h2>Democratic Party presidential candidates</h2>\n        <ul>\n        <li *ngFor=\"#item of items; #i = index\">{{item}} {{i}}</li>\n        </ul>\n    `\n})\nexport class Navbar {\n    items: Array<String>\n\n    constructor() {\n      this.items = [\n        \"Hillary Clinton\",\n        \"Martin O'Malley\",\n        \"Bernie Sanders\"\n      ]\n    }\n\n    ngOnInit() {\n        console.log('[Component] navbar onInit');\n    }\n}\n```\n\n当组件被实例化后，ng2为这个组件创建了一个shadow DOM（Shadow DOM在一个web组件中提供了js,css,template的封装），然后模板和样式被注入进去。\n\n这段代码做了这些事情：\n\n  1. 设置选择器\n  2. 设置`directives`为`[ngFor]`\n  3. 设置样式\n  4. 设置模板\n  5. 填写类的成员变量`items`\n  6. 在构造函数中给`items`添加数据\n  7. 在生命周期的钩子`ngOnInit`中打印信息\n\n我们的组件就写好了。\n\n## 组件的嵌套\n\n写好组件后，我们如何将这个组件放在`app`组件中呢？答案是`directives`。这里设计得没有react好，react的组件是可以直接用的，ng2的组件则需要以指令的身份注入，因为组件实质也是指令：\n\napp/app.ts\n\n```ts\nimport {Component} from 'angular2/core';\nimport {bootstrap} from 'angular2/platform/browser';\nimport {Navbar} from './navbar';\n\n@Component({\n    selector: \"app\",\n    directives:[Navbar],\n    template: `\n      <navbar></navbar>\n    `\n})\nexport class App {\n  constructor() {\n   \n  }\n}\n\nbootstrap(App, [])\n  .catch(err => console.error(err));\n```    \n                    \nng2中组件和指令都是注入在`directives`中，`directives`包含三种类型：\n\n  1. Components\n  2. Structural directives\n  3. Attribute directives\n\n\n关于指令，我们会单独拿出来讲解。\n\n## 生命周期钩子\n\n本例中，我们使用了`ngOnInit`这个类方法去打印一个信息，这个方法会在组件初始化时候调用。组件存在很多声明周期钩子函数\n\n  * `ngOnChanges`   \n\n  * `ngOnInit`   \n\n  * `ngOnDestroy`   \n\n  * `ngDoCheck`\n  * `ngAfterContentInit`\n  * `ngAfterContentChecked`\n  * `ngAfterViewInit`\n  * `ngAfterViewChecked`\n\n[Official docs](https://angular.io/docs/ts/latest/api/lifecycle_hooks/OnChanges-interface.html)\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n\n","source":"_posts/ng2-component.md","raw":"---\ntitle: Angular2 系列教程（三）Components\ndate: 2016-02-17 06:28:00\ntags: [Angular2]\n---\n\n今天，我们要讲的是ng2的Components。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/62.jpg)\n\n这个例子是个老外写的，我将其迁移到ng2 beta版本，想了解迁移的同学可以参考我的做法。\n\n[源代码](https://github.com/lewis617/angular2-tutorial/tree/gh-pages/componnets)\n\n## 消失的控制器\n\nng2的组件就是ng1中的指令。它包含模板、样式、注入、和选择器。\n\n组件嵌套组件可以实现类似react的模块化，我曾经也用ng1做过类似的事情\n\n[Angular 结合RequireJs实现模块化开发](https://lewis617.github.io/2015/10/01/ng-requirejs-module/)\n\n我当时就想，既然有了指令（ng1）还要什么控制器（ng1）啊！果不其然ng2中移除了控制器，直接用指令也就是ng2的组件来展示界面：\n\napp/navbar.ts\n\n```ts\nimport { Component} from 'angular2/core';\nimport {NgFor} from 'angular2/common'\n\n@Component({\n    selector: \"navbar\",\n    directives: [NgFor],\n    styles: [`\n        li{\n          color: gray;\n        }\n    `],\n    template: `\n        <h2>Democratic Party presidential candidates</h2>\n        <ul>\n        <li *ngFor=\"#item of items; #i = index\">{{item}} {{i}}</li>\n        </ul>\n    `\n})\nexport class Navbar {\n    items: Array<String>\n\n    constructor() {\n      this.items = [\n        \"Hillary Clinton\",\n        \"Martin O'Malley\",\n        \"Bernie Sanders\"\n      ]\n    }\n\n    ngOnInit() {\n        console.log('[Component] navbar onInit');\n    }\n}\n```\n\n当组件被实例化后，ng2为这个组件创建了一个shadow DOM（Shadow DOM在一个web组件中提供了js,css,template的封装），然后模板和样式被注入进去。\n\n这段代码做了这些事情：\n\n  1. 设置选择器\n  2. 设置`directives`为`[ngFor]`\n  3. 设置样式\n  4. 设置模板\n  5. 填写类的成员变量`items`\n  6. 在构造函数中给`items`添加数据\n  7. 在生命周期的钩子`ngOnInit`中打印信息\n\n我们的组件就写好了。\n\n## 组件的嵌套\n\n写好组件后，我们如何将这个组件放在`app`组件中呢？答案是`directives`。这里设计得没有react好，react的组件是可以直接用的，ng2的组件则需要以指令的身份注入，因为组件实质也是指令：\n\napp/app.ts\n\n```ts\nimport {Component} from 'angular2/core';\nimport {bootstrap} from 'angular2/platform/browser';\nimport {Navbar} from './navbar';\n\n@Component({\n    selector: \"app\",\n    directives:[Navbar],\n    template: `\n      <navbar></navbar>\n    `\n})\nexport class App {\n  constructor() {\n   \n  }\n}\n\nbootstrap(App, [])\n  .catch(err => console.error(err));\n```    \n                    \nng2中组件和指令都是注入在`directives`中，`directives`包含三种类型：\n\n  1. Components\n  2. Structural directives\n  3. Attribute directives\n\n\n关于指令，我们会单独拿出来讲解。\n\n## 生命周期钩子\n\n本例中，我们使用了`ngOnInit`这个类方法去打印一个信息，这个方法会在组件初始化时候调用。组件存在很多声明周期钩子函数\n\n  * `ngOnChanges`   \n\n  * `ngOnInit`   \n\n  * `ngOnDestroy`   \n\n  * `ngDoCheck`\n  * `ngAfterContentInit`\n  * `ngAfterContentChecked`\n  * `ngAfterViewInit`\n  * `ngAfterViewChecked`\n\n[Official docs](https://angular.io/docs/ts/latest/api/lifecycle_hooks/OnChanges-interface.html)\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n\n","slug":"ng2-component","published":1,"updated":"2019-05-01T08:10:29.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvlu001jtgyt7m7oklj2","content":"<p>今天，我们要讲的是ng2的Components。</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/62.jpg\" alt=\"\"></p>\n<p>这个例子是个老外写的，我将其迁移到ng2 beta版本，想了解迁移的同学可以参考我的做法。</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/componnets\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<h2 id=\"消失的控制器\"><a href=\"#消失的控制器\" class=\"headerlink\" title=\"消失的控制器\"></a>消失的控制器</h2><p>ng2的组件就是ng1中的指令。它包含模板、样式、注入、和选择器。</p>\n<p>组件嵌套组件可以实现类似react的模块化，我曾经也用ng1做过类似的事情</p>\n<p><a href=\"https://lewis617.github.io/2015/10/01/ng-requirejs-module/\" target=\"_blank\" rel=\"noopener\">Angular 结合RequireJs实现模块化开发</a></p>\n<p>我当时就想，既然有了指令（ng1）还要什么控制器（ng1）啊！果不其然ng2中移除了控制器，直接用指令也就是ng2的组件来展示界面：</p>\n<p>app/navbar.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;NgFor&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/common'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">    selector: <span class=\"string\">\"navbar\"</span>,</span><br><span class=\"line\">    directives: [NgFor],</span><br><span class=\"line\">    styles: [<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        li&#123;</span></span><br><span class=\"line\"><span class=\"string\">          color: gray;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    `</span>],</span><br><span class=\"line\">    template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        &lt;h2&gt;Democratic Party presidential candidates&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li *ngFor=\"#item of items; #i = index\"&gt;&#123;&#123;item&#125;&#125; &#123;&#123;i&#125;&#125;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> Navbar &#123;</span><br><span class=\"line\">    items: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">String</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.items = [</span><br><span class=\"line\">        <span class=\"string\">\"Hillary Clinton\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Martin O'Malley\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Bernie Sanders\"</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ngOnInit() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'[Component] navbar onInit'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当组件被实例化后，ng2为这个组件创建了一个shadow DOM（Shadow DOM在一个web组件中提供了js,css,template的封装），然后模板和样式被注入进去。</p>\n<p>这段代码做了这些事情：</p>\n<ol>\n<li>设置选择器</li>\n<li>设置<code>directives</code>为<code>[ngFor]</code></li>\n<li>设置样式</li>\n<li>设置模板</li>\n<li>填写类的成员变量<code>items</code></li>\n<li>在构造函数中给<code>items</code>添加数据</li>\n<li>在生命周期的钩子<code>ngOnInit</code>中打印信息</li>\n</ol>\n<p>我们的组件就写好了。</p>\n<h2 id=\"组件的嵌套\"><a href=\"#组件的嵌套\" class=\"headerlink\" title=\"组件的嵌套\"></a>组件的嵌套</h2><p>写好组件后，我们如何将这个组件放在<code>app</code>组件中呢？答案是<code>directives</code>。这里设计得没有react好，react的组件是可以直接用的，ng2的组件则需要以指令的身份注入，因为组件实质也是指令：</p>\n<p>app/app.ts</p>\n<pre><code class=\"ts\"><span class=\"keyword\">import</span> {Component} <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;\n<span class=\"keyword\">import</span> {bootstrap} <span class=\"keyword\">from</span> <span class=\"string\">'angular2/platform/browser'</span>;\n<span class=\"keyword\">import</span> {Navbar} <span class=\"keyword\">from</span> <span class=\"string\">'./navbar'</span>;\n\n<span class=\"meta\">@Component</span>({\n    selector: <span class=\"string\">\"app\"</span>,\n    directives:[Navbar],\n    template: <span class=\"string\">`</span>\n<span class=\"string\">      &lt;navbar&gt;&lt;/navbar&gt;</span>\n<span class=\"string\">    `</span>\n})\n<span class=\"keyword\">export</span> <span class=\"keyword\">class</span> App {\n  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) {\n\n  }\n}\n\nbootstrap(App, [])\n  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.error(err));\n</code></pre>\n<p>ng2中组件和指令都是注入在<code>directives</code>中，<code>directives</code>包含三种类型：</p>\n<ol>\n<li>Components</li>\n<li>Structural directives</li>\n<li>Attribute directives</li>\n</ol>\n<p>关于指令，我们会单独拿出来讲解。</p>\n<h2 id=\"生命周期钩子\"><a href=\"#生命周期钩子\" class=\"headerlink\" title=\"生命周期钩子\"></a>生命周期钩子</h2><p>本例中，我们使用了<code>ngOnInit</code>这个类方法去打印一个信息，这个方法会在组件初始化时候调用。组件存在很多声明周期钩子函数</p>\n<ul>\n<li><p><code>ngOnChanges</code>   </p>\n</li>\n<li><p><code>ngOnInit</code>   </p>\n</li>\n<li><p><code>ngOnDestroy</code>   </p>\n</li>\n<li><p><code>ngDoCheck</code></p>\n</li>\n<li><code>ngAfterContentInit</code></li>\n<li><code>ngAfterContentChecked</code></li>\n<li><code>ngAfterViewInit</code></li>\n<li><code>ngAfterViewChecked</code></li>\n</ul>\n<p><a href=\"https://angular.io/docs/ts/latest/api/lifecycle_hooks/OnChanges-interface.html\" target=\"_blank\" rel=\"noopener\">Official docs</a></p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是ng2的Components。</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/62.jpg\" alt=\"\"></p>\n<p>这个例子是个老外写的，我将其迁移到ng2 beta版本，想了解迁移的同学可以参考我的做法。</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/componnets\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<h2 id=\"消失的控制器\"><a href=\"#消失的控制器\" class=\"headerlink\" title=\"消失的控制器\"></a>消失的控制器</h2><p>ng2的组件就是ng1中的指令。它包含模板、样式、注入、和选择器。</p>\n<p>组件嵌套组件可以实现类似react的模块化，我曾经也用ng1做过类似的事情</p>\n<p><a href=\"https://lewis617.github.io/2015/10/01/ng-requirejs-module/\" target=\"_blank\" rel=\"noopener\">Angular 结合RequireJs实现模块化开发</a></p>\n<p>我当时就想，既然有了指令（ng1）还要什么控制器（ng1）啊！果不其然ng2中移除了控制器，直接用指令也就是ng2的组件来展示界面：</p>\n<p>app/navbar.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;NgFor&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/common'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">    selector: <span class=\"string\">\"navbar\"</span>,</span><br><span class=\"line\">    directives: [NgFor],</span><br><span class=\"line\">    styles: [<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        li&#123;</span></span><br><span class=\"line\"><span class=\"string\">          color: gray;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    `</span>],</span><br><span class=\"line\">    template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        &lt;h2&gt;Democratic Party presidential candidates&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li *ngFor=\"#item of items; #i = index\"&gt;&#123;&#123;item&#125;&#125; &#123;&#123;i&#125;&#125;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> Navbar &#123;</span><br><span class=\"line\">    items: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">String</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.items = [</span><br><span class=\"line\">        <span class=\"string\">\"Hillary Clinton\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Martin O'Malley\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Bernie Sanders\"</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ngOnInit() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'[Component] navbar onInit'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当组件被实例化后，ng2为这个组件创建了一个shadow DOM（Shadow DOM在一个web组件中提供了js,css,template的封装），然后模板和样式被注入进去。</p>\n<p>这段代码做了这些事情：</p>\n<ol>\n<li>设置选择器</li>\n<li>设置<code>directives</code>为<code>[ngFor]</code></li>\n<li>设置样式</li>\n<li>设置模板</li>\n<li>填写类的成员变量<code>items</code></li>\n<li>在构造函数中给<code>items</code>添加数据</li>\n<li>在生命周期的钩子<code>ngOnInit</code>中打印信息</li>\n</ol>\n<p>我们的组件就写好了。</p>\n<h2 id=\"组件的嵌套\"><a href=\"#组件的嵌套\" class=\"headerlink\" title=\"组件的嵌套\"></a>组件的嵌套</h2><p>写好组件后，我们如何将这个组件放在<code>app</code>组件中呢？答案是<code>directives</code>。这里设计得没有react好，react的组件是可以直接用的，ng2的组件则需要以指令的身份注入，因为组件实质也是指令：</p>\n<p>app/app.ts</p>\n<pre><code class=\"ts\"><span class=\"keyword\">import</span> {Component} <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;\n<span class=\"keyword\">import</span> {bootstrap} <span class=\"keyword\">from</span> <span class=\"string\">'angular2/platform/browser'</span>;\n<span class=\"keyword\">import</span> {Navbar} <span class=\"keyword\">from</span> <span class=\"string\">'./navbar'</span>;\n\n<span class=\"meta\">@Component</span>({\n    selector: <span class=\"string\">\"app\"</span>,\n    directives:[Navbar],\n    template: <span class=\"string\">`</span>\n<span class=\"string\">      &lt;navbar&gt;&lt;/navbar&gt;</span>\n<span class=\"string\">    `</span>\n})\n<span class=\"keyword\">export</span> <span class=\"keyword\">class</span> App {\n  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) {\n\n  }\n}\n\nbootstrap(App, [])\n  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.error(err));\n</code></pre>\n<p>ng2中组件和指令都是注入在<code>directives</code>中，<code>directives</code>包含三种类型：</p>\n<ol>\n<li>Components</li>\n<li>Structural directives</li>\n<li>Attribute directives</li>\n</ol>\n<p>关于指令，我们会单独拿出来讲解。</p>\n<h2 id=\"生命周期钩子\"><a href=\"#生命周期钩子\" class=\"headerlink\" title=\"生命周期钩子\"></a>生命周期钩子</h2><p>本例中，我们使用了<code>ngOnInit</code>这个类方法去打印一个信息，这个方法会在组件初始化时候调用。组件存在很多声明周期钩子函数</p>\n<ul>\n<li><p><code>ngOnChanges</code>   </p>\n</li>\n<li><p><code>ngOnInit</code>   </p>\n</li>\n<li><p><code>ngOnDestroy</code>   </p>\n</li>\n<li><p><code>ngDoCheck</code></p>\n</li>\n<li><code>ngAfterContentInit</code></li>\n<li><code>ngAfterContentChecked</code></li>\n<li><code>ngAfterViewInit</code></li>\n<li><code>ngAfterViewChecked</code></li>\n</ul>\n<p><a href=\"https://angular.io/docs/ts/latest/api/lifecycle_hooks/OnChanges-interface.html\" target=\"_blank\" rel=\"noopener\">Official docs</a></p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>"},{"title":"Angular2 系列教程（四）Attribute directives","date":"2016-02-17T19:05:00.000Z","_content":"\n今天我们要讲的是ng2的Attribute directives。顾名思义，就是拓展dom属性的指令。这算是指令的第二课了，因为上节课的components实质也是指令。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/61.jpg)\n\n这个例子共两个指令，第一个是redify指令，能使元素的color属性变红。另外一个直接复制官网的highlight指令，但是我自己做了很多变化，来讲解写法的多样化。\n\n[源代码](https://github.com/lewis617/angular2-tutorial/tree/gh-pages/directives)\n\n## @Directive\n\n写指令，你需要从`'angular2/core'`中导入`Directive`，然后使用`@Directive`装饰器去装饰一个类：\n\napp/directives.ts\n\n```ts\nimport {Directive, ElementRef, Renderer} from 'angular2/core';\n\n@Directive({\n  selector: '[redify]'\n})\nexport class Redify {\n\n  constructor(private _element: ElementRef, private renderer: Renderer) {\n      renderer.setElementStyle(_element.nativeElement, 'color', 'red');\n  }\n}\n```\n\n这段代码做了这些事：\n\n  1. 在装饰器`@Directive`中定义选择器`redify`\n  2. 在类`Redify`中的构造函数里面注入`ElementRef`，来获取当前的dom元素\n  3. 同样注入`Renderer`服务来操作dom，使其`color`属性为红色\n\n服务是可以注入指令的。`Renderer`服务提供了多种操作dom样式的方法。\n\n[Official docs for ElementRef](https://angular.io/docs/ts/latest/api/core/ElementRef-class.html)\n\n[Official docs for Renderer](https://angular.io/docs/ts/latest/api/core/Renderer-class.html)\n\n## 事件监听\n\n如何实现指令的事件监听呢？答案是设置`host`：\n\nsrc/app/highlight.directive.ts\n\n```ts\nhost: {\n  '(mouseenter)': 'onMouseEnter()',\n  '(mouseleave)': 'onMouseLeave()'\n}\n```\n\n我们在`@Directive`中设置`host`元数据，`host`是个对象，你可以通过`host`配置指令的事件监听，当事件发生，将触发相应的成员函数。本例子中，设置了鼠标进入和离开两个鼠标事件。并在类中编写相应的成员函数：\n\nsrc/app/highlight.directive.ts\n\n```ts\nonMouseEnter() { this._highlight(this.highlightColor || this._defaultColor); }\nonMouseLeave() { this._highlight(null); }\n```\n\n## @Input\n\n如果需要向指令中输入什么，那么需要`@input`这个装饰器，从`'angular2/core'`中导入`Input`即可使用：\n\n```ts\n@Input('myHighlight') highlightColor: string;\n\nprivate _defaultColor = 'red';\n@Input() set defaultColor(colorName:string){\n  this._defaultColor = colorName || this._defaultColor;\n}\n```\n上述代码我们做了几件事：\n\n  1. 给成员变量`highlightColor`，装饰一个`@Input('myHighlight')`，使其等于从`myHighlight`输入的属性\n  2. 设置一个私有成员变量`_defaultColor`\n  3. `defaultColor`属性有个`setter`，可以重写`_defaultColor`变量，使`_defaultColor`等于从`defaultColor`属性输入的值或者其本身默认值\n\n 这都什么鬼？没有接触过装饰器的同学可能觉得不舒服。这是es7里面的语法糖，python里面也有，是一种函数式编程。装饰器实质是个函数，可以多个嵌套装饰。\n\n指令的`@Input`装饰器，有两种写法：\n\n一就是给成员变量加个装饰器：\n\n```ts\n@Input('myHighlight') \nhighlightColor: string;\n```\n\n代表从`myHighlight`属性输入的值会赋给成员变量`highlightColor`。\n\n二就是使用`set`，编写一个函数，重写相关的成员变量，不明白`get` 和`set` 用法的同学可以参考这个：\n\n* [getters](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/get)\n* [setters](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/set)\n\n \n \n```ts   \nprivate _defaultColor = 'red';\n@Input() set defaultColor(colorName:string){\n  this._defaultColor = colorName || this._defaultColor;\n}\n```\n\n我们来两个替换一下把：\n\n```ts   \nprivate highlightColor:string;\n@Input() set myHighlight(colorName:string){\n  this.highlightColor=colorName\n}\n\n@Input('defaultColor')\nprivate _defaultColor = 'red';\n```\n\n仍然可以运行！\n\n## 使用指令\n\n导入指令的类，然后注入组件的`directives`中`[Redify,HighlightDirective]`，就可以在模板中使用指令了，这跟组件嵌套是一样的。\n\napp/app.ts\n\n```ts\nimport {Component} from 'angular2/core';\nimport {bootstrap} from 'angular2/platform/browser';\nimport {Redify} from './directives';\nimport {HighlightDirective} from './highlight.directive';\n\n@Component({\n    selector: \"app\",\n    directives:[Redify,HighlightDirective],\n    template: `\n    redify:\n      <p redify >hello,lewis</p>\n     myHighlight:\n        <div>\n          <input type=\"radio\" name=\"colors\" (click)=\"color='lightgreen'\">Green\n          <input type=\"radio\" name=\"colors\" (click)=\"color='yellow'\">Yellow\n          <input type=\"radio\" name=\"colors\" (click)=\"color='cyan'\">Cyan\n        </div>\n      <p [myHighlight]=\"color\">Highlight me!</p>\n      <p [myHighlight]=\"color\" [defaultColor]=\"'violet'\">Highlight me too!</p>\n    `\n})\nexport class App {\n    constructor() {\n\n    }\n}\n\nbootstrap(App, [])\n    .catch(err => console.error(err));\n    \n```                    \n\n我们可以看到`<p redify >hello,lewis</p>`，`redify`指令就是元素的一个属性而已。\n\n而`highlight`则使用了`[]`\n\n```ts\n<p [myHighlight]=\"color\">Highlight me!</p>\n<p [myHighlight]=\"color\" [defaultColor]=\"'violet'\">Highlight me too!</p>\n\n```\n我们在模板语法里面讲过，[]是单向属性绑定的语法，里面可以是任何hmtl5属性，当然也可以是我们拓展的html属性，即指令。毕竟angular仍然是\"旨在拓展html能力\"。\n\n`[myHighlight]=\"color\"`将成员变量`color`绑定在`myHighlight`属性中，`[defaultColor]=\"'violet'\"`给`defaultColor`设置了`'violet'`的值。\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n\n\n\n","source":"_posts/ng2-attribute-directive.md","raw":"---\ntitle: Angular2 系列教程（四）Attribute directives\ndate: 2016-02-18 03:05:00\ntags: [Angular2]\n---\n\n今天我们要讲的是ng2的Attribute directives。顾名思义，就是拓展dom属性的指令。这算是指令的第二课了，因为上节课的components实质也是指令。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/61.jpg)\n\n这个例子共两个指令，第一个是redify指令，能使元素的color属性变红。另外一个直接复制官网的highlight指令，但是我自己做了很多变化，来讲解写法的多样化。\n\n[源代码](https://github.com/lewis617/angular2-tutorial/tree/gh-pages/directives)\n\n## @Directive\n\n写指令，你需要从`'angular2/core'`中导入`Directive`，然后使用`@Directive`装饰器去装饰一个类：\n\napp/directives.ts\n\n```ts\nimport {Directive, ElementRef, Renderer} from 'angular2/core';\n\n@Directive({\n  selector: '[redify]'\n})\nexport class Redify {\n\n  constructor(private _element: ElementRef, private renderer: Renderer) {\n      renderer.setElementStyle(_element.nativeElement, 'color', 'red');\n  }\n}\n```\n\n这段代码做了这些事：\n\n  1. 在装饰器`@Directive`中定义选择器`redify`\n  2. 在类`Redify`中的构造函数里面注入`ElementRef`，来获取当前的dom元素\n  3. 同样注入`Renderer`服务来操作dom，使其`color`属性为红色\n\n服务是可以注入指令的。`Renderer`服务提供了多种操作dom样式的方法。\n\n[Official docs for ElementRef](https://angular.io/docs/ts/latest/api/core/ElementRef-class.html)\n\n[Official docs for Renderer](https://angular.io/docs/ts/latest/api/core/Renderer-class.html)\n\n## 事件监听\n\n如何实现指令的事件监听呢？答案是设置`host`：\n\nsrc/app/highlight.directive.ts\n\n```ts\nhost: {\n  '(mouseenter)': 'onMouseEnter()',\n  '(mouseleave)': 'onMouseLeave()'\n}\n```\n\n我们在`@Directive`中设置`host`元数据，`host`是个对象，你可以通过`host`配置指令的事件监听，当事件发生，将触发相应的成员函数。本例子中，设置了鼠标进入和离开两个鼠标事件。并在类中编写相应的成员函数：\n\nsrc/app/highlight.directive.ts\n\n```ts\nonMouseEnter() { this._highlight(this.highlightColor || this._defaultColor); }\nonMouseLeave() { this._highlight(null); }\n```\n\n## @Input\n\n如果需要向指令中输入什么，那么需要`@input`这个装饰器，从`'angular2/core'`中导入`Input`即可使用：\n\n```ts\n@Input('myHighlight') highlightColor: string;\n\nprivate _defaultColor = 'red';\n@Input() set defaultColor(colorName:string){\n  this._defaultColor = colorName || this._defaultColor;\n}\n```\n上述代码我们做了几件事：\n\n  1. 给成员变量`highlightColor`，装饰一个`@Input('myHighlight')`，使其等于从`myHighlight`输入的属性\n  2. 设置一个私有成员变量`_defaultColor`\n  3. `defaultColor`属性有个`setter`，可以重写`_defaultColor`变量，使`_defaultColor`等于从`defaultColor`属性输入的值或者其本身默认值\n\n 这都什么鬼？没有接触过装饰器的同学可能觉得不舒服。这是es7里面的语法糖，python里面也有，是一种函数式编程。装饰器实质是个函数，可以多个嵌套装饰。\n\n指令的`@Input`装饰器，有两种写法：\n\n一就是给成员变量加个装饰器：\n\n```ts\n@Input('myHighlight') \nhighlightColor: string;\n```\n\n代表从`myHighlight`属性输入的值会赋给成员变量`highlightColor`。\n\n二就是使用`set`，编写一个函数，重写相关的成员变量，不明白`get` 和`set` 用法的同学可以参考这个：\n\n* [getters](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/get)\n* [setters](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/set)\n\n \n \n```ts   \nprivate _defaultColor = 'red';\n@Input() set defaultColor(colorName:string){\n  this._defaultColor = colorName || this._defaultColor;\n}\n```\n\n我们来两个替换一下把：\n\n```ts   \nprivate highlightColor:string;\n@Input() set myHighlight(colorName:string){\n  this.highlightColor=colorName\n}\n\n@Input('defaultColor')\nprivate _defaultColor = 'red';\n```\n\n仍然可以运行！\n\n## 使用指令\n\n导入指令的类，然后注入组件的`directives`中`[Redify,HighlightDirective]`，就可以在模板中使用指令了，这跟组件嵌套是一样的。\n\napp/app.ts\n\n```ts\nimport {Component} from 'angular2/core';\nimport {bootstrap} from 'angular2/platform/browser';\nimport {Redify} from './directives';\nimport {HighlightDirective} from './highlight.directive';\n\n@Component({\n    selector: \"app\",\n    directives:[Redify,HighlightDirective],\n    template: `\n    redify:\n      <p redify >hello,lewis</p>\n     myHighlight:\n        <div>\n          <input type=\"radio\" name=\"colors\" (click)=\"color='lightgreen'\">Green\n          <input type=\"radio\" name=\"colors\" (click)=\"color='yellow'\">Yellow\n          <input type=\"radio\" name=\"colors\" (click)=\"color='cyan'\">Cyan\n        </div>\n      <p [myHighlight]=\"color\">Highlight me!</p>\n      <p [myHighlight]=\"color\" [defaultColor]=\"'violet'\">Highlight me too!</p>\n    `\n})\nexport class App {\n    constructor() {\n\n    }\n}\n\nbootstrap(App, [])\n    .catch(err => console.error(err));\n    \n```                    \n\n我们可以看到`<p redify >hello,lewis</p>`，`redify`指令就是元素的一个属性而已。\n\n而`highlight`则使用了`[]`\n\n```ts\n<p [myHighlight]=\"color\">Highlight me!</p>\n<p [myHighlight]=\"color\" [defaultColor]=\"'violet'\">Highlight me too!</p>\n\n```\n我们在模板语法里面讲过，[]是单向属性绑定的语法，里面可以是任何hmtl5属性，当然也可以是我们拓展的html属性，即指令。毕竟angular仍然是\"旨在拓展html能力\"。\n\n`[myHighlight]=\"color\"`将成员变量`color`绑定在`myHighlight`属性中，`[defaultColor]=\"'violet'\"`给`defaultColor`设置了`'violet'`的值。\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n\n\n\n","slug":"ng2-attribute-directive","published":1,"updated":"2019-05-01T08:10:29.765Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvlv001ltgyti3vo5oru","content":"<p>今天我们要讲的是ng2的Attribute directives。顾名思义，就是拓展dom属性的指令。这算是指令的第二课了，因为上节课的components实质也是指令。</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/61.jpg\" alt=\"\"></p>\n<p>这个例子共两个指令，第一个是redify指令，能使元素的color属性变红。另外一个直接复制官网的highlight指令，但是我自己做了很多变化，来讲解写法的多样化。</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/directives\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<h2 id=\"Directive\"><a href=\"#Directive\" class=\"headerlink\" title=\"@Directive\"></a>@Directive</h2><p>写指令，你需要从<code>&#39;angular2/core&#39;</code>中导入<code>Directive</code>，然后使用<code>@Directive</code>装饰器去装饰一个类：</p>\n<p>app/directives.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Directive, ElementRef, Renderer&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Directive</span>(&#123;</span><br><span class=\"line\">  selector: <span class=\"string\">'[redify]'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> Redify &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> _element: ElementRef, <span class=\"keyword\">private</span> renderer: Renderer</span>) &#123;</span><br><span class=\"line\">      renderer.setElementStyle(_element.nativeElement, <span class=\"string\">'color'</span>, <span class=\"string\">'red'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码做了这些事：</p>\n<ol>\n<li>在装饰器<code>@Directive</code>中定义选择器<code>redify</code></li>\n<li>在类<code>Redify</code>中的构造函数里面注入<code>ElementRef</code>，来获取当前的dom元素</li>\n<li>同样注入<code>Renderer</code>服务来操作dom，使其<code>color</code>属性为红色</li>\n</ol>\n<p>服务是可以注入指令的。<code>Renderer</code>服务提供了多种操作dom样式的方法。</p>\n<p><a href=\"https://angular.io/docs/ts/latest/api/core/ElementRef-class.html\" target=\"_blank\" rel=\"noopener\">Official docs for ElementRef</a></p>\n<p><a href=\"https://angular.io/docs/ts/latest/api/core/Renderer-class.html\" target=\"_blank\" rel=\"noopener\">Official docs for Renderer</a></p>\n<h2 id=\"事件监听\"><a href=\"#事件监听\" class=\"headerlink\" title=\"事件监听\"></a>事件监听</h2><p>如何实现指令的事件监听呢？答案是设置<code>host</code>：</p>\n<p>src/app/highlight.directive.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">host: &#123;</span><br><span class=\"line\">  <span class=\"string\">'(mouseenter)'</span>: <span class=\"string\">'onMouseEnter()'</span>,</span><br><span class=\"line\">  <span class=\"string\">'(mouseleave)'</span>: <span class=\"string\">'onMouseLeave()'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在<code>@Directive</code>中设置<code>host</code>元数据，<code>host</code>是个对象，你可以通过<code>host</code>配置指令的事件监听，当事件发生，将触发相应的成员函数。本例子中，设置了鼠标进入和离开两个鼠标事件。并在类中编写相应的成员函数：</p>\n<p>src/app/highlight.directive.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onMouseEnter() &#123; <span class=\"keyword\">this</span>._highlight(<span class=\"keyword\">this</span>.highlightColor || <span class=\"keyword\">this</span>._defaultColor); &#125;</span><br><span class=\"line\">onMouseLeave() &#123; <span class=\"keyword\">this</span>._highlight(<span class=\"literal\">null</span>); &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"@Input\"></a>@Input</h2><p>如果需要向指令中输入什么，那么需要<code>@input</code>这个装饰器，从<code>&#39;angular2/core&#39;</code>中导入<code>Input</code>即可使用：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Input</span>(<span class=\"string\">'myHighlight'</span>) highlightColor: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> _defaultColor = <span class=\"string\">'red'</span>;</span><br><span class=\"line\"><span class=\"meta\">@Input</span>() <span class=\"keyword\">set</span> defaultColor(colorName:<span class=\"built_in\">string</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._defaultColor = colorName || <span class=\"keyword\">this</span>._defaultColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码我们做了几件事：</p>\n<ol>\n<li>给成员变量<code>highlightColor</code>，装饰一个<code>@Input(&#39;myHighlight&#39;)</code>，使其等于从<code>myHighlight</code>输入的属性</li>\n<li>设置一个私有成员变量<code>_defaultColor</code></li>\n<li><p><code>defaultColor</code>属性有个<code>setter</code>，可以重写<code>_defaultColor</code>变量，使<code>_defaultColor</code>等于从<code>defaultColor</code>属性输入的值或者其本身默认值</p>\n<p>这都什么鬼？没有接触过装饰器的同学可能觉得不舒服。这是es7里面的语法糖，python里面也有，是一种函数式编程。装饰器实质是个函数，可以多个嵌套装饰。</p>\n</li>\n</ol>\n<p>指令的<code>@Input</code>装饰器，有两种写法：</p>\n<p>一就是给成员变量加个装饰器：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Input</span>(<span class=\"string\">'myHighlight'</span>) </span><br><span class=\"line\">highlightColor: <span class=\"built_in\">string</span>;</span><br></pre></td></tr></table></figure>\n<p>代表从<code>myHighlight</code>属性输入的值会赋给成员变量<code>highlightColor</code>。</p>\n<p>二就是使用<code>set</code>，编写一个函数，重写相关的成员变量，不明白<code>get</code> 和<code>set</code> 用法的同学可以参考这个：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/get\" target=\"_blank\" rel=\"noopener\">getters</a></li>\n<li><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/set\" target=\"_blank\" rel=\"noopener\">setters</a></li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> _defaultColor = <span class=\"string\">'red'</span>;</span><br><span class=\"line\"><span class=\"meta\">@Input</span>() <span class=\"keyword\">set</span> defaultColor(colorName:<span class=\"built_in\">string</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._defaultColor = colorName || <span class=\"keyword\">this</span>._defaultColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来两个替换一下把：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> highlightColor:<span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"meta\">@Input</span>() <span class=\"keyword\">set</span> myHighlight(colorName:<span class=\"built_in\">string</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.highlightColor=colorName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Input</span>(<span class=\"string\">'defaultColor'</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> _defaultColor = <span class=\"string\">'red'</span>;</span><br></pre></td></tr></table></figure>\n<p>仍然可以运行！</p>\n<h2 id=\"使用指令\"><a href=\"#使用指令\" class=\"headerlink\" title=\"使用指令\"></a>使用指令</h2><p>导入指令的类，然后注入组件的<code>directives</code>中<code>[Redify,HighlightDirective]</code>，就可以在模板中使用指令了，这跟组件嵌套是一样的。</p>\n<p>app/app.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;bootstrap&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/platform/browser'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Redify&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./directives'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;HighlightDirective&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./highlight.directive'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">    selector: <span class=\"string\">\"app\"</span>,</span><br><span class=\"line\">    directives:[Redify,HighlightDirective],</span><br><span class=\"line\">    template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    redify:</span></span><br><span class=\"line\"><span class=\"string\">      &lt;p redify &gt;hello,lewis&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">     myHighlight:</span></span><br><span class=\"line\"><span class=\"string\">        &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;input type=\"radio\" name=\"colors\" (click)=\"color='lightgreen'\"&gt;Green</span></span><br><span class=\"line\"><span class=\"string\">          &lt;input type=\"radio\" name=\"colors\" (click)=\"color='yellow'\"&gt;Yellow</span></span><br><span class=\"line\"><span class=\"string\">          &lt;input type=\"radio\" name=\"colors\" (click)=\"color='cyan'\"&gt;Cyan</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;p [myHighlight]=\"color\"&gt;Highlight me!&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;p [myHighlight]=\"color\" [defaultColor]=\"'violet'\"&gt;Highlight me too!&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> App &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bootstrap(App, [])</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.error(err));</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`                    </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">我们可以看到`</span>&lt;p redify &gt;hello,lewis&lt;<span class=\"regexp\">/p&gt;`，`redify`指令就是元素的一个属性而已。</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">而`highlight`则使用了`[]`</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">```ts</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;p [myHighlight]=\"color\"&gt;Highlight me!&lt;/</span>p&gt;</span><br><span class=\"line\">&lt;p [myHighlight]=<span class=\"string\">\"color\"</span> [defaultColor]=<span class=\"string\">\"'violet'\"</span>&gt;Highlight me too!&lt;<span class=\"regexp\">/p&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们在模板语法里面讲过，[]是单向属性绑定的语法，里面可以是任何hmtl5属性，当然也可以是我们拓展的html属性，即指令。毕竟angular仍然是”旨在拓展html能力”。</p>\n<p><code>[myHighlight]=&quot;color&quot;</code>将成员变量<code>color</code>绑定在<code>myHighlight</code>属性中，<code>[defaultColor]=&quot;&#39;violet&#39;&quot;</code>给<code>defaultColor</code>设置了<code>&#39;violet&#39;</code>的值。</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天我们要讲的是ng2的Attribute directives。顾名思义，就是拓展dom属性的指令。这算是指令的第二课了，因为上节课的components实质也是指令。</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/61.jpg\" alt=\"\"></p>\n<p>这个例子共两个指令，第一个是redify指令，能使元素的color属性变红。另外一个直接复制官网的highlight指令，但是我自己做了很多变化，来讲解写法的多样化。</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/directives\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<h2 id=\"Directive\"><a href=\"#Directive\" class=\"headerlink\" title=\"@Directive\"></a>@Directive</h2><p>写指令，你需要从<code>&#39;angular2/core&#39;</code>中导入<code>Directive</code>，然后使用<code>@Directive</code>装饰器去装饰一个类：</p>\n<p>app/directives.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Directive, ElementRef, Renderer&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Directive</span>(&#123;</span><br><span class=\"line\">  selector: <span class=\"string\">'[redify]'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> Redify &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> _element: ElementRef, <span class=\"keyword\">private</span> renderer: Renderer</span>) &#123;</span><br><span class=\"line\">      renderer.setElementStyle(_element.nativeElement, <span class=\"string\">'color'</span>, <span class=\"string\">'red'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码做了这些事：</p>\n<ol>\n<li>在装饰器<code>@Directive</code>中定义选择器<code>redify</code></li>\n<li>在类<code>Redify</code>中的构造函数里面注入<code>ElementRef</code>，来获取当前的dom元素</li>\n<li>同样注入<code>Renderer</code>服务来操作dom，使其<code>color</code>属性为红色</li>\n</ol>\n<p>服务是可以注入指令的。<code>Renderer</code>服务提供了多种操作dom样式的方法。</p>\n<p><a href=\"https://angular.io/docs/ts/latest/api/core/ElementRef-class.html\" target=\"_blank\" rel=\"noopener\">Official docs for ElementRef</a></p>\n<p><a href=\"https://angular.io/docs/ts/latest/api/core/Renderer-class.html\" target=\"_blank\" rel=\"noopener\">Official docs for Renderer</a></p>\n<h2 id=\"事件监听\"><a href=\"#事件监听\" class=\"headerlink\" title=\"事件监听\"></a>事件监听</h2><p>如何实现指令的事件监听呢？答案是设置<code>host</code>：</p>\n<p>src/app/highlight.directive.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">host: &#123;</span><br><span class=\"line\">  <span class=\"string\">'(mouseenter)'</span>: <span class=\"string\">'onMouseEnter()'</span>,</span><br><span class=\"line\">  <span class=\"string\">'(mouseleave)'</span>: <span class=\"string\">'onMouseLeave()'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在<code>@Directive</code>中设置<code>host</code>元数据，<code>host</code>是个对象，你可以通过<code>host</code>配置指令的事件监听，当事件发生，将触发相应的成员函数。本例子中，设置了鼠标进入和离开两个鼠标事件。并在类中编写相应的成员函数：</p>\n<p>src/app/highlight.directive.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onMouseEnter() &#123; <span class=\"keyword\">this</span>._highlight(<span class=\"keyword\">this</span>.highlightColor || <span class=\"keyword\">this</span>._defaultColor); &#125;</span><br><span class=\"line\">onMouseLeave() &#123; <span class=\"keyword\">this</span>._highlight(<span class=\"literal\">null</span>); &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"@Input\"></a>@Input</h2><p>如果需要向指令中输入什么，那么需要<code>@input</code>这个装饰器，从<code>&#39;angular2/core&#39;</code>中导入<code>Input</code>即可使用：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Input</span>(<span class=\"string\">'myHighlight'</span>) highlightColor: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> _defaultColor = <span class=\"string\">'red'</span>;</span><br><span class=\"line\"><span class=\"meta\">@Input</span>() <span class=\"keyword\">set</span> defaultColor(colorName:<span class=\"built_in\">string</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._defaultColor = colorName || <span class=\"keyword\">this</span>._defaultColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码我们做了几件事：</p>\n<ol>\n<li>给成员变量<code>highlightColor</code>，装饰一个<code>@Input(&#39;myHighlight&#39;)</code>，使其等于从<code>myHighlight</code>输入的属性</li>\n<li>设置一个私有成员变量<code>_defaultColor</code></li>\n<li><p><code>defaultColor</code>属性有个<code>setter</code>，可以重写<code>_defaultColor</code>变量，使<code>_defaultColor</code>等于从<code>defaultColor</code>属性输入的值或者其本身默认值</p>\n<p>这都什么鬼？没有接触过装饰器的同学可能觉得不舒服。这是es7里面的语法糖，python里面也有，是一种函数式编程。装饰器实质是个函数，可以多个嵌套装饰。</p>\n</li>\n</ol>\n<p>指令的<code>@Input</code>装饰器，有两种写法：</p>\n<p>一就是给成员变量加个装饰器：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Input</span>(<span class=\"string\">'myHighlight'</span>) </span><br><span class=\"line\">highlightColor: <span class=\"built_in\">string</span>;</span><br></pre></td></tr></table></figure>\n<p>代表从<code>myHighlight</code>属性输入的值会赋给成员变量<code>highlightColor</code>。</p>\n<p>二就是使用<code>set</code>，编写一个函数，重写相关的成员变量，不明白<code>get</code> 和<code>set</code> 用法的同学可以参考这个：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/get\" target=\"_blank\" rel=\"noopener\">getters</a></li>\n<li><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/set\" target=\"_blank\" rel=\"noopener\">setters</a></li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> _defaultColor = <span class=\"string\">'red'</span>;</span><br><span class=\"line\"><span class=\"meta\">@Input</span>() <span class=\"keyword\">set</span> defaultColor(colorName:<span class=\"built_in\">string</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._defaultColor = colorName || <span class=\"keyword\">this</span>._defaultColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来两个替换一下把：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> highlightColor:<span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"meta\">@Input</span>() <span class=\"keyword\">set</span> myHighlight(colorName:<span class=\"built_in\">string</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.highlightColor=colorName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Input</span>(<span class=\"string\">'defaultColor'</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> _defaultColor = <span class=\"string\">'red'</span>;</span><br></pre></td></tr></table></figure>\n<p>仍然可以运行！</p>\n<h2 id=\"使用指令\"><a href=\"#使用指令\" class=\"headerlink\" title=\"使用指令\"></a>使用指令</h2><p>导入指令的类，然后注入组件的<code>directives</code>中<code>[Redify,HighlightDirective]</code>，就可以在模板中使用指令了，这跟组件嵌套是一样的。</p>\n<p>app/app.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;bootstrap&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/platform/browser'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Redify&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./directives'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;HighlightDirective&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./highlight.directive'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">    selector: <span class=\"string\">\"app\"</span>,</span><br><span class=\"line\">    directives:[Redify,HighlightDirective],</span><br><span class=\"line\">    template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    redify:</span></span><br><span class=\"line\"><span class=\"string\">      &lt;p redify &gt;hello,lewis&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">     myHighlight:</span></span><br><span class=\"line\"><span class=\"string\">        &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;input type=\"radio\" name=\"colors\" (click)=\"color='lightgreen'\"&gt;Green</span></span><br><span class=\"line\"><span class=\"string\">          &lt;input type=\"radio\" name=\"colors\" (click)=\"color='yellow'\"&gt;Yellow</span></span><br><span class=\"line\"><span class=\"string\">          &lt;input type=\"radio\" name=\"colors\" (click)=\"color='cyan'\"&gt;Cyan</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;p [myHighlight]=\"color\"&gt;Highlight me!&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;p [myHighlight]=\"color\" [defaultColor]=\"'violet'\"&gt;Highlight me too!&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> App &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bootstrap(App, [])</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.error(err));</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`                    </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">我们可以看到`</span>&lt;p redify &gt;hello,lewis&lt;<span class=\"regexp\">/p&gt;`，`redify`指令就是元素的一个属性而已。</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">而`highlight`则使用了`[]`</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">```ts</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;p [myHighlight]=\"color\"&gt;Highlight me!&lt;/</span>p&gt;</span><br><span class=\"line\">&lt;p [myHighlight]=<span class=\"string\">\"color\"</span> [defaultColor]=<span class=\"string\">\"'violet'\"</span>&gt;Highlight me too!&lt;<span class=\"regexp\">/p&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们在模板语法里面讲过，[]是单向属性绑定的语法，里面可以是任何hmtl5属性，当然也可以是我们拓展的html属性，即指令。毕竟angular仍然是”旨在拓展html能力”。</p>\n<p><code>[myHighlight]=&quot;color&quot;</code>将成员变量<code>color</code>绑定在<code>myHighlight</code>属性中，<code>[defaultColor]=&quot;&#39;violet&#39;&quot;</code>给<code>defaultColor</code>设置了<code>&#39;violet&#39;</code>的值。</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>"},{"title":"Angular2 系列教程（九）Jsonp、URLSearchParams、中断选择数据流","date":"2016-03-21T00:54:00.000Z","_content":"\n大家好，今天我们要讲的是http模块的第二部分，主要学习ng2中Jsonp、URLSearchParams、observable中断选择数据流的用法。\n\n<!--more-->\n\n# 例子\n\n![](/css/images/65.jpg)\n\n例子的第一个程序，上节课已经讲过了。这节课我们学习第二个程序，从wiki的api中跨域获取数据，可实现300毫秒内中断和选择最近请求等炫酷功能，这些功能都来自于observable！\n\n运行方法：\n\n在http目录或者上级目录起个服务即可：\n\n```sh\nhttp-server\n```\n\n没有则需要安装http-server：\n\n```sh\nsudo  npm install http-server -g\n```\n\n源代码：\n\nhttps://github.com/lewis617/angular2-tutorial/tree/gh-pages/http\n\ndemo演示：\n\nhttp://lewis617.github.io/angular2-tutorial/http\n\n# Jsonp\n\n在讲解observable的api前呢？我们还是把例子的代码给讲解完\n\napp/wiki/wikipedia.service.ts\n\n```ts\nimport {Injectable} from 'angular2/core';\nimport {Jsonp, URLSearchParams} from 'angular2/http';\n\n@Injectable()\nexport class WikipediaService {\n  constructor(private jsonp: Jsonp) {}\n\n  search (term: string) {\n\n    let wikiUrl = 'http://en.wikipedia.org/w/api.php';\n\n    var params = new URLSearchParams();\n    params.set('search', term); // the user's search value\n    params.set('action', 'opensearch');\n    params.set('format', 'json');\n    params.set('callback', 'JSONP_CALLBACK');\n\n    // TODO: Add error handling\n    return this.jsonp\n               .get(wikiUrl, { search: params })\n               .map(request => <string[]> request.json()[1]);\n  }\n}\n```\n\n以上代码我们干了几件事：\n\n  1. 导入需要的api\n  2. 写一个使用`Injectable`装饰的类（服务）\n  3. 在构造函数中注入`Jsonp`服务\n  4. 编写`search`成员函数实现获取数据的功能\n\n这个`jsonp`服务从何而来？来自\n\n```ts\nimport {JSONP_PROVIDERS} from 'angular2/http';\n```\n我们将其注入在组件中：\n\napp/wiki/wiki.component.ts和app/wiki/wiki-smart.component.ts\n\n```ts\nproviders:[JSONP_PROVIDERS, WikipediaService]\n```\n\n这样组件中的服务就可以用了！\n\n# URLSearchParams\n\n然后我们发现我们从\n\n```ts\nimport {Jsonp, URLSearchParams} from 'angular2/http';\n```\n\nhttp中引入了另一个api，`URLSearchParams`。\n\n这是什么？用来干嘛？qs大家一定非常熟悉，就是url后面那个 `？`和 `&` 。我们的程序也可以这样写：\n\n```ts\n    \nlet queryString =\n  `?search=${term}&action=opensearch&format=json&callback=JSONP_CALLBACK`\n\nreturn this.jsonp\n           .get(wikiUrl + queryString)\n           .map(request => <string[]> request.json()[1]);\n```\n\n`URLSearchParams`，可以将qs写成对象，通过调用对象的方法来获取设置其参数，然后给ng2用！像这样需要对象嵌套对象的时候，`URLSearchParams`就显得非常方便！\n\n# 简单监听数据流\n\n服务写好了，然后我们在组件中调用服务来请求数据吧！首先来个简单的，即每次输入都会发请求：\n\napp/wiki/wiki.component.ts\n\n```ts\nitems: Observable<string[]>;\n\nsearch (term: string) {\n  this.items = this._wikipediaService.search(term);\n}\n\n```\n\n我们在组件的类中定义了一个`items`，类型是Observable。然后又写了一个成员函数`search`用于调用服务获取数据。非常简单，输入的数据在`term`变量中，被源源不断的输入到服务里面，服务通过调用api，源源不断的返回数据流给observable，我们拿到observable后将其传给`items`这个observable，然后在模板中渲染出来！\n\napp/wiki/wiki.component.ts\n\n```ts\n<input #term (keyup)=\"search(term.value)\"/>\n\n<ul>\n  <li *ngFor=\"#item of items | async\">{{item}}</li>\n</ul>\n```\n\n`async`这个过滤器之前已经讲过不再赘述！\n\n# 中断数据流，选择数据流\n\n让我们来实现更炫酷的功能吧！我们希望不要每个字符输入都请求服务器，我们希望300毫秒以内的字符输入都被中断掉！使用observable就对了，promise可没有这么炫酷的功能！\n\napp/wiki/wiki-smart.component.ts\n\n```ts    \nprivate _searchTermStream = new Subject<string>();\n\n search(term:string) { this._searchTermStream.next(term); }\n\n items:Observable<string[]> = this._searchTermStream\n   .debounceTime(300)\n   .distinctUntilChanged()\n   .switchMap((term:string) => this._wikipediaService.search(term));\n```\n\n我们在上一个简单的程序基础上增加了一个成员变量`searchTermStream`，是个`Subject`类型，这是什么鬼？这是[官方文档。](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/subjects.md)\n\n简单来说，`Subject`就是用来创建流的，每次我们输入字符，都可以使用`searchTermStream`的next方法将字符源源不断的添加到`searchTermStream`中。\n\n然而这个`searchTermStream`同时也是observable，我们可以使用`debounceTime`这个api将数据流的流动频率控制在300毫秒以上，这意味着300毫秒以内输入多次也只能发出一次。\n\n<https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/debounce.md>\n\n接着我们使用了`distinctUntilChanged`这个api用于中断没有改变的情况，比如一个用户先输入\"angular\"，然后不小心输入了\"angularrrrr\"，接着他立马按回格键，变成了\"angular\"，两次都是\"angular\"，没有发生改变，就会被`distinctUntilChanged`这个api给中断掉！promise可没有中断功能！非常炫酷！\n\nhttps://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/distinctuntilchanged.md\n\n好吧，还有更加炫酷的api。我们甚至可以选择最近的一次数据流。使用`switchMap`就可以做到，新版本被更换成了[flatmaplatest](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/flatmaplatest.md)，顾名思义就是选择最后的项，这里指的是最近的请求！\n\nhttps://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/flatmaplatest.md\n\nobservable的api太多了，大家需要可以查询，不再一一讲述：\n\nhttps://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators\n\n* * *\n\n# 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n\n","source":"_posts/ng2-http-2.md","raw":"---\ntitle: Angular2 系列教程（九）Jsonp、URLSearchParams、中断选择数据流\ndate: 2016-03-21 08:54:00\ntags: [Angular2]\n---\n\n大家好，今天我们要讲的是http模块的第二部分，主要学习ng2中Jsonp、URLSearchParams、observable中断选择数据流的用法。\n\n<!--more-->\n\n# 例子\n\n![](/css/images/65.jpg)\n\n例子的第一个程序，上节课已经讲过了。这节课我们学习第二个程序，从wiki的api中跨域获取数据，可实现300毫秒内中断和选择最近请求等炫酷功能，这些功能都来自于observable！\n\n运行方法：\n\n在http目录或者上级目录起个服务即可：\n\n```sh\nhttp-server\n```\n\n没有则需要安装http-server：\n\n```sh\nsudo  npm install http-server -g\n```\n\n源代码：\n\nhttps://github.com/lewis617/angular2-tutorial/tree/gh-pages/http\n\ndemo演示：\n\nhttp://lewis617.github.io/angular2-tutorial/http\n\n# Jsonp\n\n在讲解observable的api前呢？我们还是把例子的代码给讲解完\n\napp/wiki/wikipedia.service.ts\n\n```ts\nimport {Injectable} from 'angular2/core';\nimport {Jsonp, URLSearchParams} from 'angular2/http';\n\n@Injectable()\nexport class WikipediaService {\n  constructor(private jsonp: Jsonp) {}\n\n  search (term: string) {\n\n    let wikiUrl = 'http://en.wikipedia.org/w/api.php';\n\n    var params = new URLSearchParams();\n    params.set('search', term); // the user's search value\n    params.set('action', 'opensearch');\n    params.set('format', 'json');\n    params.set('callback', 'JSONP_CALLBACK');\n\n    // TODO: Add error handling\n    return this.jsonp\n               .get(wikiUrl, { search: params })\n               .map(request => <string[]> request.json()[1]);\n  }\n}\n```\n\n以上代码我们干了几件事：\n\n  1. 导入需要的api\n  2. 写一个使用`Injectable`装饰的类（服务）\n  3. 在构造函数中注入`Jsonp`服务\n  4. 编写`search`成员函数实现获取数据的功能\n\n这个`jsonp`服务从何而来？来自\n\n```ts\nimport {JSONP_PROVIDERS} from 'angular2/http';\n```\n我们将其注入在组件中：\n\napp/wiki/wiki.component.ts和app/wiki/wiki-smart.component.ts\n\n```ts\nproviders:[JSONP_PROVIDERS, WikipediaService]\n```\n\n这样组件中的服务就可以用了！\n\n# URLSearchParams\n\n然后我们发现我们从\n\n```ts\nimport {Jsonp, URLSearchParams} from 'angular2/http';\n```\n\nhttp中引入了另一个api，`URLSearchParams`。\n\n这是什么？用来干嘛？qs大家一定非常熟悉，就是url后面那个 `？`和 `&` 。我们的程序也可以这样写：\n\n```ts\n    \nlet queryString =\n  `?search=${term}&action=opensearch&format=json&callback=JSONP_CALLBACK`\n\nreturn this.jsonp\n           .get(wikiUrl + queryString)\n           .map(request => <string[]> request.json()[1]);\n```\n\n`URLSearchParams`，可以将qs写成对象，通过调用对象的方法来获取设置其参数，然后给ng2用！像这样需要对象嵌套对象的时候，`URLSearchParams`就显得非常方便！\n\n# 简单监听数据流\n\n服务写好了，然后我们在组件中调用服务来请求数据吧！首先来个简单的，即每次输入都会发请求：\n\napp/wiki/wiki.component.ts\n\n```ts\nitems: Observable<string[]>;\n\nsearch (term: string) {\n  this.items = this._wikipediaService.search(term);\n}\n\n```\n\n我们在组件的类中定义了一个`items`，类型是Observable。然后又写了一个成员函数`search`用于调用服务获取数据。非常简单，输入的数据在`term`变量中，被源源不断的输入到服务里面，服务通过调用api，源源不断的返回数据流给observable，我们拿到observable后将其传给`items`这个observable，然后在模板中渲染出来！\n\napp/wiki/wiki.component.ts\n\n```ts\n<input #term (keyup)=\"search(term.value)\"/>\n\n<ul>\n  <li *ngFor=\"#item of items | async\">{{item}}</li>\n</ul>\n```\n\n`async`这个过滤器之前已经讲过不再赘述！\n\n# 中断数据流，选择数据流\n\n让我们来实现更炫酷的功能吧！我们希望不要每个字符输入都请求服务器，我们希望300毫秒以内的字符输入都被中断掉！使用observable就对了，promise可没有这么炫酷的功能！\n\napp/wiki/wiki-smart.component.ts\n\n```ts    \nprivate _searchTermStream = new Subject<string>();\n\n search(term:string) { this._searchTermStream.next(term); }\n\n items:Observable<string[]> = this._searchTermStream\n   .debounceTime(300)\n   .distinctUntilChanged()\n   .switchMap((term:string) => this._wikipediaService.search(term));\n```\n\n我们在上一个简单的程序基础上增加了一个成员变量`searchTermStream`，是个`Subject`类型，这是什么鬼？这是[官方文档。](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/subjects.md)\n\n简单来说，`Subject`就是用来创建流的，每次我们输入字符，都可以使用`searchTermStream`的next方法将字符源源不断的添加到`searchTermStream`中。\n\n然而这个`searchTermStream`同时也是observable，我们可以使用`debounceTime`这个api将数据流的流动频率控制在300毫秒以上，这意味着300毫秒以内输入多次也只能发出一次。\n\n<https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/debounce.md>\n\n接着我们使用了`distinctUntilChanged`这个api用于中断没有改变的情况，比如一个用户先输入\"angular\"，然后不小心输入了\"angularrrrr\"，接着他立马按回格键，变成了\"angular\"，两次都是\"angular\"，没有发生改变，就会被`distinctUntilChanged`这个api给中断掉！promise可没有中断功能！非常炫酷！\n\nhttps://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/distinctuntilchanged.md\n\n好吧，还有更加炫酷的api。我们甚至可以选择最近的一次数据流。使用`switchMap`就可以做到，新版本被更换成了[flatmaplatest](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/flatmaplatest.md)，顾名思义就是选择最后的项，这里指的是最近的请求！\n\nhttps://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/flatmaplatest.md\n\nobservable的api太多了，大家需要可以查询，不再一一讲述：\n\nhttps://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators\n\n* * *\n\n# 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n\n","slug":"ng2-http-2","published":1,"updated":"2019-05-01T08:10:29.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvlw001otgyt5zscodws","content":"<p>大家好，今天我们要讲的是http模块的第二部分，主要学习ng2中Jsonp、URLSearchParams、observable中断选择数据流的用法。</p>\n<a id=\"more\"></a>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p><img src=\"/css/images/65.jpg\" alt=\"\"></p>\n<p>例子的第一个程序，上节课已经讲过了。这节课我们学习第二个程序，从wiki的api中跨域获取数据，可实现300毫秒内中断和选择最近请求等炫酷功能，这些功能都来自于observable！</p>\n<p>运行方法：</p>\n<p>在http目录或者上级目录起个服务即可：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server</span><br></pre></td></tr></table></figure>\n<p>没有则需要安装http-server：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo  npm install http-server -g</span><br></pre></td></tr></table></figure>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/http\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial/tree/gh-pages/http</a></p>\n<p>demo演示：</p>\n<p><a href=\"http://lewis617.github.io/angular2-tutorial/http\" target=\"_blank\" rel=\"noopener\">http://lewis617.github.io/angular2-tutorial/http</a></p>\n<h1 id=\"Jsonp\"><a href=\"#Jsonp\" class=\"headerlink\" title=\"Jsonp\"></a>Jsonp</h1><p>在讲解observable的api前呢？我们还是把例子的代码给讲解完</p>\n<p>app/wiki/wikipedia.service.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Injectable&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Jsonp, URLSearchParams&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/http'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> WikipediaService &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> jsonp: Jsonp</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  search (term: <span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> wikiUrl = <span class=\"string\">'http://en.wikipedia.org/w/api.php'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> params = <span class=\"keyword\">new</span> URLSearchParams();</span><br><span class=\"line\">    params.set(<span class=\"string\">'search'</span>, term); <span class=\"comment\">// the user's search value</span></span><br><span class=\"line\">    params.set(<span class=\"string\">'action'</span>, <span class=\"string\">'opensearch'</span>);</span><br><span class=\"line\">    params.set(<span class=\"string\">'format'</span>, <span class=\"string\">'json'</span>);</span><br><span class=\"line\">    params.set(<span class=\"string\">'callback'</span>, <span class=\"string\">'JSONP_CALLBACK'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Add error handling</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.jsonp</span><br><span class=\"line\">               .get(wikiUrl, &#123; search: params &#125;)</span><br><span class=\"line\">               .map(<span class=\"function\"><span class=\"params\">request</span> =&gt;</span> &lt;<span class=\"built_in\">string</span>[]&gt; request.json()[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码我们干了几件事：</p>\n<ol>\n<li>导入需要的api</li>\n<li>写一个使用<code>Injectable</code>装饰的类（服务）</li>\n<li>在构造函数中注入<code>Jsonp</code>服务</li>\n<li>编写<code>search</code>成员函数实现获取数据的功能</li>\n</ol>\n<p>这个<code>jsonp</code>服务从何而来？来自</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;JSONP_PROVIDERS&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/http'</span>;</span><br></pre></td></tr></table></figure>\n<p>我们将其注入在组件中：</p>\n<p>app/wiki/wiki.component.ts和app/wiki/wiki-smart.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">providers:[JSONP_PROVIDERS, WikipediaService]</span><br></pre></td></tr></table></figure>\n<p>这样组件中的服务就可以用了！</p>\n<h1 id=\"URLSearchParams\"><a href=\"#URLSearchParams\" class=\"headerlink\" title=\"URLSearchParams\"></a>URLSearchParams</h1><p>然后我们发现我们从</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Jsonp, URLSearchParams&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/http'</span>;</span><br></pre></td></tr></table></figure>\n<p>http中引入了另一个api，<code>URLSearchParams</code>。</p>\n<p>这是什么？用来干嘛？qs大家一定非常熟悉，就是url后面那个 <code>？</code>和 <code>&amp;</code> 。我们的程序也可以这样写：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">let</span> queryString =</span><br><span class=\"line\">  <span class=\"string\">`?search=<span class=\"subst\">$&#123;term&#125;</span>&amp;action=opensearch&amp;format=json&amp;callback=JSONP_CALLBACK`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.jsonp</span><br><span class=\"line\">           .get(wikiUrl + queryString)</span><br><span class=\"line\">           .map(<span class=\"function\"><span class=\"params\">request</span> =&gt;</span> &lt;<span class=\"built_in\">string</span>[]&gt; request.json()[<span class=\"number\">1</span>]);</span><br></pre></td></tr></table></figure>\n<p><code>URLSearchParams</code>，可以将qs写成对象，通过调用对象的方法来获取设置其参数，然后给ng2用！像这样需要对象嵌套对象的时候，<code>URLSearchParams</code>就显得非常方便！</p>\n<h1 id=\"简单监听数据流\"><a href=\"#简单监听数据流\" class=\"headerlink\" title=\"简单监听数据流\"></a>简单监听数据流</h1><p>服务写好了，然后我们在组件中调用服务来请求数据吧！首先来个简单的，即每次输入都会发请求：</p>\n<p>app/wiki/wiki.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">items: Observable&lt;<span class=\"built_in\">string</span>[]&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">search (term: <span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.items = <span class=\"keyword\">this</span>._wikipediaService.search(term);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在组件的类中定义了一个<code>items</code>，类型是Observable。然后又写了一个成员函数<code>search</code>用于调用服务获取数据。非常简单，输入的数据在<code>term</code>变量中，被源源不断的输入到服务里面，服务通过调用api，源源不断的返回数据流给observable，我们拿到observable后将其传给<code>items</code>这个observable，然后在模板中渲染出来！</p>\n<p>app/wiki/wiki.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input #term (keyup)=<span class=\"string\">\"search(term.value)\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;li *ngFor=<span class=\"string\">\"#item of items | async\"</span>&gt;&#123;&#123;item&#125;&#125;&lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>\n<p><code>async</code>这个过滤器之前已经讲过不再赘述！</p>\n<h1 id=\"中断数据流，选择数据流\"><a href=\"#中断数据流，选择数据流\" class=\"headerlink\" title=\"中断数据流，选择数据流\"></a>中断数据流，选择数据流</h1><p>让我们来实现更炫酷的功能吧！我们希望不要每个字符输入都请求服务器，我们希望300毫秒以内的字符输入都被中断掉！使用observable就对了，promise可没有这么炫酷的功能！</p>\n<p>app/wiki/wiki-smart.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> _searchTermStream = <span class=\"keyword\">new</span> Subject&lt;<span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"> search(term:<span class=\"built_in\">string</span>) &#123; <span class=\"keyword\">this</span>._searchTermStream.next(term); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> items:Observable&lt;<span class=\"built_in\">string</span>[]&gt; = <span class=\"keyword\">this</span>._searchTermStream</span><br><span class=\"line\">   .debounceTime(<span class=\"number\">300</span>)</span><br><span class=\"line\">   .distinctUntilChanged()</span><br><span class=\"line\">   .switchMap(<span class=\"function\">(<span class=\"params\">term:<span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"keyword\">this</span>._wikipediaService.search(term));</span><br></pre></td></tr></table></figure>\n<p>我们在上一个简单的程序基础上增加了一个成员变量<code>searchTermStream</code>，是个<code>Subject</code>类型，这是什么鬼？这是<a href=\"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/subjects.md\" target=\"_blank\" rel=\"noopener\">官方文档。</a></p>\n<p>简单来说，<code>Subject</code>就是用来创建流的，每次我们输入字符，都可以使用<code>searchTermStream</code>的next方法将字符源源不断的添加到<code>searchTermStream</code>中。</p>\n<p>然而这个<code>searchTermStream</code>同时也是observable，我们可以使用<code>debounceTime</code>这个api将数据流的流动频率控制在300毫秒以上，这意味着300毫秒以内输入多次也只能发出一次。</p>\n<p><a href=\"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/debounce.md\" target=\"_blank\" rel=\"noopener\">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/debounce.md</a></p>\n<p>接着我们使用了<code>distinctUntilChanged</code>这个api用于中断没有改变的情况，比如一个用户先输入”angular”，然后不小心输入了”angularrrrr”，接着他立马按回格键，变成了”angular”，两次都是”angular”，没有发生改变，就会被<code>distinctUntilChanged</code>这个api给中断掉！promise可没有中断功能！非常炫酷！</p>\n<p><a href=\"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/distinctuntilchanged.md\" target=\"_blank\" rel=\"noopener\">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/distinctuntilchanged.md</a></p>\n<p>好吧，还有更加炫酷的api。我们甚至可以选择最近的一次数据流。使用<code>switchMap</code>就可以做到，新版本被更换成了<a href=\"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/flatmaplatest.md\" target=\"_blank\" rel=\"noopener\">flatmaplatest</a>，顾名思义就是选择最后的项，这里指的是最近的请求！</p>\n<p><a href=\"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/flatmaplatest.md\" target=\"_blank\" rel=\"noopener\">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/flatmaplatest.md</a></p>\n<p>observable的api太多了，大家需要可以查询，不再一一讲述：</p>\n<p><a href=\"https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators\" target=\"_blank\" rel=\"noopener\">https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators</a></p>\n<hr>\n<h1 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h1><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>\n","site":{"data":{}},"excerpt":"<p>大家好，今天我们要讲的是http模块的第二部分，主要学习ng2中Jsonp、URLSearchParams、observable中断选择数据流的用法。</p>","more":"<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p><img src=\"/css/images/65.jpg\" alt=\"\"></p>\n<p>例子的第一个程序，上节课已经讲过了。这节课我们学习第二个程序，从wiki的api中跨域获取数据，可实现300毫秒内中断和选择最近请求等炫酷功能，这些功能都来自于observable！</p>\n<p>运行方法：</p>\n<p>在http目录或者上级目录起个服务即可：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server</span><br></pre></td></tr></table></figure>\n<p>没有则需要安装http-server：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo  npm install http-server -g</span><br></pre></td></tr></table></figure>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/http\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial/tree/gh-pages/http</a></p>\n<p>demo演示：</p>\n<p><a href=\"http://lewis617.github.io/angular2-tutorial/http\" target=\"_blank\" rel=\"noopener\">http://lewis617.github.io/angular2-tutorial/http</a></p>\n<h1 id=\"Jsonp\"><a href=\"#Jsonp\" class=\"headerlink\" title=\"Jsonp\"></a>Jsonp</h1><p>在讲解observable的api前呢？我们还是把例子的代码给讲解完</p>\n<p>app/wiki/wikipedia.service.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Injectable&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Jsonp, URLSearchParams&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/http'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> WikipediaService &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> jsonp: Jsonp</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  search (term: <span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> wikiUrl = <span class=\"string\">'http://en.wikipedia.org/w/api.php'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> params = <span class=\"keyword\">new</span> URLSearchParams();</span><br><span class=\"line\">    params.set(<span class=\"string\">'search'</span>, term); <span class=\"comment\">// the user's search value</span></span><br><span class=\"line\">    params.set(<span class=\"string\">'action'</span>, <span class=\"string\">'opensearch'</span>);</span><br><span class=\"line\">    params.set(<span class=\"string\">'format'</span>, <span class=\"string\">'json'</span>);</span><br><span class=\"line\">    params.set(<span class=\"string\">'callback'</span>, <span class=\"string\">'JSONP_CALLBACK'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Add error handling</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.jsonp</span><br><span class=\"line\">               .get(wikiUrl, &#123; search: params &#125;)</span><br><span class=\"line\">               .map(<span class=\"function\"><span class=\"params\">request</span> =&gt;</span> &lt;<span class=\"built_in\">string</span>[]&gt; request.json()[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码我们干了几件事：</p>\n<ol>\n<li>导入需要的api</li>\n<li>写一个使用<code>Injectable</code>装饰的类（服务）</li>\n<li>在构造函数中注入<code>Jsonp</code>服务</li>\n<li>编写<code>search</code>成员函数实现获取数据的功能</li>\n</ol>\n<p>这个<code>jsonp</code>服务从何而来？来自</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;JSONP_PROVIDERS&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/http'</span>;</span><br></pre></td></tr></table></figure>\n<p>我们将其注入在组件中：</p>\n<p>app/wiki/wiki.component.ts和app/wiki/wiki-smart.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">providers:[JSONP_PROVIDERS, WikipediaService]</span><br></pre></td></tr></table></figure>\n<p>这样组件中的服务就可以用了！</p>\n<h1 id=\"URLSearchParams\"><a href=\"#URLSearchParams\" class=\"headerlink\" title=\"URLSearchParams\"></a>URLSearchParams</h1><p>然后我们发现我们从</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Jsonp, URLSearchParams&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/http'</span>;</span><br></pre></td></tr></table></figure>\n<p>http中引入了另一个api，<code>URLSearchParams</code>。</p>\n<p>这是什么？用来干嘛？qs大家一定非常熟悉，就是url后面那个 <code>？</code>和 <code>&amp;</code> 。我们的程序也可以这样写：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">let</span> queryString =</span><br><span class=\"line\">  <span class=\"string\">`?search=<span class=\"subst\">$&#123;term&#125;</span>&amp;action=opensearch&amp;format=json&amp;callback=JSONP_CALLBACK`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.jsonp</span><br><span class=\"line\">           .get(wikiUrl + queryString)</span><br><span class=\"line\">           .map(<span class=\"function\"><span class=\"params\">request</span> =&gt;</span> &lt;<span class=\"built_in\">string</span>[]&gt; request.json()[<span class=\"number\">1</span>]);</span><br></pre></td></tr></table></figure>\n<p><code>URLSearchParams</code>，可以将qs写成对象，通过调用对象的方法来获取设置其参数，然后给ng2用！像这样需要对象嵌套对象的时候，<code>URLSearchParams</code>就显得非常方便！</p>\n<h1 id=\"简单监听数据流\"><a href=\"#简单监听数据流\" class=\"headerlink\" title=\"简单监听数据流\"></a>简单监听数据流</h1><p>服务写好了，然后我们在组件中调用服务来请求数据吧！首先来个简单的，即每次输入都会发请求：</p>\n<p>app/wiki/wiki.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">items: Observable&lt;<span class=\"built_in\">string</span>[]&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">search (term: <span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.items = <span class=\"keyword\">this</span>._wikipediaService.search(term);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在组件的类中定义了一个<code>items</code>，类型是Observable。然后又写了一个成员函数<code>search</code>用于调用服务获取数据。非常简单，输入的数据在<code>term</code>变量中，被源源不断的输入到服务里面，服务通过调用api，源源不断的返回数据流给observable，我们拿到observable后将其传给<code>items</code>这个observable，然后在模板中渲染出来！</p>\n<p>app/wiki/wiki.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input #term (keyup)=<span class=\"string\">\"search(term.value)\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;li *ngFor=<span class=\"string\">\"#item of items | async\"</span>&gt;&#123;&#123;item&#125;&#125;&lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>\n<p><code>async</code>这个过滤器之前已经讲过不再赘述！</p>\n<h1 id=\"中断数据流，选择数据流\"><a href=\"#中断数据流，选择数据流\" class=\"headerlink\" title=\"中断数据流，选择数据流\"></a>中断数据流，选择数据流</h1><p>让我们来实现更炫酷的功能吧！我们希望不要每个字符输入都请求服务器，我们希望300毫秒以内的字符输入都被中断掉！使用observable就对了，promise可没有这么炫酷的功能！</p>\n<p>app/wiki/wiki-smart.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> _searchTermStream = <span class=\"keyword\">new</span> Subject&lt;<span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"> search(term:<span class=\"built_in\">string</span>) &#123; <span class=\"keyword\">this</span>._searchTermStream.next(term); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> items:Observable&lt;<span class=\"built_in\">string</span>[]&gt; = <span class=\"keyword\">this</span>._searchTermStream</span><br><span class=\"line\">   .debounceTime(<span class=\"number\">300</span>)</span><br><span class=\"line\">   .distinctUntilChanged()</span><br><span class=\"line\">   .switchMap(<span class=\"function\">(<span class=\"params\">term:<span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"keyword\">this</span>._wikipediaService.search(term));</span><br></pre></td></tr></table></figure>\n<p>我们在上一个简单的程序基础上增加了一个成员变量<code>searchTermStream</code>，是个<code>Subject</code>类型，这是什么鬼？这是<a href=\"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/subjects.md\" target=\"_blank\" rel=\"noopener\">官方文档。</a></p>\n<p>简单来说，<code>Subject</code>就是用来创建流的，每次我们输入字符，都可以使用<code>searchTermStream</code>的next方法将字符源源不断的添加到<code>searchTermStream</code>中。</p>\n<p>然而这个<code>searchTermStream</code>同时也是observable，我们可以使用<code>debounceTime</code>这个api将数据流的流动频率控制在300毫秒以上，这意味着300毫秒以内输入多次也只能发出一次。</p>\n<p><a href=\"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/debounce.md\" target=\"_blank\" rel=\"noopener\">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/debounce.md</a></p>\n<p>接着我们使用了<code>distinctUntilChanged</code>这个api用于中断没有改变的情况，比如一个用户先输入”angular”，然后不小心输入了”angularrrrr”，接着他立马按回格键，变成了”angular”，两次都是”angular”，没有发生改变，就会被<code>distinctUntilChanged</code>这个api给中断掉！promise可没有中断功能！非常炫酷！</p>\n<p><a href=\"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/distinctuntilchanged.md\" target=\"_blank\" rel=\"noopener\">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/distinctuntilchanged.md</a></p>\n<p>好吧，还有更加炫酷的api。我们甚至可以选择最近的一次数据流。使用<code>switchMap</code>就可以做到，新版本被更换成了<a href=\"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/flatmaplatest.md\" target=\"_blank\" rel=\"noopener\">flatmaplatest</a>，顾名思义就是选择最后的项，这里指的是最近的请求！</p>\n<p><a href=\"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/flatmaplatest.md\" target=\"_blank\" rel=\"noopener\">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/flatmaplatest.md</a></p>\n<p>observable的api太多了，大家需要可以查询，不再一一讲述：</p>\n<p><a href=\"https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators\" target=\"_blank\" rel=\"noopener\">https://github.com/Reactive-Extensions/RxJS/tree/master/doc/api/core/operators</a></p>\n<hr>\n<h1 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h1><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>"},{"title":"Angular2 系列教程（八）In-memory web api、HTTP服务、依赖注入、Observable","date":"2016-03-20T23:30:00.000Z","_content":"\n 大家好，今天我们要讲是ng2的http功能模块，这个功能模块的代码不在ng2里面，需要我们另外引入：\n\nindex.html\n\n```html\n<script src=\"lib/http.dev.js\"></script>\n```\n\n<!--more-->\n\n## 例子\n\n![](/css/images/64.jpg)\n\n这是官网的例子，包含两个程序：\n\n  1. 英雄列表\n  2. wiki关键词\n\n第一个程序可以实现http的get请求，获取英雄列表，也可以实现http的post请求，新增英雄。\n\n第二个程序可以实现输入关键字即时获取wiki的包含该关键字的名词列表，第一个是每输一个字符都会请求，第二个时只有停顿够300毫秒才会发出请求。两个都使用了jsonp的跨域方法。\n\n运行方法：\n\n在http目录或者上级目录起个服务即可：\n\n```sh\nhttp-server\n```\n\n没有则需要安装http-server：\n\n```sh\nsudo  npm install http-server -g\n```\n\n源代码：\n\nhttps://github.com/lewis617/angular2-tutorial/tree/gh-pages/http\n\ndemo演示：\n\nhttp://lewis617.github.io/angular2-tutorial/http\n\n## In-memory web api\n\n首先我们先来看第一个程序，英雄列表。在运行这个程序前，我们需要学习一个库，[a2-in-memory-web-api](https://github.com/wardbell/a2-in-memory-web-api)  。\n\n这个库的功能是可以帮助你在ng2里面虚拟api，不用你写api后台了，方便测试。顾名思义，这个库所虚拟的api在内存中，也就意味着你刷新浏览器后，所有的数据都会消失！好，让我们来学习如何使用！  \n\n第一步，你需要引入这个库：\n\nindex.html\n\n```html    \n<script src=\"lib/web-api.js\"></script>\n```\n\n然后，我们要使用这个库给我们封装好的服务：\n\napp/toh/toh.component.ts\n\n```ts\n// in-memory web api providers\nprovide(XHRBackend, { useClass: InMemoryBackendService }), // in-mem server\nprovide(SEED_DATA,  { useClass: HeroData }) // in-mem server data\n```\n\n`XHRBackend`和`SEED_DATA`是服务里面提供的变量，我们需要设置。`XHRBackend`使用`InMemoryBackendService`来创建provider，`SEED_DATA`使用我们自己写的`HeroData`来创建provider，作用是初始化数据。我们来看`HeroData`的代码：\n\napp/hero-data.ts\n\n```ts\nexport class HeroData {\n  createDb() {\n    let heroes = [\n      { \"id\": \"1\", \"name\": \"Windstorm\" },\n      { \"id\": \"2\", \"name\": \"Bombasto\" },\n      { \"id\": \"3\", \"name\": \"Magneta\" },\n      { \"id\": \"4\", \"name\": \"Tornado\" }\n    ];\n    return {heroes};\n  }\n}\n```\n那个`createDB`是webapi里提供的方法用于创建虚拟的数据库。\n\n那么什么是provider？~~provider就是服务，provide是ng2给我们提供的创建服务的api~~，这个可以参考官网，比较简单不再赘述：\n\n~~https://angular.io/docs/ts/latest/api/core/provide-function.html~~\n\nprovider 是依赖注入中的一个概念，它决定了服务的实例化方式。\n到此为止，我们的虚拟api就配置好了，我们可以在`app/heroes`这个url上进行get和post请求，用于获取和新增数据了。为什么是这个url？因为我们在创建数据库时候定义了这个节点：\n\napp/hero-data.ts\n\n```ts   \nreturn {heroes};\n```\n你可以将其改变为`heroes1`或者`heroes2`来测试下。\n\n## 使用HTTP服务\n\napi虚拟好了，我们开始调用api，如何调用呢？我需要使用ng2给我们提供的http服务。这个服务需要额外http库文件，它不在ng2的库文件中。因为官方考虑到大家伙可能想使用别的http库吧！\n\n我们先引入js文件：\n\nindex.html\n\n```html\n<script src=\"lib/http.dev.js\"></script>\n```\n\n 然后注入服务：\n\napp/toh/toh.component.ts\n\n```ts    \nHTTP_PROVIDERS,\n```\n\n然后就可以在这个组建下层的服务中使用HTTP了：\n\napp/toh/hero.service.ts\n\n```ts\nexport class HeroService {\n  constructor (private http: Http) {}\n}\n```\napp/toh/hero.service.ts\n\n```ts\nthis.http.get(this._heroesUrl)\n```\n\napp/toh/hero.service.ts\n\n```ts\nthis.http.post(this._heroesUrl, body, options)\n```\n## ng2的依赖注入\n\n刚才提到了http服务的注入。我们就来聊聊\"依赖注入\"。\n\nng1里面的依赖注入被保留到ng2里面了，什么是依赖注入，为什么要用依赖注入，依赖注入和规则是什么样的？\n\n~~依赖注入类似于import、require，可以将我们封装好的模块注入另一个模块，成为其依赖。~~\n\n~~这样做有什么好处？代码复用度高，模块相互独立，管理清晰。~~\n\n~~依赖注入的规则是什么？~~\n\n  ~~1. 注入组件指令：只能在当前组件用，当前组件的父子组件都不能用！~~\n  ~~2. 注入服务：可以给当前组件和其所有的子组件用！~~\n\n依赖注入是一种编程模式，该模式可以让一个类从外部源中获得它的依赖，而不必亲自创建它们。\n\n依赖注入的规则是什么？\n\n 1. NgModule 中的服务是被注册到根注入器的。这意味着任何注册到 NgModule 上的服务都可以被整个应用访问到。\n 2. 另一方面，注册到应用组件上的只在该组件及其各级子组件中可用。\n\n有一个很有趣的问题：我们是否应该将所有服务都放在顶层？什么时候我们需要将其注入子组件中呢？\n\n当每个组件需要独立的服务实例时候！\n\n服务是单例模式，也就意味着我们所编写的服务只能被实例化为一个对象，如果我们将服务注入在顶层，那么我们无法享受独立的服务。比如如果你要给\"英雄列表\"的每一项添加编辑功能，那么\"编辑\"这个服务就不能放在顶层，需要放在每个英雄列表的组件上。这样才能保证每个英雄列表拥有独立的服务（比如独立的当前名称属性等）。\n\n放在顶层的服务也很多比如，提供方法的工具库如HTTP等都可以放在顶层，我们不需要多例。还有一些用于共享数据的服务更应该放在顶层，我们需要\"单例模式\"来帮助我们统一共享数据！\n\n## **Observable**\n\n刚才我们进行了http请求，不过我们发现，我们接着使用了`map()`这个方法：\n\napp/toh/hero.service.ts\n\n```ts\nthis.http.get(this._heroesUrl)  \n         .map(res => <Hero[]> res.json().data)  \n         .do(data => console.log(data)) // eyeball results in the console\n```\n\n一般情况，我们这里都会返回一个Promise，然后我们使用`then`来处理数据。不过这里使用了`map()`，很显然，这里不是Promise而是Observable！\n\n它来自于Rx.js，可以帮助我们实现响应式编程，处理异步的另一套解决方案（promise也是一套解决方案）。\n\n这是十分复杂的概念，不过我会多罗嗦几句，所以不用担心。首先我们先来看Observable 和Promise的区别：\n\n  1. Observable 可以处理多个事件，Promise则通常处理一个事件\n  2. Observable 可以终止，Promise则不能\n\n我们继续解读代码，讲完你就会明白这两个区别。\n\n`this.http.get(this._heroesUrl)`就返回了一个Obeservable，我们可以使用`map()`方法处理事件，和数组一样，你也可以使用`filter`。所以我们说observable可以处理多个事件。\n\n这里的多个事件指的是什么呢？其实就是你输入的\"英雄名称\"，先后输入很多次，输入的名字如同流水一般进入我们程序中，我们使用observable来处理这个\"流\"。假如你前后就输入一次英雄名称并点击添加，那么这个流其实就一个事件。\n\nobservable定义完是不会执行的！直到你使用`subscribe`：\n\napp/toh/hero-list.component.ts\n\n```ts\nthis._heroService.getHeroes()\n         .subscribe(\n           heroes => this.heroes = heroes,\n           error =>  this.errorMessage = <any>error\n         );\n```\n现在我们提到了很多observable的api，让我们总结下，后面还要补充：\n\n  1. `map()`：遍历流\n  2. `filter()`：过滤流\n  3. `do()`：监视流（通常打个console而已）\n  4. `catch()`：捕获异常\n  5. `subscribe()`：订阅流（即执行）\n\n到此为止，http的第一个程序\"英雄列表\"就可以运行了。这节课我们先讲到这里，下节课我们继续讲解observable中更加炫酷的api用法！\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n\n\n\n","source":"_posts/ng2-http-1.md","raw":"---\ntitle: Angular2 系列教程（八）In-memory web api、HTTP服务、依赖注入、Observable\ndate: 2016-03-21 07:30:00\ntags: [Angular2]\n---\n\n 大家好，今天我们要讲是ng2的http功能模块，这个功能模块的代码不在ng2里面，需要我们另外引入：\n\nindex.html\n\n```html\n<script src=\"lib/http.dev.js\"></script>\n```\n\n<!--more-->\n\n## 例子\n\n![](/css/images/64.jpg)\n\n这是官网的例子，包含两个程序：\n\n  1. 英雄列表\n  2. wiki关键词\n\n第一个程序可以实现http的get请求，获取英雄列表，也可以实现http的post请求，新增英雄。\n\n第二个程序可以实现输入关键字即时获取wiki的包含该关键字的名词列表，第一个是每输一个字符都会请求，第二个时只有停顿够300毫秒才会发出请求。两个都使用了jsonp的跨域方法。\n\n运行方法：\n\n在http目录或者上级目录起个服务即可：\n\n```sh\nhttp-server\n```\n\n没有则需要安装http-server：\n\n```sh\nsudo  npm install http-server -g\n```\n\n源代码：\n\nhttps://github.com/lewis617/angular2-tutorial/tree/gh-pages/http\n\ndemo演示：\n\nhttp://lewis617.github.io/angular2-tutorial/http\n\n## In-memory web api\n\n首先我们先来看第一个程序，英雄列表。在运行这个程序前，我们需要学习一个库，[a2-in-memory-web-api](https://github.com/wardbell/a2-in-memory-web-api)  。\n\n这个库的功能是可以帮助你在ng2里面虚拟api，不用你写api后台了，方便测试。顾名思义，这个库所虚拟的api在内存中，也就意味着你刷新浏览器后，所有的数据都会消失！好，让我们来学习如何使用！  \n\n第一步，你需要引入这个库：\n\nindex.html\n\n```html    \n<script src=\"lib/web-api.js\"></script>\n```\n\n然后，我们要使用这个库给我们封装好的服务：\n\napp/toh/toh.component.ts\n\n```ts\n// in-memory web api providers\nprovide(XHRBackend, { useClass: InMemoryBackendService }), // in-mem server\nprovide(SEED_DATA,  { useClass: HeroData }) // in-mem server data\n```\n\n`XHRBackend`和`SEED_DATA`是服务里面提供的变量，我们需要设置。`XHRBackend`使用`InMemoryBackendService`来创建provider，`SEED_DATA`使用我们自己写的`HeroData`来创建provider，作用是初始化数据。我们来看`HeroData`的代码：\n\napp/hero-data.ts\n\n```ts\nexport class HeroData {\n  createDb() {\n    let heroes = [\n      { \"id\": \"1\", \"name\": \"Windstorm\" },\n      { \"id\": \"2\", \"name\": \"Bombasto\" },\n      { \"id\": \"3\", \"name\": \"Magneta\" },\n      { \"id\": \"4\", \"name\": \"Tornado\" }\n    ];\n    return {heroes};\n  }\n}\n```\n那个`createDB`是webapi里提供的方法用于创建虚拟的数据库。\n\n那么什么是provider？~~provider就是服务，provide是ng2给我们提供的创建服务的api~~，这个可以参考官网，比较简单不再赘述：\n\n~~https://angular.io/docs/ts/latest/api/core/provide-function.html~~\n\nprovider 是依赖注入中的一个概念，它决定了服务的实例化方式。\n到此为止，我们的虚拟api就配置好了，我们可以在`app/heroes`这个url上进行get和post请求，用于获取和新增数据了。为什么是这个url？因为我们在创建数据库时候定义了这个节点：\n\napp/hero-data.ts\n\n```ts   \nreturn {heroes};\n```\n你可以将其改变为`heroes1`或者`heroes2`来测试下。\n\n## 使用HTTP服务\n\napi虚拟好了，我们开始调用api，如何调用呢？我需要使用ng2给我们提供的http服务。这个服务需要额外http库文件，它不在ng2的库文件中。因为官方考虑到大家伙可能想使用别的http库吧！\n\n我们先引入js文件：\n\nindex.html\n\n```html\n<script src=\"lib/http.dev.js\"></script>\n```\n\n 然后注入服务：\n\napp/toh/toh.component.ts\n\n```ts    \nHTTP_PROVIDERS,\n```\n\n然后就可以在这个组建下层的服务中使用HTTP了：\n\napp/toh/hero.service.ts\n\n```ts\nexport class HeroService {\n  constructor (private http: Http) {}\n}\n```\napp/toh/hero.service.ts\n\n```ts\nthis.http.get(this._heroesUrl)\n```\n\napp/toh/hero.service.ts\n\n```ts\nthis.http.post(this._heroesUrl, body, options)\n```\n## ng2的依赖注入\n\n刚才提到了http服务的注入。我们就来聊聊\"依赖注入\"。\n\nng1里面的依赖注入被保留到ng2里面了，什么是依赖注入，为什么要用依赖注入，依赖注入和规则是什么样的？\n\n~~依赖注入类似于import、require，可以将我们封装好的模块注入另一个模块，成为其依赖。~~\n\n~~这样做有什么好处？代码复用度高，模块相互独立，管理清晰。~~\n\n~~依赖注入的规则是什么？~~\n\n  ~~1. 注入组件指令：只能在当前组件用，当前组件的父子组件都不能用！~~\n  ~~2. 注入服务：可以给当前组件和其所有的子组件用！~~\n\n依赖注入是一种编程模式，该模式可以让一个类从外部源中获得它的依赖，而不必亲自创建它们。\n\n依赖注入的规则是什么？\n\n 1. NgModule 中的服务是被注册到根注入器的。这意味着任何注册到 NgModule 上的服务都可以被整个应用访问到。\n 2. 另一方面，注册到应用组件上的只在该组件及其各级子组件中可用。\n\n有一个很有趣的问题：我们是否应该将所有服务都放在顶层？什么时候我们需要将其注入子组件中呢？\n\n当每个组件需要独立的服务实例时候！\n\n服务是单例模式，也就意味着我们所编写的服务只能被实例化为一个对象，如果我们将服务注入在顶层，那么我们无法享受独立的服务。比如如果你要给\"英雄列表\"的每一项添加编辑功能，那么\"编辑\"这个服务就不能放在顶层，需要放在每个英雄列表的组件上。这样才能保证每个英雄列表拥有独立的服务（比如独立的当前名称属性等）。\n\n放在顶层的服务也很多比如，提供方法的工具库如HTTP等都可以放在顶层，我们不需要多例。还有一些用于共享数据的服务更应该放在顶层，我们需要\"单例模式\"来帮助我们统一共享数据！\n\n## **Observable**\n\n刚才我们进行了http请求，不过我们发现，我们接着使用了`map()`这个方法：\n\napp/toh/hero.service.ts\n\n```ts\nthis.http.get(this._heroesUrl)  \n         .map(res => <Hero[]> res.json().data)  \n         .do(data => console.log(data)) // eyeball results in the console\n```\n\n一般情况，我们这里都会返回一个Promise，然后我们使用`then`来处理数据。不过这里使用了`map()`，很显然，这里不是Promise而是Observable！\n\n它来自于Rx.js，可以帮助我们实现响应式编程，处理异步的另一套解决方案（promise也是一套解决方案）。\n\n这是十分复杂的概念，不过我会多罗嗦几句，所以不用担心。首先我们先来看Observable 和Promise的区别：\n\n  1. Observable 可以处理多个事件，Promise则通常处理一个事件\n  2. Observable 可以终止，Promise则不能\n\n我们继续解读代码，讲完你就会明白这两个区别。\n\n`this.http.get(this._heroesUrl)`就返回了一个Obeservable，我们可以使用`map()`方法处理事件，和数组一样，你也可以使用`filter`。所以我们说observable可以处理多个事件。\n\n这里的多个事件指的是什么呢？其实就是你输入的\"英雄名称\"，先后输入很多次，输入的名字如同流水一般进入我们程序中，我们使用observable来处理这个\"流\"。假如你前后就输入一次英雄名称并点击添加，那么这个流其实就一个事件。\n\nobservable定义完是不会执行的！直到你使用`subscribe`：\n\napp/toh/hero-list.component.ts\n\n```ts\nthis._heroService.getHeroes()\n         .subscribe(\n           heroes => this.heroes = heroes,\n           error =>  this.errorMessage = <any>error\n         );\n```\n现在我们提到了很多observable的api，让我们总结下，后面还要补充：\n\n  1. `map()`：遍历流\n  2. `filter()`：过滤流\n  3. `do()`：监视流（通常打个console而已）\n  4. `catch()`：捕获异常\n  5. `subscribe()`：订阅流（即执行）\n\n到此为止，http的第一个程序\"英雄列表\"就可以运行了。这节课我们先讲到这里，下节课我们继续讲解observable中更加炫酷的api用法！\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n\n\n\n","slug":"ng2-http-1","published":1,"updated":"2019-05-01T08:10:29.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvlx001qtgytrnw083fg","content":"<p> 大家好，今天我们要讲是ng2的http功能模块，这个功能模块的代码不在ng2里面，需要我们另外引入：</p>\n<p>index.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"lib/http.dev.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/64.jpg\" alt=\"\"></p>\n<p>这是官网的例子，包含两个程序：</p>\n<ol>\n<li>英雄列表</li>\n<li>wiki关键词</li>\n</ol>\n<p>第一个程序可以实现http的get请求，获取英雄列表，也可以实现http的post请求，新增英雄。</p>\n<p>第二个程序可以实现输入关键字即时获取wiki的包含该关键字的名词列表，第一个是每输一个字符都会请求，第二个时只有停顿够300毫秒才会发出请求。两个都使用了jsonp的跨域方法。</p>\n<p>运行方法：</p>\n<p>在http目录或者上级目录起个服务即可：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server</span><br></pre></td></tr></table></figure>\n<p>没有则需要安装http-server：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo  npm install http-server -g</span><br></pre></td></tr></table></figure>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/http\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial/tree/gh-pages/http</a></p>\n<p>demo演示：</p>\n<p><a href=\"http://lewis617.github.io/angular2-tutorial/http\" target=\"_blank\" rel=\"noopener\">http://lewis617.github.io/angular2-tutorial/http</a></p>\n<h2 id=\"In-memory-web-api\"><a href=\"#In-memory-web-api\" class=\"headerlink\" title=\"In-memory web api\"></a>In-memory web api</h2><p>首先我们先来看第一个程序，英雄列表。在运行这个程序前，我们需要学习一个库，<a href=\"https://github.com/wardbell/a2-in-memory-web-api\" target=\"_blank\" rel=\"noopener\">a2-in-memory-web-api</a>  。</p>\n<p>这个库的功能是可以帮助你在ng2里面虚拟api，不用你写api后台了，方便测试。顾名思义，这个库所虚拟的api在内存中，也就意味着你刷新浏览器后，所有的数据都会消失！好，让我们来学习如何使用！  </p>\n<p>第一步，你需要引入这个库：</p>\n<p>index.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"lib/web-api.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后，我们要使用这个库给我们封装好的服务：</p>\n<p>app/toh/toh.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in-memory web api providers</span></span><br><span class=\"line\">provide(XHRBackend, &#123; useClass: InMemoryBackendService &#125;), <span class=\"comment\">// in-mem server</span></span><br><span class=\"line\">provide(SEED_DATA,  &#123; useClass: HeroData &#125;) <span class=\"comment\">// in-mem server data</span></span><br></pre></td></tr></table></figure>\n<p><code>XHRBackend</code>和<code>SEED_DATA</code>是服务里面提供的变量，我们需要设置。<code>XHRBackend</code>使用<code>InMemoryBackendService</code>来创建provider，<code>SEED_DATA</code>使用我们自己写的<code>HeroData</code>来创建provider，作用是初始化数据。我们来看<code>HeroData</code>的代码：</p>\n<p>app/hero-data.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroData &#123;</span><br><span class=\"line\">  createDb() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> heroes = [</span><br><span class=\"line\">      &#123; <span class=\"string\">\"id\"</span>: <span class=\"string\">\"1\"</span>, <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Windstorm\"</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"string\">\"id\"</span>: <span class=\"string\">\"2\"</span>, <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Bombasto\"</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"string\">\"id\"</span>: <span class=\"string\">\"3\"</span>, <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Magneta\"</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"string\">\"id\"</span>: <span class=\"string\">\"4\"</span>, <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Tornado\"</span> &#125;</span><br><span class=\"line\">    ];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;heroes&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那个<code>createDB</code>是webapi里提供的方法用于创建虚拟的数据库。</p>\n<p>那么什么是provider？<del>provider就是服务，provide是ng2给我们提供的创建服务的api</del>，这个可以参考官网，比较简单不再赘述：</p>\n<p><del><a href=\"https://angular.io/docs/ts/latest/api/core/provide-function.html\" target=\"_blank\" rel=\"noopener\">https://angular.io/docs/ts/latest/api/core/provide-function.html</a></del></p>\n<p>provider 是依赖注入中的一个概念，它决定了服务的实例化方式。<br>到此为止，我们的虚拟api就配置好了，我们可以在<code>app/heroes</code>这个url上进行get和post请求，用于获取和新增数据了。为什么是这个url？因为我们在创建数据库时候定义了这个节点：</p>\n<p>app/hero-data.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> &#123;heroes&#125;;</span><br></pre></td></tr></table></figure>\n<p>你可以将其改变为<code>heroes1</code>或者<code>heroes2</code>来测试下。</p>\n<h2 id=\"使用HTTP服务\"><a href=\"#使用HTTP服务\" class=\"headerlink\" title=\"使用HTTP服务\"></a>使用HTTP服务</h2><p>api虚拟好了，我们开始调用api，如何调用呢？我需要使用ng2给我们提供的http服务。这个服务需要额外http库文件，它不在ng2的库文件中。因为官方考虑到大家伙可能想使用别的http库吧！</p>\n<p>我们先引入js文件：</p>\n<p>index.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"lib/http.dev.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p> 然后注入服务：</p>\n<p>app/toh/toh.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP_PROVIDERS,</span><br></pre></td></tr></table></figure>\n<p>然后就可以在这个组建下层的服务中使用HTTP了：</p>\n<p>app/toh/hero.service.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroService &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\"><span class=\"keyword\">private</span> http: Http</span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>app/toh/hero.service.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.http.get(<span class=\"keyword\">this</span>._heroesUrl)</span><br></pre></td></tr></table></figure>\n<p>app/toh/hero.service.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.http.post(<span class=\"keyword\">this</span>._heroesUrl, body, options)</span><br></pre></td></tr></table></figure>\n<h2 id=\"ng2的依赖注入\"><a href=\"#ng2的依赖注入\" class=\"headerlink\" title=\"ng2的依赖注入\"></a>ng2的依赖注入</h2><p>刚才提到了http服务的注入。我们就来聊聊”依赖注入”。</p>\n<p>ng1里面的依赖注入被保留到ng2里面了，什么是依赖注入，为什么要用依赖注入，依赖注入和规则是什么样的？</p>\n<p><del>依赖注入类似于import、require，可以将我们封装好的模块注入另一个模块，成为其依赖。</del></p>\n<p><del>这样做有什么好处？代码复用度高，模块相互独立，管理清晰。</del></p>\n<p><del>依赖注入的规则是什么？</del></p>\n<p>  <del>1. 注入组件指令：只能在当前组件用，当前组件的父子组件都不能用！</del><br>  <del>2. 注入服务：可以给当前组件和其所有的子组件用！</del></p>\n<p>依赖注入是一种编程模式，该模式可以让一个类从外部源中获得它的依赖，而不必亲自创建它们。</p>\n<p>依赖注入的规则是什么？</p>\n<ol>\n<li>NgModule 中的服务是被注册到根注入器的。这意味着任何注册到 NgModule 上的服务都可以被整个应用访问到。</li>\n<li>另一方面，注册到应用组件上的只在该组件及其各级子组件中可用。</li>\n</ol>\n<p>有一个很有趣的问题：我们是否应该将所有服务都放在顶层？什么时候我们需要将其注入子组件中呢？</p>\n<p>当每个组件需要独立的服务实例时候！</p>\n<p>服务是单例模式，也就意味着我们所编写的服务只能被实例化为一个对象，如果我们将服务注入在顶层，那么我们无法享受独立的服务。比如如果你要给”英雄列表”的每一项添加编辑功能，那么”编辑”这个服务就不能放在顶层，需要放在每个英雄列表的组件上。这样才能保证每个英雄列表拥有独立的服务（比如独立的当前名称属性等）。</p>\n<p>放在顶层的服务也很多比如，提供方法的工具库如HTTP等都可以放在顶层，我们不需要多例。还有一些用于共享数据的服务更应该放在顶层，我们需要”单例模式”来帮助我们统一共享数据！</p>\n<h2 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a><strong>Observable</strong></h2><p>刚才我们进行了http请求，不过我们发现，我们接着使用了<code>map()</code>这个方法：</p>\n<p>app/toh/hero.service.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.http.get(<span class=\"keyword\">this</span>._heroesUrl)  </span><br><span class=\"line\">         .map(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &lt;Hero[]&gt; res.json().data)  </span><br><span class=\"line\">         .do(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> <span class=\"built_in\">console</span>.log(data)) <span class=\"comment\">// eyeball results in the console</span></span><br></pre></td></tr></table></figure>\n<p>一般情况，我们这里都会返回一个Promise，然后我们使用<code>then</code>来处理数据。不过这里使用了<code>map()</code>，很显然，这里不是Promise而是Observable！</p>\n<p>它来自于Rx.js，可以帮助我们实现响应式编程，处理异步的另一套解决方案（promise也是一套解决方案）。</p>\n<p>这是十分复杂的概念，不过我会多罗嗦几句，所以不用担心。首先我们先来看Observable 和Promise的区别：</p>\n<ol>\n<li>Observable 可以处理多个事件，Promise则通常处理一个事件</li>\n<li>Observable 可以终止，Promise则不能</li>\n</ol>\n<p>我们继续解读代码，讲完你就会明白这两个区别。</p>\n<p><code>this.http.get(this._heroesUrl)</code>就返回了一个Obeservable，我们可以使用<code>map()</code>方法处理事件，和数组一样，你也可以使用<code>filter</code>。所以我们说observable可以处理多个事件。</p>\n<p>这里的多个事件指的是什么呢？其实就是你输入的”英雄名称”，先后输入很多次，输入的名字如同流水一般进入我们程序中，我们使用observable来处理这个”流”。假如你前后就输入一次英雄名称并点击添加，那么这个流其实就一个事件。</p>\n<p>observable定义完是不会执行的！直到你使用<code>subscribe</code>：</p>\n<p>app/toh/hero-list.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._heroService.getHeroes()</span><br><span class=\"line\">         .subscribe(</span><br><span class=\"line\">           heroes =&gt; <span class=\"keyword\">this</span>.heroes = heroes,</span><br><span class=\"line\">           error =&gt;  <span class=\"keyword\">this</span>.errorMessage = &lt;<span class=\"built_in\">any</span>&gt;error</span><br><span class=\"line\">         );</span><br></pre></td></tr></table></figure>\n<p>现在我们提到了很多observable的api，让我们总结下，后面还要补充：</p>\n<ol>\n<li><code>map()</code>：遍历流</li>\n<li><code>filter()</code>：过滤流</li>\n<li><code>do()</code>：监视流（通常打个console而已）</li>\n<li><code>catch()</code>：捕获异常</li>\n<li><code>subscribe()</code>：订阅流（即执行）</li>\n</ol>\n<p>到此为止，http的第一个程序”英雄列表”就可以运行了。这节课我们先讲到这里，下节课我们继续讲解observable中更加炫酷的api用法！</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>\n","site":{"data":{}},"excerpt":"<p> 大家好，今天我们要讲是ng2的http功能模块，这个功能模块的代码不在ng2里面，需要我们另外引入：</p>\n<p>index.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"lib/http.dev.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/64.jpg\" alt=\"\"></p>\n<p>这是官网的例子，包含两个程序：</p>\n<ol>\n<li>英雄列表</li>\n<li>wiki关键词</li>\n</ol>\n<p>第一个程序可以实现http的get请求，获取英雄列表，也可以实现http的post请求，新增英雄。</p>\n<p>第二个程序可以实现输入关键字即时获取wiki的包含该关键字的名词列表，第一个是每输一个字符都会请求，第二个时只有停顿够300毫秒才会发出请求。两个都使用了jsonp的跨域方法。</p>\n<p>运行方法：</p>\n<p>在http目录或者上级目录起个服务即可：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server</span><br></pre></td></tr></table></figure>\n<p>没有则需要安装http-server：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo  npm install http-server -g</span><br></pre></td></tr></table></figure>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/http\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial/tree/gh-pages/http</a></p>\n<p>demo演示：</p>\n<p><a href=\"http://lewis617.github.io/angular2-tutorial/http\" target=\"_blank\" rel=\"noopener\">http://lewis617.github.io/angular2-tutorial/http</a></p>\n<h2 id=\"In-memory-web-api\"><a href=\"#In-memory-web-api\" class=\"headerlink\" title=\"In-memory web api\"></a>In-memory web api</h2><p>首先我们先来看第一个程序，英雄列表。在运行这个程序前，我们需要学习一个库，<a href=\"https://github.com/wardbell/a2-in-memory-web-api\" target=\"_blank\" rel=\"noopener\">a2-in-memory-web-api</a>  。</p>\n<p>这个库的功能是可以帮助你在ng2里面虚拟api，不用你写api后台了，方便测试。顾名思义，这个库所虚拟的api在内存中，也就意味着你刷新浏览器后，所有的数据都会消失！好，让我们来学习如何使用！  </p>\n<p>第一步，你需要引入这个库：</p>\n<p>index.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"lib/web-api.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后，我们要使用这个库给我们封装好的服务：</p>\n<p>app/toh/toh.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in-memory web api providers</span></span><br><span class=\"line\">provide(XHRBackend, &#123; useClass: InMemoryBackendService &#125;), <span class=\"comment\">// in-mem server</span></span><br><span class=\"line\">provide(SEED_DATA,  &#123; useClass: HeroData &#125;) <span class=\"comment\">// in-mem server data</span></span><br></pre></td></tr></table></figure>\n<p><code>XHRBackend</code>和<code>SEED_DATA</code>是服务里面提供的变量，我们需要设置。<code>XHRBackend</code>使用<code>InMemoryBackendService</code>来创建provider，<code>SEED_DATA</code>使用我们自己写的<code>HeroData</code>来创建provider，作用是初始化数据。我们来看<code>HeroData</code>的代码：</p>\n<p>app/hero-data.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroData &#123;</span><br><span class=\"line\">  createDb() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> heroes = [</span><br><span class=\"line\">      &#123; <span class=\"string\">\"id\"</span>: <span class=\"string\">\"1\"</span>, <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Windstorm\"</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"string\">\"id\"</span>: <span class=\"string\">\"2\"</span>, <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Bombasto\"</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"string\">\"id\"</span>: <span class=\"string\">\"3\"</span>, <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Magneta\"</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"string\">\"id\"</span>: <span class=\"string\">\"4\"</span>, <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Tornado\"</span> &#125;</span><br><span class=\"line\">    ];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;heroes&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那个<code>createDB</code>是webapi里提供的方法用于创建虚拟的数据库。</p>\n<p>那么什么是provider？<del>provider就是服务，provide是ng2给我们提供的创建服务的api</del>，这个可以参考官网，比较简单不再赘述：</p>\n<p><del><a href=\"https://angular.io/docs/ts/latest/api/core/provide-function.html\" target=\"_blank\" rel=\"noopener\">https://angular.io/docs/ts/latest/api/core/provide-function.html</a></del></p>\n<p>provider 是依赖注入中的一个概念，它决定了服务的实例化方式。<br>到此为止，我们的虚拟api就配置好了，我们可以在<code>app/heroes</code>这个url上进行get和post请求，用于获取和新增数据了。为什么是这个url？因为我们在创建数据库时候定义了这个节点：</p>\n<p>app/hero-data.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> &#123;heroes&#125;;</span><br></pre></td></tr></table></figure>\n<p>你可以将其改变为<code>heroes1</code>或者<code>heroes2</code>来测试下。</p>\n<h2 id=\"使用HTTP服务\"><a href=\"#使用HTTP服务\" class=\"headerlink\" title=\"使用HTTP服务\"></a>使用HTTP服务</h2><p>api虚拟好了，我们开始调用api，如何调用呢？我需要使用ng2给我们提供的http服务。这个服务需要额外http库文件，它不在ng2的库文件中。因为官方考虑到大家伙可能想使用别的http库吧！</p>\n<p>我们先引入js文件：</p>\n<p>index.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"lib/http.dev.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p> 然后注入服务：</p>\n<p>app/toh/toh.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP_PROVIDERS,</span><br></pre></td></tr></table></figure>\n<p>然后就可以在这个组建下层的服务中使用HTTP了：</p>\n<p>app/toh/hero.service.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroService &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\"><span class=\"keyword\">private</span> http: Http</span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>app/toh/hero.service.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.http.get(<span class=\"keyword\">this</span>._heroesUrl)</span><br></pre></td></tr></table></figure>\n<p>app/toh/hero.service.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.http.post(<span class=\"keyword\">this</span>._heroesUrl, body, options)</span><br></pre></td></tr></table></figure>\n<h2 id=\"ng2的依赖注入\"><a href=\"#ng2的依赖注入\" class=\"headerlink\" title=\"ng2的依赖注入\"></a>ng2的依赖注入</h2><p>刚才提到了http服务的注入。我们就来聊聊”依赖注入”。</p>\n<p>ng1里面的依赖注入被保留到ng2里面了，什么是依赖注入，为什么要用依赖注入，依赖注入和规则是什么样的？</p>\n<p><del>依赖注入类似于import、require，可以将我们封装好的模块注入另一个模块，成为其依赖。</del></p>\n<p><del>这样做有什么好处？代码复用度高，模块相互独立，管理清晰。</del></p>\n<p><del>依赖注入的规则是什么？</del></p>\n<p>  <del>1. 注入组件指令：只能在当前组件用，当前组件的父子组件都不能用！</del><br>  <del>2. 注入服务：可以给当前组件和其所有的子组件用！</del></p>\n<p>依赖注入是一种编程模式，该模式可以让一个类从外部源中获得它的依赖，而不必亲自创建它们。</p>\n<p>依赖注入的规则是什么？</p>\n<ol>\n<li>NgModule 中的服务是被注册到根注入器的。这意味着任何注册到 NgModule 上的服务都可以被整个应用访问到。</li>\n<li>另一方面，注册到应用组件上的只在该组件及其各级子组件中可用。</li>\n</ol>\n<p>有一个很有趣的问题：我们是否应该将所有服务都放在顶层？什么时候我们需要将其注入子组件中呢？</p>\n<p>当每个组件需要独立的服务实例时候！</p>\n<p>服务是单例模式，也就意味着我们所编写的服务只能被实例化为一个对象，如果我们将服务注入在顶层，那么我们无法享受独立的服务。比如如果你要给”英雄列表”的每一项添加编辑功能，那么”编辑”这个服务就不能放在顶层，需要放在每个英雄列表的组件上。这样才能保证每个英雄列表拥有独立的服务（比如独立的当前名称属性等）。</p>\n<p>放在顶层的服务也很多比如，提供方法的工具库如HTTP等都可以放在顶层，我们不需要多例。还有一些用于共享数据的服务更应该放在顶层，我们需要”单例模式”来帮助我们统一共享数据！</p>\n<h2 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a><strong>Observable</strong></h2><p>刚才我们进行了http请求，不过我们发现，我们接着使用了<code>map()</code>这个方法：</p>\n<p>app/toh/hero.service.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.http.get(<span class=\"keyword\">this</span>._heroesUrl)  </span><br><span class=\"line\">         .map(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &lt;Hero[]&gt; res.json().data)  </span><br><span class=\"line\">         .do(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> <span class=\"built_in\">console</span>.log(data)) <span class=\"comment\">// eyeball results in the console</span></span><br></pre></td></tr></table></figure>\n<p>一般情况，我们这里都会返回一个Promise，然后我们使用<code>then</code>来处理数据。不过这里使用了<code>map()</code>，很显然，这里不是Promise而是Observable！</p>\n<p>它来自于Rx.js，可以帮助我们实现响应式编程，处理异步的另一套解决方案（promise也是一套解决方案）。</p>\n<p>这是十分复杂的概念，不过我会多罗嗦几句，所以不用担心。首先我们先来看Observable 和Promise的区别：</p>\n<ol>\n<li>Observable 可以处理多个事件，Promise则通常处理一个事件</li>\n<li>Observable 可以终止，Promise则不能</li>\n</ol>\n<p>我们继续解读代码，讲完你就会明白这两个区别。</p>\n<p><code>this.http.get(this._heroesUrl)</code>就返回了一个Obeservable，我们可以使用<code>map()</code>方法处理事件，和数组一样，你也可以使用<code>filter</code>。所以我们说observable可以处理多个事件。</p>\n<p>这里的多个事件指的是什么呢？其实就是你输入的”英雄名称”，先后输入很多次，输入的名字如同流水一般进入我们程序中，我们使用observable来处理这个”流”。假如你前后就输入一次英雄名称并点击添加，那么这个流其实就一个事件。</p>\n<p>observable定义完是不会执行的！直到你使用<code>subscribe</code>：</p>\n<p>app/toh/hero-list.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._heroService.getHeroes()</span><br><span class=\"line\">         .subscribe(</span><br><span class=\"line\">           heroes =&gt; <span class=\"keyword\">this</span>.heroes = heroes,</span><br><span class=\"line\">           error =&gt;  <span class=\"keyword\">this</span>.errorMessage = &lt;<span class=\"built_in\">any</span>&gt;error</span><br><span class=\"line\">         );</span><br></pre></td></tr></table></figure>\n<p>现在我们提到了很多observable的api，让我们总结下，后面还要补充：</p>\n<ol>\n<li><code>map()</code>：遍历流</li>\n<li><code>filter()</code>：过滤流</li>\n<li><code>do()</code>：监视流（通常打个console而已）</li>\n<li><code>catch()</code>：捕获异常</li>\n<li><code>subscribe()</code>：订阅流（即执行）</li>\n</ol>\n<p>到此为止，http的第一个程序”英雄列表”就可以运行了。这节课我们先讲到这里，下节课我们继续讲解observable中更加炫酷的api用法！</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>"},{"title":"Angular2 系列教程（六）两种pipe：函数式编程与面向对象编程","date":"2016-02-24T19:28:00.000Z","_content":"\n今天，我们要讲的是ng2的pipe这个知识点。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/66.jpg)\n\n这个例子包含两个pipe，~~一个是stateful，一个是stateless~~，是直接复制官方的例子。（最新的官网文档已经将其改为了pure和impure，并移除了面向对象的比喻，个人认为较为准确，请以最新的官网文档为参考！）\n\n[源代码](https://github.com/lewis617/angular2-tutorial/tree/gh-pages/pipes)\n\n## stateless pipe\n\npipe就是ng1中的filter。先看看内建pipe吧：\n\n  * `currency`\n  * `date`\n  * `uppercase`\n  * `json`\n  * `limitTo`\n  * `lowercase`\n  * `async`\n  * `decimal`\n  * `percent`\n\n无需编写直接用！今天说了太多\"直接用\"哈哈！\n\npipe分为两种，一种是stateful，一种是stateless。我们先说stateless，stateless就是使用纯函数，不记住任何数据，也不会带来任何副作用。`DatePipe`就是stateless，我们再写个计算次方的pipe吧:\n\napp/stateless/exponential-strength.pipe.ts\n\n```ts\nimport {Pipe, PipeTransform} from 'angular2/core';\n/*\n * Raise the value exponentially\n * Takes an exponent argument that defaults to 1.\n * Usage:\n *   value | exponentialStrength:exponent\n * Example:\n *   {{ 2 |  exponentialStrength:10}}\n *   formats to: 1024\n*/\n@Pipe({name: 'exponentialStrength'})\nexport class ExponentialStrengthPipe implements PipeTransform {\n  transform(value: number, args: string[]) : any {\n    return Math.pow(value, parseInt(args[0] || '1', 10));\n  }\n}\n```\n很简单，计算某个值的某次方，比如2的10次方：\n\n```ts\n{{ 2 | exponentialStrength:10}}\n```\n\n写个模板测试下：\n\napp/stateless/power-booster.component.ts\n\n```ts\nimport {Component} from 'angular2/core';\nimport {ExponentialStrengthPipe} from './exponential-strength.pipe';\n@Component({\n  selector: 'power-booster',\n  template: `\n    <h2>Power Booster</h2>\n    <p>\n      Super power boost: {{2 | exponentialStrength: 10}}\n    </p>\n  `,\n  pipes: [ExponentialStrengthPipe]\n})\nexport class PowerBooster { }\n```\n\n注入`pipes: [ExponentialStrengthPipe]`，然后直接用！\n\n## stateful pipe\n\n先看一个stateful pipe的例子吧：\n\napp/stateful/fetch-json.pipe.ts\n\n```ts\ndeclare var fetch;\nimport {Pipe, PipeTransform} from 'angular2/core';\n@Pipe({\n  name: 'fetch',\n  pure: false\n})\nexport class FetchJsonPipe  implements PipeTransform {\n  private fetchedValue: any;\n  private fetchPromise: Promise<any>;\n  transform(value: string, args: string[]): any {\n    if (!this.fetchPromise) {\n      this.fetchPromise = fetch(value)\n        .then((result: any) => result.json())\n        .then((json: any)   => this.fetchedValue = json);\n    }\n    return this.fetchedValue;\n  }\n}\n```\n我们干了这些事：\n\n  1. 将`pure`参数设为`false`\n  2. 在成员函数`transform`中，执行`fetch`请求，将结果赋给`this.fetchedValue = json`，最后返回结果\n  3. 如果`this.fetchPromise`这个成员变量已经被定义过，则直接返回成员变量`fetchedValue`\n\n写个模板测试下：\n\napp/stateful/hero-list.component.ts\n\n```ts\nimport {Component} from 'angular2/core';\nimport {FetchJsonPipe} from './fetch-json.pipe';\n@Component({\n  selector: 'hero-list',\n  template: `\n    <h4>Heroes from JSON File</h4>\n    <div *ngFor=\"#hero of ('/assets/heroes.json' | fetch) \">\n      {{hero.name}}\n    </div>\n    <p>Heroes as JSON:\n    {{'/assets/heroes.json' | fetch | json}}\n    </p>\n  `,\n  pipes: [FetchJsonPipe]\n})\nexport class HeroListComponent {\n  /* I've got nothing to do ;-) */\n}\n```\n`'/assets/heroes.json'`是我自己编写的json文件，放在了assets里面，因为这是webpack的静态文件地址。\n\n结果：\n\n![](/css/images/67.jpg)\n\n### 特性解读\n\n>Stateful pipes are conceptually similar to classes in object-oriented\nprogramming. They can manage the data they transform. A pipe that creates an\nHTTP request, stores the response and displays the output, is a stateful pipe.\n\n这是官方对statefule pipe的描述。说是能够创建http请求，存储响应，显示输出的pipe就是stateful pipe。那么stateless pipe不能做这些事吗？我好奇的在stateless pipe中尝试做http请求：\n\n```ts\ndeclare var fetch;\nimport {Pipe, PipeTransform} from 'angular2/core';\n@Pipe({\n  name: 'fetch'\n})\nexport class FetchJsonPipe  implements PipeTransform {\n  transform(value: string, args: string[]): any {\n    fetch(value)\n        .then((result: any) => result.json())\n        .then((json: any)   =>  json);\n  }\n}\n```\n结果什么都输出不了！说明当我们需要使用http的时候，或者处理异步的时候，需要使用stateful pipe。~~这两个pipe的区别也正是\"函数式编程\"和\"面向对象\"的区别----有无状态~~ （使用“有无状态“来区别函数式编程和面向对象编程不够准确！）。\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n\n\n\n","source":"_posts/ng2-pipe.md","raw":"---\ntitle: Angular2 系列教程（六）两种pipe：函数式编程与面向对象编程\ndate: 2016-02-25 03:28:00\ntags: [Angular2]\n---\n\n今天，我们要讲的是ng2的pipe这个知识点。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/66.jpg)\n\n这个例子包含两个pipe，~~一个是stateful，一个是stateless~~，是直接复制官方的例子。（最新的官网文档已经将其改为了pure和impure，并移除了面向对象的比喻，个人认为较为准确，请以最新的官网文档为参考！）\n\n[源代码](https://github.com/lewis617/angular2-tutorial/tree/gh-pages/pipes)\n\n## stateless pipe\n\npipe就是ng1中的filter。先看看内建pipe吧：\n\n  * `currency`\n  * `date`\n  * `uppercase`\n  * `json`\n  * `limitTo`\n  * `lowercase`\n  * `async`\n  * `decimal`\n  * `percent`\n\n无需编写直接用！今天说了太多\"直接用\"哈哈！\n\npipe分为两种，一种是stateful，一种是stateless。我们先说stateless，stateless就是使用纯函数，不记住任何数据，也不会带来任何副作用。`DatePipe`就是stateless，我们再写个计算次方的pipe吧:\n\napp/stateless/exponential-strength.pipe.ts\n\n```ts\nimport {Pipe, PipeTransform} from 'angular2/core';\n/*\n * Raise the value exponentially\n * Takes an exponent argument that defaults to 1.\n * Usage:\n *   value | exponentialStrength:exponent\n * Example:\n *   {{ 2 |  exponentialStrength:10}}\n *   formats to: 1024\n*/\n@Pipe({name: 'exponentialStrength'})\nexport class ExponentialStrengthPipe implements PipeTransform {\n  transform(value: number, args: string[]) : any {\n    return Math.pow(value, parseInt(args[0] || '1', 10));\n  }\n}\n```\n很简单，计算某个值的某次方，比如2的10次方：\n\n```ts\n{{ 2 | exponentialStrength:10}}\n```\n\n写个模板测试下：\n\napp/stateless/power-booster.component.ts\n\n```ts\nimport {Component} from 'angular2/core';\nimport {ExponentialStrengthPipe} from './exponential-strength.pipe';\n@Component({\n  selector: 'power-booster',\n  template: `\n    <h2>Power Booster</h2>\n    <p>\n      Super power boost: {{2 | exponentialStrength: 10}}\n    </p>\n  `,\n  pipes: [ExponentialStrengthPipe]\n})\nexport class PowerBooster { }\n```\n\n注入`pipes: [ExponentialStrengthPipe]`，然后直接用！\n\n## stateful pipe\n\n先看一个stateful pipe的例子吧：\n\napp/stateful/fetch-json.pipe.ts\n\n```ts\ndeclare var fetch;\nimport {Pipe, PipeTransform} from 'angular2/core';\n@Pipe({\n  name: 'fetch',\n  pure: false\n})\nexport class FetchJsonPipe  implements PipeTransform {\n  private fetchedValue: any;\n  private fetchPromise: Promise<any>;\n  transform(value: string, args: string[]): any {\n    if (!this.fetchPromise) {\n      this.fetchPromise = fetch(value)\n        .then((result: any) => result.json())\n        .then((json: any)   => this.fetchedValue = json);\n    }\n    return this.fetchedValue;\n  }\n}\n```\n我们干了这些事：\n\n  1. 将`pure`参数设为`false`\n  2. 在成员函数`transform`中，执行`fetch`请求，将结果赋给`this.fetchedValue = json`，最后返回结果\n  3. 如果`this.fetchPromise`这个成员变量已经被定义过，则直接返回成员变量`fetchedValue`\n\n写个模板测试下：\n\napp/stateful/hero-list.component.ts\n\n```ts\nimport {Component} from 'angular2/core';\nimport {FetchJsonPipe} from './fetch-json.pipe';\n@Component({\n  selector: 'hero-list',\n  template: `\n    <h4>Heroes from JSON File</h4>\n    <div *ngFor=\"#hero of ('/assets/heroes.json' | fetch) \">\n      {{hero.name}}\n    </div>\n    <p>Heroes as JSON:\n    {{'/assets/heroes.json' | fetch | json}}\n    </p>\n  `,\n  pipes: [FetchJsonPipe]\n})\nexport class HeroListComponent {\n  /* I've got nothing to do ;-) */\n}\n```\n`'/assets/heroes.json'`是我自己编写的json文件，放在了assets里面，因为这是webpack的静态文件地址。\n\n结果：\n\n![](/css/images/67.jpg)\n\n### 特性解读\n\n>Stateful pipes are conceptually similar to classes in object-oriented\nprogramming. They can manage the data they transform. A pipe that creates an\nHTTP request, stores the response and displays the output, is a stateful pipe.\n\n这是官方对statefule pipe的描述。说是能够创建http请求，存储响应，显示输出的pipe就是stateful pipe。那么stateless pipe不能做这些事吗？我好奇的在stateless pipe中尝试做http请求：\n\n```ts\ndeclare var fetch;\nimport {Pipe, PipeTransform} from 'angular2/core';\n@Pipe({\n  name: 'fetch'\n})\nexport class FetchJsonPipe  implements PipeTransform {\n  transform(value: string, args: string[]): any {\n    fetch(value)\n        .then((result: any) => result.json())\n        .then((json: any)   =>  json);\n  }\n}\n```\n结果什么都输出不了！说明当我们需要使用http的时候，或者处理异步的时候，需要使用stateful pipe。~~这两个pipe的区别也正是\"函数式编程\"和\"面向对象\"的区别----有无状态~~ （使用“有无状态“来区别函数式编程和面向对象编程不够准确！）。\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n\n\n\n","slug":"ng2-pipe","published":1,"updated":"2019-05-01T08:10:29.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvly001stgytfy2wuc7h","content":"<p>今天，我们要讲的是ng2的pipe这个知识点。</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/66.jpg\" alt=\"\"></p>\n<p>这个例子包含两个pipe，<del>一个是stateful，一个是stateless</del>，是直接复制官方的例子。（最新的官网文档已经将其改为了pure和impure，并移除了面向对象的比喻，个人认为较为准确，请以最新的官网文档为参考！）</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/pipes\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<h2 id=\"stateless-pipe\"><a href=\"#stateless-pipe\" class=\"headerlink\" title=\"stateless pipe\"></a>stateless pipe</h2><p>pipe就是ng1中的filter。先看看内建pipe吧：</p>\n<ul>\n<li><code>currency</code></li>\n<li><code>date</code></li>\n<li><code>uppercase</code></li>\n<li><code>json</code></li>\n<li><code>limitTo</code></li>\n<li><code>lowercase</code></li>\n<li><code>async</code></li>\n<li><code>decimal</code></li>\n<li><code>percent</code></li>\n</ul>\n<p>无需编写直接用！今天说了太多”直接用”哈哈！</p>\n<p>pipe分为两种，一种是stateful，一种是stateless。我们先说stateless，stateless就是使用纯函数，不记住任何数据，也不会带来任何副作用。<code>DatePipe</code>就是stateless，我们再写个计算次方的pipe吧:</p>\n<p>app/stateless/exponential-strength.pipe.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Pipe, PipeTransform&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Raise the value exponentially</span></span><br><span class=\"line\"><span class=\"comment\"> * Takes an exponent argument that defaults to 1.</span></span><br><span class=\"line\"><span class=\"comment\"> * Usage:</span></span><br><span class=\"line\"><span class=\"comment\"> *   value | exponentialStrength:exponent</span></span><br><span class=\"line\"><span class=\"comment\"> * Example:</span></span><br><span class=\"line\"><span class=\"comment\"> *   &#123;&#123; 2 |  exponentialStrength:10&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *   formats to: 1024</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Pipe</span>(&#123;name: <span class=\"string\">'exponentialStrength'</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> ExponentialStrengthPipe <span class=\"keyword\">implements</span> PipeTransform &#123;</span><br><span class=\"line\">  transform(value: <span class=\"built_in\">number</span>, args: <span class=\"built_in\">string</span>[]) : <span class=\"built_in\">any</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.pow(value, <span class=\"built_in\">parseInt</span>(args[<span class=\"number\">0</span>] || <span class=\"string\">'1'</span>, <span class=\"number\">10</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很简单，计算某个值的某次方，比如2的10次方：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; <span class=\"number\">2</span> | exponentialStrength:<span class=\"number\">10</span>&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>写个模板测试下：</p>\n<p>app/stateless/power-booster.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;ExponentialStrengthPipe&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./exponential-strength.pipe'</span>;</span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  selector: <span class=\"string\">'power-booster'</span>,</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;h2&gt;Power Booster&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"string\">      Super power boost: &#123;&#123;2 | exponentialStrength: 10&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>,</span><br><span class=\"line\">  pipes: [ExponentialStrengthPipe]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> PowerBooster &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>注入<code>pipes: [ExponentialStrengthPipe]</code>，然后直接用！</p>\n<h2 id=\"stateful-pipe\"><a href=\"#stateful-pipe\" class=\"headerlink\" title=\"stateful pipe\"></a>stateful pipe</h2><p>先看一个stateful pipe的例子吧：</p>\n<p>app/stateful/fetch-json.pipe.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> fetch;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Pipe, PipeTransform&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"meta\">@Pipe</span>(&#123;</span><br><span class=\"line\">  name: <span class=\"string\">'fetch'</span>,</span><br><span class=\"line\">  pure: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> FetchJsonPipe  <span class=\"keyword\">implements</span> PipeTransform &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> fetchedValue: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> fetchPromise: <span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">any</span>&gt;;</span><br><span class=\"line\">  transform(value: <span class=\"built_in\">string</span>, args: <span class=\"built_in\">string</span>[]): <span class=\"built_in\">any</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.fetchPromise) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.fetchPromise = fetch(value)</span><br><span class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">result: <span class=\"built_in\">any</span></span>) =&gt;</span> result.json())</span><br><span class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">json: <span class=\"built_in\">any</span></span>)   =&gt;</span> <span class=\"keyword\">this</span>.fetchedValue = json);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.fetchedValue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们干了这些事：</p>\n<ol>\n<li>将<code>pure</code>参数设为<code>false</code></li>\n<li>在成员函数<code>transform</code>中，执行<code>fetch</code>请求，将结果赋给<code>this.fetchedValue = json</code>，最后返回结果</li>\n<li>如果<code>this.fetchPromise</code>这个成员变量已经被定义过，则直接返回成员变量<code>fetchedValue</code></li>\n</ol>\n<p>写个模板测试下：</p>\n<p>app/stateful/hero-list.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;FetchJsonPipe&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./fetch-json.pipe'</span>;</span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  selector: <span class=\"string\">'hero-list'</span>,</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;h4&gt;Heroes from JSON File&lt;/h4&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div *ngFor=\"#hero of ('/assets/heroes.json' | fetch) \"&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &#123;&#123;hero.name&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;p&gt;Heroes as JSON:</span></span><br><span class=\"line\"><span class=\"string\">    &#123;&#123;'/assets/heroes.json' | fetch | json&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>,</span><br><span class=\"line\">  pipes: [FetchJsonPipe]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroListComponent &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* I've got nothing to do ;-) */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>&#39;/assets/heroes.json&#39;</code>是我自己编写的json文件，放在了assets里面，因为这是webpack的静态文件地址。</p>\n<p>结果：</p>\n<p><img src=\"/css/images/67.jpg\" alt=\"\"></p>\n<h3 id=\"特性解读\"><a href=\"#特性解读\" class=\"headerlink\" title=\"特性解读\"></a>特性解读</h3><blockquote>\n<p>Stateful pipes are conceptually similar to classes in object-oriented<br>programming. They can manage the data they transform. A pipe that creates an<br>HTTP request, stores the response and displays the output, is a stateful pipe.</p>\n</blockquote>\n<p>这是官方对statefule pipe的描述。说是能够创建http请求，存储响应，显示输出的pipe就是stateful pipe。那么stateless pipe不能做这些事吗？我好奇的在stateless pipe中尝试做http请求：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> fetch;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Pipe, PipeTransform&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"meta\">@Pipe</span>(&#123;</span><br><span class=\"line\">  name: <span class=\"string\">'fetch'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> FetchJsonPipe  <span class=\"keyword\">implements</span> PipeTransform &#123;</span><br><span class=\"line\">  transform(value: <span class=\"built_in\">string</span>, args: <span class=\"built_in\">string</span>[]): <span class=\"built_in\">any</span> &#123;</span><br><span class=\"line\">    fetch(value)</span><br><span class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">result: <span class=\"built_in\">any</span></span>) =&gt;</span> result.json())</span><br><span class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">json: <span class=\"built_in\">any</span></span>)   =&gt;</span>  json);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果什么都输出不了！说明当我们需要使用http的时候，或者处理异步的时候，需要使用stateful pipe。<del>这两个pipe的区别也正是”函数式编程”和”面向对象”的区别—-有无状态</del> （使用“有无状态“来区别函数式编程和面向对象编程不够准确！）。</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是ng2的pipe这个知识点。</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/66.jpg\" alt=\"\"></p>\n<p>这个例子包含两个pipe，<del>一个是stateful，一个是stateless</del>，是直接复制官方的例子。（最新的官网文档已经将其改为了pure和impure，并移除了面向对象的比喻，个人认为较为准确，请以最新的官网文档为参考！）</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/pipes\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<h2 id=\"stateless-pipe\"><a href=\"#stateless-pipe\" class=\"headerlink\" title=\"stateless pipe\"></a>stateless pipe</h2><p>pipe就是ng1中的filter。先看看内建pipe吧：</p>\n<ul>\n<li><code>currency</code></li>\n<li><code>date</code></li>\n<li><code>uppercase</code></li>\n<li><code>json</code></li>\n<li><code>limitTo</code></li>\n<li><code>lowercase</code></li>\n<li><code>async</code></li>\n<li><code>decimal</code></li>\n<li><code>percent</code></li>\n</ul>\n<p>无需编写直接用！今天说了太多”直接用”哈哈！</p>\n<p>pipe分为两种，一种是stateful，一种是stateless。我们先说stateless，stateless就是使用纯函数，不记住任何数据，也不会带来任何副作用。<code>DatePipe</code>就是stateless，我们再写个计算次方的pipe吧:</p>\n<p>app/stateless/exponential-strength.pipe.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Pipe, PipeTransform&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Raise the value exponentially</span></span><br><span class=\"line\"><span class=\"comment\"> * Takes an exponent argument that defaults to 1.</span></span><br><span class=\"line\"><span class=\"comment\"> * Usage:</span></span><br><span class=\"line\"><span class=\"comment\"> *   value | exponentialStrength:exponent</span></span><br><span class=\"line\"><span class=\"comment\"> * Example:</span></span><br><span class=\"line\"><span class=\"comment\"> *   &#123;&#123; 2 |  exponentialStrength:10&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *   formats to: 1024</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Pipe</span>(&#123;name: <span class=\"string\">'exponentialStrength'</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> ExponentialStrengthPipe <span class=\"keyword\">implements</span> PipeTransform &#123;</span><br><span class=\"line\">  transform(value: <span class=\"built_in\">number</span>, args: <span class=\"built_in\">string</span>[]) : <span class=\"built_in\">any</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.pow(value, <span class=\"built_in\">parseInt</span>(args[<span class=\"number\">0</span>] || <span class=\"string\">'1'</span>, <span class=\"number\">10</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很简单，计算某个值的某次方，比如2的10次方：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; <span class=\"number\">2</span> | exponentialStrength:<span class=\"number\">10</span>&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>写个模板测试下：</p>\n<p>app/stateless/power-booster.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;ExponentialStrengthPipe&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./exponential-strength.pipe'</span>;</span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  selector: <span class=\"string\">'power-booster'</span>,</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;h2&gt;Power Booster&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"string\">      Super power boost: &#123;&#123;2 | exponentialStrength: 10&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>,</span><br><span class=\"line\">  pipes: [ExponentialStrengthPipe]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> PowerBooster &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>注入<code>pipes: [ExponentialStrengthPipe]</code>，然后直接用！</p>\n<h2 id=\"stateful-pipe\"><a href=\"#stateful-pipe\" class=\"headerlink\" title=\"stateful pipe\"></a>stateful pipe</h2><p>先看一个stateful pipe的例子吧：</p>\n<p>app/stateful/fetch-json.pipe.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> fetch;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Pipe, PipeTransform&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"meta\">@Pipe</span>(&#123;</span><br><span class=\"line\">  name: <span class=\"string\">'fetch'</span>,</span><br><span class=\"line\">  pure: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> FetchJsonPipe  <span class=\"keyword\">implements</span> PipeTransform &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> fetchedValue: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> fetchPromise: <span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">any</span>&gt;;</span><br><span class=\"line\">  transform(value: <span class=\"built_in\">string</span>, args: <span class=\"built_in\">string</span>[]): <span class=\"built_in\">any</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.fetchPromise) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.fetchPromise = fetch(value)</span><br><span class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">result: <span class=\"built_in\">any</span></span>) =&gt;</span> result.json())</span><br><span class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">json: <span class=\"built_in\">any</span></span>)   =&gt;</span> <span class=\"keyword\">this</span>.fetchedValue = json);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.fetchedValue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们干了这些事：</p>\n<ol>\n<li>将<code>pure</code>参数设为<code>false</code></li>\n<li>在成员函数<code>transform</code>中，执行<code>fetch</code>请求，将结果赋给<code>this.fetchedValue = json</code>，最后返回结果</li>\n<li>如果<code>this.fetchPromise</code>这个成员变量已经被定义过，则直接返回成员变量<code>fetchedValue</code></li>\n</ol>\n<p>写个模板测试下：</p>\n<p>app/stateful/hero-list.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;FetchJsonPipe&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./fetch-json.pipe'</span>;</span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  selector: <span class=\"string\">'hero-list'</span>,</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;h4&gt;Heroes from JSON File&lt;/h4&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div *ngFor=\"#hero of ('/assets/heroes.json' | fetch) \"&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &#123;&#123;hero.name&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;p&gt;Heroes as JSON:</span></span><br><span class=\"line\"><span class=\"string\">    &#123;&#123;'/assets/heroes.json' | fetch | json&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>,</span><br><span class=\"line\">  pipes: [FetchJsonPipe]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroListComponent &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* I've got nothing to do ;-) */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>&#39;/assets/heroes.json&#39;</code>是我自己编写的json文件，放在了assets里面，因为这是webpack的静态文件地址。</p>\n<p>结果：</p>\n<p><img src=\"/css/images/67.jpg\" alt=\"\"></p>\n<h3 id=\"特性解读\"><a href=\"#特性解读\" class=\"headerlink\" title=\"特性解读\"></a>特性解读</h3><blockquote>\n<p>Stateful pipes are conceptually similar to classes in object-oriented<br>programming. They can manage the data they transform. A pipe that creates an<br>HTTP request, stores the response and displays the output, is a stateful pipe.</p>\n</blockquote>\n<p>这是官方对statefule pipe的描述。说是能够创建http请求，存储响应，显示输出的pipe就是stateful pipe。那么stateless pipe不能做这些事吗？我好奇的在stateless pipe中尝试做http请求：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> fetch;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Pipe, PipeTransform&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"meta\">@Pipe</span>(&#123;</span><br><span class=\"line\">  name: <span class=\"string\">'fetch'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> FetchJsonPipe  <span class=\"keyword\">implements</span> PipeTransform &#123;</span><br><span class=\"line\">  transform(value: <span class=\"built_in\">string</span>, args: <span class=\"built_in\">string</span>[]): <span class=\"built_in\">any</span> &#123;</span><br><span class=\"line\">    fetch(value)</span><br><span class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">result: <span class=\"built_in\">any</span></span>) =&gt;</span> result.json())</span><br><span class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">json: <span class=\"built_in\">any</span></span>)   =&gt;</span>  json);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果什么都输出不了！说明当我们需要使用http的时候，或者处理异步的时候，需要使用stateful pipe。<del>这两个pipe的区别也正是”函数式编程”和”面向对象”的区别—-有无状态</del> （使用“有无状态“来区别函数式编程和面向对象编程不够准确！）。</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>"},{"title":"Angular2 系列教程（十一）路由嵌套、路由生命周期、matrix URL notation","date":"2016-04-04T01:33:00.000Z","_content":"\n今天我们要讲的是 ng2 的路由的第二部分，包括路由嵌套、路由生命周期等知识点。\n\n<!--more-->\n\n## 例子\n\n例子仍然是上节课的例子：\n\n![](/css/images/71.jpg)\n\n上节课，我们讲解了英雄列表，这节课我们讲解危机中心。\n\n源代码：\n\n<https://github.com/lewis617/angular2-tutorial/tree/gh-pages/router>\n\n运行方法：\n\n在根目录下运行：\n\n```sh\nhttp-server\n```\n\n##  路由嵌套\n\n我们在 app/app.component.ts 中定义了路由 URL 和视图组件，其中包括这样一项：\n\napp/app.component.ts\n\n```ts\n    \n{ // Crisis Center child route\n  path: '/crisis-center/...',\n  name: 'CrisisCenter',\n  component: CrisisCenterComponent,\n  useAsDefault: true\n},\n```\n\n那个`...`就是代表这个 URL 下面可以定义子路由，也就是嵌套路由。嵌套路由是如何实现的？很简单，只需要在视图组件中再次配置路由即可：\n\napp/crisis-center/crisis-center.component.ts\n\n```ts\nimport {Component}     from 'angular2/core';\nimport {RouteConfig, RouterOutlet} from 'angular2/router';\n\nimport {CrisisListComponent}   from './crisis-list.component';\nimport {CrisisDetailComponent} from './crisis-detail.component';\nimport {CrisisService}         from './crisis.service';\n\n@Component({\n  template:  `\n    <h2>CRISIS CENTER</h2>\n    <router-outlet></router-outlet>\n  `,\n  directives: [RouterOutlet],\n  providers:  [CrisisService]\n})\n@RouteConfig([\n  {path:'/',    name: 'CrisisList',   component: CrisisListComponent, useAsDefault: true},\n  {path:'/:id', name: 'CrisisDetail', component: CrisisDetailComponent}\n])\nexport class CrisisCenterComponent { }\n\n```\n\n上述代码，我们干了几件事\"：\n\n  1. 写了一个组件，包括`h2`和 `router-outlet`\n  2. 使用`@RouteConfig`，进行路由配置\n\n这样我们就实现了嵌套路由。就是这么简单。\n\n## 路由生命周期\n\n路由跳转到别的视图的时候，会触发一个路由的生命周期钩子：`routerCanDeactivate`:\n\napp/crisis-center/crisis-detail.component.ts  \n\n```ts\n\nrouterCanDeactivate(next: ComponentInstruction, prev: ComponentInstruction) : any {\n  // Allow synchronous navigation (`true`) if no crisis or the crisis is unchanged.\n  if (!this.crisis || this.crisis.name === this.editName) {\n    return true;\n  }\n  // Otherwise ask the user with the dialog service and return its\n  // promise which resolves to true or false when the user decides\n  return this._dialog.confirm('Discard changes?');\n}\n```\n\n这段代码，会在你修改完危机信息后，既不点击 save 也不点击 cancer 时候触发。也就是\n\n```ts\nthis._dialog.confirm('Discard changes?');\n```\n\n弹出一个对话框：\n\n![](/css/images/72.jpg)\n\n这里为什么要使用单独的`dialog` 服务呢？为何不直接出发`window.confirm()？`因为路由的生命周期接受 Bool 或者 Promise 对象（ ng1 也是这样哦）。而`window.confirm` 并不返回一个promise对象，我们需要对其进行包装：  \n\napp/dialog.service.ts\n\n```ts\n    \n\nimport {Injectable} from 'angular2/core';\n/**\n * Async modal dialog service\n * DialogService makes this app easier to test by faking this service.\n * TODO: better modal implemenation that doesn't use window.confirm\n */\n@Injectable()\nexport class DialogService {\n  /**\n   * Ask user to confirm an action. `message` explains the action and choices.\n   * Returns promise resolving to `true`=confirm or `false`=cancel\n   */\n  confirm(message?:string) {\n    return new Promise<boolean>((resolve, reject) =>\n      resolve(window.confirm(message || 'Is it OK?')));\n  };\n}\n```\n我们使用 Promise 包装了`confirm` 这个方法，使得这个服务，会触发`confirm`的同时，最后也能返回一个Promise。这样以来我们就可以在路由的生命周期中尽情的使用了！\n\n值得一提的是 ng1 路由的`resolve`属性也是接受一个Promise，有兴趣的同学可以看我在 ng1 中对 wilddog 的路由改装：\n\nhttps://github.com/lewis617/wild-angular-seed/blob/gh-pages/components/wilddog.utils/wilddog.utils.js#L85\n\n# _matrix URL_ notation\n\n当我们从危机详情视图返回危机列表视图的时候，我们发现 URL 变成了：\n\nhttp://localhost:63342/angular2-tutorial/router/index.html/crisis-center/;id=1;foo=foo\n\n`;id=1;foo=foo` 这个参数是我们没有见过的，我们知道query string一般都是`?`加`&`，而这个参数则使用了`;`，这叫做 _matrix URL_ notation。  \n\n> _Matrix URL_ notation is an idea first floated in a [1996 proposal](http://www.w3.org/DesignIssues/MatrixURIs.html) by the founder of the web, Tim Berners-Lee.\n\n> Although matrix notation never made it into the HTML standard, it is legal and it became popular among browser routing systems as a way to isolate parameters belonging to parent and child routes. The Angular Component Router is such a system.\n\n> The syntax may seem strange to us but users are unlikely to notice or care as long as the URL can be emailed and pasted into a browser address bar as this one can.\n\n这是 ng2 官方文档对这个概念的解释，我们从中得知，这个概念用区分参数属于父视图还是子视图。\n\n我们在上节课英雄列表中，发现 URL 是普通的 query string。为什么在这里变成了_matrix URL_ notation？因为英雄列表视图没有子视图，没有嵌套路由的概念。而危机中心则使用了嵌套路由，拥有父子视图的嵌套，为了加一区分，ng2 的路由系统使用了 _matrix URL_  notation 这个概念。\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n","source":"_posts/ng2-router-2.md","raw":"---\ntitle: Angular2 系列教程（十一）路由嵌套、路由生命周期、matrix URL notation\ndate: 2016-04-04 09:33:00\ntags: [Angular2]\n---\n\n今天我们要讲的是 ng2 的路由的第二部分，包括路由嵌套、路由生命周期等知识点。\n\n<!--more-->\n\n## 例子\n\n例子仍然是上节课的例子：\n\n![](/css/images/71.jpg)\n\n上节课，我们讲解了英雄列表，这节课我们讲解危机中心。\n\n源代码：\n\n<https://github.com/lewis617/angular2-tutorial/tree/gh-pages/router>\n\n运行方法：\n\n在根目录下运行：\n\n```sh\nhttp-server\n```\n\n##  路由嵌套\n\n我们在 app/app.component.ts 中定义了路由 URL 和视图组件，其中包括这样一项：\n\napp/app.component.ts\n\n```ts\n    \n{ // Crisis Center child route\n  path: '/crisis-center/...',\n  name: 'CrisisCenter',\n  component: CrisisCenterComponent,\n  useAsDefault: true\n},\n```\n\n那个`...`就是代表这个 URL 下面可以定义子路由，也就是嵌套路由。嵌套路由是如何实现的？很简单，只需要在视图组件中再次配置路由即可：\n\napp/crisis-center/crisis-center.component.ts\n\n```ts\nimport {Component}     from 'angular2/core';\nimport {RouteConfig, RouterOutlet} from 'angular2/router';\n\nimport {CrisisListComponent}   from './crisis-list.component';\nimport {CrisisDetailComponent} from './crisis-detail.component';\nimport {CrisisService}         from './crisis.service';\n\n@Component({\n  template:  `\n    <h2>CRISIS CENTER</h2>\n    <router-outlet></router-outlet>\n  `,\n  directives: [RouterOutlet],\n  providers:  [CrisisService]\n})\n@RouteConfig([\n  {path:'/',    name: 'CrisisList',   component: CrisisListComponent, useAsDefault: true},\n  {path:'/:id', name: 'CrisisDetail', component: CrisisDetailComponent}\n])\nexport class CrisisCenterComponent { }\n\n```\n\n上述代码，我们干了几件事\"：\n\n  1. 写了一个组件，包括`h2`和 `router-outlet`\n  2. 使用`@RouteConfig`，进行路由配置\n\n这样我们就实现了嵌套路由。就是这么简单。\n\n## 路由生命周期\n\n路由跳转到别的视图的时候，会触发一个路由的生命周期钩子：`routerCanDeactivate`:\n\napp/crisis-center/crisis-detail.component.ts  \n\n```ts\n\nrouterCanDeactivate(next: ComponentInstruction, prev: ComponentInstruction) : any {\n  // Allow synchronous navigation (`true`) if no crisis or the crisis is unchanged.\n  if (!this.crisis || this.crisis.name === this.editName) {\n    return true;\n  }\n  // Otherwise ask the user with the dialog service and return its\n  // promise which resolves to true or false when the user decides\n  return this._dialog.confirm('Discard changes?');\n}\n```\n\n这段代码，会在你修改完危机信息后，既不点击 save 也不点击 cancer 时候触发。也就是\n\n```ts\nthis._dialog.confirm('Discard changes?');\n```\n\n弹出一个对话框：\n\n![](/css/images/72.jpg)\n\n这里为什么要使用单独的`dialog` 服务呢？为何不直接出发`window.confirm()？`因为路由的生命周期接受 Bool 或者 Promise 对象（ ng1 也是这样哦）。而`window.confirm` 并不返回一个promise对象，我们需要对其进行包装：  \n\napp/dialog.service.ts\n\n```ts\n    \n\nimport {Injectable} from 'angular2/core';\n/**\n * Async modal dialog service\n * DialogService makes this app easier to test by faking this service.\n * TODO: better modal implemenation that doesn't use window.confirm\n */\n@Injectable()\nexport class DialogService {\n  /**\n   * Ask user to confirm an action. `message` explains the action and choices.\n   * Returns promise resolving to `true`=confirm or `false`=cancel\n   */\n  confirm(message?:string) {\n    return new Promise<boolean>((resolve, reject) =>\n      resolve(window.confirm(message || 'Is it OK?')));\n  };\n}\n```\n我们使用 Promise 包装了`confirm` 这个方法，使得这个服务，会触发`confirm`的同时，最后也能返回一个Promise。这样以来我们就可以在路由的生命周期中尽情的使用了！\n\n值得一提的是 ng1 路由的`resolve`属性也是接受一个Promise，有兴趣的同学可以看我在 ng1 中对 wilddog 的路由改装：\n\nhttps://github.com/lewis617/wild-angular-seed/blob/gh-pages/components/wilddog.utils/wilddog.utils.js#L85\n\n# _matrix URL_ notation\n\n当我们从危机详情视图返回危机列表视图的时候，我们发现 URL 变成了：\n\nhttp://localhost:63342/angular2-tutorial/router/index.html/crisis-center/;id=1;foo=foo\n\n`;id=1;foo=foo` 这个参数是我们没有见过的，我们知道query string一般都是`?`加`&`，而这个参数则使用了`;`，这叫做 _matrix URL_ notation。  \n\n> _Matrix URL_ notation is an idea first floated in a [1996 proposal](http://www.w3.org/DesignIssues/MatrixURIs.html) by the founder of the web, Tim Berners-Lee.\n\n> Although matrix notation never made it into the HTML standard, it is legal and it became popular among browser routing systems as a way to isolate parameters belonging to parent and child routes. The Angular Component Router is such a system.\n\n> The syntax may seem strange to us but users are unlikely to notice or care as long as the URL can be emailed and pasted into a browser address bar as this one can.\n\n这是 ng2 官方文档对这个概念的解释，我们从中得知，这个概念用区分参数属于父视图还是子视图。\n\n我们在上节课英雄列表中，发现 URL 是普通的 query string。为什么在这里变成了_matrix URL_ notation？因为英雄列表视图没有子视图，没有嵌套路由的概念。而危机中心则使用了嵌套路由，拥有父子视图的嵌套，为了加一区分，ng2 的路由系统使用了 _matrix URL_  notation 这个概念。\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n","slug":"ng2-router-2","published":1,"updated":"2019-05-01T08:10:29.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvlz001utgytq694duzk","content":"<p>今天我们要讲的是 ng2 的路由的第二部分，包括路由嵌套、路由生命周期等知识点。</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>例子仍然是上节课的例子：</p>\n<p><img src=\"/css/images/71.jpg\" alt=\"\"></p>\n<p>上节课，我们讲解了英雄列表，这节课我们讲解危机中心。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/router\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial/tree/gh-pages/router</a></p>\n<p>运行方法：</p>\n<p>在根目录下运行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server</span><br></pre></td></tr></table></figure>\n<h2 id=\"路由嵌套\"><a href=\"#路由嵌套\" class=\"headerlink\" title=\"路由嵌套\"></a>路由嵌套</h2><p>我们在 app/app.component.ts 中定义了路由 URL 和视图组件，其中包括这样一项：</p>\n<p>app/app.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\">&#123; <span class=\"comment\">// Crisis Center child route</span></span><br><span class=\"line\">  path: <span class=\"string\">'/crisis-center/...'</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'CrisisCenter'</span>,</span><br><span class=\"line\">  component: CrisisCenterComponent,</span><br><span class=\"line\">  useAsDefault: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>那个<code>...</code>就是代表这个 URL 下面可以定义子路由，也就是嵌套路由。嵌套路由是如何实现的？很简单，只需要在视图组件中再次配置路由即可：</p>\n<p>app/crisis-center/crisis-center.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component&#125;     <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;RouteConfig, RouterOutlet&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;CrisisListComponent&#125;   <span class=\"keyword\">from</span> <span class=\"string\">'./crisis-list.component'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;CrisisDetailComponent&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./crisis-detail.component'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;CrisisService&#125;         <span class=\"keyword\">from</span> <span class=\"string\">'./crisis.service'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  template:  <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;h2&gt;CRISIS CENTER&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;router-outlet&gt;&lt;/router-outlet&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>,</span><br><span class=\"line\">  directives: [RouterOutlet],</span><br><span class=\"line\">  providers:  [CrisisService]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"meta\">@RouteConfig</span>([</span><br><span class=\"line\">  &#123;path:<span class=\"string\">'/'</span>,    name: <span class=\"string\">'CrisisList'</span>,   component: CrisisListComponent, useAsDefault: <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">  &#123;path:<span class=\"string\">'/:id'</span>, name: <span class=\"string\">'CrisisDetail'</span>, component: CrisisDetailComponent&#125;</span><br><span class=\"line\">])</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> CrisisCenterComponent &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码，我们干了几件事”：</p>\n<ol>\n<li>写了一个组件，包括<code>h2</code>和 <code>router-outlet</code></li>\n<li>使用<code>@RouteConfig</code>，进行路由配置</li>\n</ol>\n<p>这样我们就实现了嵌套路由。就是这么简单。</p>\n<h2 id=\"路由生命周期\"><a href=\"#路由生命周期\" class=\"headerlink\" title=\"路由生命周期\"></a>路由生命周期</h2><p>路由跳转到别的视图的时候，会触发一个路由的生命周期钩子：<code>routerCanDeactivate</code>:</p>\n<p>app/crisis-center/crisis-detail.component.ts  </p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">routerCanDeactivate(next: ComponentInstruction, prev: ComponentInstruction) : <span class=\"built_in\">any</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Allow synchronous navigation (`true`) if no crisis or the crisis is unchanged.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.crisis || <span class=\"keyword\">this</span>.crisis.name === <span class=\"keyword\">this</span>.editName) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Otherwise ask the user with the dialog service and return its</span></span><br><span class=\"line\">  <span class=\"comment\">// promise which resolves to true or false when the user decides</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._dialog.confirm(<span class=\"string\">'Discard changes?'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码，会在你修改完危机信息后，既不点击 save 也不点击 cancer 时候触发。也就是</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._dialog.confirm(<span class=\"string\">'Discard changes?'</span>);</span><br></pre></td></tr></table></figure>\n<p>弹出一个对话框：</p>\n<p><img src=\"/css/images/72.jpg\" alt=\"\"></p>\n<p>这里为什么要使用单独的<code>dialog</code> 服务呢？为何不直接出发<code>window.confirm()？</code>因为路由的生命周期接受 Bool 或者 Promise 对象（ ng1 也是这样哦）。而<code>window.confirm</code> 并不返回一个promise对象，我们需要对其进行包装：  </p>\n<p>app/dialog.service.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Injectable&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Async modal dialog service</span></span><br><span class=\"line\"><span class=\"comment\"> * DialogService makes this app easier to test by faking this service.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">TODO:</span> better modal implemenation that doesn't use window.confirm</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> DialogService &#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Ask user to confirm an action. `message` explains the action and choices.</span></span><br><span class=\"line\"><span class=\"comment\">   * Returns promise resolving to `true`=confirm or `false`=cancel</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  confirm(message?:<span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">boolean</span>&gt;<span class=\"function\">(<span class=\"params\">(<span class=\"params\">resolve, reject</span>) =&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      resolve(<span class=\"params\"><span class=\"built_in\">window</span>.confirm(<span class=\"params\">message || 'Is it OK?'</span>)</span>)</span>);</span></span><br><span class=\"line\"><span class=\"function\">  &#125;;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们使用 Promise 包装了<code>confirm</code> 这个方法，使得这个服务，会触发<code>confirm</code>的同时，最后也能返回一个Promise。这样以来我们就可以在路由的生命周期中尽情的使用了！</p>\n<p>值得一提的是 ng1 路由的<code>resolve</code>属性也是接受一个Promise，有兴趣的同学可以看我在 ng1 中对 wilddog 的路由改装：</p>\n<p><a href=\"https://github.com/lewis617/wild-angular-seed/blob/gh-pages/components/wilddog.utils/wilddog.utils.js#L85\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/wild-angular-seed/blob/gh-pages/components/wilddog.utils/wilddog.utils.js#L85</a></p>\n<h1 id=\"matrix-URL-notation\"><a href=\"#matrix-URL-notation\" class=\"headerlink\" title=\"matrix URL notation\"></a><em>matrix URL</em> notation</h1><p>当我们从危机详情视图返回危机列表视图的时候，我们发现 URL 变成了：</p>\n<p><a href=\"http://localhost:63342/angular2-tutorial/router/index.html/crisis-center/;id=1;foo=foo\" target=\"_blank\" rel=\"noopener\">http://localhost:63342/angular2-tutorial/router/index.html/crisis-center/;id=1;foo=foo</a></p>\n<p><code>;id=1;foo=foo</code> 这个参数是我们没有见过的，我们知道query string一般都是<code>?</code>加<code>&amp;</code>，而这个参数则使用了<code>;</code>，这叫做 <em>matrix URL</em> notation。  </p>\n<blockquote>\n<p><em>Matrix URL</em> notation is an idea first floated in a <a href=\"http://www.w3.org/DesignIssues/MatrixURIs.html\" target=\"_blank\" rel=\"noopener\">1996 proposal</a> by the founder of the web, Tim Berners-Lee.</p>\n</blockquote>\n<blockquote>\n<p>Although matrix notation never made it into the HTML standard, it is legal and it became popular among browser routing systems as a way to isolate parameters belonging to parent and child routes. The Angular Component Router is such a system.</p>\n</blockquote>\n<blockquote>\n<p>The syntax may seem strange to us but users are unlikely to notice or care as long as the URL can be emailed and pasted into a browser address bar as this one can.</p>\n</blockquote>\n<p>这是 ng2 官方文档对这个概念的解释，我们从中得知，这个概念用区分参数属于父视图还是子视图。</p>\n<p>我们在上节课英雄列表中，发现 URL 是普通的 query string。为什么在这里变成了<em>matrix URL</em> notation？因为英雄列表视图没有子视图，没有嵌套路由的概念。而危机中心则使用了嵌套路由，拥有父子视图的嵌套，为了加一区分，ng2 的路由系统使用了 <em>matrix URL</em>  notation 这个概念。</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天我们要讲的是 ng2 的路由的第二部分，包括路由嵌套、路由生命周期等知识点。</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>例子仍然是上节课的例子：</p>\n<p><img src=\"/css/images/71.jpg\" alt=\"\"></p>\n<p>上节课，我们讲解了英雄列表，这节课我们讲解危机中心。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/router\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial/tree/gh-pages/router</a></p>\n<p>运行方法：</p>\n<p>在根目录下运行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server</span><br></pre></td></tr></table></figure>\n<h2 id=\"路由嵌套\"><a href=\"#路由嵌套\" class=\"headerlink\" title=\"路由嵌套\"></a>路由嵌套</h2><p>我们在 app/app.component.ts 中定义了路由 URL 和视图组件，其中包括这样一项：</p>\n<p>app/app.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\">&#123; <span class=\"comment\">// Crisis Center child route</span></span><br><span class=\"line\">  path: <span class=\"string\">'/crisis-center/...'</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'CrisisCenter'</span>,</span><br><span class=\"line\">  component: CrisisCenterComponent,</span><br><span class=\"line\">  useAsDefault: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>那个<code>...</code>就是代表这个 URL 下面可以定义子路由，也就是嵌套路由。嵌套路由是如何实现的？很简单，只需要在视图组件中再次配置路由即可：</p>\n<p>app/crisis-center/crisis-center.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component&#125;     <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;RouteConfig, RouterOutlet&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;CrisisListComponent&#125;   <span class=\"keyword\">from</span> <span class=\"string\">'./crisis-list.component'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;CrisisDetailComponent&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./crisis-detail.component'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;CrisisService&#125;         <span class=\"keyword\">from</span> <span class=\"string\">'./crisis.service'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  template:  <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;h2&gt;CRISIS CENTER&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;router-outlet&gt;&lt;/router-outlet&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>,</span><br><span class=\"line\">  directives: [RouterOutlet],</span><br><span class=\"line\">  providers:  [CrisisService]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"meta\">@RouteConfig</span>([</span><br><span class=\"line\">  &#123;path:<span class=\"string\">'/'</span>,    name: <span class=\"string\">'CrisisList'</span>,   component: CrisisListComponent, useAsDefault: <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">  &#123;path:<span class=\"string\">'/:id'</span>, name: <span class=\"string\">'CrisisDetail'</span>, component: CrisisDetailComponent&#125;</span><br><span class=\"line\">])</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> CrisisCenterComponent &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码，我们干了几件事”：</p>\n<ol>\n<li>写了一个组件，包括<code>h2</code>和 <code>router-outlet</code></li>\n<li>使用<code>@RouteConfig</code>，进行路由配置</li>\n</ol>\n<p>这样我们就实现了嵌套路由。就是这么简单。</p>\n<h2 id=\"路由生命周期\"><a href=\"#路由生命周期\" class=\"headerlink\" title=\"路由生命周期\"></a>路由生命周期</h2><p>路由跳转到别的视图的时候，会触发一个路由的生命周期钩子：<code>routerCanDeactivate</code>:</p>\n<p>app/crisis-center/crisis-detail.component.ts  </p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">routerCanDeactivate(next: ComponentInstruction, prev: ComponentInstruction) : <span class=\"built_in\">any</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Allow synchronous navigation (`true`) if no crisis or the crisis is unchanged.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.crisis || <span class=\"keyword\">this</span>.crisis.name === <span class=\"keyword\">this</span>.editName) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Otherwise ask the user with the dialog service and return its</span></span><br><span class=\"line\">  <span class=\"comment\">// promise which resolves to true or false when the user decides</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._dialog.confirm(<span class=\"string\">'Discard changes?'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码，会在你修改完危机信息后，既不点击 save 也不点击 cancer 时候触发。也就是</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._dialog.confirm(<span class=\"string\">'Discard changes?'</span>);</span><br></pre></td></tr></table></figure>\n<p>弹出一个对话框：</p>\n<p><img src=\"/css/images/72.jpg\" alt=\"\"></p>\n<p>这里为什么要使用单独的<code>dialog</code> 服务呢？为何不直接出发<code>window.confirm()？</code>因为路由的生命周期接受 Bool 或者 Promise 对象（ ng1 也是这样哦）。而<code>window.confirm</code> 并不返回一个promise对象，我们需要对其进行包装：  </p>\n<p>app/dialog.service.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Injectable&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Async modal dialog service</span></span><br><span class=\"line\"><span class=\"comment\"> * DialogService makes this app easier to test by faking this service.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">TODO:</span> better modal implemenation that doesn't use window.confirm</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> DialogService &#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Ask user to confirm an action. `message` explains the action and choices.</span></span><br><span class=\"line\"><span class=\"comment\">   * Returns promise resolving to `true`=confirm or `false`=cancel</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  confirm(message?:<span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">boolean</span>&gt;<span class=\"function\">(<span class=\"params\">(<span class=\"params\">resolve, reject</span>) =&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      resolve(<span class=\"params\"><span class=\"built_in\">window</span>.confirm(<span class=\"params\">message || 'Is it OK?'</span>)</span>)</span>);</span></span><br><span class=\"line\"><span class=\"function\">  &#125;;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们使用 Promise 包装了<code>confirm</code> 这个方法，使得这个服务，会触发<code>confirm</code>的同时，最后也能返回一个Promise。这样以来我们就可以在路由的生命周期中尽情的使用了！</p>\n<p>值得一提的是 ng1 路由的<code>resolve</code>属性也是接受一个Promise，有兴趣的同学可以看我在 ng1 中对 wilddog 的路由改装：</p>\n<p><a href=\"https://github.com/lewis617/wild-angular-seed/blob/gh-pages/components/wilddog.utils/wilddog.utils.js#L85\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/wild-angular-seed/blob/gh-pages/components/wilddog.utils/wilddog.utils.js#L85</a></p>\n<h1 id=\"matrix-URL-notation\"><a href=\"#matrix-URL-notation\" class=\"headerlink\" title=\"matrix URL notation\"></a><em>matrix URL</em> notation</h1><p>当我们从危机详情视图返回危机列表视图的时候，我们发现 URL 变成了：</p>\n<p><a href=\"http://localhost:63342/angular2-tutorial/router/index.html/crisis-center/;id=1;foo=foo\" target=\"_blank\" rel=\"noopener\">http://localhost:63342/angular2-tutorial/router/index.html/crisis-center/;id=1;foo=foo</a></p>\n<p><code>;id=1;foo=foo</code> 这个参数是我们没有见过的，我们知道query string一般都是<code>?</code>加<code>&amp;</code>，而这个参数则使用了<code>;</code>，这叫做 <em>matrix URL</em> notation。  </p>\n<blockquote>\n<p><em>Matrix URL</em> notation is an idea first floated in a <a href=\"http://www.w3.org/DesignIssues/MatrixURIs.html\" target=\"_blank\" rel=\"noopener\">1996 proposal</a> by the founder of the web, Tim Berners-Lee.</p>\n</blockquote>\n<blockquote>\n<p>Although matrix notation never made it into the HTML standard, it is legal and it became popular among browser routing systems as a way to isolate parameters belonging to parent and child routes. The Angular Component Router is such a system.</p>\n</blockquote>\n<blockquote>\n<p>The syntax may seem strange to us but users are unlikely to notice or care as long as the URL can be emailed and pasted into a browser address bar as this one can.</p>\n</blockquote>\n<p>这是 ng2 官方文档对这个概念的解释，我们从中得知，这个概念用区分参数属于父视图还是子视图。</p>\n<p>我们在上节课英雄列表中，发现 URL 是普通的 query string。为什么在这里变成了<em>matrix URL</em> notation？因为英雄列表视图没有子视图，没有嵌套路由的概念。而危机中心则使用了嵌套路由，拥有父子视图的嵌套，为了加一区分，ng2 的路由系统使用了 <em>matrix URL</em>  notation 这个概念。</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>"},{"title":"Angular2 系列教程（十）两种启动方法、两个路由服务、引用类型和单例模式的妙用","date":"2016-04-04T00:49:00.000Z","_content":"\n今天我们要讲的是 ng2 的路由系统。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/68.jpg)\n\n例子是官网的例子，包含一个\"危机中心\"和\"英雄列表\"，都在一个app中，通过路由来控制切换视图。还包含了Promise的用法，服务的用法等多个知识点。\n\n源代码：\n\n<https://github.com/lewis617/angular2-tutorial/tree/gh-pages/router>\n\n运行方法：\n\n在根目录下运行：\n\n```sh    \nhttp-server\n```\n\n## 引入库文件设置base href  \n\n路由并不在ng2中，需要我们额外引入，另外我们需要设置base href，这是个什么东西呢？相当于我们后续所有 URL 的\"前缀\"，因为我们的app默认是基于[HTML 5 pushState](https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries) 风格的路由，所以我们需要加上base href，来保证当我们导航到深层次的 URL 时候，资源可以被正确加载：\n\nindex.html\n\n```html   \n<!-- Add the router library -->\n<script src=\"lib/router.dev.js\"></script>\n\n<!-- Set the base href -->\n<script>document.write('<base href=\"' + document.location + '\" />');</script>\n\n```\n## 两种启动方法\n\napp/main.ts\n\n```ts\nimport {bootstrap}        from 'angular2/platform/browser';\nimport {ROUTER_PROVIDERS} from 'angular2/router';\n\nimport {AppComponent}     from './app.component';\n\n// Add these symbols to override the `LocationStrategy`\n//import {provide}           from 'angular2/core';\n//import {LocationStrategy,\n//        HashLocationStrategy} from 'angular2/router';\n\nbootstrap(AppComponent, [ROUTER_PROVIDERS,\n  //provide(LocationStrategy,\n  //       {useClass: HashLocationStrategy}) // .../#/crisis-center/\n ]);\n```\n\n这种启动方法采取默认的 [HTML 5 pushState](https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries) 风格，没有#号，但是存在一个弊端。就是当我们在子路经刷新浏览器时候，会出现404的错误。~~解决办法可以将所有的路由都指向根目录，但是我们使用了http-server，显然不太方便设置。~~ （可以通过设置base href为“/“来解决！）所以还有另外一种风格，就是老式风格，和ng1一样的，带有#的路由风格，它的启动方法是：\n\n```ts\nimport {bootstrap}        from 'angular2/platform/browser';\nimport {ROUTER_PROVIDERS} from 'angular2/router';\n\nimport {AppComponent}     from './app.component';\n\n// Add these symbols to override the `LocationStrategy`\nimport {provide}           from 'angular2/core';\nimport {LocationStrategy,\n    HashLocationStrategy} from 'angular2/router';\n\nbootstrap(AppComponent, [ROUTER_PROVIDERS,\nprovide(LocationStrategy,\n     {useClass: HashLocationStrategy}) // .../#/crisis-center/\n]);\n\n```\n\n如此一来，我们的app的路由就全部带上#了，当你刷新页面时候，也不会出现404的错误了，但是url的可读性没有 [HTML 5 pushState](https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries) 风格好看。\n\n## ROUTER_DIRECTIVES、RouteConfig、routerLink、router-outlet\n\n路由的编写很简单，我们只需要在我们的组件中进行配置就行了：\n\napp/app.component.ts\n\n```ts\nimport {Component} from 'angular2/core';\nimport {RouteConfig, ROUTER_DIRECTIVES} from 'angular2/router';\n\nimport {CrisisCenterComponent} from './crisis-center/crisis-center.component';\nimport {HeroListComponent}     from './heroes/hero-list.component';\nimport {HeroDetailComponent}   from './heroes/hero-detail.component';\n\nimport {DialogService}         from './dialog.service';\nimport {HeroService}           from './heroes/hero.service';\n\n@Component({\n  selector: 'my-app',\n  template: `\n    <h1 class=\"title\">Component Router</h1>\n    <nav>\n      <a [routerLink]=\"['CrisisCenter']\">Crisis Center</a>\n      <a [routerLink]=\"['Heroes']\">Heroes</a>\n    </nav>\n    <router-outlet></router-outlet>\n  `,\n  providers:  [DialogService, HeroService],\n  directives: [ROUTER_DIRECTIVES]\n})\n@RouteConfig([\n\n  { // Crisis Center child route\n    path: '/crisis-center/...',\n    name: 'CrisisCenter',\n    component: CrisisCenterComponent,\n    useAsDefault: true\n  },\n\n  {path: '/heroes',   name: 'Heroes',     component: HeroListComponent},\n  {path: '/hero/:id', name: 'HeroDetail', component: HeroDetailComponent},\n  {path: '/disaster', name: 'Asteroid', redirectTo: ['CrisisCenter', 'CrisisDetail', {id:3}]}\n])\nexport class AppComponent { }\n```\n\n上述代码我们干了几件事：\n\n  1. 写了一个组件，包含一个`h1`，一个`nav`里面包含两个`a`，还有一个`router-outlet`组件\n  2. 注入了两个服务，`DialogService`, `HeroService`（这一步不属于路由构建步骤）\n  3. 注入了一个指令，`ROUTER_DIRECTIVES`\n  4. 使用`@RouteConfig`，配置子路径和对应的子组件，当/crisis-center/时候，在`router-outlet`中显示`CrisisCenterComponent`组件，当/heroes时候，在`router-outlet`中显示`HeroListComponent`组件，以此类推\n  5. 当导航到/disaster，重定向到`CrisisCenter`的`CrisisDetail`视图。`CrisisCenter`, `CrisisDetail`是父子视图关系，下面会讲到。\n  6. 导出这个组件\n\n好了我们的带有路由的组件编写好了，其实就是个可以切换视图的组件而已，就是这么简单。我们在浏览器中运行程序，点击`nav`中的heroes，就可以把子视图`Heroes`渲染出来了。\n\n![](/css/images/69.jpg)\n\n浏览器路径变为\n\nhttp://localhost:63342/angular2-tutorial/router/index.html/heroes\n\n在原有的基础上加上了/heroes。\n\n## 温习promise\n\n当我们导航到heroes视图的时候，我们就进入了另一个子组件，这个组件需要一个heroes服务，里面用到了Promise，我们在[Angular2 系列教程（七）Injectable、Promise、Interface、使用服务](https://lewis617.github.io/2016/02/28/ng2-service/)讲过Promise，然我们来温习Promise：\n\napp/heroes/hero.service.ts\n\n```ts\nimport {Injectable} from 'angular2/core';\n\nexport class Hero {\n  constructor(public id: number, public name: string) { }\n}\n\n@Injectable()\nexport class HeroService {\n  getHeroes() { return heroesPromise; }\n\n  getHero(id: number | string) {\n    return heroesPromise\n      .then(heroes => heroes.filter(h => h.id === +id)[0]);\n  }\n}\n\nvar HEROES = [\n    new Hero(11, 'Mr. Nice'),\n    new Hero(12, 'Narco'),\n    new Hero(13, 'Bombasto'),\n    new Hero(14, 'Celeritas'),\n    new Hero(15, 'Magneta'),\n    new Hero(16, 'RubberMan')\n];\n\nvar heroesPromise = Promise.resolve(HEROES);\n```\n\n以上代码我们干了几件事：\n\n  1. 写了一个`Hero`类\n  2. 写了一个`HeroService`类，包含两个成员函数\n\n  3. 写了一个数组`HEROES`，里面每一项都是一个`hero`类的实例，也就是个对象（引用类型）\n  4. 定义了一个`heroesPromise`，将`value`设为数组`HEROES`，状态为`resolved`，随时可以使用`then`来获取`value`，也就是数组`HEROES`\n\n温习Promise，Promise的两种构建方法：\n\n  1. `Promise.resolve()`\n  2. `new Promise()`，里面是个function，该function的参数是resolve和reject。\n\n例子（chrome console）：\n\n![](/css/images/70.jpg)\n\n更详细的的用法，可以看我之前讲的Promise：[Angular2 系列教程（七）Injectable、Promise、Interface、使用服务](https://lewis617.github.io/2016/02/28/ng2-service/) 。\n\n## 两个服务：Router、RouteParams\n\n我们的英雄服务写好了，然我们继续看英雄列表组件，当我们想要点击列表的某一项的时候，我们需要一个参数来导航到指定的英雄详情视图，这时候我们就需要`RouteParams`了，导航这个动作出发则需要`Router`服务：\n\napp/heroes/hero-list.component.ts\n\n```ts\n    \n\n// TODO SOMEDAY: Feature Componetized like CrisisCenter\nimport {Component, OnInit}   from 'angular2/core';\nimport {Hero, HeroService}   from './hero.service';\nimport {Router, RouteParams} from 'angular2/router';\n\n@Component({\n  template: `\n    <h2>HEROES</h2>\n    <ul class=\"items\">\n      <li *ngFor=\"#hero of heroes\"\n        [class.selected]=\"isSelected(hero)\"\n        (click)=\"onSelect(hero)\">\n        <span class=\"badge\">{{hero.id}}</span> {{hero.name}}\n      </li>\n    </ul>\n  `\n})\nexport class HeroListComponent implements OnInit {\n  heroes: Hero[];\n\n  private _selectedId: number;\n\n  constructor(\n    private _service: HeroService,\n    private _router: Router,\n    routeParams: RouteParams) {\n      this._selectedId = +routeParams.get('id');\n  }\n\n  isSelected(hero: Hero) { return hero.id === this._selectedId; }\n\n  onSelect(hero: Hero) {\n    this._router.navigate( ['HeroDetail', { id: hero.id }] );\n  }\n\n  ngOnInit() {\n    this._service.getHeroes().then(heroes => this.heroes = heroes)\n  }\n}\n```\n\n以上代码，我们干了几件事：\n\n  1. 渲染一个组件，包括一个列表\n  2. 在构造函数中，将英雄服务`HeroService`、路由服务`Router`、路由参数`RouteParams`传给私有变量\n  3. 写了三个成员函数用于处理相应的业务逻辑\n  4. 其中`this._router.navigate( ['HeroDetail', { id: hero.id }] );`将`app`导航到了`HeroDetail`视图，并带上`id`参数\n  5. 其中`this._service.getHeroes().then(heroes =&gt; this.heroes = heroes)`，用于获取刚才的`heroes`数组，并将其传给`this.heroes`\n\n`Router`服务的使用：\n\n```ts\nthis._router.navigate( ['HeroDetail', { id: hero.id }] );\n```\n\n`RouteParams`服务的使用：\n\n```ts\nthis._selectedId = +routeParams.get('id');\n```\n\n其中`routeParams.get('id')`前面那个`+`代表将其转换为数字类型。\n\n`HeroService`服务的使用：\n\n```ts\nthis._service.getHeroes().then(heroes =>; this.heroes = heroes)\n```\n\n## 引用类型和单例模式的妙用\n\n我们继续看英雄详细视图：\n\napp/heroes/hero-detail.component.ts\n\n```ts\nimport {Component,  OnInit}  from 'angular2/core';\nimport {Hero, HeroService}   from './hero.service';\nimport {RouteParams, Router} from 'angular2/router';\n\n@Component({\n  template: `\n  <h2>HEROES</h2>\n  <div *ngIf=\"hero\">\n    <h3>\"{{hero.name}}\"</h3>\n    <div>\n      <label>Id: </label>{{hero.id}}</div>\n    <div>\n      <label>Name: </label>\n      <input [(ngModel)]=\"hero.name\" placeholder=\"name\"/>\n    </div>\n    <p>\n      <button (click)=\"gotoHeroes()\">Back</button>\n    </p>\n  </div>\n  `,\n})\nexport class HeroDetailComponent implements OnInit  {\n  hero: Hero;\n\n  constructor(\n    private _router:Router,\n    private _routeParams:RouteParams,\n    private _service:HeroService){}\n\n  ngOnInit() {\n    let id = this._routeParams.get('id');\n    this._service.getHero(id).then(hero => this.hero = hero);\n  }\n\n  gotoHeroes() {\n    let heroId = this.hero ? this.hero.id : null;\n    // Pass along the hero id if available\n    // so that the HeroList component can select that hero.\n    // Add a totally useless `foo` parameter for kicks.\n    this._router.navigate(['Heroes',  {id: heroId, foo: 'foo'} ]);\n  }\n}\n```\n上述代码，我们仅仅是获取指定的英雄信息，并渲染出来。那么修改英雄信息是如何实现的呢？就是通过引用类型实现的。\n\n我们知道，在js中，对象和数组是引用类型，也就意味着，当我们将某个对象传给别的变量的时候，仅仅是将对象的地址传给了那个变量，当我们修改那个变量时候，其实对象也被修改了。  \n在这个程序中，我们将`hero`对象传给`this.hero`，并将其双向数据绑定到`input`上：\n\n```ts\n<input [(ngModel)]=\"hero.name\" placeholder=\"name\"/>\n```\n这样当我们改变`input`的值的时候，`this.hero`被改变，服务中的`hero`也被改变，因为是引用类型嘛，其实操作的都是一个对象。再有我们的服务是单例模式，所以全局的`hero`列表都被改变了。\n\n让我们改变`input`的值，并点击back，我们发现英雄列表视图中的数据也被改变了，这就是引用类型和单例模式的妙用。\n\n## Route Parameters or Query Parameters?\n\n当我们点击back返回时候，我们发现URL变成了：\n\nhttp://localhost:63342/angular2-tutorial/router/index.html/heroes?id=11&amp;foo=foo\n\n也就是拥有了Query Parameters：`?id=11&amp;foo=foo`。\n\n为何会这样呢？因为我们指定了参数：\n\n```ts\nthis._router.navigate(['Heroes', {id: heroId, foo: 'foo'}]);\n```\n\n但是英雄列表视图有没有指定的`id`和`foo`的token，所以这两个变量是可选的，所以就自动生成了Query Parameters，好让我们进行select的css重绘。\n\n在英雄详细视图中，我们使用了：`id`这个token。\n\n```ts\n{path: '/hero/:id', name: 'HeroDetail', component: HeroDetailComponent}  \n```\n\n这就是Route Parameters。它是必须的，我们必须要指定id这个参数。这就是Route Parameters 和 Query Parameters的比较。\n\n这节课我们先讲到这里，下节课我们通过\"危机中心\"这个例子，继续讲解路由，将包含路由的嵌套、路由的生命周期等众多炫酷功能！\n\n* * *\n\n\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n\n","source":"_posts/ng2-router-1.md","raw":"---\ntitle: Angular2 系列教程（十）两种启动方法、两个路由服务、引用类型和单例模式的妙用\ndate: 2016-04-04 08:49:00\ntags: [Angular2]\n---\n\n今天我们要讲的是 ng2 的路由系统。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/68.jpg)\n\n例子是官网的例子，包含一个\"危机中心\"和\"英雄列表\"，都在一个app中，通过路由来控制切换视图。还包含了Promise的用法，服务的用法等多个知识点。\n\n源代码：\n\n<https://github.com/lewis617/angular2-tutorial/tree/gh-pages/router>\n\n运行方法：\n\n在根目录下运行：\n\n```sh    \nhttp-server\n```\n\n## 引入库文件设置base href  \n\n路由并不在ng2中，需要我们额外引入，另外我们需要设置base href，这是个什么东西呢？相当于我们后续所有 URL 的\"前缀\"，因为我们的app默认是基于[HTML 5 pushState](https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries) 风格的路由，所以我们需要加上base href，来保证当我们导航到深层次的 URL 时候，资源可以被正确加载：\n\nindex.html\n\n```html   \n<!-- Add the router library -->\n<script src=\"lib/router.dev.js\"></script>\n\n<!-- Set the base href -->\n<script>document.write('<base href=\"' + document.location + '\" />');</script>\n\n```\n## 两种启动方法\n\napp/main.ts\n\n```ts\nimport {bootstrap}        from 'angular2/platform/browser';\nimport {ROUTER_PROVIDERS} from 'angular2/router';\n\nimport {AppComponent}     from './app.component';\n\n// Add these symbols to override the `LocationStrategy`\n//import {provide}           from 'angular2/core';\n//import {LocationStrategy,\n//        HashLocationStrategy} from 'angular2/router';\n\nbootstrap(AppComponent, [ROUTER_PROVIDERS,\n  //provide(LocationStrategy,\n  //       {useClass: HashLocationStrategy}) // .../#/crisis-center/\n ]);\n```\n\n这种启动方法采取默认的 [HTML 5 pushState](https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries) 风格，没有#号，但是存在一个弊端。就是当我们在子路经刷新浏览器时候，会出现404的错误。~~解决办法可以将所有的路由都指向根目录，但是我们使用了http-server，显然不太方便设置。~~ （可以通过设置base href为“/“来解决！）所以还有另外一种风格，就是老式风格，和ng1一样的，带有#的路由风格，它的启动方法是：\n\n```ts\nimport {bootstrap}        from 'angular2/platform/browser';\nimport {ROUTER_PROVIDERS} from 'angular2/router';\n\nimport {AppComponent}     from './app.component';\n\n// Add these symbols to override the `LocationStrategy`\nimport {provide}           from 'angular2/core';\nimport {LocationStrategy,\n    HashLocationStrategy} from 'angular2/router';\n\nbootstrap(AppComponent, [ROUTER_PROVIDERS,\nprovide(LocationStrategy,\n     {useClass: HashLocationStrategy}) // .../#/crisis-center/\n]);\n\n```\n\n如此一来，我们的app的路由就全部带上#了，当你刷新页面时候，也不会出现404的错误了，但是url的可读性没有 [HTML 5 pushState](https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries) 风格好看。\n\n## ROUTER_DIRECTIVES、RouteConfig、routerLink、router-outlet\n\n路由的编写很简单，我们只需要在我们的组件中进行配置就行了：\n\napp/app.component.ts\n\n```ts\nimport {Component} from 'angular2/core';\nimport {RouteConfig, ROUTER_DIRECTIVES} from 'angular2/router';\n\nimport {CrisisCenterComponent} from './crisis-center/crisis-center.component';\nimport {HeroListComponent}     from './heroes/hero-list.component';\nimport {HeroDetailComponent}   from './heroes/hero-detail.component';\n\nimport {DialogService}         from './dialog.service';\nimport {HeroService}           from './heroes/hero.service';\n\n@Component({\n  selector: 'my-app',\n  template: `\n    <h1 class=\"title\">Component Router</h1>\n    <nav>\n      <a [routerLink]=\"['CrisisCenter']\">Crisis Center</a>\n      <a [routerLink]=\"['Heroes']\">Heroes</a>\n    </nav>\n    <router-outlet></router-outlet>\n  `,\n  providers:  [DialogService, HeroService],\n  directives: [ROUTER_DIRECTIVES]\n})\n@RouteConfig([\n\n  { // Crisis Center child route\n    path: '/crisis-center/...',\n    name: 'CrisisCenter',\n    component: CrisisCenterComponent,\n    useAsDefault: true\n  },\n\n  {path: '/heroes',   name: 'Heroes',     component: HeroListComponent},\n  {path: '/hero/:id', name: 'HeroDetail', component: HeroDetailComponent},\n  {path: '/disaster', name: 'Asteroid', redirectTo: ['CrisisCenter', 'CrisisDetail', {id:3}]}\n])\nexport class AppComponent { }\n```\n\n上述代码我们干了几件事：\n\n  1. 写了一个组件，包含一个`h1`，一个`nav`里面包含两个`a`，还有一个`router-outlet`组件\n  2. 注入了两个服务，`DialogService`, `HeroService`（这一步不属于路由构建步骤）\n  3. 注入了一个指令，`ROUTER_DIRECTIVES`\n  4. 使用`@RouteConfig`，配置子路径和对应的子组件，当/crisis-center/时候，在`router-outlet`中显示`CrisisCenterComponent`组件，当/heroes时候，在`router-outlet`中显示`HeroListComponent`组件，以此类推\n  5. 当导航到/disaster，重定向到`CrisisCenter`的`CrisisDetail`视图。`CrisisCenter`, `CrisisDetail`是父子视图关系，下面会讲到。\n  6. 导出这个组件\n\n好了我们的带有路由的组件编写好了，其实就是个可以切换视图的组件而已，就是这么简单。我们在浏览器中运行程序，点击`nav`中的heroes，就可以把子视图`Heroes`渲染出来了。\n\n![](/css/images/69.jpg)\n\n浏览器路径变为\n\nhttp://localhost:63342/angular2-tutorial/router/index.html/heroes\n\n在原有的基础上加上了/heroes。\n\n## 温习promise\n\n当我们导航到heroes视图的时候，我们就进入了另一个子组件，这个组件需要一个heroes服务，里面用到了Promise，我们在[Angular2 系列教程（七）Injectable、Promise、Interface、使用服务](https://lewis617.github.io/2016/02/28/ng2-service/)讲过Promise，然我们来温习Promise：\n\napp/heroes/hero.service.ts\n\n```ts\nimport {Injectable} from 'angular2/core';\n\nexport class Hero {\n  constructor(public id: number, public name: string) { }\n}\n\n@Injectable()\nexport class HeroService {\n  getHeroes() { return heroesPromise; }\n\n  getHero(id: number | string) {\n    return heroesPromise\n      .then(heroes => heroes.filter(h => h.id === +id)[0]);\n  }\n}\n\nvar HEROES = [\n    new Hero(11, 'Mr. Nice'),\n    new Hero(12, 'Narco'),\n    new Hero(13, 'Bombasto'),\n    new Hero(14, 'Celeritas'),\n    new Hero(15, 'Magneta'),\n    new Hero(16, 'RubberMan')\n];\n\nvar heroesPromise = Promise.resolve(HEROES);\n```\n\n以上代码我们干了几件事：\n\n  1. 写了一个`Hero`类\n  2. 写了一个`HeroService`类，包含两个成员函数\n\n  3. 写了一个数组`HEROES`，里面每一项都是一个`hero`类的实例，也就是个对象（引用类型）\n  4. 定义了一个`heroesPromise`，将`value`设为数组`HEROES`，状态为`resolved`，随时可以使用`then`来获取`value`，也就是数组`HEROES`\n\n温习Promise，Promise的两种构建方法：\n\n  1. `Promise.resolve()`\n  2. `new Promise()`，里面是个function，该function的参数是resolve和reject。\n\n例子（chrome console）：\n\n![](/css/images/70.jpg)\n\n更详细的的用法，可以看我之前讲的Promise：[Angular2 系列教程（七）Injectable、Promise、Interface、使用服务](https://lewis617.github.io/2016/02/28/ng2-service/) 。\n\n## 两个服务：Router、RouteParams\n\n我们的英雄服务写好了，然我们继续看英雄列表组件，当我们想要点击列表的某一项的时候，我们需要一个参数来导航到指定的英雄详情视图，这时候我们就需要`RouteParams`了，导航这个动作出发则需要`Router`服务：\n\napp/heroes/hero-list.component.ts\n\n```ts\n    \n\n// TODO SOMEDAY: Feature Componetized like CrisisCenter\nimport {Component, OnInit}   from 'angular2/core';\nimport {Hero, HeroService}   from './hero.service';\nimport {Router, RouteParams} from 'angular2/router';\n\n@Component({\n  template: `\n    <h2>HEROES</h2>\n    <ul class=\"items\">\n      <li *ngFor=\"#hero of heroes\"\n        [class.selected]=\"isSelected(hero)\"\n        (click)=\"onSelect(hero)\">\n        <span class=\"badge\">{{hero.id}}</span> {{hero.name}}\n      </li>\n    </ul>\n  `\n})\nexport class HeroListComponent implements OnInit {\n  heroes: Hero[];\n\n  private _selectedId: number;\n\n  constructor(\n    private _service: HeroService,\n    private _router: Router,\n    routeParams: RouteParams) {\n      this._selectedId = +routeParams.get('id');\n  }\n\n  isSelected(hero: Hero) { return hero.id === this._selectedId; }\n\n  onSelect(hero: Hero) {\n    this._router.navigate( ['HeroDetail', { id: hero.id }] );\n  }\n\n  ngOnInit() {\n    this._service.getHeroes().then(heroes => this.heroes = heroes)\n  }\n}\n```\n\n以上代码，我们干了几件事：\n\n  1. 渲染一个组件，包括一个列表\n  2. 在构造函数中，将英雄服务`HeroService`、路由服务`Router`、路由参数`RouteParams`传给私有变量\n  3. 写了三个成员函数用于处理相应的业务逻辑\n  4. 其中`this._router.navigate( ['HeroDetail', { id: hero.id }] );`将`app`导航到了`HeroDetail`视图，并带上`id`参数\n  5. 其中`this._service.getHeroes().then(heroes =&gt; this.heroes = heroes)`，用于获取刚才的`heroes`数组，并将其传给`this.heroes`\n\n`Router`服务的使用：\n\n```ts\nthis._router.navigate( ['HeroDetail', { id: hero.id }] );\n```\n\n`RouteParams`服务的使用：\n\n```ts\nthis._selectedId = +routeParams.get('id');\n```\n\n其中`routeParams.get('id')`前面那个`+`代表将其转换为数字类型。\n\n`HeroService`服务的使用：\n\n```ts\nthis._service.getHeroes().then(heroes =>; this.heroes = heroes)\n```\n\n## 引用类型和单例模式的妙用\n\n我们继续看英雄详细视图：\n\napp/heroes/hero-detail.component.ts\n\n```ts\nimport {Component,  OnInit}  from 'angular2/core';\nimport {Hero, HeroService}   from './hero.service';\nimport {RouteParams, Router} from 'angular2/router';\n\n@Component({\n  template: `\n  <h2>HEROES</h2>\n  <div *ngIf=\"hero\">\n    <h3>\"{{hero.name}}\"</h3>\n    <div>\n      <label>Id: </label>{{hero.id}}</div>\n    <div>\n      <label>Name: </label>\n      <input [(ngModel)]=\"hero.name\" placeholder=\"name\"/>\n    </div>\n    <p>\n      <button (click)=\"gotoHeroes()\">Back</button>\n    </p>\n  </div>\n  `,\n})\nexport class HeroDetailComponent implements OnInit  {\n  hero: Hero;\n\n  constructor(\n    private _router:Router,\n    private _routeParams:RouteParams,\n    private _service:HeroService){}\n\n  ngOnInit() {\n    let id = this._routeParams.get('id');\n    this._service.getHero(id).then(hero => this.hero = hero);\n  }\n\n  gotoHeroes() {\n    let heroId = this.hero ? this.hero.id : null;\n    // Pass along the hero id if available\n    // so that the HeroList component can select that hero.\n    // Add a totally useless `foo` parameter for kicks.\n    this._router.navigate(['Heroes',  {id: heroId, foo: 'foo'} ]);\n  }\n}\n```\n上述代码，我们仅仅是获取指定的英雄信息，并渲染出来。那么修改英雄信息是如何实现的呢？就是通过引用类型实现的。\n\n我们知道，在js中，对象和数组是引用类型，也就意味着，当我们将某个对象传给别的变量的时候，仅仅是将对象的地址传给了那个变量，当我们修改那个变量时候，其实对象也被修改了。  \n在这个程序中，我们将`hero`对象传给`this.hero`，并将其双向数据绑定到`input`上：\n\n```ts\n<input [(ngModel)]=\"hero.name\" placeholder=\"name\"/>\n```\n这样当我们改变`input`的值的时候，`this.hero`被改变，服务中的`hero`也被改变，因为是引用类型嘛，其实操作的都是一个对象。再有我们的服务是单例模式，所以全局的`hero`列表都被改变了。\n\n让我们改变`input`的值，并点击back，我们发现英雄列表视图中的数据也被改变了，这就是引用类型和单例模式的妙用。\n\n## Route Parameters or Query Parameters?\n\n当我们点击back返回时候，我们发现URL变成了：\n\nhttp://localhost:63342/angular2-tutorial/router/index.html/heroes?id=11&amp;foo=foo\n\n也就是拥有了Query Parameters：`?id=11&amp;foo=foo`。\n\n为何会这样呢？因为我们指定了参数：\n\n```ts\nthis._router.navigate(['Heroes', {id: heroId, foo: 'foo'}]);\n```\n\n但是英雄列表视图有没有指定的`id`和`foo`的token，所以这两个变量是可选的，所以就自动生成了Query Parameters，好让我们进行select的css重绘。\n\n在英雄详细视图中，我们使用了：`id`这个token。\n\n```ts\n{path: '/hero/:id', name: 'HeroDetail', component: HeroDetailComponent}  \n```\n\n这就是Route Parameters。它是必须的，我们必须要指定id这个参数。这就是Route Parameters 和 Query Parameters的比较。\n\n这节课我们先讲到这里，下节课我们通过\"危机中心\"这个例子，继续讲解路由，将包含路由的嵌套、路由的生命周期等众多炫酷功能！\n\n* * *\n\n\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n\n","slug":"ng2-router-1","published":1,"updated":"2019-05-01T08:10:29.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvlz001vtgytjhmxc861","content":"<p>今天我们要讲的是 ng2 的路由系统。</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/68.jpg\" alt=\"\"></p>\n<p>例子是官网的例子，包含一个”危机中心”和”英雄列表”，都在一个app中，通过路由来控制切换视图。还包含了Promise的用法，服务的用法等多个知识点。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/router\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial/tree/gh-pages/router</a></p>\n<p>运行方法：</p>\n<p>在根目录下运行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server</span><br></pre></td></tr></table></figure>\n<h2 id=\"引入库文件设置base-href\"><a href=\"#引入库文件设置base-href\" class=\"headerlink\" title=\"引入库文件设置base href\"></a>引入库文件设置base href</h2><p>路由并不在ng2中，需要我们额外引入，另外我们需要设置base href，这是个什么东西呢？相当于我们后续所有 URL 的”前缀”，因为我们的app默认是基于<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" target=\"_blank\" rel=\"noopener\">HTML 5 pushState</a> 风格的路由，所以我们需要加上base href，来保证当我们导航到深层次的 URL 时候，资源可以被正确加载：</p>\n<p>index.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Add the router library --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"lib/router.dev.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Set the base href --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"built_in\">document</span>.write(<span class=\"string\">'&lt;base href=\"'</span> + <span class=\"built_in\">document</span>.location + <span class=\"string\">'\" /&gt;'</span>);</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"两种启动方法\"><a href=\"#两种启动方法\" class=\"headerlink\" title=\"两种启动方法\"></a>两种启动方法</h2><p>app/main.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;bootstrap&#125;        <span class=\"keyword\">from</span> <span class=\"string\">'angular2/platform/browser'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;ROUTER_PROVIDERS&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;AppComponent&#125;     <span class=\"keyword\">from</span> <span class=\"string\">'./app.component'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Add these symbols to override the `LocationStrategy`</span></span><br><span class=\"line\"><span class=\"comment\">//import &#123;provide&#125;           from 'angular2/core';</span></span><br><span class=\"line\"><span class=\"comment\">//import &#123;LocationStrategy,</span></span><br><span class=\"line\"><span class=\"comment\">//        HashLocationStrategy&#125; from 'angular2/router';</span></span><br><span class=\"line\"></span><br><span class=\"line\">bootstrap(AppComponent, [ROUTER_PROVIDERS,</span><br><span class=\"line\">  <span class=\"comment\">//provide(LocationStrategy,</span></span><br><span class=\"line\">  <span class=\"comment\">//       &#123;useClass: HashLocationStrategy&#125;) // .../#/crisis-center/</span></span><br><span class=\"line\"> ]);</span><br></pre></td></tr></table></figure>\n<p>这种启动方法采取默认的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" target=\"_blank\" rel=\"noopener\">HTML 5 pushState</a> 风格，没有#号，但是存在一个弊端。就是当我们在子路经刷新浏览器时候，会出现404的错误。<del>解决办法可以将所有的路由都指向根目录，但是我们使用了http-server，显然不太方便设置。</del> （可以通过设置base href为“/“来解决！）所以还有另外一种风格，就是老式风格，和ng1一样的，带有#的路由风格，它的启动方法是：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;bootstrap&#125;        <span class=\"keyword\">from</span> <span class=\"string\">'angular2/platform/browser'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;ROUTER_PROVIDERS&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;AppComponent&#125;     <span class=\"keyword\">from</span> <span class=\"string\">'./app.component'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Add these symbols to override the `LocationStrategy`</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;provide&#125;           <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;LocationStrategy,</span><br><span class=\"line\">    HashLocationStrategy&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bootstrap(AppComponent, [ROUTER_PROVIDERS,</span><br><span class=\"line\">provide(LocationStrategy,</span><br><span class=\"line\">     &#123;useClass: HashLocationStrategy&#125;) <span class=\"comment\">// .../#/crisis-center/</span></span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>\n<p>如此一来，我们的app的路由就全部带上#了，当你刷新页面时候，也不会出现404的错误了，但是url的可读性没有 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" target=\"_blank\" rel=\"noopener\">HTML 5 pushState</a> 风格好看。</p>\n<h2 id=\"ROUTER-DIRECTIVES、RouteConfig、routerLink、router-outlet\"><a href=\"#ROUTER-DIRECTIVES、RouteConfig、routerLink、router-outlet\" class=\"headerlink\" title=\"ROUTER_DIRECTIVES、RouteConfig、routerLink、router-outlet\"></a>ROUTER_DIRECTIVES、RouteConfig、routerLink、router-outlet</h2><p>路由的编写很简单，我们只需要在我们的组件中进行配置就行了：</p>\n<p>app/app.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;RouteConfig, ROUTER_DIRECTIVES&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;CrisisCenterComponent&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./crisis-center/crisis-center.component'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;HeroListComponent&#125;     <span class=\"keyword\">from</span> <span class=\"string\">'./heroes/hero-list.component'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;HeroDetailComponent&#125;   <span class=\"keyword\">from</span> <span class=\"string\">'./heroes/hero-detail.component'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;DialogService&#125;         <span class=\"keyword\">from</span> <span class=\"string\">'./dialog.service'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;HeroService&#125;           <span class=\"keyword\">from</span> <span class=\"string\">'./heroes/hero.service'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  selector: <span class=\"string\">'my-app'</span>,</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;h1 class=\"title\"&gt;Component Router&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;nav&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a [routerLink]=\"['CrisisCenter']\"&gt;Crisis Center&lt;/a&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a [routerLink]=\"['Heroes']\"&gt;Heroes&lt;/a&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/nav&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;router-outlet&gt;&lt;/router-outlet&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>,</span><br><span class=\"line\">  providers:  [DialogService, HeroService],</span><br><span class=\"line\">  directives: [ROUTER_DIRECTIVES]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"meta\">@RouteConfig</span>([</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123; <span class=\"comment\">// Crisis Center child route</span></span><br><span class=\"line\">    path: <span class=\"string\">'/crisis-center/...'</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'CrisisCenter'</span>,</span><br><span class=\"line\">    component: CrisisCenterComponent,</span><br><span class=\"line\">    useAsDefault: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;path: <span class=\"string\">'/heroes'</span>,   name: <span class=\"string\">'Heroes'</span>,     component: HeroListComponent&#125;,</span><br><span class=\"line\">  &#123;path: <span class=\"string\">'/hero/:id'</span>, name: <span class=\"string\">'HeroDetail'</span>, component: HeroDetailComponent&#125;,</span><br><span class=\"line\">  &#123;path: <span class=\"string\">'/disaster'</span>, name: <span class=\"string\">'Asteroid'</span>, redirectTo: [<span class=\"string\">'CrisisCenter'</span>, <span class=\"string\">'CrisisDetail'</span>, &#123;id:<span class=\"number\">3</span>&#125;]&#125;</span><br><span class=\"line\">])</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> AppComponent &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码我们干了几件事：</p>\n<ol>\n<li>写了一个组件，包含一个<code>h1</code>，一个<code>nav</code>里面包含两个<code>a</code>，还有一个<code>router-outlet</code>组件</li>\n<li>注入了两个服务，<code>DialogService</code>, <code>HeroService</code>（这一步不属于路由构建步骤）</li>\n<li>注入了一个指令，<code>ROUTER_DIRECTIVES</code></li>\n<li>使用<code>@RouteConfig</code>，配置子路径和对应的子组件，当/crisis-center/时候，在<code>router-outlet</code>中显示<code>CrisisCenterComponent</code>组件，当/heroes时候，在<code>router-outlet</code>中显示<code>HeroListComponent</code>组件，以此类推</li>\n<li>当导航到/disaster，重定向到<code>CrisisCenter</code>的<code>CrisisDetail</code>视图。<code>CrisisCenter</code>, <code>CrisisDetail</code>是父子视图关系，下面会讲到。</li>\n<li>导出这个组件</li>\n</ol>\n<p>好了我们的带有路由的组件编写好了，其实就是个可以切换视图的组件而已，就是这么简单。我们在浏览器中运行程序，点击<code>nav</code>中的heroes，就可以把子视图<code>Heroes</code>渲染出来了。</p>\n<p><img src=\"/css/images/69.jpg\" alt=\"\"></p>\n<p>浏览器路径变为</p>\n<p><a href=\"http://localhost:63342/angular2-tutorial/router/index.html/heroes\" target=\"_blank\" rel=\"noopener\">http://localhost:63342/angular2-tutorial/router/index.html/heroes</a></p>\n<p>在原有的基础上加上了/heroes。</p>\n<h2 id=\"温习promise\"><a href=\"#温习promise\" class=\"headerlink\" title=\"温习promise\"></a>温习promise</h2><p>当我们导航到heroes视图的时候，我们就进入了另一个子组件，这个组件需要一个heroes服务，里面用到了Promise，我们在<a href=\"https://lewis617.github.io/2016/02/28/ng2-service/\" target=\"_blank\" rel=\"noopener\">Angular2 系列教程（七）Injectable、Promise、Interface、使用服务</a>讲过Promise，然我们来温习Promise：</p>\n<p>app/heroes/hero.service.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Injectable&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> Hero &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> id: <span class=\"built_in\">number</span>, <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroService &#123;</span><br><span class=\"line\">  getHeroes() &#123; <span class=\"keyword\">return</span> heroesPromise; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getHero(id: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> heroesPromise</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">heroes</span> =&gt;</span> heroes.filter(<span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h.id === +id)[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> HEROES = [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Hero(<span class=\"number\">11</span>, <span class=\"string\">'Mr. Nice'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Hero(<span class=\"number\">12</span>, <span class=\"string\">'Narco'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Hero(<span class=\"number\">13</span>, <span class=\"string\">'Bombasto'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Hero(<span class=\"number\">14</span>, <span class=\"string\">'Celeritas'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Hero(<span class=\"number\">15</span>, <span class=\"string\">'Magneta'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Hero(<span class=\"number\">16</span>, <span class=\"string\">'RubberMan'</span>)</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> heroesPromise = <span class=\"built_in\">Promise</span>.resolve(HEROES);</span><br></pre></td></tr></table></figure>\n<p>以上代码我们干了几件事：</p>\n<ol>\n<li>写了一个<code>Hero</code>类</li>\n<li><p>写了一个<code>HeroService</code>类，包含两个成员函数</p>\n</li>\n<li><p>写了一个数组<code>HEROES</code>，里面每一项都是一个<code>hero</code>类的实例，也就是个对象（引用类型）</p>\n</li>\n<li>定义了一个<code>heroesPromise</code>，将<code>value</code>设为数组<code>HEROES</code>，状态为<code>resolved</code>，随时可以使用<code>then</code>来获取<code>value</code>，也就是数组<code>HEROES</code></li>\n</ol>\n<p>温习Promise，Promise的两种构建方法：</p>\n<ol>\n<li><code>Promise.resolve()</code></li>\n<li><code>new Promise()</code>，里面是个function，该function的参数是resolve和reject。</li>\n</ol>\n<p>例子（chrome console）：</p>\n<p><img src=\"/css/images/70.jpg\" alt=\"\"></p>\n<p>更详细的的用法，可以看我之前讲的Promise：<a href=\"https://lewis617.github.io/2016/02/28/ng2-service/\" target=\"_blank\" rel=\"noopener\">Angular2 系列教程（七）Injectable、Promise、Interface、使用服务</a> 。</p>\n<h2 id=\"两个服务：Router、RouteParams\"><a href=\"#两个服务：Router、RouteParams\" class=\"headerlink\" title=\"两个服务：Router、RouteParams\"></a>两个服务：Router、RouteParams</h2><p>我们的英雄服务写好了，然我们继续看英雄列表组件，当我们想要点击列表的某一项的时候，我们需要一个参数来导航到指定的英雄详情视图，这时候我们就需要<code>RouteParams</code>了，导航这个动作出发则需要<code>Router</code>服务：</p>\n<p>app/heroes/hero-list.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO SOMEDAY: Feature Componetized like CrisisCenter</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component, OnInit&#125;   <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Hero, HeroService&#125;   <span class=\"keyword\">from</span> <span class=\"string\">'./hero.service'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Router, RouteParams&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;h2&gt;HEROES&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;ul class=\"items\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;li *ngFor=\"#hero of heroes\"</span></span><br><span class=\"line\"><span class=\"string\">        [class.selected]=\"isSelected(hero)\"</span></span><br><span class=\"line\"><span class=\"string\">        (click)=\"onSelect(hero)\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;span class=\"badge\"&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroListComponent <span class=\"keyword\">implements</span> OnInit &#123;</span><br><span class=\"line\">  heroes: Hero[];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> _selectedId: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> _service: HeroService,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> _router: Router,</span></span><br><span class=\"line\"><span class=\"params\">    routeParams: RouteParams</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._selectedId = +routeParams.get(<span class=\"string\">'id'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isSelected(hero: Hero) &#123; <span class=\"keyword\">return</span> hero.id === <span class=\"keyword\">this</span>._selectedId; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  onSelect(hero: Hero) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._router.navigate( [<span class=\"string\">'HeroDetail'</span>, &#123; id: hero.id &#125;] );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._service.getHeroes().then(<span class=\"function\"><span class=\"params\">heroes</span> =&gt;</span> <span class=\"keyword\">this</span>.heroes = heroes)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码，我们干了几件事：</p>\n<ol>\n<li>渲染一个组件，包括一个列表</li>\n<li>在构造函数中，将英雄服务<code>HeroService</code>、路由服务<code>Router</code>、路由参数<code>RouteParams</code>传给私有变量</li>\n<li>写了三个成员函数用于处理相应的业务逻辑</li>\n<li>其中<code>this._router.navigate( [&#39;HeroDetail&#39;, { id: hero.id }] );</code>将<code>app</code>导航到了<code>HeroDetail</code>视图，并带上<code>id</code>参数</li>\n<li>其中<code>this._service.getHeroes().then(heroes =&amp;gt; this.heroes = heroes)</code>，用于获取刚才的<code>heroes</code>数组，并将其传给<code>this.heroes</code></li>\n</ol>\n<p><code>Router</code>服务的使用：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._router.navigate( [<span class=\"string\">'HeroDetail'</span>, &#123; id: hero.id &#125;] );</span><br></pre></td></tr></table></figure>\n<p><code>RouteParams</code>服务的使用：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._selectedId = +routeParams.get(<span class=\"string\">'id'</span>);</span><br></pre></td></tr></table></figure>\n<p>其中<code>routeParams.get(&#39;id&#39;)</code>前面那个<code>+</code>代表将其转换为数字类型。</p>\n<p><code>HeroService</code>服务的使用：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._service.getHeroes().then(<span class=\"function\"><span class=\"params\">heroes</span> =&gt;</span>; <span class=\"keyword\">this</span>.heroes = heroes)</span><br></pre></td></tr></table></figure>\n<h2 id=\"引用类型和单例模式的妙用\"><a href=\"#引用类型和单例模式的妙用\" class=\"headerlink\" title=\"引用类型和单例模式的妙用\"></a>引用类型和单例模式的妙用</h2><p>我们继续看英雄详细视图：</p>\n<p>app/heroes/hero-detail.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component,  OnInit&#125;  <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Hero, HeroService&#125;   <span class=\"keyword\">from</span> <span class=\"string\">'./hero.service'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;RouteParams, Router&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  &lt;h2&gt;HEROES&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;div *ngIf=\"hero\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;h3&gt;\"&#123;&#123;hero.name&#125;&#125;\"&lt;/h3&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;label&gt;Id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;label&gt;Name: &lt;/label&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;input [(ngModel)]=\"hero.name\" placeholder=\"name\"/&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;button (click)=\"gotoHeroes()\"&gt;Back&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroDetailComponent <span class=\"keyword\">implements</span> OnInit  &#123;</span><br><span class=\"line\">  hero: Hero;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> _router:Router,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> _routeParams:RouteParams,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> _service:HeroService</span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> id = <span class=\"keyword\">this</span>._routeParams.get(<span class=\"string\">'id'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._service.getHero(id).then(<span class=\"function\"><span class=\"params\">hero</span> =&gt;</span> <span class=\"keyword\">this</span>.hero = hero);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  gotoHeroes() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> heroId = <span class=\"keyword\">this</span>.hero ? <span class=\"keyword\">this</span>.hero.id : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Pass along the hero id if available</span></span><br><span class=\"line\">    <span class=\"comment\">// so that the HeroList component can select that hero.</span></span><br><span class=\"line\">    <span class=\"comment\">// Add a totally useless `foo` parameter for kicks.</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._router.navigate([<span class=\"string\">'Heroes'</span>,  &#123;id: heroId, foo: <span class=\"string\">'foo'</span>&#125; ]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码，我们仅仅是获取指定的英雄信息，并渲染出来。那么修改英雄信息是如何实现的呢？就是通过引用类型实现的。</p>\n<p>我们知道，在js中，对象和数组是引用类型，也就意味着，当我们将某个对象传给别的变量的时候，仅仅是将对象的地址传给了那个变量，当我们修改那个变量时候，其实对象也被修改了。<br>在这个程序中，我们将<code>hero</code>对象传给<code>this.hero</code>，并将其双向数据绑定到<code>input</code>上：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input [(ngModel)]=<span class=\"string\">\"hero.name\"</span> placeholder=<span class=\"string\">\"name\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p>这样当我们改变<code>input</code>的值的时候，<code>this.hero</code>被改变，服务中的<code>hero</code>也被改变，因为是引用类型嘛，其实操作的都是一个对象。再有我们的服务是单例模式，所以全局的<code>hero</code>列表都被改变了。</p>\n<p>让我们改变<code>input</code>的值，并点击back，我们发现英雄列表视图中的数据也被改变了，这就是引用类型和单例模式的妙用。</p>\n<h2 id=\"Route-Parameters-or-Query-Parameters\"><a href=\"#Route-Parameters-or-Query-Parameters\" class=\"headerlink\" title=\"Route Parameters or Query Parameters?\"></a>Route Parameters or Query Parameters?</h2><p>当我们点击back返回时候，我们发现URL变成了：</p>\n<p><a href=\"http://localhost:63342/angular2-tutorial/router/index.html/heroes?id=11&amp;foo=foo\" target=\"_blank\" rel=\"noopener\">http://localhost:63342/angular2-tutorial/router/index.html/heroes?id=11&amp;foo=foo</a></p>\n<p>也就是拥有了Query Parameters：<code>?id=11&amp;amp;foo=foo</code>。</p>\n<p>为何会这样呢？因为我们指定了参数：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._router.navigate([<span class=\"string\">'Heroes'</span>, &#123;id: heroId, foo: <span class=\"string\">'foo'</span>&#125;]);</span><br></pre></td></tr></table></figure>\n<p>但是英雄列表视图有没有指定的<code>id</code>和<code>foo</code>的token，所以这两个变量是可选的，所以就自动生成了Query Parameters，好让我们进行select的css重绘。</p>\n<p>在英雄详细视图中，我们使用了：<code>id</code>这个token。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;path: <span class=\"string\">'/hero/:id'</span>, name: <span class=\"string\">'HeroDetail'</span>, component: HeroDetailComponent&#125;</span><br></pre></td></tr></table></figure>\n<p>这就是Route Parameters。它是必须的，我们必须要指定id这个参数。这就是Route Parameters 和 Query Parameters的比较。</p>\n<p>这节课我们先讲到这里，下节课我们通过”危机中心”这个例子，继续讲解路由，将包含路由的嵌套、路由的生命周期等众多炫酷功能！</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天我们要讲的是 ng2 的路由系统。</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/68.jpg\" alt=\"\"></p>\n<p>例子是官网的例子，包含一个”危机中心”和”英雄列表”，都在一个app中，通过路由来控制切换视图。还包含了Promise的用法，服务的用法等多个知识点。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/router\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial/tree/gh-pages/router</a></p>\n<p>运行方法：</p>\n<p>在根目录下运行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server</span><br></pre></td></tr></table></figure>\n<h2 id=\"引入库文件设置base-href\"><a href=\"#引入库文件设置base-href\" class=\"headerlink\" title=\"引入库文件设置base href\"></a>引入库文件设置base href</h2><p>路由并不在ng2中，需要我们额外引入，另外我们需要设置base href，这是个什么东西呢？相当于我们后续所有 URL 的”前缀”，因为我们的app默认是基于<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" target=\"_blank\" rel=\"noopener\">HTML 5 pushState</a> 风格的路由，所以我们需要加上base href，来保证当我们导航到深层次的 URL 时候，资源可以被正确加载：</p>\n<p>index.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Add the router library --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"lib/router.dev.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Set the base href --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"built_in\">document</span>.write(<span class=\"string\">'&lt;base href=\"'</span> + <span class=\"built_in\">document</span>.location + <span class=\"string\">'\" /&gt;'</span>);</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"两种启动方法\"><a href=\"#两种启动方法\" class=\"headerlink\" title=\"两种启动方法\"></a>两种启动方法</h2><p>app/main.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;bootstrap&#125;        <span class=\"keyword\">from</span> <span class=\"string\">'angular2/platform/browser'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;ROUTER_PROVIDERS&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;AppComponent&#125;     <span class=\"keyword\">from</span> <span class=\"string\">'./app.component'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Add these symbols to override the `LocationStrategy`</span></span><br><span class=\"line\"><span class=\"comment\">//import &#123;provide&#125;           from 'angular2/core';</span></span><br><span class=\"line\"><span class=\"comment\">//import &#123;LocationStrategy,</span></span><br><span class=\"line\"><span class=\"comment\">//        HashLocationStrategy&#125; from 'angular2/router';</span></span><br><span class=\"line\"></span><br><span class=\"line\">bootstrap(AppComponent, [ROUTER_PROVIDERS,</span><br><span class=\"line\">  <span class=\"comment\">//provide(LocationStrategy,</span></span><br><span class=\"line\">  <span class=\"comment\">//       &#123;useClass: HashLocationStrategy&#125;) // .../#/crisis-center/</span></span><br><span class=\"line\"> ]);</span><br></pre></td></tr></table></figure>\n<p>这种启动方法采取默认的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" target=\"_blank\" rel=\"noopener\">HTML 5 pushState</a> 风格，没有#号，但是存在一个弊端。就是当我们在子路经刷新浏览器时候，会出现404的错误。<del>解决办法可以将所有的路由都指向根目录，但是我们使用了http-server，显然不太方便设置。</del> （可以通过设置base href为“/“来解决！）所以还有另外一种风格，就是老式风格，和ng1一样的，带有#的路由风格，它的启动方法是：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;bootstrap&#125;        <span class=\"keyword\">from</span> <span class=\"string\">'angular2/platform/browser'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;ROUTER_PROVIDERS&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;AppComponent&#125;     <span class=\"keyword\">from</span> <span class=\"string\">'./app.component'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Add these symbols to override the `LocationStrategy`</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;provide&#125;           <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;LocationStrategy,</span><br><span class=\"line\">    HashLocationStrategy&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bootstrap(AppComponent, [ROUTER_PROVIDERS,</span><br><span class=\"line\">provide(LocationStrategy,</span><br><span class=\"line\">     &#123;useClass: HashLocationStrategy&#125;) <span class=\"comment\">// .../#/crisis-center/</span></span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>\n<p>如此一来，我们的app的路由就全部带上#了，当你刷新页面时候，也不会出现404的错误了，但是url的可读性没有 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\" target=\"_blank\" rel=\"noopener\">HTML 5 pushState</a> 风格好看。</p>\n<h2 id=\"ROUTER-DIRECTIVES、RouteConfig、routerLink、router-outlet\"><a href=\"#ROUTER-DIRECTIVES、RouteConfig、routerLink、router-outlet\" class=\"headerlink\" title=\"ROUTER_DIRECTIVES、RouteConfig、routerLink、router-outlet\"></a>ROUTER_DIRECTIVES、RouteConfig、routerLink、router-outlet</h2><p>路由的编写很简单，我们只需要在我们的组件中进行配置就行了：</p>\n<p>app/app.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;RouteConfig, ROUTER_DIRECTIVES&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;CrisisCenterComponent&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./crisis-center/crisis-center.component'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;HeroListComponent&#125;     <span class=\"keyword\">from</span> <span class=\"string\">'./heroes/hero-list.component'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;HeroDetailComponent&#125;   <span class=\"keyword\">from</span> <span class=\"string\">'./heroes/hero-detail.component'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;DialogService&#125;         <span class=\"keyword\">from</span> <span class=\"string\">'./dialog.service'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;HeroService&#125;           <span class=\"keyword\">from</span> <span class=\"string\">'./heroes/hero.service'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  selector: <span class=\"string\">'my-app'</span>,</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;h1 class=\"title\"&gt;Component Router&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;nav&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a [routerLink]=\"['CrisisCenter']\"&gt;Crisis Center&lt;/a&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;a [routerLink]=\"['Heroes']\"&gt;Heroes&lt;/a&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/nav&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;router-outlet&gt;&lt;/router-outlet&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>,</span><br><span class=\"line\">  providers:  [DialogService, HeroService],</span><br><span class=\"line\">  directives: [ROUTER_DIRECTIVES]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"meta\">@RouteConfig</span>([</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123; <span class=\"comment\">// Crisis Center child route</span></span><br><span class=\"line\">    path: <span class=\"string\">'/crisis-center/...'</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'CrisisCenter'</span>,</span><br><span class=\"line\">    component: CrisisCenterComponent,</span><br><span class=\"line\">    useAsDefault: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;path: <span class=\"string\">'/heroes'</span>,   name: <span class=\"string\">'Heroes'</span>,     component: HeroListComponent&#125;,</span><br><span class=\"line\">  &#123;path: <span class=\"string\">'/hero/:id'</span>, name: <span class=\"string\">'HeroDetail'</span>, component: HeroDetailComponent&#125;,</span><br><span class=\"line\">  &#123;path: <span class=\"string\">'/disaster'</span>, name: <span class=\"string\">'Asteroid'</span>, redirectTo: [<span class=\"string\">'CrisisCenter'</span>, <span class=\"string\">'CrisisDetail'</span>, &#123;id:<span class=\"number\">3</span>&#125;]&#125;</span><br><span class=\"line\">])</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> AppComponent &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码我们干了几件事：</p>\n<ol>\n<li>写了一个组件，包含一个<code>h1</code>，一个<code>nav</code>里面包含两个<code>a</code>，还有一个<code>router-outlet</code>组件</li>\n<li>注入了两个服务，<code>DialogService</code>, <code>HeroService</code>（这一步不属于路由构建步骤）</li>\n<li>注入了一个指令，<code>ROUTER_DIRECTIVES</code></li>\n<li>使用<code>@RouteConfig</code>，配置子路径和对应的子组件，当/crisis-center/时候，在<code>router-outlet</code>中显示<code>CrisisCenterComponent</code>组件，当/heroes时候，在<code>router-outlet</code>中显示<code>HeroListComponent</code>组件，以此类推</li>\n<li>当导航到/disaster，重定向到<code>CrisisCenter</code>的<code>CrisisDetail</code>视图。<code>CrisisCenter</code>, <code>CrisisDetail</code>是父子视图关系，下面会讲到。</li>\n<li>导出这个组件</li>\n</ol>\n<p>好了我们的带有路由的组件编写好了，其实就是个可以切换视图的组件而已，就是这么简单。我们在浏览器中运行程序，点击<code>nav</code>中的heroes，就可以把子视图<code>Heroes</code>渲染出来了。</p>\n<p><img src=\"/css/images/69.jpg\" alt=\"\"></p>\n<p>浏览器路径变为</p>\n<p><a href=\"http://localhost:63342/angular2-tutorial/router/index.html/heroes\" target=\"_blank\" rel=\"noopener\">http://localhost:63342/angular2-tutorial/router/index.html/heroes</a></p>\n<p>在原有的基础上加上了/heroes。</p>\n<h2 id=\"温习promise\"><a href=\"#温习promise\" class=\"headerlink\" title=\"温习promise\"></a>温习promise</h2><p>当我们导航到heroes视图的时候，我们就进入了另一个子组件，这个组件需要一个heroes服务，里面用到了Promise，我们在<a href=\"https://lewis617.github.io/2016/02/28/ng2-service/\" target=\"_blank\" rel=\"noopener\">Angular2 系列教程（七）Injectable、Promise、Interface、使用服务</a>讲过Promise，然我们来温习Promise：</p>\n<p>app/heroes/hero.service.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Injectable&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> Hero &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> id: <span class=\"built_in\">number</span>, <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroService &#123;</span><br><span class=\"line\">  getHeroes() &#123; <span class=\"keyword\">return</span> heroesPromise; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getHero(id: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> heroesPromise</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">heroes</span> =&gt;</span> heroes.filter(<span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h.id === +id)[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> HEROES = [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Hero(<span class=\"number\">11</span>, <span class=\"string\">'Mr. Nice'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Hero(<span class=\"number\">12</span>, <span class=\"string\">'Narco'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Hero(<span class=\"number\">13</span>, <span class=\"string\">'Bombasto'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Hero(<span class=\"number\">14</span>, <span class=\"string\">'Celeritas'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Hero(<span class=\"number\">15</span>, <span class=\"string\">'Magneta'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Hero(<span class=\"number\">16</span>, <span class=\"string\">'RubberMan'</span>)</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> heroesPromise = <span class=\"built_in\">Promise</span>.resolve(HEROES);</span><br></pre></td></tr></table></figure>\n<p>以上代码我们干了几件事：</p>\n<ol>\n<li>写了一个<code>Hero</code>类</li>\n<li><p>写了一个<code>HeroService</code>类，包含两个成员函数</p>\n</li>\n<li><p>写了一个数组<code>HEROES</code>，里面每一项都是一个<code>hero</code>类的实例，也就是个对象（引用类型）</p>\n</li>\n<li>定义了一个<code>heroesPromise</code>，将<code>value</code>设为数组<code>HEROES</code>，状态为<code>resolved</code>，随时可以使用<code>then</code>来获取<code>value</code>，也就是数组<code>HEROES</code></li>\n</ol>\n<p>温习Promise，Promise的两种构建方法：</p>\n<ol>\n<li><code>Promise.resolve()</code></li>\n<li><code>new Promise()</code>，里面是个function，该function的参数是resolve和reject。</li>\n</ol>\n<p>例子（chrome console）：</p>\n<p><img src=\"/css/images/70.jpg\" alt=\"\"></p>\n<p>更详细的的用法，可以看我之前讲的Promise：<a href=\"https://lewis617.github.io/2016/02/28/ng2-service/\" target=\"_blank\" rel=\"noopener\">Angular2 系列教程（七）Injectable、Promise、Interface、使用服务</a> 。</p>\n<h2 id=\"两个服务：Router、RouteParams\"><a href=\"#两个服务：Router、RouteParams\" class=\"headerlink\" title=\"两个服务：Router、RouteParams\"></a>两个服务：Router、RouteParams</h2><p>我们的英雄服务写好了，然我们继续看英雄列表组件，当我们想要点击列表的某一项的时候，我们需要一个参数来导航到指定的英雄详情视图，这时候我们就需要<code>RouteParams</code>了，导航这个动作出发则需要<code>Router</code>服务：</p>\n<p>app/heroes/hero-list.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TODO SOMEDAY: Feature Componetized like CrisisCenter</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component, OnInit&#125;   <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Hero, HeroService&#125;   <span class=\"keyword\">from</span> <span class=\"string\">'./hero.service'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Router, RouteParams&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;h2&gt;HEROES&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;ul class=\"items\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;li *ngFor=\"#hero of heroes\"</span></span><br><span class=\"line\"><span class=\"string\">        [class.selected]=\"isSelected(hero)\"</span></span><br><span class=\"line\"><span class=\"string\">        (click)=\"onSelect(hero)\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;span class=\"badge\"&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroListComponent <span class=\"keyword\">implements</span> OnInit &#123;</span><br><span class=\"line\">  heroes: Hero[];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> _selectedId: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> _service: HeroService,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> _router: Router,</span></span><br><span class=\"line\"><span class=\"params\">    routeParams: RouteParams</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._selectedId = +routeParams.get(<span class=\"string\">'id'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isSelected(hero: Hero) &#123; <span class=\"keyword\">return</span> hero.id === <span class=\"keyword\">this</span>._selectedId; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  onSelect(hero: Hero) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._router.navigate( [<span class=\"string\">'HeroDetail'</span>, &#123; id: hero.id &#125;] );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._service.getHeroes().then(<span class=\"function\"><span class=\"params\">heroes</span> =&gt;</span> <span class=\"keyword\">this</span>.heroes = heroes)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码，我们干了几件事：</p>\n<ol>\n<li>渲染一个组件，包括一个列表</li>\n<li>在构造函数中，将英雄服务<code>HeroService</code>、路由服务<code>Router</code>、路由参数<code>RouteParams</code>传给私有变量</li>\n<li>写了三个成员函数用于处理相应的业务逻辑</li>\n<li>其中<code>this._router.navigate( [&#39;HeroDetail&#39;, { id: hero.id }] );</code>将<code>app</code>导航到了<code>HeroDetail</code>视图，并带上<code>id</code>参数</li>\n<li>其中<code>this._service.getHeroes().then(heroes =&amp;gt; this.heroes = heroes)</code>，用于获取刚才的<code>heroes</code>数组，并将其传给<code>this.heroes</code></li>\n</ol>\n<p><code>Router</code>服务的使用：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._router.navigate( [<span class=\"string\">'HeroDetail'</span>, &#123; id: hero.id &#125;] );</span><br></pre></td></tr></table></figure>\n<p><code>RouteParams</code>服务的使用：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._selectedId = +routeParams.get(<span class=\"string\">'id'</span>);</span><br></pre></td></tr></table></figure>\n<p>其中<code>routeParams.get(&#39;id&#39;)</code>前面那个<code>+</code>代表将其转换为数字类型。</p>\n<p><code>HeroService</code>服务的使用：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._service.getHeroes().then(<span class=\"function\"><span class=\"params\">heroes</span> =&gt;</span>; <span class=\"keyword\">this</span>.heroes = heroes)</span><br></pre></td></tr></table></figure>\n<h2 id=\"引用类型和单例模式的妙用\"><a href=\"#引用类型和单例模式的妙用\" class=\"headerlink\" title=\"引用类型和单例模式的妙用\"></a>引用类型和单例模式的妙用</h2><p>我们继续看英雄详细视图：</p>\n<p>app/heroes/hero-detail.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component,  OnInit&#125;  <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Hero, HeroService&#125;   <span class=\"keyword\">from</span> <span class=\"string\">'./hero.service'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;RouteParams, Router&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/router'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  &lt;h2&gt;HEROES&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;div *ngIf=\"hero\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;h3&gt;\"&#123;&#123;hero.name&#125;&#125;\"&lt;/h3&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;label&gt;Id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;label&gt;Name: &lt;/label&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;input [(ngModel)]=\"hero.name\" placeholder=\"name\"/&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;button (click)=\"gotoHeroes()\"&gt;Back&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroDetailComponent <span class=\"keyword\">implements</span> OnInit  &#123;</span><br><span class=\"line\">  hero: Hero;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> _router:Router,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> _routeParams:RouteParams,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> _service:HeroService</span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> id = <span class=\"keyword\">this</span>._routeParams.get(<span class=\"string\">'id'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._service.getHero(id).then(<span class=\"function\"><span class=\"params\">hero</span> =&gt;</span> <span class=\"keyword\">this</span>.hero = hero);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  gotoHeroes() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> heroId = <span class=\"keyword\">this</span>.hero ? <span class=\"keyword\">this</span>.hero.id : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Pass along the hero id if available</span></span><br><span class=\"line\">    <span class=\"comment\">// so that the HeroList component can select that hero.</span></span><br><span class=\"line\">    <span class=\"comment\">// Add a totally useless `foo` parameter for kicks.</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._router.navigate([<span class=\"string\">'Heroes'</span>,  &#123;id: heroId, foo: <span class=\"string\">'foo'</span>&#125; ]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码，我们仅仅是获取指定的英雄信息，并渲染出来。那么修改英雄信息是如何实现的呢？就是通过引用类型实现的。</p>\n<p>我们知道，在js中，对象和数组是引用类型，也就意味着，当我们将某个对象传给别的变量的时候，仅仅是将对象的地址传给了那个变量，当我们修改那个变量时候，其实对象也被修改了。<br>在这个程序中，我们将<code>hero</code>对象传给<code>this.hero</code>，并将其双向数据绑定到<code>input</code>上：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input [(ngModel)]=<span class=\"string\">\"hero.name\"</span> placeholder=<span class=\"string\">\"name\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p>这样当我们改变<code>input</code>的值的时候，<code>this.hero</code>被改变，服务中的<code>hero</code>也被改变，因为是引用类型嘛，其实操作的都是一个对象。再有我们的服务是单例模式，所以全局的<code>hero</code>列表都被改变了。</p>\n<p>让我们改变<code>input</code>的值，并点击back，我们发现英雄列表视图中的数据也被改变了，这就是引用类型和单例模式的妙用。</p>\n<h2 id=\"Route-Parameters-or-Query-Parameters\"><a href=\"#Route-Parameters-or-Query-Parameters\" class=\"headerlink\" title=\"Route Parameters or Query Parameters?\"></a>Route Parameters or Query Parameters?</h2><p>当我们点击back返回时候，我们发现URL变成了：</p>\n<p><a href=\"http://localhost:63342/angular2-tutorial/router/index.html/heroes?id=11&amp;foo=foo\" target=\"_blank\" rel=\"noopener\">http://localhost:63342/angular2-tutorial/router/index.html/heroes?id=11&amp;foo=foo</a></p>\n<p>也就是拥有了Query Parameters：<code>?id=11&amp;amp;foo=foo</code>。</p>\n<p>为何会这样呢？因为我们指定了参数：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._router.navigate([<span class=\"string\">'Heroes'</span>, &#123;id: heroId, foo: <span class=\"string\">'foo'</span>&#125;]);</span><br></pre></td></tr></table></figure>\n<p>但是英雄列表视图有没有指定的<code>id</code>和<code>foo</code>的token，所以这两个变量是可选的，所以就自动生成了Query Parameters，好让我们进行select的css重绘。</p>\n<p>在英雄详细视图中，我们使用了：<code>id</code>这个token。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;path: <span class=\"string\">'/hero/:id'</span>, name: <span class=\"string\">'HeroDetail'</span>, component: HeroDetailComponent&#125;</span><br></pre></td></tr></table></figure>\n<p>这就是Route Parameters。它是必须的，我们必须要指定id这个参数。这就是Route Parameters 和 Query Parameters的比较。</p>\n<p>这节课我们先讲到这里，下节课我们通过”危机中心”这个例子，继续讲解路由，将包含路由的嵌套、路由的生命周期等众多炫酷功能！</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>"},{"title":"Angular2 系列教程（五）Structural directives、再谈组件生命周期","date":"2016-02-19T01:11:00.000Z","_content":"\n今天，我们要讲的是structural directives和组件生命周期这两个知识点。structural directives顾名思义就是改变dom结构的指令。著名的内建结构指令有[ngIf](https://angular.io/docs/ts/latest/guide/template-syntax.html#ngIf),[ngSwitch](https://angular.io/docs/ts/latest/guide/template-syntax.html#ngSwitch) 和[ngFor](https://angular.io/docs/ts/latest/guide/template-syntax.html#ngFor)。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/76.jpg)\n\n例子是我自己改写的，编写一个structural directives，然后通过这个指令实例化和注销组件，在此同时监视组件生命周期。\n\n[源代码](https://github.com/lewis617/angular2-tutorial/tree/gh-pages/lifecycle)\n\n## UnlessDirective\n\n这个指令是官网示例中的指令。\n\napp/unless.directive.ts\n\n```ts\nimport {Directive, Input} from 'angular2/core';\nimport {TemplateRef, ViewContainerRef} from 'angular2/core';\n@Directive({ selector: '[myUnless]' })\nexport class UnlessDirective {\n  constructor(\n    private _templateRef: TemplateRef,\n    private _viewContainer: ViewContainerRef\n    ) { }\n  @Input() set myUnless(condition: boolean) {\n    if (!condition) {\n      this._viewContainer.createEmbeddedView(this._templateRef);\n    } else {\n      this._viewContainer.clear();\n    }\n  }\n}\n```\n\n通过注入`TemplateRef`, `ViewContainerRef`这两个服务，来控制`template`的实例化和注销。`TemplateRef`可以让我们获取指令所在的元素的`template`，`ViewContainerRef`提供了多种视图容器的方法。\n\n更详细的介绍：\n\n  * [TemplateRef](https://angular.io/docs/ts/latest/api/core/TemplateRef-class.html)\n  * [ViewContainerRef](https://angular.io/docs/ts/latest/api/core/ViewContainerRef-class.html)\n\n## 用于测试的组件\n\n接下来我们编写一个用于测试的组件。\n\napp/lifecycle.ts\n\n```ts\nimport {Component,Input} from 'angular2/core';\nimport {bootstrap} from 'angular2/platform/browser';\nimport {OnChanges, SimpleChange,OnInit,AfterContentInit,AfterContentChecked,AfterViewInit,AfterViewChecked,OnDestroy} from 'angular2/core';\n\n@Component({\n    selector: \"lifecycle\",\n    template: `\n    <div>\n    <span>{{name}}</span>\n     <button (click)=\"doSomething()\">click and watch the lifecycle</button>\n     </div>\n    `\n})\nexport class Lifecycle\nimplements OnChanges, OnInit,AfterContentInit,AfterContentChecked,AfterViewInit, AfterViewChecked, OnDestroy{\n    @Input()\n    name:string\n    doSomething(){\n        console.log('***********doSomething**********');\n        setTimeout(()=>{\n             console.log('***********setTimeout**********');\n            this.name='susan'\n        },1000)\n    }\n    ngOnInit(){console.log('onInit');}\n    ngOnDestroy(){console.log('OnDestroy')}\n    ngOnChanges(changes: {[propertyName: string]: SimpleChange}){console.log('ngOnChanges',changes)}\n    ngAfterContentInit(){console.log('AfterContentInit')}\n    ngAfterContentChecked(){console.log('AfterContentChecked')}\n    ngAfterViewInit(){console.log('AfterViewInit')}\n    ngAfterViewChecked(){console.log('AfterViewChecked')}\n}\n```\n\n这段代码我们做了这些事：\n\n  1. 渲染一个`span`一个`button`\n  2. 设置成员变量`name`,`@input`代表从`parent`输入\n  3. 设置成员函数`doSomething`，打印一个信息，执行一个异步操作`setTimeout`\n  4. 继承接口，设置所有的生命周期钩子，并打印信息\n\n我们将使用这个组件，来监视组件生命周期。\n\n## 使用指令控制组件\n\n我们将我们的组件渲染出来，并用我们编写的结构指令\"myunless\"去实例化和注销这个组件\n\napp/app.ts\n\n```ts\nimport {Component} from 'angular2/core';\nimport {bootstrap} from 'angular2/platform/browser';\nimport {UnlessDirective}from './unless.directive';\nimport {Lifecycle} from './lifecycle'\n\n@Component({\n    selector: \"app\",\n    directives:[UnlessDirective,Lifecycle],\n    template: `\n      <button\n      (click)=\"condition = !condition\"\n      [style.background] = \"condition ? 'orangered': 'lightgreen'\"\n      >\n      Set 'condition' to {{condition ? 'False': 'True'}}\n      </button>\n\n      <lifecycle *myUnless=\"condition\" name=\"lewis\"></lifecycle>\n    `\n})\nexport class App {\n    constructor() {}\n}\n\nbootstrap(App, [])\n    .catch(err => console.error(err));    \n```\n\n这段代码我们干了这些事：\n\n  1. 注入组件和指令`directives:[UnlessDirective,Lifecycle]`\n  2. 渲染一个`button`控制成员变量`condition`的正负\n  3. 渲染我们的组件`lifecycle`，并使用指令控制它的实例化和注销`<lifecycle *myUnless=”condition” name=”lewis”></lifecycle>`\n  4. 最后启动这个`app`组件`bootstrap(App, []) .catch(err => console.error(err));`\n\n## 开始测试\n\n### 刷新页面：\n\n![](/css/images/77.jpg)\n\n  1. `onInit`是在组件第一次`ngOnChanges`时执行\n  2. `OnChanges`在`input`和`output`绑定的值变化时候;我们可以看到打印了变化的值。可以替代ng1中的`$watch`;\n  3. `AfterContentInit`、`AfterViewInit`分别代表在组件内容和视图初始化后执行。\n  4. `AfterContentChecked`和`AfterViewChecked`是在组件内容和视图检查完后执行。\n\n这里没有`DoCheck`，因为接口没有证实。  \n\n### 点击Set 'condition' toTrue按钮，页面上的组件被注销\n\n![](/css/images/78.jpg)\n\nconsole打印：\n\n![](/css/images/79.jpg)\n\n### 点击Set 'condition' to False按钮，页面上的组件重新被实例化：\n\n![](/css/images/80.jpg)\n\nconsole打印：\n\n![](/css/images/81.jpg)\n\n打印了一次`Onchanges`、`onInit`、`AfterContentInit`、`AfterViewInit`、`AfterContentChecked`和`AfterViewChecked`，说明组件实例化，只需要触发一轮初始化和变化检查。与刷新页面的五次对比，我们可以知道多余的\"变化检查\"，可能来源于angualr的启动。\n\n### 点击click and watch the lifecycle按钮，一秒后页面上的name变为susan：\n\n![](/css/images/82.jpg)\n\nconsole打印\n\n![](/css/images/83.jpg)\n\n先打印一次`AfterContentChecked`和`AfterViewChecked`，一秒后又打印两次。`OnChanges`没有触发。\n\n## 结论和收获\n\n  1. `TemplateRef`, `ViewContainerRef`这两个服务可以帮助我们实现结构指令的编写\n  2. 结构指令可以完全注销组件，节约性能消耗\n  3. 组件实例化，只需要触发一轮初始化和\"变化检查\"\n  4. angualr的启动会触发多次\"变化检查\"\n  5. 我们可以继承`OnChanges`接口，来实现类似ng1中的`$watch`功能，获取变化前后的值，但是只能监视`@input`装饰的变量\n  6. ng2使用`zone`，将window对象上常见的异步方法（setTimeout等），都打上了\"猴子补丁\"，使其可以直接更新视图，我们再也不用在异步中写ng1中的`$apply`了\n  7. 我们可以使用`setTimeout(()=>{},0)`，在浏览器的一轮\"event loop\"后来触发ng2的\"变化检查\"\n  8. 我们触发类的成员函数（`doSomething`）时，也会导致ng2的\"变化检查\"\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n\n","source":"_posts/ng2-structural-directive.md","raw":"---\ntitle: Angular2 系列教程（五）Structural directives、再谈组件生命周期\ndate: 2016-02-19 09:11:00\ntags: [Angular2]\n---\n\n今天，我们要讲的是structural directives和组件生命周期这两个知识点。structural directives顾名思义就是改变dom结构的指令。著名的内建结构指令有[ngIf](https://angular.io/docs/ts/latest/guide/template-syntax.html#ngIf),[ngSwitch](https://angular.io/docs/ts/latest/guide/template-syntax.html#ngSwitch) 和[ngFor](https://angular.io/docs/ts/latest/guide/template-syntax.html#ngFor)。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/76.jpg)\n\n例子是我自己改写的，编写一个structural directives，然后通过这个指令实例化和注销组件，在此同时监视组件生命周期。\n\n[源代码](https://github.com/lewis617/angular2-tutorial/tree/gh-pages/lifecycle)\n\n## UnlessDirective\n\n这个指令是官网示例中的指令。\n\napp/unless.directive.ts\n\n```ts\nimport {Directive, Input} from 'angular2/core';\nimport {TemplateRef, ViewContainerRef} from 'angular2/core';\n@Directive({ selector: '[myUnless]' })\nexport class UnlessDirective {\n  constructor(\n    private _templateRef: TemplateRef,\n    private _viewContainer: ViewContainerRef\n    ) { }\n  @Input() set myUnless(condition: boolean) {\n    if (!condition) {\n      this._viewContainer.createEmbeddedView(this._templateRef);\n    } else {\n      this._viewContainer.clear();\n    }\n  }\n}\n```\n\n通过注入`TemplateRef`, `ViewContainerRef`这两个服务，来控制`template`的实例化和注销。`TemplateRef`可以让我们获取指令所在的元素的`template`，`ViewContainerRef`提供了多种视图容器的方法。\n\n更详细的介绍：\n\n  * [TemplateRef](https://angular.io/docs/ts/latest/api/core/TemplateRef-class.html)\n  * [ViewContainerRef](https://angular.io/docs/ts/latest/api/core/ViewContainerRef-class.html)\n\n## 用于测试的组件\n\n接下来我们编写一个用于测试的组件。\n\napp/lifecycle.ts\n\n```ts\nimport {Component,Input} from 'angular2/core';\nimport {bootstrap} from 'angular2/platform/browser';\nimport {OnChanges, SimpleChange,OnInit,AfterContentInit,AfterContentChecked,AfterViewInit,AfterViewChecked,OnDestroy} from 'angular2/core';\n\n@Component({\n    selector: \"lifecycle\",\n    template: `\n    <div>\n    <span>{{name}}</span>\n     <button (click)=\"doSomething()\">click and watch the lifecycle</button>\n     </div>\n    `\n})\nexport class Lifecycle\nimplements OnChanges, OnInit,AfterContentInit,AfterContentChecked,AfterViewInit, AfterViewChecked, OnDestroy{\n    @Input()\n    name:string\n    doSomething(){\n        console.log('***********doSomething**********');\n        setTimeout(()=>{\n             console.log('***********setTimeout**********');\n            this.name='susan'\n        },1000)\n    }\n    ngOnInit(){console.log('onInit');}\n    ngOnDestroy(){console.log('OnDestroy')}\n    ngOnChanges(changes: {[propertyName: string]: SimpleChange}){console.log('ngOnChanges',changes)}\n    ngAfterContentInit(){console.log('AfterContentInit')}\n    ngAfterContentChecked(){console.log('AfterContentChecked')}\n    ngAfterViewInit(){console.log('AfterViewInit')}\n    ngAfterViewChecked(){console.log('AfterViewChecked')}\n}\n```\n\n这段代码我们做了这些事：\n\n  1. 渲染一个`span`一个`button`\n  2. 设置成员变量`name`,`@input`代表从`parent`输入\n  3. 设置成员函数`doSomething`，打印一个信息，执行一个异步操作`setTimeout`\n  4. 继承接口，设置所有的生命周期钩子，并打印信息\n\n我们将使用这个组件，来监视组件生命周期。\n\n## 使用指令控制组件\n\n我们将我们的组件渲染出来，并用我们编写的结构指令\"myunless\"去实例化和注销这个组件\n\napp/app.ts\n\n```ts\nimport {Component} from 'angular2/core';\nimport {bootstrap} from 'angular2/platform/browser';\nimport {UnlessDirective}from './unless.directive';\nimport {Lifecycle} from './lifecycle'\n\n@Component({\n    selector: \"app\",\n    directives:[UnlessDirective,Lifecycle],\n    template: `\n      <button\n      (click)=\"condition = !condition\"\n      [style.background] = \"condition ? 'orangered': 'lightgreen'\"\n      >\n      Set 'condition' to {{condition ? 'False': 'True'}}\n      </button>\n\n      <lifecycle *myUnless=\"condition\" name=\"lewis\"></lifecycle>\n    `\n})\nexport class App {\n    constructor() {}\n}\n\nbootstrap(App, [])\n    .catch(err => console.error(err));    \n```\n\n这段代码我们干了这些事：\n\n  1. 注入组件和指令`directives:[UnlessDirective,Lifecycle]`\n  2. 渲染一个`button`控制成员变量`condition`的正负\n  3. 渲染我们的组件`lifecycle`，并使用指令控制它的实例化和注销`<lifecycle *myUnless=”condition” name=”lewis”></lifecycle>`\n  4. 最后启动这个`app`组件`bootstrap(App, []) .catch(err => console.error(err));`\n\n## 开始测试\n\n### 刷新页面：\n\n![](/css/images/77.jpg)\n\n  1. `onInit`是在组件第一次`ngOnChanges`时执行\n  2. `OnChanges`在`input`和`output`绑定的值变化时候;我们可以看到打印了变化的值。可以替代ng1中的`$watch`;\n  3. `AfterContentInit`、`AfterViewInit`分别代表在组件内容和视图初始化后执行。\n  4. `AfterContentChecked`和`AfterViewChecked`是在组件内容和视图检查完后执行。\n\n这里没有`DoCheck`，因为接口没有证实。  \n\n### 点击Set 'condition' toTrue按钮，页面上的组件被注销\n\n![](/css/images/78.jpg)\n\nconsole打印：\n\n![](/css/images/79.jpg)\n\n### 点击Set 'condition' to False按钮，页面上的组件重新被实例化：\n\n![](/css/images/80.jpg)\n\nconsole打印：\n\n![](/css/images/81.jpg)\n\n打印了一次`Onchanges`、`onInit`、`AfterContentInit`、`AfterViewInit`、`AfterContentChecked`和`AfterViewChecked`，说明组件实例化，只需要触发一轮初始化和变化检查。与刷新页面的五次对比，我们可以知道多余的\"变化检查\"，可能来源于angualr的启动。\n\n### 点击click and watch the lifecycle按钮，一秒后页面上的name变为susan：\n\n![](/css/images/82.jpg)\n\nconsole打印\n\n![](/css/images/83.jpg)\n\n先打印一次`AfterContentChecked`和`AfterViewChecked`，一秒后又打印两次。`OnChanges`没有触发。\n\n## 结论和收获\n\n  1. `TemplateRef`, `ViewContainerRef`这两个服务可以帮助我们实现结构指令的编写\n  2. 结构指令可以完全注销组件，节约性能消耗\n  3. 组件实例化，只需要触发一轮初始化和\"变化检查\"\n  4. angualr的启动会触发多次\"变化检查\"\n  5. 我们可以继承`OnChanges`接口，来实现类似ng1中的`$watch`功能，获取变化前后的值，但是只能监视`@input`装饰的变量\n  6. ng2使用`zone`，将window对象上常见的异步方法（setTimeout等），都打上了\"猴子补丁\"，使其可以直接更新视图，我们再也不用在异步中写ng1中的`$apply`了\n  7. 我们可以使用`setTimeout(()=>{},0)`，在浏览器的一轮\"event loop\"后来触发ng2的\"变化检查\"\n  8. 我们触发类的成员函数（`doSomething`）时，也会导致ng2的\"变化检查\"\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n\n","slug":"ng2-structural-directive","published":1,"updated":"2019-05-01T08:10:29.926Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvm1001xtgytt8k1o575","content":"<p>今天，我们要讲的是structural directives和组件生命周期这两个知识点。structural directives顾名思义就是改变dom结构的指令。著名的内建结构指令有<a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html#ngIf\" target=\"_blank\" rel=\"noopener\">ngIf</a>,<a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html#ngSwitch\" target=\"_blank\" rel=\"noopener\">ngSwitch</a> 和<a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html#ngFor\" target=\"_blank\" rel=\"noopener\">ngFor</a>。</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/76.jpg\" alt=\"\"></p>\n<p>例子是我自己改写的，编写一个structural directives，然后通过这个指令实例化和注销组件，在此同时监视组件生命周期。</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/lifecycle\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<h2 id=\"UnlessDirective\"><a href=\"#UnlessDirective\" class=\"headerlink\" title=\"UnlessDirective\"></a>UnlessDirective</h2><p>这个指令是官网示例中的指令。</p>\n<p>app/unless.directive.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Directive, Input&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;TemplateRef, ViewContainerRef&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"meta\">@Directive</span>(&#123; selector: <span class=\"string\">'[myUnless]'</span> &#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> UnlessDirective &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> _templateRef: TemplateRef,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> _viewContainer: ViewContainerRef</span></span><br><span class=\"line\"><span class=\"params\">    </span>) &#123; &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Input</span>() <span class=\"keyword\">set</span> myUnless(condition: <span class=\"built_in\">boolean</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!condition) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._viewContainer.createEmbeddedView(<span class=\"keyword\">this</span>._templateRef);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._viewContainer.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过注入<code>TemplateRef</code>, <code>ViewContainerRef</code>这两个服务，来控制<code>template</code>的实例化和注销。<code>TemplateRef</code>可以让我们获取指令所在的元素的<code>template</code>，<code>ViewContainerRef</code>提供了多种视图容器的方法。</p>\n<p>更详细的介绍：</p>\n<ul>\n<li><a href=\"https://angular.io/docs/ts/latest/api/core/TemplateRef-class.html\" target=\"_blank\" rel=\"noopener\">TemplateRef</a></li>\n<li><a href=\"https://angular.io/docs/ts/latest/api/core/ViewContainerRef-class.html\" target=\"_blank\" rel=\"noopener\">ViewContainerRef</a></li>\n</ul>\n<h2 id=\"用于测试的组件\"><a href=\"#用于测试的组件\" class=\"headerlink\" title=\"用于测试的组件\"></a>用于测试的组件</h2><p>接下来我们编写一个用于测试的组件。</p>\n<p>app/lifecycle.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component,Input&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;bootstrap&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/platform/browser'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;OnChanges, SimpleChange,OnInit,AfterContentInit,AfterContentChecked,AfterViewInit,AfterViewChecked,OnDestroy&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">    selector: <span class=\"string\">\"lifecycle\"</span>,</span><br><span class=\"line\">    template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;</span></span><br><span class=\"line\"><span class=\"string\">     &lt;button (click)=\"doSomething()\"&gt;click and watch the lifecycle&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">     &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> Lifecycle</span><br><span class=\"line\"><span class=\"keyword\">implements</span> OnChanges, OnInit,AfterContentInit,AfterContentChecked,AfterViewInit, AfterViewChecked, OnDestroy&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Input</span>()</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span></span><br><span class=\"line\">    doSomething()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'***********doSomething**********'</span>);</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">             <span class=\"built_in\">console</span>.log(<span class=\"string\">'***********setTimeout**********'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name=<span class=\"string\">'susan'</span></span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ngOnInit()&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'onInit'</span>);&#125;</span><br><span class=\"line\">    ngOnDestroy()&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'OnDestroy'</span>)&#125;</span><br><span class=\"line\">    ngOnChanges(changes: &#123;[propertyName: <span class=\"built_in\">string</span>]: SimpleChange&#125;)&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'ngOnChanges'</span>,changes)&#125;</span><br><span class=\"line\">    ngAfterContentInit()&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'AfterContentInit'</span>)&#125;</span><br><span class=\"line\">    ngAfterContentChecked()&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'AfterContentChecked'</span>)&#125;</span><br><span class=\"line\">    ngAfterViewInit()&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'AfterViewInit'</span>)&#125;</span><br><span class=\"line\">    ngAfterViewChecked()&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'AfterViewChecked'</span>)&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码我们做了这些事：</p>\n<ol>\n<li>渲染一个<code>span</code>一个<code>button</code></li>\n<li>设置成员变量<code>name</code>,<code>@input</code>代表从<code>parent</code>输入</li>\n<li>设置成员函数<code>doSomething</code>，打印一个信息，执行一个异步操作<code>setTimeout</code></li>\n<li>继承接口，设置所有的生命周期钩子，并打印信息</li>\n</ol>\n<p>我们将使用这个组件，来监视组件生命周期。</p>\n<h2 id=\"使用指令控制组件\"><a href=\"#使用指令控制组件\" class=\"headerlink\" title=\"使用指令控制组件\"></a>使用指令控制组件</h2><p>我们将我们的组件渲染出来，并用我们编写的结构指令”myunless”去实例化和注销这个组件</p>\n<p>app/app.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;bootstrap&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/platform/browser'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;UnlessDirective&#125;<span class=\"keyword\">from</span> <span class=\"string\">'./unless.directive'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Lifecycle&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./lifecycle'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">    selector: <span class=\"string\">\"app\"</span>,</span><br><span class=\"line\">    directives:[UnlessDirective,Lifecycle],</span><br><span class=\"line\">    template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      &lt;button</span></span><br><span class=\"line\"><span class=\"string\">      (click)=\"condition = !condition\"</span></span><br><span class=\"line\"><span class=\"string\">      [style.background] = \"condition ? 'orangered': 'lightgreen'\"</span></span><br><span class=\"line\"><span class=\"string\">      &gt;</span></span><br><span class=\"line\"><span class=\"string\">      Set 'condition' to &#123;&#123;condition ? 'False': 'True'&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">      &lt;lifecycle *myUnless=\"condition\" name=\"lewis\"&gt;&lt;/lifecycle&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> App &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bootstrap(App, [])</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.error(err));</span><br></pre></td></tr></table></figure>\n<p>这段代码我们干了这些事：</p>\n<ol>\n<li>注入组件和指令<code>directives:[UnlessDirective,Lifecycle]</code></li>\n<li>渲染一个<code>button</code>控制成员变量<code>condition</code>的正负</li>\n<li>渲染我们的组件<code>lifecycle</code>，并使用指令控制它的实例化和注销<code>&lt;lifecycle *myUnless=”condition” name=”lewis”&gt;&lt;/lifecycle&gt;</code></li>\n<li>最后启动这个<code>app</code>组件<code>bootstrap(App, []) .catch(err =&gt; console.error(err));</code></li>\n</ol>\n<h2 id=\"开始测试\"><a href=\"#开始测试\" class=\"headerlink\" title=\"开始测试\"></a>开始测试</h2><h3 id=\"刷新页面：\"><a href=\"#刷新页面：\" class=\"headerlink\" title=\"刷新页面：\"></a>刷新页面：</h3><p><img src=\"/css/images/77.jpg\" alt=\"\"></p>\n<ol>\n<li><code>onInit</code>是在组件第一次<code>ngOnChanges</code>时执行</li>\n<li><code>OnChanges</code>在<code>input</code>和<code>output</code>绑定的值变化时候;我们可以看到打印了变化的值。可以替代ng1中的<code>$watch</code>;</li>\n<li><code>AfterContentInit</code>、<code>AfterViewInit</code>分别代表在组件内容和视图初始化后执行。</li>\n<li><code>AfterContentChecked</code>和<code>AfterViewChecked</code>是在组件内容和视图检查完后执行。</li>\n</ol>\n<p>这里没有<code>DoCheck</code>，因为接口没有证实。  </p>\n<h3 id=\"点击Set-‘condition’-toTrue按钮，页面上的组件被注销\"><a href=\"#点击Set-‘condition’-toTrue按钮，页面上的组件被注销\" class=\"headerlink\" title=\"点击Set ‘condition’ toTrue按钮，页面上的组件被注销\"></a>点击Set ‘condition’ toTrue按钮，页面上的组件被注销</h3><p><img src=\"/css/images/78.jpg\" alt=\"\"></p>\n<p>console打印：</p>\n<p><img src=\"/css/images/79.jpg\" alt=\"\"></p>\n<h3 id=\"点击Set-‘condition’-to-False按钮，页面上的组件重新被实例化：\"><a href=\"#点击Set-‘condition’-to-False按钮，页面上的组件重新被实例化：\" class=\"headerlink\" title=\"点击Set ‘condition’ to False按钮，页面上的组件重新被实例化：\"></a>点击Set ‘condition’ to False按钮，页面上的组件重新被实例化：</h3><p><img src=\"/css/images/80.jpg\" alt=\"\"></p>\n<p>console打印：</p>\n<p><img src=\"/css/images/81.jpg\" alt=\"\"></p>\n<p>打印了一次<code>Onchanges</code>、<code>onInit</code>、<code>AfterContentInit</code>、<code>AfterViewInit</code>、<code>AfterContentChecked</code>和<code>AfterViewChecked</code>，说明组件实例化，只需要触发一轮初始化和变化检查。与刷新页面的五次对比，我们可以知道多余的”变化检查”，可能来源于angualr的启动。</p>\n<h3 id=\"点击click-and-watch-the-lifecycle按钮，一秒后页面上的name变为susan：\"><a href=\"#点击click-and-watch-the-lifecycle按钮，一秒后页面上的name变为susan：\" class=\"headerlink\" title=\"点击click and watch the lifecycle按钮，一秒后页面上的name变为susan：\"></a>点击click and watch the lifecycle按钮，一秒后页面上的name变为susan：</h3><p><img src=\"/css/images/82.jpg\" alt=\"\"></p>\n<p>console打印</p>\n<p><img src=\"/css/images/83.jpg\" alt=\"\"></p>\n<p>先打印一次<code>AfterContentChecked</code>和<code>AfterViewChecked</code>，一秒后又打印两次。<code>OnChanges</code>没有触发。</p>\n<h2 id=\"结论和收获\"><a href=\"#结论和收获\" class=\"headerlink\" title=\"结论和收获\"></a>结论和收获</h2><ol>\n<li><code>TemplateRef</code>, <code>ViewContainerRef</code>这两个服务可以帮助我们实现结构指令的编写</li>\n<li>结构指令可以完全注销组件，节约性能消耗</li>\n<li>组件实例化，只需要触发一轮初始化和”变化检查”</li>\n<li>angualr的启动会触发多次”变化检查”</li>\n<li>我们可以继承<code>OnChanges</code>接口，来实现类似ng1中的<code>$watch</code>功能，获取变化前后的值，但是只能监视<code>@input</code>装饰的变量</li>\n<li>ng2使用<code>zone</code>，将window对象上常见的异步方法（setTimeout等），都打上了”猴子补丁”，使其可以直接更新视图，我们再也不用在异步中写ng1中的<code>$apply</code>了</li>\n<li>我们可以使用<code>setTimeout(()=&gt;{},0)</code>，在浏览器的一轮”event loop”后来触发ng2的”变化检查”</li>\n<li>我们触发类的成员函数（<code>doSomething</code>）时，也会导致ng2的”变化检查”</li>\n</ol>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是structural directives和组件生命周期这两个知识点。structural directives顾名思义就是改变dom结构的指令。著名的内建结构指令有<a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html#ngIf\" target=\"_blank\" rel=\"noopener\">ngIf</a>,<a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html#ngSwitch\" target=\"_blank\" rel=\"noopener\">ngSwitch</a> 和<a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html#ngFor\" target=\"_blank\" rel=\"noopener\">ngFor</a>。</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/76.jpg\" alt=\"\"></p>\n<p>例子是我自己改写的，编写一个structural directives，然后通过这个指令实例化和注销组件，在此同时监视组件生命周期。</p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/lifecycle\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<h2 id=\"UnlessDirective\"><a href=\"#UnlessDirective\" class=\"headerlink\" title=\"UnlessDirective\"></a>UnlessDirective</h2><p>这个指令是官网示例中的指令。</p>\n<p>app/unless.directive.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Directive, Input&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;TemplateRef, ViewContainerRef&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"meta\">@Directive</span>(&#123; selector: <span class=\"string\">'[myUnless]'</span> &#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> UnlessDirective &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> _templateRef: TemplateRef,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> _viewContainer: ViewContainerRef</span></span><br><span class=\"line\"><span class=\"params\">    </span>) &#123; &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Input</span>() <span class=\"keyword\">set</span> myUnless(condition: <span class=\"built_in\">boolean</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!condition) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._viewContainer.createEmbeddedView(<span class=\"keyword\">this</span>._templateRef);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._viewContainer.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过注入<code>TemplateRef</code>, <code>ViewContainerRef</code>这两个服务，来控制<code>template</code>的实例化和注销。<code>TemplateRef</code>可以让我们获取指令所在的元素的<code>template</code>，<code>ViewContainerRef</code>提供了多种视图容器的方法。</p>\n<p>更详细的介绍：</p>\n<ul>\n<li><a href=\"https://angular.io/docs/ts/latest/api/core/TemplateRef-class.html\" target=\"_blank\" rel=\"noopener\">TemplateRef</a></li>\n<li><a href=\"https://angular.io/docs/ts/latest/api/core/ViewContainerRef-class.html\" target=\"_blank\" rel=\"noopener\">ViewContainerRef</a></li>\n</ul>\n<h2 id=\"用于测试的组件\"><a href=\"#用于测试的组件\" class=\"headerlink\" title=\"用于测试的组件\"></a>用于测试的组件</h2><p>接下来我们编写一个用于测试的组件。</p>\n<p>app/lifecycle.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component,Input&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;bootstrap&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/platform/browser'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;OnChanges, SimpleChange,OnInit,AfterContentInit,AfterContentChecked,AfterViewInit,AfterViewChecked,OnDestroy&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">    selector: <span class=\"string\">\"lifecycle\"</span>,</span><br><span class=\"line\">    template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;</span></span><br><span class=\"line\"><span class=\"string\">     &lt;button (click)=\"doSomething()\"&gt;click and watch the lifecycle&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">     &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> Lifecycle</span><br><span class=\"line\"><span class=\"keyword\">implements</span> OnChanges, OnInit,AfterContentInit,AfterContentChecked,AfterViewInit, AfterViewChecked, OnDestroy&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Input</span>()</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span></span><br><span class=\"line\">    doSomething()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'***********doSomething**********'</span>);</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">             <span class=\"built_in\">console</span>.log(<span class=\"string\">'***********setTimeout**********'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name=<span class=\"string\">'susan'</span></span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ngOnInit()&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'onInit'</span>);&#125;</span><br><span class=\"line\">    ngOnDestroy()&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'OnDestroy'</span>)&#125;</span><br><span class=\"line\">    ngOnChanges(changes: &#123;[propertyName: <span class=\"built_in\">string</span>]: SimpleChange&#125;)&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'ngOnChanges'</span>,changes)&#125;</span><br><span class=\"line\">    ngAfterContentInit()&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'AfterContentInit'</span>)&#125;</span><br><span class=\"line\">    ngAfterContentChecked()&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'AfterContentChecked'</span>)&#125;</span><br><span class=\"line\">    ngAfterViewInit()&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'AfterViewInit'</span>)&#125;</span><br><span class=\"line\">    ngAfterViewChecked()&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'AfterViewChecked'</span>)&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码我们做了这些事：</p>\n<ol>\n<li>渲染一个<code>span</code>一个<code>button</code></li>\n<li>设置成员变量<code>name</code>,<code>@input</code>代表从<code>parent</code>输入</li>\n<li>设置成员函数<code>doSomething</code>，打印一个信息，执行一个异步操作<code>setTimeout</code></li>\n<li>继承接口，设置所有的生命周期钩子，并打印信息</li>\n</ol>\n<p>我们将使用这个组件，来监视组件生命周期。</p>\n<h2 id=\"使用指令控制组件\"><a href=\"#使用指令控制组件\" class=\"headerlink\" title=\"使用指令控制组件\"></a>使用指令控制组件</h2><p>我们将我们的组件渲染出来，并用我们编写的结构指令”myunless”去实例化和注销这个组件</p>\n<p>app/app.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;bootstrap&#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2/platform/browser'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;UnlessDirective&#125;<span class=\"keyword\">from</span> <span class=\"string\">'./unless.directive'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Lifecycle&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./lifecycle'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">    selector: <span class=\"string\">\"app\"</span>,</span><br><span class=\"line\">    directives:[UnlessDirective,Lifecycle],</span><br><span class=\"line\">    template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      &lt;button</span></span><br><span class=\"line\"><span class=\"string\">      (click)=\"condition = !condition\"</span></span><br><span class=\"line\"><span class=\"string\">      [style.background] = \"condition ? 'orangered': 'lightgreen'\"</span></span><br><span class=\"line\"><span class=\"string\">      &gt;</span></span><br><span class=\"line\"><span class=\"string\">      Set 'condition' to &#123;&#123;condition ? 'False': 'True'&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">      &lt;lifecycle *myUnless=\"condition\" name=\"lewis\"&gt;&lt;/lifecycle&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> App &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bootstrap(App, [])</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.error(err));</span><br></pre></td></tr></table></figure>\n<p>这段代码我们干了这些事：</p>\n<ol>\n<li>注入组件和指令<code>directives:[UnlessDirective,Lifecycle]</code></li>\n<li>渲染一个<code>button</code>控制成员变量<code>condition</code>的正负</li>\n<li>渲染我们的组件<code>lifecycle</code>，并使用指令控制它的实例化和注销<code>&lt;lifecycle *myUnless=”condition” name=”lewis”&gt;&lt;/lifecycle&gt;</code></li>\n<li>最后启动这个<code>app</code>组件<code>bootstrap(App, []) .catch(err =&gt; console.error(err));</code></li>\n</ol>\n<h2 id=\"开始测试\"><a href=\"#开始测试\" class=\"headerlink\" title=\"开始测试\"></a>开始测试</h2><h3 id=\"刷新页面：\"><a href=\"#刷新页面：\" class=\"headerlink\" title=\"刷新页面：\"></a>刷新页面：</h3><p><img src=\"/css/images/77.jpg\" alt=\"\"></p>\n<ol>\n<li><code>onInit</code>是在组件第一次<code>ngOnChanges</code>时执行</li>\n<li><code>OnChanges</code>在<code>input</code>和<code>output</code>绑定的值变化时候;我们可以看到打印了变化的值。可以替代ng1中的<code>$watch</code>;</li>\n<li><code>AfterContentInit</code>、<code>AfterViewInit</code>分别代表在组件内容和视图初始化后执行。</li>\n<li><code>AfterContentChecked</code>和<code>AfterViewChecked</code>是在组件内容和视图检查完后执行。</li>\n</ol>\n<p>这里没有<code>DoCheck</code>，因为接口没有证实。  </p>\n<h3 id=\"点击Set-‘condition’-toTrue按钮，页面上的组件被注销\"><a href=\"#点击Set-‘condition’-toTrue按钮，页面上的组件被注销\" class=\"headerlink\" title=\"点击Set ‘condition’ toTrue按钮，页面上的组件被注销\"></a>点击Set ‘condition’ toTrue按钮，页面上的组件被注销</h3><p><img src=\"/css/images/78.jpg\" alt=\"\"></p>\n<p>console打印：</p>\n<p><img src=\"/css/images/79.jpg\" alt=\"\"></p>\n<h3 id=\"点击Set-‘condition’-to-False按钮，页面上的组件重新被实例化：\"><a href=\"#点击Set-‘condition’-to-False按钮，页面上的组件重新被实例化：\" class=\"headerlink\" title=\"点击Set ‘condition’ to False按钮，页面上的组件重新被实例化：\"></a>点击Set ‘condition’ to False按钮，页面上的组件重新被实例化：</h3><p><img src=\"/css/images/80.jpg\" alt=\"\"></p>\n<p>console打印：</p>\n<p><img src=\"/css/images/81.jpg\" alt=\"\"></p>\n<p>打印了一次<code>Onchanges</code>、<code>onInit</code>、<code>AfterContentInit</code>、<code>AfterViewInit</code>、<code>AfterContentChecked</code>和<code>AfterViewChecked</code>，说明组件实例化，只需要触发一轮初始化和变化检查。与刷新页面的五次对比，我们可以知道多余的”变化检查”，可能来源于angualr的启动。</p>\n<h3 id=\"点击click-and-watch-the-lifecycle按钮，一秒后页面上的name变为susan：\"><a href=\"#点击click-and-watch-the-lifecycle按钮，一秒后页面上的name变为susan：\" class=\"headerlink\" title=\"点击click and watch the lifecycle按钮，一秒后页面上的name变为susan：\"></a>点击click and watch the lifecycle按钮，一秒后页面上的name变为susan：</h3><p><img src=\"/css/images/82.jpg\" alt=\"\"></p>\n<p>console打印</p>\n<p><img src=\"/css/images/83.jpg\" alt=\"\"></p>\n<p>先打印一次<code>AfterContentChecked</code>和<code>AfterViewChecked</code>，一秒后又打印两次。<code>OnChanges</code>没有触发。</p>\n<h2 id=\"结论和收获\"><a href=\"#结论和收获\" class=\"headerlink\" title=\"结论和收获\"></a>结论和收获</h2><ol>\n<li><code>TemplateRef</code>, <code>ViewContainerRef</code>这两个服务可以帮助我们实现结构指令的编写</li>\n<li>结构指令可以完全注销组件，节约性能消耗</li>\n<li>组件实例化，只需要触发一轮初始化和”变化检查”</li>\n<li>angualr的启动会触发多次”变化检查”</li>\n<li>我们可以继承<code>OnChanges</code>接口，来实现类似ng1中的<code>$watch</code>功能，获取变化前后的值，但是只能监视<code>@input</code>装饰的变量</li>\n<li>ng2使用<code>zone</code>，将window对象上常见的异步方法（setTimeout等），都打上了”猴子补丁”，使其可以直接更新视图，我们再也不用在异步中写ng1中的<code>$apply</code>了</li>\n<li>我们可以使用<code>setTimeout(()=&gt;{},0)</code>，在浏览器的一轮”event loop”后来触发ng2的”变化检查”</li>\n<li>我们触发类的成员函数（<code>doSomething</code>）时，也会导致ng2的”变化检查”</li>\n</ol>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>"},{"title":"Angular2 系列教程（七）Injectable、Promise、Interface、使用服务","date":"2016-02-28T21:29:00.000Z","_content":"\n今天我们要讲的ng2的service这个概念，和ng1一样，service通常用于发送http请求，但其实你可以在里面封装任何你想封装的方法，有时候控制器之间的通讯也是依靠service来完成的，让我们一睹为快！\n\n<!--more-->\n\n# 例子\n\n例子是官方的例子，加载一个英雄列表，点击显示详细信息。我直接放在我们的升级后的装备里面。\n\n![](/css/images/73.jpg)\n\n[源代码](https://github.com/lewis617/angular2-tutorial/tree/gh-pages/service)\n\n# Injectable\n\n在ng2里面如何编写服务呢？非常简单，你只需要写个类即可。那么这个`@Injectable()`是做什么的？其实单就这个例子来说，我们是不需要写个这个装饰的，因为我们的`HeroSerivce`没有依赖，如果你要写一个有依赖的服务，那么你需要加上这个`@Injectable()`，此处加上`@Injectable()`是可有可无的，但是写上是个好习惯。\n\napp/hero.service.ts（部分代码）\n\n```ts\n@Injectable()\nexport class HeroService {\n  getHeroes() {\n    return Promise.resolve(HEROES);\n  }\n  // See the \"Take it slow\" appendix\n  getHeroesSlowly() {\n    return new Promise<Hero[]>(resolve =>\n      setTimeout(() => resolve(HEROES), 2000) // 2 seconds\n    );\n  }\n}\n```\n\n以上代码我们干了哪些事儿呢？\n\n  1. 写了一个使用`injectable`装饰的类\n  2. 写了两个成员函数\n  3. 一个返回一个Promise，直接`resolve`数据\n  4. 另一个也返回一个Promise，不过在两秒后`resolve`数据\n\n有的同学会问：`resolve`的数据哪去了？Promise是什么？我们继续讲解。\n\n# Promise\n\n如果你玩过ng1，你一定对promise不陌生，因为我们经常在路由里面写`resolve`，这里就可以接受一个Promise对象。还有ng1中的`$q.defer()`等等。\n\n但是promise并不是ng1的专利，你可以在你的任何javascript程序中使用promise，因为在ES6中已经原生提供[Promise对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)。你可以查看它的用法，这里我简单描述下：\n\n  1. 构造Promise，只需要在里面加入一个参数，这个参数是个function，这个function可以接受两个参数：`resolve`, `reject`。或者使用`Promise.resolve()`，不过这样没有延迟了。\n  2. 使用Promise对象，最常用的方法是`then()`，里面接受一个function，这个function的参数为`resolve`的值。除了`then()`还有`catch()`等\n\n为了让大家能够清晰的了解Promise的用法，我们打开chrome的console：\n\n![](/css/images/74.jpg)\n\n  1. 输入Promise，是个function。\n  2. 输入`Promise.resolve('123')`，我们得到一个状态为\"已经解决\"的promise。\n  3. 输入`new Promise(resolve=>;resolve('123'))`，我们还是得到一个状态为\"已经解决\"的promise。\n\n2和3的区别在于，后者可以在参数的函数中做一些处理，比如延迟或者http请求。\n\n然后让我们来看Promise的then方法：\n\n![](/css/images/75.jpg)\n\n  1. 首先我们写了一个已经`resolved`的promise，并将其赋值给`p`\n  2. 然后使用`p.then()`，在回调函数里面打印参数，得到`'123'`\n  3. 最后`p.then()`整体返回的是个初始化（pending）的promise。\n\n现在我们明白一下这个代码中promise的用法了吧？\n\napp/hero.service.ts（部分代码）\n\n```ts\n@Injectable()\nexport class HeroService {\n  getHeroes() {\n    return Promise.resolve(HEROES);\n  }\n  // See the \"Take it slow\" appendix\n  getHeroesSlowly() {\n    return new Promise<Hero[]>(resolve =>\n      setTimeout(() => resolve(HEROES), 2000) // 2 seconds\n    );\n  }\n}\n```\n那么我们为何要使用promise呢？主要是为了解决回调地狱的问题。因为有了promise，你不必再写深层的回调，而是像极了同步的写法。\n\n这是我的一个ng1的项目的[部分代码](https://github.com/lewis617/daily-task/blob/gh-pages/modules/login/ctrl.js)，用promise的`then()`来解决回调地狱。\n\n```js    \n    \nAuth.$createUser({email: email, password: pass})\n    .then(function() {\n        // authenticate so we have permission to write to Firebase\n        return Auth.$authWithPassword({ email: email, password: pass });\n    })\n    .then(function(user) {\n        // create a user profile in our data store\n        var ref = wdutil.ref('users', user.uid);\n        return wdutil.handler(function(cb) {\n            ref.set({email: email, name: $scope.name||firstPartOfEmail(email)}, cb);\n        });\n    })\n    .then(function(/* user */) {\n        $scope.wait.show=false;\n        // redirect to the account page\n        $location.path('/account');\n    }, function(err) {\n        $scope.wait.show=false;\n        $scope.alerts.push({type:'danger',msg:wdutil.errMessage(err)});\n    });\n```\n\n# Interface\n\n在编写这个服务的过程中我们使用了interface这个概念，这个知识点属于ts的范畴，我们通常在接口中声明类型，有点像react中的propTypes：\n\napp/hero.ts\n\n```ts\nexport interface Hero {\n  id: number;\n  name: string;\n}\n```\n\n然后我们在我们的服务中使用了这个接口：\n\napp/hero.service.ts（部分代码）\n\n```ts\nimport {Hero} from './hero';\n```\napp/hero.service.ts（部分代码）\n\n```ts   \nreturn new Promise<Hero[]>(resolve =>\n      setTimeout(() => resolve(HEROES), 2000) // 2 seconds\n    );\n```\n除此之外，我们在我们的组件里面也多次使用了这个接口：\n\napp/app.component.ts\n\n```ts\nheroes: Hero[];\nselectedHero: Hero;\n```\napp/hero-detail.component.ts\n\n```ts\nexport class HeroDetailComponent {\n  hero: Hero;\n}\n```\n\n到此为止，我们的服务就算是写好了！\n\n# 使用服务\n\n让我们在组件中测试一下我们写好的服务吧：\n\napp/app.component.ts（部分代码）\n\n```ts\n    \nimport {HeroService} from './hero.service';\n\n...\n\nproviders: [HeroService]\n\n...\n\nconstructor(private _heroService: HeroService) { }\n\n  getHeroes() {\n    this._heroService.getHeroes().then(heroes => this.heroes = heroes);\n  }\n```\n\n以上代码我们干了这些事儿：\n\n  1. 利用模块系统导入这个服务类\n  2. 在组件中注入这个服务\n  3. 在构造函数中将这个服务赋给一个私有变量`_heroService`\n  4. 然后就可以尽情地在类中使用这个服务对象了`this._heroService`\n\n这里的`getHeroes()`返回了一个Promise，所以我们可以使用`then`来处理接下来要发生的事。\n\n* * *\n\n# 教程示例代码及目录\n\nhttp://www.liuyiqi.cn/2016/12/25/angular2-tutorial-catalog/\n\n","source":"_posts/ng2-service.md","raw":"---\ntitle: Angular2 系列教程（七）Injectable、Promise、Interface、使用服务\ndate: 2016-02-29 05:29:00\ntags: [Angular2]\n---\n\n今天我们要讲的ng2的service这个概念，和ng1一样，service通常用于发送http请求，但其实你可以在里面封装任何你想封装的方法，有时候控制器之间的通讯也是依靠service来完成的，让我们一睹为快！\n\n<!--more-->\n\n# 例子\n\n例子是官方的例子，加载一个英雄列表，点击显示详细信息。我直接放在我们的升级后的装备里面。\n\n![](/css/images/73.jpg)\n\n[源代码](https://github.com/lewis617/angular2-tutorial/tree/gh-pages/service)\n\n# Injectable\n\n在ng2里面如何编写服务呢？非常简单，你只需要写个类即可。那么这个`@Injectable()`是做什么的？其实单就这个例子来说，我们是不需要写个这个装饰的，因为我们的`HeroSerivce`没有依赖，如果你要写一个有依赖的服务，那么你需要加上这个`@Injectable()`，此处加上`@Injectable()`是可有可无的，但是写上是个好习惯。\n\napp/hero.service.ts（部分代码）\n\n```ts\n@Injectable()\nexport class HeroService {\n  getHeroes() {\n    return Promise.resolve(HEROES);\n  }\n  // See the \"Take it slow\" appendix\n  getHeroesSlowly() {\n    return new Promise<Hero[]>(resolve =>\n      setTimeout(() => resolve(HEROES), 2000) // 2 seconds\n    );\n  }\n}\n```\n\n以上代码我们干了哪些事儿呢？\n\n  1. 写了一个使用`injectable`装饰的类\n  2. 写了两个成员函数\n  3. 一个返回一个Promise，直接`resolve`数据\n  4. 另一个也返回一个Promise，不过在两秒后`resolve`数据\n\n有的同学会问：`resolve`的数据哪去了？Promise是什么？我们继续讲解。\n\n# Promise\n\n如果你玩过ng1，你一定对promise不陌生，因为我们经常在路由里面写`resolve`，这里就可以接受一个Promise对象。还有ng1中的`$q.defer()`等等。\n\n但是promise并不是ng1的专利，你可以在你的任何javascript程序中使用promise，因为在ES6中已经原生提供[Promise对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)。你可以查看它的用法，这里我简单描述下：\n\n  1. 构造Promise，只需要在里面加入一个参数，这个参数是个function，这个function可以接受两个参数：`resolve`, `reject`。或者使用`Promise.resolve()`，不过这样没有延迟了。\n  2. 使用Promise对象，最常用的方法是`then()`，里面接受一个function，这个function的参数为`resolve`的值。除了`then()`还有`catch()`等\n\n为了让大家能够清晰的了解Promise的用法，我们打开chrome的console：\n\n![](/css/images/74.jpg)\n\n  1. 输入Promise，是个function。\n  2. 输入`Promise.resolve('123')`，我们得到一个状态为\"已经解决\"的promise。\n  3. 输入`new Promise(resolve=>;resolve('123'))`，我们还是得到一个状态为\"已经解决\"的promise。\n\n2和3的区别在于，后者可以在参数的函数中做一些处理，比如延迟或者http请求。\n\n然后让我们来看Promise的then方法：\n\n![](/css/images/75.jpg)\n\n  1. 首先我们写了一个已经`resolved`的promise，并将其赋值给`p`\n  2. 然后使用`p.then()`，在回调函数里面打印参数，得到`'123'`\n  3. 最后`p.then()`整体返回的是个初始化（pending）的promise。\n\n现在我们明白一下这个代码中promise的用法了吧？\n\napp/hero.service.ts（部分代码）\n\n```ts\n@Injectable()\nexport class HeroService {\n  getHeroes() {\n    return Promise.resolve(HEROES);\n  }\n  // See the \"Take it slow\" appendix\n  getHeroesSlowly() {\n    return new Promise<Hero[]>(resolve =>\n      setTimeout(() => resolve(HEROES), 2000) // 2 seconds\n    );\n  }\n}\n```\n那么我们为何要使用promise呢？主要是为了解决回调地狱的问题。因为有了promise，你不必再写深层的回调，而是像极了同步的写法。\n\n这是我的一个ng1的项目的[部分代码](https://github.com/lewis617/daily-task/blob/gh-pages/modules/login/ctrl.js)，用promise的`then()`来解决回调地狱。\n\n```js    \n    \nAuth.$createUser({email: email, password: pass})\n    .then(function() {\n        // authenticate so we have permission to write to Firebase\n        return Auth.$authWithPassword({ email: email, password: pass });\n    })\n    .then(function(user) {\n        // create a user profile in our data store\n        var ref = wdutil.ref('users', user.uid);\n        return wdutil.handler(function(cb) {\n            ref.set({email: email, name: $scope.name||firstPartOfEmail(email)}, cb);\n        });\n    })\n    .then(function(/* user */) {\n        $scope.wait.show=false;\n        // redirect to the account page\n        $location.path('/account');\n    }, function(err) {\n        $scope.wait.show=false;\n        $scope.alerts.push({type:'danger',msg:wdutil.errMessage(err)});\n    });\n```\n\n# Interface\n\n在编写这个服务的过程中我们使用了interface这个概念，这个知识点属于ts的范畴，我们通常在接口中声明类型，有点像react中的propTypes：\n\napp/hero.ts\n\n```ts\nexport interface Hero {\n  id: number;\n  name: string;\n}\n```\n\n然后我们在我们的服务中使用了这个接口：\n\napp/hero.service.ts（部分代码）\n\n```ts\nimport {Hero} from './hero';\n```\napp/hero.service.ts（部分代码）\n\n```ts   \nreturn new Promise<Hero[]>(resolve =>\n      setTimeout(() => resolve(HEROES), 2000) // 2 seconds\n    );\n```\n除此之外，我们在我们的组件里面也多次使用了这个接口：\n\napp/app.component.ts\n\n```ts\nheroes: Hero[];\nselectedHero: Hero;\n```\napp/hero-detail.component.ts\n\n```ts\nexport class HeroDetailComponent {\n  hero: Hero;\n}\n```\n\n到此为止，我们的服务就算是写好了！\n\n# 使用服务\n\n让我们在组件中测试一下我们写好的服务吧：\n\napp/app.component.ts（部分代码）\n\n```ts\n    \nimport {HeroService} from './hero.service';\n\n...\n\nproviders: [HeroService]\n\n...\n\nconstructor(private _heroService: HeroService) { }\n\n  getHeroes() {\n    this._heroService.getHeroes().then(heroes => this.heroes = heroes);\n  }\n```\n\n以上代码我们干了这些事儿：\n\n  1. 利用模块系统导入这个服务类\n  2. 在组件中注入这个服务\n  3. 在构造函数中将这个服务赋给一个私有变量`_heroService`\n  4. 然后就可以尽情地在类中使用这个服务对象了`this._heroService`\n\n这里的`getHeroes()`返回了一个Promise，所以我们可以使用`then`来处理接下来要发生的事。\n\n* * *\n\n# 教程示例代码及目录\n\nhttp://www.liuyiqi.cn/2016/12/25/angular2-tutorial-catalog/\n\n","slug":"ng2-service","published":1,"updated":"2019-05-01T08:10:29.899Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvm1001ztgytc6oggr1j","content":"<p>今天我们要讲的ng2的service这个概念，和ng1一样，service通常用于发送http请求，但其实你可以在里面封装任何你想封装的方法，有时候控制器之间的通讯也是依靠service来完成的，让我们一睹为快！</p>\n<a id=\"more\"></a>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p>例子是官方的例子，加载一个英雄列表，点击显示详细信息。我直接放在我们的升级后的装备里面。</p>\n<p><img src=\"/css/images/73.jpg\" alt=\"\"></p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/service\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<h1 id=\"Injectable\"><a href=\"#Injectable\" class=\"headerlink\" title=\"Injectable\"></a>Injectable</h1><p>在ng2里面如何编写服务呢？非常简单，你只需要写个类即可。那么这个<code>@Injectable()</code>是做什么的？其实单就这个例子来说，我们是不需要写个这个装饰的，因为我们的<code>HeroSerivce</code>没有依赖，如果你要写一个有依赖的服务，那么你需要加上这个<code>@Injectable()</code>，此处加上<code>@Injectable()</code>是可有可无的，但是写上是个好习惯。</p>\n<p>app/hero.service.ts（部分代码）</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroService &#123;</span><br><span class=\"line\">  getHeroes() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(HEROES);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// See the \"Take it slow\" appendix</span></span><br><span class=\"line\">  getHeroesSlowly() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>&lt;Hero[]&gt;(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span></span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(HEROES), <span class=\"number\">2000</span>) <span class=\"comment\">// 2 seconds</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码我们干了哪些事儿呢？</p>\n<ol>\n<li>写了一个使用<code>injectable</code>装饰的类</li>\n<li>写了两个成员函数</li>\n<li>一个返回一个Promise，直接<code>resolve</code>数据</li>\n<li>另一个也返回一个Promise，不过在两秒后<code>resolve</code>数据</li>\n</ol>\n<p>有的同学会问：<code>resolve</code>的数据哪去了？Promise是什么？我们继续讲解。</p>\n<h1 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h1><p>如果你玩过ng1，你一定对promise不陌生，因为我们经常在路由里面写<code>resolve</code>，这里就可以接受一个Promise对象。还有ng1中的<code>$q.defer()</code>等等。</p>\n<p>但是promise并不是ng1的专利，你可以在你的任何javascript程序中使用promise，因为在ES6中已经原生提供<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"noopener\">Promise对象</a>。你可以查看它的用法，这里我简单描述下：</p>\n<ol>\n<li>构造Promise，只需要在里面加入一个参数，这个参数是个function，这个function可以接受两个参数：<code>resolve</code>, <code>reject</code>。或者使用<code>Promise.resolve()</code>，不过这样没有延迟了。</li>\n<li>使用Promise对象，最常用的方法是<code>then()</code>，里面接受一个function，这个function的参数为<code>resolve</code>的值。除了<code>then()</code>还有<code>catch()</code>等</li>\n</ol>\n<p>为了让大家能够清晰的了解Promise的用法，我们打开chrome的console：</p>\n<p><img src=\"/css/images/74.jpg\" alt=\"\"></p>\n<ol>\n<li>输入Promise，是个function。</li>\n<li>输入<code>Promise.resolve(&#39;123&#39;)</code>，我们得到一个状态为”已经解决”的promise。</li>\n<li>输入<code>new Promise(resolve=&gt;;resolve(&#39;123&#39;))</code>，我们还是得到一个状态为”已经解决”的promise。</li>\n</ol>\n<p>2和3的区别在于，后者可以在参数的函数中做一些处理，比如延迟或者http请求。</p>\n<p>然后让我们来看Promise的then方法：</p>\n<p><img src=\"/css/images/75.jpg\" alt=\"\"></p>\n<ol>\n<li>首先我们写了一个已经<code>resolved</code>的promise，并将其赋值给<code>p</code></li>\n<li>然后使用<code>p.then()</code>，在回调函数里面打印参数，得到<code>&#39;123&#39;</code></li>\n<li>最后<code>p.then()</code>整体返回的是个初始化（pending）的promise。</li>\n</ol>\n<p>现在我们明白一下这个代码中promise的用法了吧？</p>\n<p>app/hero.service.ts（部分代码）</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroService &#123;</span><br><span class=\"line\">  getHeroes() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(HEROES);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// See the \"Take it slow\" appendix</span></span><br><span class=\"line\">  getHeroesSlowly() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>&lt;Hero[]&gt;(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span></span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(HEROES), <span class=\"number\">2000</span>) <span class=\"comment\">// 2 seconds</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么我们为何要使用promise呢？主要是为了解决回调地狱的问题。因为有了promise，你不必再写深层的回调，而是像极了同步的写法。</p>\n<p>这是我的一个ng1的项目的<a href=\"https://github.com/lewis617/daily-task/blob/gh-pages/modules/login/ctrl.js\" target=\"_blank\" rel=\"noopener\">部分代码</a>，用promise的<code>then()</code>来解决回调地狱。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\">Auth.$createUser(&#123;<span class=\"attr\">email</span>: email, <span class=\"attr\">password</span>: pass&#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// authenticate so we have permission to write to Firebase</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Auth.$authWithPassword(&#123; <span class=\"attr\">email</span>: email, <span class=\"attr\">password</span>: pass &#125;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// create a user profile in our data store</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> ref = wdutil.ref(<span class=\"string\">'users'</span>, user.uid);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wdutil.handler(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cb</span>) </span>&#123;</span><br><span class=\"line\">            ref.set(&#123;<span class=\"attr\">email</span>: email, <span class=\"attr\">name</span>: $scope.name||firstPartOfEmail(email)&#125;, cb);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"><span class=\"regexp\">/* user */</span></span>) </span>&#123;</span><br><span class=\"line\">        $scope.wait.show=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// redirect to the account page</span></span><br><span class=\"line\">        $location.path(<span class=\"string\">'/account'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">        $scope.wait.show=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        $scope.alerts.push(&#123;<span class=\"attr\">type</span>:<span class=\"string\">'danger'</span>,<span class=\"attr\">msg</span>:wdutil.errMessage(err)&#125;);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"Interface\"><a href=\"#Interface\" class=\"headerlink\" title=\"Interface\"></a>Interface</h1><p>在编写这个服务的过程中我们使用了interface这个概念，这个知识点属于ts的范畴，我们通常在接口中声明类型，有点像react中的propTypes：</p>\n<p>app/hero.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Hero &#123;</span><br><span class=\"line\">  id: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们在我们的服务中使用了这个接口：</p>\n<p>app/hero.service.ts（部分代码）</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Hero&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./hero'</span>;</span><br></pre></td></tr></table></figure>\n<p>app/hero.service.ts（部分代码）</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>&lt;Hero[]&gt;(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span></span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(HEROES), <span class=\"number\">2000</span>) <span class=\"comment\">// 2 seconds</span></span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n<p>除此之外，我们在我们的组件里面也多次使用了这个接口：</p>\n<p>app/app.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heroes: Hero[];</span><br><span class=\"line\">selectedHero: Hero;</span><br></pre></td></tr></table></figure>\n<p>app/hero-detail.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroDetailComponent &#123;</span><br><span class=\"line\">  hero: Hero;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此为止，我们的服务就算是写好了！</p>\n<h1 id=\"使用服务\"><a href=\"#使用服务\" class=\"headerlink\" title=\"使用服务\"></a>使用服务</h1><p>让我们在组件中测试一下我们写好的服务吧：</p>\n<p>app/app.component.ts（部分代码）</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;HeroService&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./hero.service'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">providers: [HeroService]</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> _heroService: HeroService</span>) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getHeroes() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._heroService.getHeroes().then(<span class=\"function\"><span class=\"params\">heroes</span> =&gt;</span> <span class=\"keyword\">this</span>.heroes = heroes);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码我们干了这些事儿：</p>\n<ol>\n<li>利用模块系统导入这个服务类</li>\n<li>在组件中注入这个服务</li>\n<li>在构造函数中将这个服务赋给一个私有变量<code>_heroService</code></li>\n<li>然后就可以尽情地在类中使用这个服务对象了<code>this._heroService</code></li>\n</ol>\n<p>这里的<code>getHeroes()</code>返回了一个Promise，所以我们可以使用<code>then</code>来处理接下来要发生的事。</p>\n<hr>\n<h1 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h1><p><a href=\"http://www.liuyiqi.cn/2016/12/25/angular2-tutorial-catalog/\">http://www.liuyiqi.cn/2016/12/25/angular2-tutorial-catalog/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天我们要讲的ng2的service这个概念，和ng1一样，service通常用于发送http请求，但其实你可以在里面封装任何你想封装的方法，有时候控制器之间的通讯也是依靠service来完成的，让我们一睹为快！</p>","more":"<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p>例子是官方的例子，加载一个英雄列表，点击显示详细信息。我直接放在我们的升级后的装备里面。</p>\n<p><img src=\"/css/images/73.jpg\" alt=\"\"></p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/service\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<h1 id=\"Injectable\"><a href=\"#Injectable\" class=\"headerlink\" title=\"Injectable\"></a>Injectable</h1><p>在ng2里面如何编写服务呢？非常简单，你只需要写个类即可。那么这个<code>@Injectable()</code>是做什么的？其实单就这个例子来说，我们是不需要写个这个装饰的，因为我们的<code>HeroSerivce</code>没有依赖，如果你要写一个有依赖的服务，那么你需要加上这个<code>@Injectable()</code>，此处加上<code>@Injectable()</code>是可有可无的，但是写上是个好习惯。</p>\n<p>app/hero.service.ts（部分代码）</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroService &#123;</span><br><span class=\"line\">  getHeroes() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(HEROES);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// See the \"Take it slow\" appendix</span></span><br><span class=\"line\">  getHeroesSlowly() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>&lt;Hero[]&gt;(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span></span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(HEROES), <span class=\"number\">2000</span>) <span class=\"comment\">// 2 seconds</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码我们干了哪些事儿呢？</p>\n<ol>\n<li>写了一个使用<code>injectable</code>装饰的类</li>\n<li>写了两个成员函数</li>\n<li>一个返回一个Promise，直接<code>resolve</code>数据</li>\n<li>另一个也返回一个Promise，不过在两秒后<code>resolve</code>数据</li>\n</ol>\n<p>有的同学会问：<code>resolve</code>的数据哪去了？Promise是什么？我们继续讲解。</p>\n<h1 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h1><p>如果你玩过ng1，你一定对promise不陌生，因为我们经常在路由里面写<code>resolve</code>，这里就可以接受一个Promise对象。还有ng1中的<code>$q.defer()</code>等等。</p>\n<p>但是promise并不是ng1的专利，你可以在你的任何javascript程序中使用promise，因为在ES6中已经原生提供<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"noopener\">Promise对象</a>。你可以查看它的用法，这里我简单描述下：</p>\n<ol>\n<li>构造Promise，只需要在里面加入一个参数，这个参数是个function，这个function可以接受两个参数：<code>resolve</code>, <code>reject</code>。或者使用<code>Promise.resolve()</code>，不过这样没有延迟了。</li>\n<li>使用Promise对象，最常用的方法是<code>then()</code>，里面接受一个function，这个function的参数为<code>resolve</code>的值。除了<code>then()</code>还有<code>catch()</code>等</li>\n</ol>\n<p>为了让大家能够清晰的了解Promise的用法，我们打开chrome的console：</p>\n<p><img src=\"/css/images/74.jpg\" alt=\"\"></p>\n<ol>\n<li>输入Promise，是个function。</li>\n<li>输入<code>Promise.resolve(&#39;123&#39;)</code>，我们得到一个状态为”已经解决”的promise。</li>\n<li>输入<code>new Promise(resolve=&gt;;resolve(&#39;123&#39;))</code>，我们还是得到一个状态为”已经解决”的promise。</li>\n</ol>\n<p>2和3的区别在于，后者可以在参数的函数中做一些处理，比如延迟或者http请求。</p>\n<p>然后让我们来看Promise的then方法：</p>\n<p><img src=\"/css/images/75.jpg\" alt=\"\"></p>\n<ol>\n<li>首先我们写了一个已经<code>resolved</code>的promise，并将其赋值给<code>p</code></li>\n<li>然后使用<code>p.then()</code>，在回调函数里面打印参数，得到<code>&#39;123&#39;</code></li>\n<li>最后<code>p.then()</code>整体返回的是个初始化（pending）的promise。</li>\n</ol>\n<p>现在我们明白一下这个代码中promise的用法了吧？</p>\n<p>app/hero.service.ts（部分代码）</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroService &#123;</span><br><span class=\"line\">  getHeroes() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(HEROES);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// See the \"Take it slow\" appendix</span></span><br><span class=\"line\">  getHeroesSlowly() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>&lt;Hero[]&gt;(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span></span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(HEROES), <span class=\"number\">2000</span>) <span class=\"comment\">// 2 seconds</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么我们为何要使用promise呢？主要是为了解决回调地狱的问题。因为有了promise，你不必再写深层的回调，而是像极了同步的写法。</p>\n<p>这是我的一个ng1的项目的<a href=\"https://github.com/lewis617/daily-task/blob/gh-pages/modules/login/ctrl.js\" target=\"_blank\" rel=\"noopener\">部分代码</a>，用promise的<code>then()</code>来解决回调地狱。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\">Auth.$createUser(&#123;<span class=\"attr\">email</span>: email, <span class=\"attr\">password</span>: pass&#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// authenticate so we have permission to write to Firebase</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Auth.$authWithPassword(&#123; <span class=\"attr\">email</span>: email, <span class=\"attr\">password</span>: pass &#125;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// create a user profile in our data store</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> ref = wdutil.ref(<span class=\"string\">'users'</span>, user.uid);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wdutil.handler(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cb</span>) </span>&#123;</span><br><span class=\"line\">            ref.set(&#123;<span class=\"attr\">email</span>: email, <span class=\"attr\">name</span>: $scope.name||firstPartOfEmail(email)&#125;, cb);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"><span class=\"regexp\">/* user */</span></span>) </span>&#123;</span><br><span class=\"line\">        $scope.wait.show=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// redirect to the account page</span></span><br><span class=\"line\">        $location.path(<span class=\"string\">'/account'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">        $scope.wait.show=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        $scope.alerts.push(&#123;<span class=\"attr\">type</span>:<span class=\"string\">'danger'</span>,<span class=\"attr\">msg</span>:wdutil.errMessage(err)&#125;);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"Interface\"><a href=\"#Interface\" class=\"headerlink\" title=\"Interface\"></a>Interface</h1><p>在编写这个服务的过程中我们使用了interface这个概念，这个知识点属于ts的范畴，我们通常在接口中声明类型，有点像react中的propTypes：</p>\n<p>app/hero.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Hero &#123;</span><br><span class=\"line\">  id: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们在我们的服务中使用了这个接口：</p>\n<p>app/hero.service.ts（部分代码）</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Hero&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./hero'</span>;</span><br></pre></td></tr></table></figure>\n<p>app/hero.service.ts（部分代码）</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>&lt;Hero[]&gt;(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span></span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(HEROES), <span class=\"number\">2000</span>) <span class=\"comment\">// 2 seconds</span></span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n<p>除此之外，我们在我们的组件里面也多次使用了这个接口：</p>\n<p>app/app.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heroes: Hero[];</span><br><span class=\"line\">selectedHero: Hero;</span><br></pre></td></tr></table></figure>\n<p>app/hero-detail.component.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> HeroDetailComponent &#123;</span><br><span class=\"line\">  hero: Hero;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此为止，我们的服务就算是写好了！</p>\n<h1 id=\"使用服务\"><a href=\"#使用服务\" class=\"headerlink\" title=\"使用服务\"></a>使用服务</h1><p>让我们在组件中测试一下我们写好的服务吧：</p>\n<p>app/app.component.ts（部分代码）</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;HeroService&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./hero.service'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">providers: [HeroService]</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> _heroService: HeroService</span>) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getHeroes() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._heroService.getHeroes().then(<span class=\"function\"><span class=\"params\">heroes</span> =&gt;</span> <span class=\"keyword\">this</span>.heroes = heroes);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码我们干了这些事儿：</p>\n<ol>\n<li>利用模块系统导入这个服务类</li>\n<li>在组件中注入这个服务</li>\n<li>在构造函数中将这个服务赋给一个私有变量<code>_heroService</code></li>\n<li>然后就可以尽情地在类中使用这个服务对象了<code>this._heroService</code></li>\n</ol>\n<p>这里的<code>getHeroes()</code>返回了一个Promise，所以我们可以使用<code>then</code>来处理接下来要发生的事。</p>\n<hr>\n<h1 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h1><p><a href=\"http://www.liuyiqi.cn/2016/12/25/angular2-tutorial-catalog/\">http://www.liuyiqi.cn/2016/12/25/angular2-tutorial-catalog/</a></p>"},{"title":"使用 superagent+cheerio 写爬虫","date":"2017-04-24T11:57:00.000Z","_content":"本文将会讲解如何使用 superagent+cheerio 写爬虫。阅读本文，你会学习到这些知识点：\n\n- 如何使用 superagent 获取页面内容\n- 如何使用 superagent 获取 JS 文件的内容\n- 如何使用 superagent 下载文件\n- 如何使用 cheerio 操作页面 DOM\n- 如何正确设置字符编码来避免乱码\n- 如何使用正则表达式去除字符串中的多余信息\n\n<!--more-->\n\n## 使用 superagent 获取页面内容\n\nsuperagent+cheerio 是 Node 爬虫的经典组合。superagent 是一个发起 Ajax 请求的工具。我们使用它来请求各种网络资源。比如，我们想批量爬取一些文件，我们就必须先找到文件的 URl，想找到 URL 就必须先获取记录这些 URL 的页面，想获取页面内容，那么首先就应该使用 superagent 把页面给请求下来。基本的请求代码如下：\n\n```js\n request\n   .get('http://example.com/search')\n   .end(function(err, res){\n\t   // 将会打印页面的 HTML 字符串\n       console.log(res.text);\n   });\n```\n\n拿到了 HTMl 字符串，就可以使用 cheerio 进行解析了。关于 cheerio 我们等会介绍～ \n\n## 使用 superagent 获取 JS 文件的内容\n\n使用 superagent 获取页面内容非常简单，但是当我请求完页面后发现，音频和字幕的 URL 不在页面上，而是通过 JS 动态渲染到页面上的，我的爬虫无法和 JS 通信，这该怎么办呢？其实非常简单，既然 URL 信息在 JS 文件中，那么我们直接获取 JS 文件，并使用 eval 方法解析不就行了？所以，我们来使用 superagent 获取 JS 文件的内容。与获取页面内容的方法不同，获取 JS 文件，需要加个 `.buffer(true)` ：\n\n```js\nrequest.get('https://raw.githubusercontent.com/sindresorhus/negative-zero/master/index.js')\n    .buffer(true)\n    .end(function (err, res) {\n      ...\n    }\n```\n\n为何要如此？具体原因可以看这个 Issue：\n\n https://github.com/visionmedia/superagent/issues/523\n\n## 使用 superagent 下载文件\n\n前面两节介绍了使用 superagent 获取页面和 JS 文件，那么如何使用 superagent 下载保存文件到硬盘上呢？这里需要配合使用 Node 的 `fs.createWriteStream` 方法，代码如下：\n\n```js\nfunction download(url, localPath, cb) {\n    var stream = fs.createWriteStream(localPath);\n    stream.on('finish', function () {\n        console.log('The download of ' + localPath + ' is complete!');\n        cb();\n    });\n    request.get(url).pipe(stream);\n}\n```\n\n非常简单，不再赘述！\n\n## 使用 cheerio 操作页面 DOM\n\n在第一节，我们介绍了使用 superagent 获取页面内容，但是页面内容太多，我们想高效提取有用信息，该如何做呢？在浏览器中，我们通常使用 jQuery 来高效操作 DOM，在 Node 爬虫中，我们可以使用 cheerio 来模拟 jQuery 的操作方法。cheerio 的基本用法如下：\n\n```js\nvar cheerio = require('cheerio')\nvar $ = cheerio.load('<h2 class=\"title\">Hello world</h2>')\n\n$('h2.title').text('Hello there!')\n$('h2').addClass('welcome')\n\nreturn $.html()\n//=> <h2 class=\"title welcome\">Hello there!</h2>\n```\n\n通过 superagent 获取 html 字符串，然后使用 cheerio 解析，页面上的内容就尽在你的掌握中了！\n\n更多 cheerio 的用法可以参考：\n\nhttps://github.com/cheeriojs/cheerio\n\n\n## 正确设置字符编码来避免乱码\n\n在获取页面内容，并提取里面的中文信息时，偶尔会遇到中文乱码。这是因为页面的 chartset 设置了`gb2312` 的原因，那么想要正确解析设置 `gb2312` 编码的页面，就必须使用这个编码来解析。值得高兴的是，superagent 为我们提供了相关的插件来实现：\n\nhttps://github.com/magicdawn/superagent-charset\n\n基本用法如下：\n\n```js\nrequest.get(mainOrigin + mainPathname)\n    .charset('gb2312')\n    .end(function (err, res) {\n    ...\n  })\n```\n如何知道 `.charset()` 中填的是什么编码呢？你只需要看看页面的这行代码即可：\n\n```html\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=gb2312\">\n```\n\n## 使用正则表达式去除字符串中的多余信息\n\n最后，我们来讲一下如何使用使用正则表达式去除字符串中的多余信息。在下载文件时，可能需要处理一些中文名称作为将来的文件名或目录名。页面中的中文名称往往不是我们想要的，那么如何处理名称中的多余信息呢？使用正则表达式就可以做到！比如：\n\n如果你想将 `'听电影学英语之海上钢琴师'`变为`'海上钢琴师'`，那么你可以这么做：\n\n```js\n// str 就是'海上钢琴师'\nvar str = '听电影学英语之海上钢琴师'.replace(/听电影学英语之/g, '');\n```\n\n如果你想将 `'听电影MP3学英语之海上钢琴师'` 或 `'听电影学英语之海上钢琴师'`变为`'海上钢琴师'`，那么你可以这么做：\n\n```js\n// str 就是'海上钢琴师'\nvar str = '听电影学英语之海上钢琴师'.replace(/听电影(MP3)?学英语之/g, '');\n```\n> 注：小括号代表子表达式，问号代表前面的字符出现 0 或 1 次。\n\n如果你想将以下字符串：\n\n- `'听电影学英语之海上钢琴师'`\n- `'听电影MP3学英语之海上钢琴师'`\n- `'听电影MP3学英语之海上钢琴师中英双语MP3+LRC'`\n- `'听电影MP3学英语之海上钢琴师 中英双语MP3+LRC'`\n- `'听电影MP3学英语之海上钢琴师 中英双语MP3+LRC+文本'`\n- `'听电影MP3学英语之海上钢琴师 中英双语MP3+LRC+文本 '`\n\n都变为 `'海上钢琴师'`，那么正则表达式应该这么写：\n\n```js\n/(听电影(MP3)?学英语之)|(\\s?中英双语MP3\\+LRC(\\+文本)?)|(\\s?$)/g\n```\n\n把各种情况都考虑进去，然后用 `|` 隔开。其中，`\\s` 匹配任何空白字符，包括空格、制表符、换页符等等。\n\n## 总结\n\n上面介绍了 superagent+cheerio 写爬虫需要用到的各种技术，本文不打算对业务进行过多叙述。只要掌握了上述方法，就可以轻松读懂爬虫代码，如果你没写过爬虫，就赶快试试吧！\n\n## 教程示例代码及目录\n\n<https://github.com/lewis617/practical-js>","source":"_posts/node-spider.md","raw":"---\ntitle: 使用 superagent+cheerio 写爬虫\ndate: 2017-04-24 19:57:00\ntags: [practical-js, Node, 爬虫, superagent, cheerio, 字符编码, 正则表达式]\n---\n本文将会讲解如何使用 superagent+cheerio 写爬虫。阅读本文，你会学习到这些知识点：\n\n- 如何使用 superagent 获取页面内容\n- 如何使用 superagent 获取 JS 文件的内容\n- 如何使用 superagent 下载文件\n- 如何使用 cheerio 操作页面 DOM\n- 如何正确设置字符编码来避免乱码\n- 如何使用正则表达式去除字符串中的多余信息\n\n<!--more-->\n\n## 使用 superagent 获取页面内容\n\nsuperagent+cheerio 是 Node 爬虫的经典组合。superagent 是一个发起 Ajax 请求的工具。我们使用它来请求各种网络资源。比如，我们想批量爬取一些文件，我们就必须先找到文件的 URl，想找到 URL 就必须先获取记录这些 URL 的页面，想获取页面内容，那么首先就应该使用 superagent 把页面给请求下来。基本的请求代码如下：\n\n```js\n request\n   .get('http://example.com/search')\n   .end(function(err, res){\n\t   // 将会打印页面的 HTML 字符串\n       console.log(res.text);\n   });\n```\n\n拿到了 HTMl 字符串，就可以使用 cheerio 进行解析了。关于 cheerio 我们等会介绍～ \n\n## 使用 superagent 获取 JS 文件的内容\n\n使用 superagent 获取页面内容非常简单，但是当我请求完页面后发现，音频和字幕的 URL 不在页面上，而是通过 JS 动态渲染到页面上的，我的爬虫无法和 JS 通信，这该怎么办呢？其实非常简单，既然 URL 信息在 JS 文件中，那么我们直接获取 JS 文件，并使用 eval 方法解析不就行了？所以，我们来使用 superagent 获取 JS 文件的内容。与获取页面内容的方法不同，获取 JS 文件，需要加个 `.buffer(true)` ：\n\n```js\nrequest.get('https://raw.githubusercontent.com/sindresorhus/negative-zero/master/index.js')\n    .buffer(true)\n    .end(function (err, res) {\n      ...\n    }\n```\n\n为何要如此？具体原因可以看这个 Issue：\n\n https://github.com/visionmedia/superagent/issues/523\n\n## 使用 superagent 下载文件\n\n前面两节介绍了使用 superagent 获取页面和 JS 文件，那么如何使用 superagent 下载保存文件到硬盘上呢？这里需要配合使用 Node 的 `fs.createWriteStream` 方法，代码如下：\n\n```js\nfunction download(url, localPath, cb) {\n    var stream = fs.createWriteStream(localPath);\n    stream.on('finish', function () {\n        console.log('The download of ' + localPath + ' is complete!');\n        cb();\n    });\n    request.get(url).pipe(stream);\n}\n```\n\n非常简单，不再赘述！\n\n## 使用 cheerio 操作页面 DOM\n\n在第一节，我们介绍了使用 superagent 获取页面内容，但是页面内容太多，我们想高效提取有用信息，该如何做呢？在浏览器中，我们通常使用 jQuery 来高效操作 DOM，在 Node 爬虫中，我们可以使用 cheerio 来模拟 jQuery 的操作方法。cheerio 的基本用法如下：\n\n```js\nvar cheerio = require('cheerio')\nvar $ = cheerio.load('<h2 class=\"title\">Hello world</h2>')\n\n$('h2.title').text('Hello there!')\n$('h2').addClass('welcome')\n\nreturn $.html()\n//=> <h2 class=\"title welcome\">Hello there!</h2>\n```\n\n通过 superagent 获取 html 字符串，然后使用 cheerio 解析，页面上的内容就尽在你的掌握中了！\n\n更多 cheerio 的用法可以参考：\n\nhttps://github.com/cheeriojs/cheerio\n\n\n## 正确设置字符编码来避免乱码\n\n在获取页面内容，并提取里面的中文信息时，偶尔会遇到中文乱码。这是因为页面的 chartset 设置了`gb2312` 的原因，那么想要正确解析设置 `gb2312` 编码的页面，就必须使用这个编码来解析。值得高兴的是，superagent 为我们提供了相关的插件来实现：\n\nhttps://github.com/magicdawn/superagent-charset\n\n基本用法如下：\n\n```js\nrequest.get(mainOrigin + mainPathname)\n    .charset('gb2312')\n    .end(function (err, res) {\n    ...\n  })\n```\n如何知道 `.charset()` 中填的是什么编码呢？你只需要看看页面的这行代码即可：\n\n```html\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=gb2312\">\n```\n\n## 使用正则表达式去除字符串中的多余信息\n\n最后，我们来讲一下如何使用使用正则表达式去除字符串中的多余信息。在下载文件时，可能需要处理一些中文名称作为将来的文件名或目录名。页面中的中文名称往往不是我们想要的，那么如何处理名称中的多余信息呢？使用正则表达式就可以做到！比如：\n\n如果你想将 `'听电影学英语之海上钢琴师'`变为`'海上钢琴师'`，那么你可以这么做：\n\n```js\n// str 就是'海上钢琴师'\nvar str = '听电影学英语之海上钢琴师'.replace(/听电影学英语之/g, '');\n```\n\n如果你想将 `'听电影MP3学英语之海上钢琴师'` 或 `'听电影学英语之海上钢琴师'`变为`'海上钢琴师'`，那么你可以这么做：\n\n```js\n// str 就是'海上钢琴师'\nvar str = '听电影学英语之海上钢琴师'.replace(/听电影(MP3)?学英语之/g, '');\n```\n> 注：小括号代表子表达式，问号代表前面的字符出现 0 或 1 次。\n\n如果你想将以下字符串：\n\n- `'听电影学英语之海上钢琴师'`\n- `'听电影MP3学英语之海上钢琴师'`\n- `'听电影MP3学英语之海上钢琴师中英双语MP3+LRC'`\n- `'听电影MP3学英语之海上钢琴师 中英双语MP3+LRC'`\n- `'听电影MP3学英语之海上钢琴师 中英双语MP3+LRC+文本'`\n- `'听电影MP3学英语之海上钢琴师 中英双语MP3+LRC+文本 '`\n\n都变为 `'海上钢琴师'`，那么正则表达式应该这么写：\n\n```js\n/(听电影(MP3)?学英语之)|(\\s?中英双语MP3\\+LRC(\\+文本)?)|(\\s?$)/g\n```\n\n把各种情况都考虑进去，然后用 `|` 隔开。其中，`\\s` 匹配任何空白字符，包括空格、制表符、换页符等等。\n\n## 总结\n\n上面介绍了 superagent+cheerio 写爬虫需要用到的各种技术，本文不打算对业务进行过多叙述。只要掌握了上述方法，就可以轻松读懂爬虫代码，如果你没写过爬虫，就赶快试试吧！\n\n## 教程示例代码及目录\n\n<https://github.com/lewis617/practical-js>","slug":"node-spider","published":1,"updated":"2019-05-01T08:02:11.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvm20022tgytlxx68xrd","content":"<p>本文将会讲解如何使用 superagent+cheerio 写爬虫。阅读本文，你会学习到这些知识点：</p>\n<ul>\n<li>如何使用 superagent 获取页面内容</li>\n<li>如何使用 superagent 获取 JS 文件的内容</li>\n<li>如何使用 superagent 下载文件</li>\n<li>如何使用 cheerio 操作页面 DOM</li>\n<li>如何正确设置字符编码来避免乱码</li>\n<li>如何使用正则表达式去除字符串中的多余信息</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"使用-superagent-获取页面内容\"><a href=\"#使用-superagent-获取页面内容\" class=\"headerlink\" title=\"使用 superagent 获取页面内容\"></a>使用 superagent 获取页面内容</h2><p>superagent+cheerio 是 Node 爬虫的经典组合。superagent 是一个发起 Ajax 请求的工具。我们使用它来请求各种网络资源。比如，我们想批量爬取一些文件，我们就必须先找到文件的 URl，想找到 URL 就必须先获取记录这些 URL 的页面，想获取页面内容，那么首先就应该使用 superagent 把页面给请求下来。基本的请求代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request</span><br><span class=\"line\">  .get(<span class=\"string\">'http://example.com/search'</span>)</span><br><span class=\"line\">  .end(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 将会打印页面的 HTML 字符串</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(res.text);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>拿到了 HTMl 字符串，就可以使用 cheerio 进行解析了。关于 cheerio 我们等会介绍～ </p>\n<h2 id=\"使用-superagent-获取-JS-文件的内容\"><a href=\"#使用-superagent-获取-JS-文件的内容\" class=\"headerlink\" title=\"使用 superagent 获取 JS 文件的内容\"></a>使用 superagent 获取 JS 文件的内容</h2><p>使用 superagent 获取页面内容非常简单，但是当我请求完页面后发现，音频和字幕的 URL 不在页面上，而是通过 JS 动态渲染到页面上的，我的爬虫无法和 JS 通信，这该怎么办呢？其实非常简单，既然 URL 信息在 JS 文件中，那么我们直接获取 JS 文件，并使用 eval 方法解析不就行了？所以，我们来使用 superagent 获取 JS 文件的内容。与获取页面内容的方法不同，获取 JS 文件，需要加个 <code>.buffer(true)</code> ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.get(<span class=\"string\">'https://raw.githubusercontent.com/sindresorhus/negative-zero/master/index.js'</span>)</span><br><span class=\"line\">    .buffer(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    .end(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>为何要如此？具体原因可以看这个 Issue：</p>\n<p> <a href=\"https://github.com/visionmedia/superagent/issues/523\" target=\"_blank\" rel=\"noopener\">https://github.com/visionmedia/superagent/issues/523</a></p>\n<h2 id=\"使用-superagent-下载文件\"><a href=\"#使用-superagent-下载文件\" class=\"headerlink\" title=\"使用 superagent 下载文件\"></a>使用 superagent 下载文件</h2><p>前面两节介绍了使用 superagent 获取页面和 JS 文件，那么如何使用 superagent 下载保存文件到硬盘上呢？这里需要配合使用 Node 的 <code>fs.createWriteStream</code> 方法，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">download</span>(<span class=\"params\">url, localPath, cb</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stream = fs.createWriteStream(localPath);</span><br><span class=\"line\">    stream.on(<span class=\"string\">'finish'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'The download of '</span> + localPath + <span class=\"string\">' is complete!'</span>);</span><br><span class=\"line\">        cb();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    request.get(url).pipe(stream);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>非常简单，不再赘述！</p>\n<h2 id=\"使用-cheerio-操作页面-DOM\"><a href=\"#使用-cheerio-操作页面-DOM\" class=\"headerlink\" title=\"使用 cheerio 操作页面 DOM\"></a>使用 cheerio 操作页面 DOM</h2><p>在第一节，我们介绍了使用 superagent 获取页面内容，但是页面内容太多，我们想高效提取有用信息，该如何做呢？在浏览器中，我们通常使用 jQuery 来高效操作 DOM，在 Node 爬虫中，我们可以使用 cheerio 来模拟 jQuery 的操作方法。cheerio 的基本用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">'cheerio'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> $ = cheerio.load(<span class=\"string\">'&lt;h2 class=\"title\"&gt;Hello world&lt;/h2&gt;'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">'h2.title'</span>).text(<span class=\"string\">'Hello there!'</span>)</span><br><span class=\"line\">$(<span class=\"string\">'h2'</span>).addClass(<span class=\"string\">'welcome'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> $.html()</span><br><span class=\"line\"><span class=\"comment\">//=&gt; &lt;h2 class=\"title welcome\"&gt;Hello there!&lt;/h2&gt;</span></span><br></pre></td></tr></table></figure>\n<p>通过 superagent 获取 html 字符串，然后使用 cheerio 解析，页面上的内容就尽在你的掌握中了！</p>\n<p>更多 cheerio 的用法可以参考：</p>\n<p><a href=\"https://github.com/cheeriojs/cheerio\" target=\"_blank\" rel=\"noopener\">https://github.com/cheeriojs/cheerio</a></p>\n<h2 id=\"正确设置字符编码来避免乱码\"><a href=\"#正确设置字符编码来避免乱码\" class=\"headerlink\" title=\"正确设置字符编码来避免乱码\"></a>正确设置字符编码来避免乱码</h2><p>在获取页面内容，并提取里面的中文信息时，偶尔会遇到中文乱码。这是因为页面的 chartset 设置了<code>gb2312</code> 的原因，那么想要正确解析设置 <code>gb2312</code> 编码的页面，就必须使用这个编码来解析。值得高兴的是，superagent 为我们提供了相关的插件来实现：</p>\n<p><a href=\"https://github.com/magicdawn/superagent-charset\" target=\"_blank\" rel=\"noopener\">https://github.com/magicdawn/superagent-charset</a></p>\n<p>基本用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.get(mainOrigin + mainPathname)</span><br><span class=\"line\">    .charset(<span class=\"string\">'gb2312'</span>)</span><br><span class=\"line\">    .end(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>如何知道 <code>.charset()</code> 中填的是什么编码呢？你只需要看看页面的这行代码即可：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html; charset=gb2312\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"使用正则表达式去除字符串中的多余信息\"><a href=\"#使用正则表达式去除字符串中的多余信息\" class=\"headerlink\" title=\"使用正则表达式去除字符串中的多余信息\"></a>使用正则表达式去除字符串中的多余信息</h2><p>最后，我们来讲一下如何使用使用正则表达式去除字符串中的多余信息。在下载文件时，可能需要处理一些中文名称作为将来的文件名或目录名。页面中的中文名称往往不是我们想要的，那么如何处理名称中的多余信息呢？使用正则表达式就可以做到！比如：</p>\n<p>如果你想将 <code>&#39;听电影学英语之海上钢琴师&#39;</code>变为<code>&#39;海上钢琴师&#39;</code>，那么你可以这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// str 就是'海上钢琴师'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'听电影学英语之海上钢琴师'</span>.replace(<span class=\"regexp\">/听电影学英语之/g</span>, <span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n<p>如果你想将 <code>&#39;听电影MP3学英语之海上钢琴师&#39;</code> 或 <code>&#39;听电影学英语之海上钢琴师&#39;</code>变为<code>&#39;海上钢琴师&#39;</code>，那么你可以这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// str 就是'海上钢琴师'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'听电影学英语之海上钢琴师'</span>.replace(<span class=\"regexp\">/听电影(MP3)?学英语之/g</span>, <span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：小括号代表子表达式，问号代表前面的字符出现 0 或 1 次。</p>\n</blockquote>\n<p>如果你想将以下字符串：</p>\n<ul>\n<li><code>&#39;听电影学英语之海上钢琴师&#39;</code></li>\n<li><code>&#39;听电影MP3学英语之海上钢琴师&#39;</code></li>\n<li><code>&#39;听电影MP3学英语之海上钢琴师中英双语MP3+LRC&#39;</code></li>\n<li><code>&#39;听电影MP3学英语之海上钢琴师 中英双语MP3+LRC&#39;</code></li>\n<li><code>&#39;听电影MP3学英语之海上钢琴师 中英双语MP3+LRC+文本&#39;</code></li>\n<li><code>&#39;听电影MP3学英语之海上钢琴师 中英双语MP3+LRC+文本 &#39;</code></li>\n</ul>\n<p>都变为 <code>&#39;海上钢琴师&#39;</code>，那么正则表达式应该这么写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/(听电影(MP3)?学英语之)|(\\s?中英双语MP3\\+LRC(\\+文本)?)|(\\s?$)/g</span><br></pre></td></tr></table></figure>\n<p>把各种情况都考虑进去，然后用 <code>|</code> 隔开。其中，<code>\\s</code> 匹配任何空白字符，包括空格、制表符、换页符等等。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面介绍了 superagent+cheerio 写爬虫需要用到的各种技术，本文不打算对业务进行过多叙述。只要掌握了上述方法，就可以轻松读懂爬虫代码，如果你没写过爬虫，就赶快试试吧！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p><a href=\"https://github.com/lewis617/practical-js\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/practical-js</a></p>\n","site":{"data":{}},"excerpt":"<p>本文将会讲解如何使用 superagent+cheerio 写爬虫。阅读本文，你会学习到这些知识点：</p>\n<ul>\n<li>如何使用 superagent 获取页面内容</li>\n<li>如何使用 superagent 获取 JS 文件的内容</li>\n<li>如何使用 superagent 下载文件</li>\n<li>如何使用 cheerio 操作页面 DOM</li>\n<li>如何正确设置字符编码来避免乱码</li>\n<li>如何使用正则表达式去除字符串中的多余信息</li>\n</ul>","more":"<h2 id=\"使用-superagent-获取页面内容\"><a href=\"#使用-superagent-获取页面内容\" class=\"headerlink\" title=\"使用 superagent 获取页面内容\"></a>使用 superagent 获取页面内容</h2><p>superagent+cheerio 是 Node 爬虫的经典组合。superagent 是一个发起 Ajax 请求的工具。我们使用它来请求各种网络资源。比如，我们想批量爬取一些文件，我们就必须先找到文件的 URl，想找到 URL 就必须先获取记录这些 URL 的页面，想获取页面内容，那么首先就应该使用 superagent 把页面给请求下来。基本的请求代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request</span><br><span class=\"line\">  .get(<span class=\"string\">'http://example.com/search'</span>)</span><br><span class=\"line\">  .end(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 将会打印页面的 HTML 字符串</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(res.text);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>拿到了 HTMl 字符串，就可以使用 cheerio 进行解析了。关于 cheerio 我们等会介绍～ </p>\n<h2 id=\"使用-superagent-获取-JS-文件的内容\"><a href=\"#使用-superagent-获取-JS-文件的内容\" class=\"headerlink\" title=\"使用 superagent 获取 JS 文件的内容\"></a>使用 superagent 获取 JS 文件的内容</h2><p>使用 superagent 获取页面内容非常简单，但是当我请求完页面后发现，音频和字幕的 URL 不在页面上，而是通过 JS 动态渲染到页面上的，我的爬虫无法和 JS 通信，这该怎么办呢？其实非常简单，既然 URL 信息在 JS 文件中，那么我们直接获取 JS 文件，并使用 eval 方法解析不就行了？所以，我们来使用 superagent 获取 JS 文件的内容。与获取页面内容的方法不同，获取 JS 文件，需要加个 <code>.buffer(true)</code> ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.get(<span class=\"string\">'https://raw.githubusercontent.com/sindresorhus/negative-zero/master/index.js'</span>)</span><br><span class=\"line\">    .buffer(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    .end(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>为何要如此？具体原因可以看这个 Issue：</p>\n<p> <a href=\"https://github.com/visionmedia/superagent/issues/523\" target=\"_blank\" rel=\"noopener\">https://github.com/visionmedia/superagent/issues/523</a></p>\n<h2 id=\"使用-superagent-下载文件\"><a href=\"#使用-superagent-下载文件\" class=\"headerlink\" title=\"使用 superagent 下载文件\"></a>使用 superagent 下载文件</h2><p>前面两节介绍了使用 superagent 获取页面和 JS 文件，那么如何使用 superagent 下载保存文件到硬盘上呢？这里需要配合使用 Node 的 <code>fs.createWriteStream</code> 方法，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">download</span>(<span class=\"params\">url, localPath, cb</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stream = fs.createWriteStream(localPath);</span><br><span class=\"line\">    stream.on(<span class=\"string\">'finish'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'The download of '</span> + localPath + <span class=\"string\">' is complete!'</span>);</span><br><span class=\"line\">        cb();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    request.get(url).pipe(stream);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>非常简单，不再赘述！</p>\n<h2 id=\"使用-cheerio-操作页面-DOM\"><a href=\"#使用-cheerio-操作页面-DOM\" class=\"headerlink\" title=\"使用 cheerio 操作页面 DOM\"></a>使用 cheerio 操作页面 DOM</h2><p>在第一节，我们介绍了使用 superagent 获取页面内容，但是页面内容太多，我们想高效提取有用信息，该如何做呢？在浏览器中，我们通常使用 jQuery 来高效操作 DOM，在 Node 爬虫中，我们可以使用 cheerio 来模拟 jQuery 的操作方法。cheerio 的基本用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">'cheerio'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> $ = cheerio.load(<span class=\"string\">'&lt;h2 class=\"title\"&gt;Hello world&lt;/h2&gt;'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">'h2.title'</span>).text(<span class=\"string\">'Hello there!'</span>)</span><br><span class=\"line\">$(<span class=\"string\">'h2'</span>).addClass(<span class=\"string\">'welcome'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> $.html()</span><br><span class=\"line\"><span class=\"comment\">//=&gt; &lt;h2 class=\"title welcome\"&gt;Hello there!&lt;/h2&gt;</span></span><br></pre></td></tr></table></figure>\n<p>通过 superagent 获取 html 字符串，然后使用 cheerio 解析，页面上的内容就尽在你的掌握中了！</p>\n<p>更多 cheerio 的用法可以参考：</p>\n<p><a href=\"https://github.com/cheeriojs/cheerio\" target=\"_blank\" rel=\"noopener\">https://github.com/cheeriojs/cheerio</a></p>\n<h2 id=\"正确设置字符编码来避免乱码\"><a href=\"#正确设置字符编码来避免乱码\" class=\"headerlink\" title=\"正确设置字符编码来避免乱码\"></a>正确设置字符编码来避免乱码</h2><p>在获取页面内容，并提取里面的中文信息时，偶尔会遇到中文乱码。这是因为页面的 chartset 设置了<code>gb2312</code> 的原因，那么想要正确解析设置 <code>gb2312</code> 编码的页面，就必须使用这个编码来解析。值得高兴的是，superagent 为我们提供了相关的插件来实现：</p>\n<p><a href=\"https://github.com/magicdawn/superagent-charset\" target=\"_blank\" rel=\"noopener\">https://github.com/magicdawn/superagent-charset</a></p>\n<p>基本用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.get(mainOrigin + mainPathname)</span><br><span class=\"line\">    .charset(<span class=\"string\">'gb2312'</span>)</span><br><span class=\"line\">    .end(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>如何知道 <code>.charset()</code> 中填的是什么编码呢？你只需要看看页面的这行代码即可：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html; charset=gb2312\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"使用正则表达式去除字符串中的多余信息\"><a href=\"#使用正则表达式去除字符串中的多余信息\" class=\"headerlink\" title=\"使用正则表达式去除字符串中的多余信息\"></a>使用正则表达式去除字符串中的多余信息</h2><p>最后，我们来讲一下如何使用使用正则表达式去除字符串中的多余信息。在下载文件时，可能需要处理一些中文名称作为将来的文件名或目录名。页面中的中文名称往往不是我们想要的，那么如何处理名称中的多余信息呢？使用正则表达式就可以做到！比如：</p>\n<p>如果你想将 <code>&#39;听电影学英语之海上钢琴师&#39;</code>变为<code>&#39;海上钢琴师&#39;</code>，那么你可以这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// str 就是'海上钢琴师'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'听电影学英语之海上钢琴师'</span>.replace(<span class=\"regexp\">/听电影学英语之/g</span>, <span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n<p>如果你想将 <code>&#39;听电影MP3学英语之海上钢琴师&#39;</code> 或 <code>&#39;听电影学英语之海上钢琴师&#39;</code>变为<code>&#39;海上钢琴师&#39;</code>，那么你可以这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// str 就是'海上钢琴师'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'听电影学英语之海上钢琴师'</span>.replace(<span class=\"regexp\">/听电影(MP3)?学英语之/g</span>, <span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：小括号代表子表达式，问号代表前面的字符出现 0 或 1 次。</p>\n</blockquote>\n<p>如果你想将以下字符串：</p>\n<ul>\n<li><code>&#39;听电影学英语之海上钢琴师&#39;</code></li>\n<li><code>&#39;听电影MP3学英语之海上钢琴师&#39;</code></li>\n<li><code>&#39;听电影MP3学英语之海上钢琴师中英双语MP3+LRC&#39;</code></li>\n<li><code>&#39;听电影MP3学英语之海上钢琴师 中英双语MP3+LRC&#39;</code></li>\n<li><code>&#39;听电影MP3学英语之海上钢琴师 中英双语MP3+LRC+文本&#39;</code></li>\n<li><code>&#39;听电影MP3学英语之海上钢琴师 中英双语MP3+LRC+文本 &#39;</code></li>\n</ul>\n<p>都变为 <code>&#39;海上钢琴师&#39;</code>，那么正则表达式应该这么写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/(听电影(MP3)?学英语之)|(\\s?中英双语MP3\\+LRC(\\+文本)?)|(\\s?$)/g</span><br></pre></td></tr></table></figure>\n<p>把各种情况都考虑进去，然后用 <code>|</code> 隔开。其中，<code>\\s</code> 匹配任何空白字符，包括空格、制表符、换页符等等。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面介绍了 superagent+cheerio 写爬虫需要用到的各种技术，本文不打算对业务进行过多叙述。只要掌握了上述方法，就可以轻松读懂爬虫代码，如果你没写过爬虫，就赶快试试吧！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p><a href=\"https://github.com/lewis617/practical-js\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/practical-js</a></p>"},{"title":"使用nginx解决跨域问题（flask为例）","date":"2015-12-17T19:56:00.000Z","_content":"\n## 背景\n\n我们单位的架构是在api和js之间架构一个中间层（python编写），以实现后端渲染，登录状态判定，跨域转发api等功能。但是这样一个中间会使前端工程师的工作量乘上两倍，原本js可以直接ajax请求api，但是我们不得不ajax请求中间层，中间层再请求api。如图：\n\n<!--more-->\n\n![](/css/images/85.jpg)\n\n为了少敲代码，提高工作效率，我们当然希望将python中间层砍掉，但是如何解决以下三个问题，成为关键：\n\n1.  后端渲染\n2.  登录状态判定\n3.  跨域转发api\n\n关于1，2我会在另外两篇博客中详细叙述，这篇文章主要解决3，也就是跨域问题。解决跨域问题方法很多：反向代理，jsonp，Cross-Origin Resource Sharing等，我们今天通过nginx反向代理实现。\n\n## 新建两个flask程序来实验\n\n打开pycharm，新建项目选择flask，name分别设为client和server。\n\n![](/css/images/86.jpg)\n\n编写client和server的python文件，使其分别跑在5000端口和5001端口：\n\nclient.py\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/') def hello_world(): return 'this is client'\n\nif __name__ == '__main__':\n    app.run(port=5000)\n```\n\n server.py\n\n```\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/') def hello_world(): return 'this is server' @app.route('/api/') def api(): return 'api'\n\nif __name__ == '__main__':\n    app.run(port=5001)\n```\n\n运行client.py\n\n![](/css/images/87.jpg)\n\n运行server.py\n\n![](/css/images/88.jpg)\n\n## 安装nginx（ubuntu）\n\n打开新立得，搜索nginx，选中并安装。ubuntu就是这么简单，其他平台暂不叙述，可自行搜索。\n\n## 配置nginx，使其将5000端口（客户端）的请求转发到5001端口（服务器端）\n\n打开nginx默认的配置文件：\n\n```sh\nsudo gedit /etc/nginx/sites-available/default\n```\n\n在文件末尾添加如下命令：\n\n```test\n## demo listen 5017 proxy 5000 and 5001 ##\nserver {\n    listen 5017; \n    server_name a.xxx.com;\n    access_log /var/log/nginx/a.access.log;\n    error_log /var/log/nginx/a.error.log;\n    root html;\n    index index.html index.htm index.php;\n\n    ## send request back to flask ##\n    location / {\n        proxy_pass  http://127.0.0.1:5000/ ; \n #Proxy Settings\n        proxy_redirect off;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;\n        proxy_max_temp_file_size 0;\n        proxy_connect_timeout 90;\n        proxy_send_timeout 90;\n        proxy_read_timeout 90;\n        proxy_buffer_size 4k;\n        proxy_buffers 4 32k;\n        proxy_busy_buffers_size 64k;\n\n   }\n    location /proxy {\n        rewrite ^.+proxy/?(.*)$ /$1 break;\n        proxy_pass  http://127.0.0.1:5001/ ; \n #Proxy Settings\n        proxy_redirect off;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;\n        proxy_max_temp_file_size 0;\n        proxy_connect_timeout 90;\n        proxy_send_timeout 90;\n        proxy_read_timeout 90;\n        proxy_buffer_size 4k;\n        proxy_buffers 4 32k;\n        proxy_busy_buffers_size 64k;\n\n   }\n\n}\n\n## End a.xxx.com ##\n```\n\n运行nginx:\n\n```sh\nsudo /etc/init.d/nginx restart \n```\n\n这些命令使得localhost:5017代理了localhost:5000，如图：\n\n![](/css/images/89.jpg)\n\n使得localhost:5017/proxy代理了localhost:5001，如图：\n\n![](/css/images/90.jpg)\n\n使得localhost:5017/proxy/api/代理了localhost:5001/api/，如图：\n\n![](/css/images/91.jpg)\n\n如此以来，原本需要从5000端口请求5001端口的url，变成了从5017端口请求5017端口的/proxy。解决了同源策略带来的跨域问题。\n\n![](/css/images/92.jpg)\n\n这个配置文件也可以和uwsgi配合起来用，也可以不用uwsgi，直接运行python文件启动服务，本文便是后一种。","source":"_posts/nginx-cross-domain.md","raw":"---\ntitle: 使用nginx解决跨域问题（flask为例）\ndate: 2015-12-18 03:56:00\ntags: [nginx, 跨域, Flask]\n---\n\n## 背景\n\n我们单位的架构是在api和js之间架构一个中间层（python编写），以实现后端渲染，登录状态判定，跨域转发api等功能。但是这样一个中间会使前端工程师的工作量乘上两倍，原本js可以直接ajax请求api，但是我们不得不ajax请求中间层，中间层再请求api。如图：\n\n<!--more-->\n\n![](/css/images/85.jpg)\n\n为了少敲代码，提高工作效率，我们当然希望将python中间层砍掉，但是如何解决以下三个问题，成为关键：\n\n1.  后端渲染\n2.  登录状态判定\n3.  跨域转发api\n\n关于1，2我会在另外两篇博客中详细叙述，这篇文章主要解决3，也就是跨域问题。解决跨域问题方法很多：反向代理，jsonp，Cross-Origin Resource Sharing等，我们今天通过nginx反向代理实现。\n\n## 新建两个flask程序来实验\n\n打开pycharm，新建项目选择flask，name分别设为client和server。\n\n![](/css/images/86.jpg)\n\n编写client和server的python文件，使其分别跑在5000端口和5001端口：\n\nclient.py\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/') def hello_world(): return 'this is client'\n\nif __name__ == '__main__':\n    app.run(port=5000)\n```\n\n server.py\n\n```\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/') def hello_world(): return 'this is server' @app.route('/api/') def api(): return 'api'\n\nif __name__ == '__main__':\n    app.run(port=5001)\n```\n\n运行client.py\n\n![](/css/images/87.jpg)\n\n运行server.py\n\n![](/css/images/88.jpg)\n\n## 安装nginx（ubuntu）\n\n打开新立得，搜索nginx，选中并安装。ubuntu就是这么简单，其他平台暂不叙述，可自行搜索。\n\n## 配置nginx，使其将5000端口（客户端）的请求转发到5001端口（服务器端）\n\n打开nginx默认的配置文件：\n\n```sh\nsudo gedit /etc/nginx/sites-available/default\n```\n\n在文件末尾添加如下命令：\n\n```test\n## demo listen 5017 proxy 5000 and 5001 ##\nserver {\n    listen 5017; \n    server_name a.xxx.com;\n    access_log /var/log/nginx/a.access.log;\n    error_log /var/log/nginx/a.error.log;\n    root html;\n    index index.html index.htm index.php;\n\n    ## send request back to flask ##\n    location / {\n        proxy_pass  http://127.0.0.1:5000/ ; \n #Proxy Settings\n        proxy_redirect off;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;\n        proxy_max_temp_file_size 0;\n        proxy_connect_timeout 90;\n        proxy_send_timeout 90;\n        proxy_read_timeout 90;\n        proxy_buffer_size 4k;\n        proxy_buffers 4 32k;\n        proxy_busy_buffers_size 64k;\n\n   }\n    location /proxy {\n        rewrite ^.+proxy/?(.*)$ /$1 break;\n        proxy_pass  http://127.0.0.1:5001/ ; \n #Proxy Settings\n        proxy_redirect off;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;\n        proxy_max_temp_file_size 0;\n        proxy_connect_timeout 90;\n        proxy_send_timeout 90;\n        proxy_read_timeout 90;\n        proxy_buffer_size 4k;\n        proxy_buffers 4 32k;\n        proxy_busy_buffers_size 64k;\n\n   }\n\n}\n\n## End a.xxx.com ##\n```\n\n运行nginx:\n\n```sh\nsudo /etc/init.d/nginx restart \n```\n\n这些命令使得localhost:5017代理了localhost:5000，如图：\n\n![](/css/images/89.jpg)\n\n使得localhost:5017/proxy代理了localhost:5001，如图：\n\n![](/css/images/90.jpg)\n\n使得localhost:5017/proxy/api/代理了localhost:5001/api/，如图：\n\n![](/css/images/91.jpg)\n\n如此以来，原本需要从5000端口请求5001端口的url，变成了从5017端口请求5017端口的/proxy。解决了同源策略带来的跨域问题。\n\n![](/css/images/92.jpg)\n\n这个配置文件也可以和uwsgi配合起来用，也可以不用uwsgi，直接运行python文件启动服务，本文便是后一种。","slug":"nginx-cross-domain","published":1,"updated":"2019-05-01T08:10:29.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvm30024tgyt271d9618","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>我们单位的架构是在api和js之间架构一个中间层（python编写），以实现后端渲染，登录状态判定，跨域转发api等功能。但是这样一个中间会使前端工程师的工作量乘上两倍，原本js可以直接ajax请求api，但是我们不得不ajax请求中间层，中间层再请求api。如图：</p>\n<a id=\"more\"></a>\n<p><img src=\"/css/images/85.jpg\" alt=\"\"></p>\n<p>为了少敲代码，提高工作效率，我们当然希望将python中间层砍掉，但是如何解决以下三个问题，成为关键：</p>\n<ol>\n<li>后端渲染</li>\n<li>登录状态判定</li>\n<li>跨域转发api</li>\n</ol>\n<p>关于1，2我会在另外两篇博客中详细叙述，这篇文章主要解决3，也就是跨域问题。解决跨域问题方法很多：反向代理，jsonp，Cross-Origin Resource Sharing等，我们今天通过nginx反向代理实现。</p>\n<h2 id=\"新建两个flask程序来实验\"><a href=\"#新建两个flask程序来实验\" class=\"headerlink\" title=\"新建两个flask程序来实验\"></a>新建两个flask程序来实验</h2><p>打开pycharm，新建项目选择flask，name分别设为client和server。</p>\n<p><img src=\"/css/images/86.jpg\" alt=\"\"></p>\n<p>编写client和server的python文件，使其分别跑在5000端口和5001端口：</p>\n<p>client.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/') def hello_world(): return 'this is client'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run(port=<span class=\"number\">5000</span>)</span><br></pre></td></tr></table></figure>\n<p> server.py</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from flask import Flask</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">@app.route(&apos;/&apos;) def hello_world(): return &apos;this is server&apos; @app.route(&apos;/api/&apos;) def api(): return &apos;api&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    app.run(port=5001)</span><br></pre></td></tr></table></figure>\n<p>运行client.py</p>\n<p><img src=\"/css/images/87.jpg\" alt=\"\"></p>\n<p>运行server.py</p>\n<p><img src=\"/css/images/88.jpg\" alt=\"\"></p>\n<h2 id=\"安装nginx（ubuntu）\"><a href=\"#安装nginx（ubuntu）\" class=\"headerlink\" title=\"安装nginx（ubuntu）\"></a>安装nginx（ubuntu）</h2><p>打开新立得，搜索nginx，选中并安装。ubuntu就是这么简单，其他平台暂不叙述，可自行搜索。</p>\n<h2 id=\"配置nginx，使其将5000端口（客户端）的请求转发到5001端口（服务器端）\"><a href=\"#配置nginx，使其将5000端口（客户端）的请求转发到5001端口（服务器端）\" class=\"headerlink\" title=\"配置nginx，使其将5000端口（客户端）的请求转发到5001端口（服务器端）\"></a>配置nginx，使其将5000端口（客户端）的请求转发到5001端口（服务器端）</h2><p>打开nginx默认的配置文件：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gedit /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure>\n<p>在文件末尾添加如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## demo listen 5017 proxy 5000 and 5001 ##</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 5017; </span><br><span class=\"line\">    server_name a.xxx.com;</span><br><span class=\"line\">    access_log /var/log/nginx/a.access.log;</span><br><span class=\"line\">    error_log /var/log/nginx/a.error.log;</span><br><span class=\"line\">    root html;</span><br><span class=\"line\">    index index.html index.htm index.php;</span><br><span class=\"line\"></span><br><span class=\"line\">    ## send request back to flask ##</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass  http://127.0.0.1:5000/ ; </span><br><span class=\"line\"> #Proxy Settings</span><br><span class=\"line\">        proxy_redirect off;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class=\"line\">        proxy_max_temp_file_size 0;</span><br><span class=\"line\">        proxy_connect_timeout 90;</span><br><span class=\"line\">        proxy_send_timeout 90;</span><br><span class=\"line\">        proxy_read_timeout 90;</span><br><span class=\"line\">        proxy_buffer_size 4k;</span><br><span class=\"line\">        proxy_buffers 4 32k;</span><br><span class=\"line\">        proxy_busy_buffers_size 64k;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    location /proxy &#123;</span><br><span class=\"line\">        rewrite ^.+proxy/?(.*)$ /$1 break;</span><br><span class=\"line\">        proxy_pass  http://127.0.0.1:5001/ ; </span><br><span class=\"line\"> #Proxy Settings</span><br><span class=\"line\">        proxy_redirect off;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class=\"line\">        proxy_max_temp_file_size 0;</span><br><span class=\"line\">        proxy_connect_timeout 90;</span><br><span class=\"line\">        proxy_send_timeout 90;</span><br><span class=\"line\">        proxy_read_timeout 90;</span><br><span class=\"line\">        proxy_buffer_size 4k;</span><br><span class=\"line\">        proxy_buffers 4 32k;</span><br><span class=\"line\">        proxy_busy_buffers_size 64k;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">## End a.xxx.com ##</span><br></pre></td></tr></table></figure>\n<p>运行nginx:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /etc/init.d/nginx restart</span><br></pre></td></tr></table></figure>\n<p>这些命令使得localhost:5017代理了localhost:5000，如图：</p>\n<p><img src=\"/css/images/89.jpg\" alt=\"\"></p>\n<p>使得localhost:5017/proxy代理了localhost:5001，如图：</p>\n<p><img src=\"/css/images/90.jpg\" alt=\"\"></p>\n<p>使得localhost:5017/proxy/api/代理了localhost:5001/api/，如图：</p>\n<p><img src=\"/css/images/91.jpg\" alt=\"\"></p>\n<p>如此以来，原本需要从5000端口请求5001端口的url，变成了从5017端口请求5017端口的/proxy。解决了同源策略带来的跨域问题。</p>\n<p><img src=\"/css/images/92.jpg\" alt=\"\"></p>\n<p>这个配置文件也可以和uwsgi配合起来用，也可以不用uwsgi，直接运行python文件启动服务，本文便是后一种。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>我们单位的架构是在api和js之间架构一个中间层（python编写），以实现后端渲染，登录状态判定，跨域转发api等功能。但是这样一个中间会使前端工程师的工作量乘上两倍，原本js可以直接ajax请求api，但是我们不得不ajax请求中间层，中间层再请求api。如图：</p>","more":"<p><img src=\"/css/images/85.jpg\" alt=\"\"></p>\n<p>为了少敲代码，提高工作效率，我们当然希望将python中间层砍掉，但是如何解决以下三个问题，成为关键：</p>\n<ol>\n<li>后端渲染</li>\n<li>登录状态判定</li>\n<li>跨域转发api</li>\n</ol>\n<p>关于1，2我会在另外两篇博客中详细叙述，这篇文章主要解决3，也就是跨域问题。解决跨域问题方法很多：反向代理，jsonp，Cross-Origin Resource Sharing等，我们今天通过nginx反向代理实现。</p>\n<h2 id=\"新建两个flask程序来实验\"><a href=\"#新建两个flask程序来实验\" class=\"headerlink\" title=\"新建两个flask程序来实验\"></a>新建两个flask程序来实验</h2><p>打开pycharm，新建项目选择flask，name分别设为client和server。</p>\n<p><img src=\"/css/images/86.jpg\" alt=\"\"></p>\n<p>编写client和server的python文件，使其分别跑在5000端口和5001端口：</p>\n<p>client.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/') def hello_world(): return 'this is client'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run(port=<span class=\"number\">5000</span>)</span><br></pre></td></tr></table></figure>\n<p> server.py</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from flask import Flask</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">@app.route(&apos;/&apos;) def hello_world(): return &apos;this is server&apos; @app.route(&apos;/api/&apos;) def api(): return &apos;api&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    app.run(port=5001)</span><br></pre></td></tr></table></figure>\n<p>运行client.py</p>\n<p><img src=\"/css/images/87.jpg\" alt=\"\"></p>\n<p>运行server.py</p>\n<p><img src=\"/css/images/88.jpg\" alt=\"\"></p>\n<h2 id=\"安装nginx（ubuntu）\"><a href=\"#安装nginx（ubuntu）\" class=\"headerlink\" title=\"安装nginx（ubuntu）\"></a>安装nginx（ubuntu）</h2><p>打开新立得，搜索nginx，选中并安装。ubuntu就是这么简单，其他平台暂不叙述，可自行搜索。</p>\n<h2 id=\"配置nginx，使其将5000端口（客户端）的请求转发到5001端口（服务器端）\"><a href=\"#配置nginx，使其将5000端口（客户端）的请求转发到5001端口（服务器端）\" class=\"headerlink\" title=\"配置nginx，使其将5000端口（客户端）的请求转发到5001端口（服务器端）\"></a>配置nginx，使其将5000端口（客户端）的请求转发到5001端口（服务器端）</h2><p>打开nginx默认的配置文件：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gedit /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure>\n<p>在文件末尾添加如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## demo listen 5017 proxy 5000 and 5001 ##</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 5017; </span><br><span class=\"line\">    server_name a.xxx.com;</span><br><span class=\"line\">    access_log /var/log/nginx/a.access.log;</span><br><span class=\"line\">    error_log /var/log/nginx/a.error.log;</span><br><span class=\"line\">    root html;</span><br><span class=\"line\">    index index.html index.htm index.php;</span><br><span class=\"line\"></span><br><span class=\"line\">    ## send request back to flask ##</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass  http://127.0.0.1:5000/ ; </span><br><span class=\"line\"> #Proxy Settings</span><br><span class=\"line\">        proxy_redirect off;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class=\"line\">        proxy_max_temp_file_size 0;</span><br><span class=\"line\">        proxy_connect_timeout 90;</span><br><span class=\"line\">        proxy_send_timeout 90;</span><br><span class=\"line\">        proxy_read_timeout 90;</span><br><span class=\"line\">        proxy_buffer_size 4k;</span><br><span class=\"line\">        proxy_buffers 4 32k;</span><br><span class=\"line\">        proxy_busy_buffers_size 64k;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    location /proxy &#123;</span><br><span class=\"line\">        rewrite ^.+proxy/?(.*)$ /$1 break;</span><br><span class=\"line\">        proxy_pass  http://127.0.0.1:5001/ ; </span><br><span class=\"line\"> #Proxy Settings</span><br><span class=\"line\">        proxy_redirect off;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class=\"line\">        proxy_max_temp_file_size 0;</span><br><span class=\"line\">        proxy_connect_timeout 90;</span><br><span class=\"line\">        proxy_send_timeout 90;</span><br><span class=\"line\">        proxy_read_timeout 90;</span><br><span class=\"line\">        proxy_buffer_size 4k;</span><br><span class=\"line\">        proxy_buffers 4 32k;</span><br><span class=\"line\">        proxy_busy_buffers_size 64k;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">## End a.xxx.com ##</span><br></pre></td></tr></table></figure>\n<p>运行nginx:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo /etc/init.d/nginx restart</span><br></pre></td></tr></table></figure>\n<p>这些命令使得localhost:5017代理了localhost:5000，如图：</p>\n<p><img src=\"/css/images/89.jpg\" alt=\"\"></p>\n<p>使得localhost:5017/proxy代理了localhost:5001，如图：</p>\n<p><img src=\"/css/images/90.jpg\" alt=\"\"></p>\n<p>使得localhost:5017/proxy/api/代理了localhost:5001/api/，如图：</p>\n<p><img src=\"/css/images/91.jpg\" alt=\"\"></p>\n<p>如此以来，原本需要从5000端口请求5001端口的url，变成了从5017端口请求5017端口的/proxy。解决了同源策略带来的跨域问题。</p>\n<p><img src=\"/css/images/92.jpg\" alt=\"\"></p>\n<p>这个配置文件也可以和uwsgi配合起来用，也可以不用uwsgi，直接运行python文件启动服务，本文便是后一种。</p>"},{"title":"Jason Miller：Preact：Into the void 0（译）","date":"2017-09-04T11:00:00.000Z","_content":"本文整理自Jason Miller在JSConf上的talk。原视频地址：\n\nhttps://www.youtube.com/watch?v=LY6y3HbDVmg\n\n![](/css/images/96.jpg)\n\n<!--more-->\n\n## 开场白\n\n嗨，大家好，我是Jason，Github上那个developit和推特上的_developit，是一系列库的作者（serial library author），我喜欢甜甜圈、肉汁乳酪薯条和斧头，这意味着我是加拿大人（枫叶国的人喜欢斧头——[在加拿大把扔斧头做成15万用户的大生意](https://dushi.singtao.ca/toronto/%E8%B4%A2%E7%BB%8F-%E5%88%86%E7%B1%BB/%E5%88%9B%E4%B8%9A%E6%95%85%E4%BA%8B-%E5%88%86%E7%B1%BB/%E5%9C%A8%E5%8A%A0%E6%8B%BF%E5%A4%A7%E6%8A%8A%E6%89%94%E6%96%A7%E5%A4%B4%E5%81%9A%E6%88%9015%E4%B8%87%E7%94%A8%E6%88%B7%E7%9A%84%E5%A4%A7%E7%94%9F%E6%84%8F/)）。\n\n![](/css/images/94.jpg)\n\n我也喜欢“限制”。我在移动web广泛应用前就开始开发它了，那时候还是windows mobile 5。我写了很多UI框架，遇到了很多问题，然后努力去解决它们。这样的理由是我发现“限制”是很有趣的“挑战”，我有些ADHD（注意（力）缺陷多动障碍），你或许熟悉这个东西，为了高效做一些事，最好可以非常专注在上面，这些有趣的“限制”挑战可以帮助我营造这个环境。\n\n![](/css/images/95.jpg)\n\n## 点题\n\n我写了Preact，这个展示叫“Preact: Into the void 0”，我觉得这么叫很聪明（这哥们太极客了，void(0)是js中返回undefined的最小脚本），这也是这个幻灯片中唯一的一个分号哦。\n\n![](https://ww1.sinaimg.cn/mw690/83900b4egy1fj6o29y7yvj21gk0t8gp1.jpg)\n\n或许你会好奇啥是Preact，这就是Preact。我移除了源代码映射的注释，今天我们主要讲一下这几个圆圈圈中的部分。因为这是Preact的展示，所以我们需要一些紫色，不管那是啥，那都是我们最后要讲的东西。\n\n![](/css/images/97.jpg)\n\n\n## JSX简介\n\n不过在开始讲这些东西前，我们需要聊聊JSX。如果你对JSX不熟悉，我不知道你之前是靠在哪个山头。不过别担心，JSX真的非常容易理解。JSX的核心非常简单，等我讲完时候，你完全可以用JSX重写你Webpack配置，让它变得更长、更复杂，这是个好事。如果你不相信我，去看看webpack2的文档吧，都在里面写着呢。\n\n![](/css/images/98.jpg)\n\n那么什么是JSX？JSX是一个XML风格的表达式，然后被编译为函数调用。我们编写左边的那个很像HTML的尖括号语法。右边是像babel这样的编译器输出的结果，现在貌似已经有十种编译器了。我最喜欢的JSX的点就是很喜欢这种写法，这种带有点DOM风格的写法，编译在前面做了一些事，好让我们可以更好地理解它。\n\n![](/css/images/99.jpg)\n\n\n再来看一个稍微复杂一点的写法。这些尖括号语法被编译为了JavaScript，其中`one` 和变量 `world`都被保留了下来，另外一个复杂的地方是，如果你的标签名首字母大写，那么它在生成代码中将会是个变量引用。\n\n> 译者注：JSX中的标签名大小写是有讲究的，小写代表是HTML标签，大写代表一个组件，具体可以看JSX的文档。\n\n![](/css/images/100.jpg)\n\nJSX的精髓就是我们看过的那个工厂函数，它非常简单，只有一个接受节点名称、属性、children的签名。节点名称就是之前说的标签名称，它可以是字符串或者函数，属性是可选的，它可以是个对象，剩余的参数就是children，这就是我们编写的形式。\n![](/css/images/101.jpg)\n\n你或许会想，我刚才编写不是hyperscript吗？你想的也不算错，hyperscript确实跟JSX很相似，有点JSX超集的意思。看看这两个例子吧！hyperscript支持这种附加的标签写法，本质上来说是CSS选择器的写法，去预定义元素上的属性，而JSX却不支持这种写法。\n\n![](/css/images/102.jpg)\n\nJSX真正的能力是可以支持这种拓展标签名称。理解好JSX是很重要的，JSX是我们连接各种虚拟DOM库的接口，JSX不是DOM，它跟DOM没啥关联，它只是一种语法，它并不理解你的代码或它被用来做的事，你甚至可以用它编写Webpack配置，但还是别了。你可以用它编写XML，如果你想编写一个SOAP客户端，而且你想用解析和序列化，你就可以使用JSX做这个。总之，我想说JSX是问题的有趣解决方案。\n\n![](/css/images/103.jpg)\n\n## 虚拟DOM\n\n下个话题是虚拟DOM。\n\n![](/css/images/104.jpg)\n\n虚拟DOM仅仅只是个代表树状结构的对象而已，仅仅如此，没啥别的玄乎的！我经常把它想成一个传递给DOM构建器的一个配置，好让DOM构建器不那么理论化。\n\n![](/css/images/105.jpg)\n\n不过，首先我们要理解的是，我们如何从JSX到虚拟DOM。\n\n![](/css/images/106.jpg)\n\n我们所做的方式是调用刚才定义参数的那个h函数。这非常容易理解，我们编写JSX，然后调用h函数，我们要做的就是定义一个h函数，生成这样的对象。这个对象就是虚拟DOM，虚拟DOM就是一个嵌套对象。\n\n![](/css/images/107.jpg)\n\n令人惊讶的简单，我们要做的就是这个而已！一个只有一行代码的函数！当然，你可以在这里做更多的事情，如果你想扁平化children，去除空值，连接相邻的字符串节点等。但核心是，你可以通过这个函数编写一个虚拟DOM渲染器。\n\n![](/css/images/108.jpg)\n\n所以，让我们做这个吧！让我们编写一个虚拟DOM渲染器！第一件事，我们要传递给我们自己一个虚拟节点，这是我们之前见过的那个对象，看右上方的滚动框。所以，第一件事是我们需要创建一个DOM对象，匹配传递进来的虚拟节点的类型。所以我们使用`document.createElement`来做这个。然后我们循环给DOM赋予属性。接着，我们又写了一个递归来循环渲染子节点。最后，我们在类型为字符串时，直接返回DOM对象。这就是我们编写的虚拟DOM渲染器！\n\n![](/css/images/109.jpg)\n\n这里有个稍微复杂的地方，那就是attributes。如果有人用过React，那么你可能会怒气冲冲地说那不是attrbutes，那是properties！事实上应该叫“props”。attributes和properties是两个不同东东的抽象！大多HTML元素会接受数据作为attributes，它们也可以接受类似的，定型数据作为properties，通过一个叫DOM property reflection的东东。但事实上，这两种都是不太对的，有时候我们可以使用properties，不能使用attributes，有时候又反过来。\n\n![](/css/images/110.jpg)\n\n我们需要的是将两种写法都写出来！我们有一个DOM节点的引用，我们问它，你支持foo这个property吗？如果它支持，就用property，否则就用attributes。这对自定义元素很好，因为自定义元素倾向于为property定义getter setter对。\n\n![](/css/images/111.jpg)\n\n这时你可能想问，这能运行吗？这是个虚拟DOM，我们把它传给编写的渲染函数。右边显示的是结果，它可以运行哈哈。\n\n![](/css/images/112.jpg)\n\n\n## DIFF算法\n\n我们刚才编写了一个非常简单的虚拟DOM渲染器，也是个非常糟糕的虚拟DOM渲染器，这是版本0。说它糟糕是因为它不能DIFF，它不关注当前的DOM状态，只是完全替换了新dom。虚拟DOM中的DIFF算法是一个争议和神秘的主题，争议是有必要的，因为过程中充满了权衡，并不是非黑即白，而神秘是没有必要的，我试图去揭开它神秘的面纱！\n\n![](/css/images/113.jpg)\n\nDIFF舍弃从上到下渲染，创建新的DOM。我们将会传递给我们自己一个现在DOM，然后把它变为JSX中写的样子，只是应用一下差异而已。\n![](/css/images/114.jpg)\n\n在左边，你可以看到虚拟DOM长啥样，只是一个对象。在右边，是一个真实的DOM。你可以看到，名字都差不多。你可以比较一下，然后把差异应用到右边。\n\n![](/css/images/115.jpg)\n\n运行DIFF，只需要三步。第一步是type，在所有事情前，我们必须要创建一个准确类型的DOM。第二步是循环遍历children，去双向比较它们，然后找出我们是否需要添加、移除、重排它们等。最后一步是更新attributes/props。\n\n![](/css/images/116.jpg)\n\n所以，让我们从type 开始吧！第一件事是判断节点是否是组件创建的。如果不是，事情就简单了！如果同类型就更新，否则就抛弃原来的，创建一个新的。如果是组件创建的，事情会稍微复杂一点。我们需要创建一个实例，通过比较创建或更新组件的props，然后调用render方法。\n\n> 译者注：实际情况其实更加复杂，这里需要对组件、组件实例、组件生命周期非常熟悉才能理解。在组件生命周期中，真正操控大局的是组件实例，所以这里需要先创建一个组件实例。\n\n![](/css/images/117.jpg)\n\nchildren更加简单，只有三步。第一步是循环遍历所有的children，把它们放到列表中，没key的话就放到unkey列表，有key就放到keyed map中。第二步是我们把新的虚拟children转移过去，我们在列表中发现匹配的，然后和虚拟DOM做对比，最后把它插入到当前的index中。最后一步是最简单的，如果有kids剩余，就删除它们，因为它们已经用不到了。\n\n![](/css/images/118.jpg)\n\n你或许对keyed map和unkey list感兴趣。我今天很想讨论这个话题，我曾在stack overflow上回答过这个问题，这是我在stack overflow上回答的唯一的问题。所以，让我们用PPT来演示它。keys是一些虚拟DOM上有意义的顺序属性，当这些虚拟DOM拥有唯一的类型。我们可以在这个例子中看到，我们拥有三个列表项——one，two，three。在第二个渲染框中，我们只有两个列表项，对于你和我这样的人类而言，我们只需要删除two，把第三项移上去。但虚拟DOM渲染器不知道这个，没有任何东西说明two就是第二项，它就是每次接受一个新的树，没有什么事可以矫正它。这整个过程就是，看看第一项，没变，然后啥事也没发生，然后看看第二项，它说，不，内容不一样啊，然后它就更改了内容。第三项直接被删除了。默认情况下，虚拟DOM中的元素列表，它只会push和pop，没法移动改变中间的项。与此相反，在有key的方法中，我们给每个元素一个唯一的key，所以在第一个框中，我们看到了1，2，3，在第二个框中，我们看到了1，3。很明显，key2被移除了，现在，我们告诉虚拟DOM应该做什么，所以它知道当它循环到key2时，它就会删除该项。\n\n![](/css/images/119.jpg)\n\nDIFF的最后一步是attributes，这真的很简单，我们给我们自己老的属性和新的属性，从老的属性中找到不在新属性中的属性，然后把它们设置为undefined。对于新的属性，我们和老属性对比，然后设置新属性的值。我们解决了所有的问题，现在我们的app变得非常快！我们把所有问题都转移到了库中，这些库包括：react、preact、inferno等。\n\n![](/css/images/120.jpg)\n\n## 性能\n\n我想和大家讨论一些性能的话题。我编写Preact时，就想测试它的性能。\n\n![](/css/images/121.jpg)\n\n这句话是你经常在推特上看见人说的。我们经常听到有人抱怨说DOM太慢了，DOM是性能差的根源所在。确实，DOM没有immediate mode drawing API那么快，它设计的目的不是这个，这是完全不同的事。DOM本质上提供了内建的accessibility。你可以使用title和字体注释DOM，还可以得到屏幕阅读器的支持。其他平台也可以这么做，但是DOM做这种事情更加简单。你根本不需要理解它是如何运作的，只需要编写语意化的标记即可。DOM也可以拓展，人们经常忘记这点。如果我在windows上使用推特，我想为推特添加emoji，我就安装浏览器拓展，然后就hook到了每一个在推特上的输入文本，接下来我不依赖推特的输入字段就可以使用emoji了。推特不知道这个，也不需要知道，也不在乎这个。这就是DOM的价值之一，这种基质巩固了所有的应用，它是一种超越我们知识范畴的拓展。这就跟那个“框架不可知论”不谋而合。你可以编写两个不同的插件在两个不同的框架中，只要它们可以渲染元素，你可以假设这些元素拥有相同的祖先元素，它们彼此之间不需要相互在乎。所以，Preact本质上来说就是个DOM渲染器，它是虚拟DOM渲染器，但它就是一种DOM库。\n\n![](/css/images/122.jpg)\n\n接下来，我想分享我在编写DOM库过程中的一些经验，第一个是使用文本节点来表示文本。这听起来很傻，我意识到了这个。但是很惊讶的是，我们经常曲解这句话。\n\n![](/css/images/123.jpg)\n\nDOM拥有API去和文本打交道，我们却经常忽略这些API。我们可以通过这些API去创建文本，插入文本，反转文本等。\n\n![](/css/images/124.jpg)\n\n\n这是个benchmark showing，展示了`textContent`和`Text.nodeValue`的速度，后者很明显更快。如果你正在编写一个有处理文本的DOM库或框架，那么选择前者会让你发疯。`textContent`做了更多工作，只说它慢貌似不太公平。但大多情况下，我们不需要处理“更多的工作”。\n\n![](/css/images/125.jpg)\n\n下一个经验是，避免getters，完全的！别使用它们。Text的nodeType是undefined，但是它继承的Node的nodeType是个getter方法，性能不好。\n\n![](/css/images/126.jpg)\n\n如图所示，splitText更快，因为这只是检查某个属性是否存在，而不是调用getter。\n\n![](/css/images/127.jpg)\n\n这是一个性能测试，可以看到getters都很慢，而属性获取的速度却很快。\n\n![](/css/images/128.jpg)\n\n最后一个经验是避免Live NodeLists，不要试图去用它们，它们特别耗性能。\n\n![](/css/images/129.jpg)\n\n这是一个例子，试图去移除父元素的children。第一个你写了一个倒置的循环去移除，之所以倒置是因为这是个live NodeList，它的项数不停的在变化。第二个就快多了，因为我们只是在获取一个属性，不需要回头去请求子节点。我们不需要去获取数组的位移，我们只是在用一个引用。\n\n![](/css/images/130.jpg)\n\n这是测试结果。\n\n![](/css/images/131.jpg)\n\n\n## 性能测试\n\n我已经做性能优化很久了。Benchmark运行了五百万次循环，然后计算时间。\n\n![](/css/images/132.jpg)\n\nChrome开发工具优化了这个，使其更加可视化。\n\n![](/css/images/133.jpg)\n\n另一个工具是IRHydra。\n\n![](/css/images/134.jpg)\n\n最后一个工具是ESBench。这个工具的目的是给你一个非常简单的用户界面去使用Babel和benchmark。\n\n![](/css/images/135.jpg)\n\n\n## 其他经验\n\n第一个是尽量明确的。不要使用一些意外情况，如果你没有理由使用它们。这个例子中，我们检查一个对象的属性，它可能是0，空字符串，null，false等，第二种就清楚多了。\n\n![](/css/images/136.jpg)\n\n下一个经验是行内帮助函数。函数可以更加通用。\n\n![](/css/images/137.jpg)\n\n下一个是短路语法。最便宜的函数调用就是你不调用它。\n\n![](/css/images/138.jpg)\n\n所有这一切都是在说一个道理：基于数据去做决定。\n\n![](/css/images/139.jpg)\n\n---\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n","source":"_posts/preact-into-the-void-0.md","raw":"---\ntitle: Jason Miller：Preact：Into the void 0（译）\ndate: 2017-09-04 19:00:00\ntags: [技术讲座, Preact, JSX, 虚拟DOM, 性能]\n---\n本文整理自Jason Miller在JSConf上的talk。原视频地址：\n\nhttps://www.youtube.com/watch?v=LY6y3HbDVmg\n\n![](/css/images/96.jpg)\n\n<!--more-->\n\n## 开场白\n\n嗨，大家好，我是Jason，Github上那个developit和推特上的_developit，是一系列库的作者（serial library author），我喜欢甜甜圈、肉汁乳酪薯条和斧头，这意味着我是加拿大人（枫叶国的人喜欢斧头——[在加拿大把扔斧头做成15万用户的大生意](https://dushi.singtao.ca/toronto/%E8%B4%A2%E7%BB%8F-%E5%88%86%E7%B1%BB/%E5%88%9B%E4%B8%9A%E6%95%85%E4%BA%8B-%E5%88%86%E7%B1%BB/%E5%9C%A8%E5%8A%A0%E6%8B%BF%E5%A4%A7%E6%8A%8A%E6%89%94%E6%96%A7%E5%A4%B4%E5%81%9A%E6%88%9015%E4%B8%87%E7%94%A8%E6%88%B7%E7%9A%84%E5%A4%A7%E7%94%9F%E6%84%8F/)）。\n\n![](/css/images/94.jpg)\n\n我也喜欢“限制”。我在移动web广泛应用前就开始开发它了，那时候还是windows mobile 5。我写了很多UI框架，遇到了很多问题，然后努力去解决它们。这样的理由是我发现“限制”是很有趣的“挑战”，我有些ADHD（注意（力）缺陷多动障碍），你或许熟悉这个东西，为了高效做一些事，最好可以非常专注在上面，这些有趣的“限制”挑战可以帮助我营造这个环境。\n\n![](/css/images/95.jpg)\n\n## 点题\n\n我写了Preact，这个展示叫“Preact: Into the void 0”，我觉得这么叫很聪明（这哥们太极客了，void(0)是js中返回undefined的最小脚本），这也是这个幻灯片中唯一的一个分号哦。\n\n![](https://ww1.sinaimg.cn/mw690/83900b4egy1fj6o29y7yvj21gk0t8gp1.jpg)\n\n或许你会好奇啥是Preact，这就是Preact。我移除了源代码映射的注释，今天我们主要讲一下这几个圆圈圈中的部分。因为这是Preact的展示，所以我们需要一些紫色，不管那是啥，那都是我们最后要讲的东西。\n\n![](/css/images/97.jpg)\n\n\n## JSX简介\n\n不过在开始讲这些东西前，我们需要聊聊JSX。如果你对JSX不熟悉，我不知道你之前是靠在哪个山头。不过别担心，JSX真的非常容易理解。JSX的核心非常简单，等我讲完时候，你完全可以用JSX重写你Webpack配置，让它变得更长、更复杂，这是个好事。如果你不相信我，去看看webpack2的文档吧，都在里面写着呢。\n\n![](/css/images/98.jpg)\n\n那么什么是JSX？JSX是一个XML风格的表达式，然后被编译为函数调用。我们编写左边的那个很像HTML的尖括号语法。右边是像babel这样的编译器输出的结果，现在貌似已经有十种编译器了。我最喜欢的JSX的点就是很喜欢这种写法，这种带有点DOM风格的写法，编译在前面做了一些事，好让我们可以更好地理解它。\n\n![](/css/images/99.jpg)\n\n\n再来看一个稍微复杂一点的写法。这些尖括号语法被编译为了JavaScript，其中`one` 和变量 `world`都被保留了下来，另外一个复杂的地方是，如果你的标签名首字母大写，那么它在生成代码中将会是个变量引用。\n\n> 译者注：JSX中的标签名大小写是有讲究的，小写代表是HTML标签，大写代表一个组件，具体可以看JSX的文档。\n\n![](/css/images/100.jpg)\n\nJSX的精髓就是我们看过的那个工厂函数，它非常简单，只有一个接受节点名称、属性、children的签名。节点名称就是之前说的标签名称，它可以是字符串或者函数，属性是可选的，它可以是个对象，剩余的参数就是children，这就是我们编写的形式。\n![](/css/images/101.jpg)\n\n你或许会想，我刚才编写不是hyperscript吗？你想的也不算错，hyperscript确实跟JSX很相似，有点JSX超集的意思。看看这两个例子吧！hyperscript支持这种附加的标签写法，本质上来说是CSS选择器的写法，去预定义元素上的属性，而JSX却不支持这种写法。\n\n![](/css/images/102.jpg)\n\nJSX真正的能力是可以支持这种拓展标签名称。理解好JSX是很重要的，JSX是我们连接各种虚拟DOM库的接口，JSX不是DOM，它跟DOM没啥关联，它只是一种语法，它并不理解你的代码或它被用来做的事，你甚至可以用它编写Webpack配置，但还是别了。你可以用它编写XML，如果你想编写一个SOAP客户端，而且你想用解析和序列化，你就可以使用JSX做这个。总之，我想说JSX是问题的有趣解决方案。\n\n![](/css/images/103.jpg)\n\n## 虚拟DOM\n\n下个话题是虚拟DOM。\n\n![](/css/images/104.jpg)\n\n虚拟DOM仅仅只是个代表树状结构的对象而已，仅仅如此，没啥别的玄乎的！我经常把它想成一个传递给DOM构建器的一个配置，好让DOM构建器不那么理论化。\n\n![](/css/images/105.jpg)\n\n不过，首先我们要理解的是，我们如何从JSX到虚拟DOM。\n\n![](/css/images/106.jpg)\n\n我们所做的方式是调用刚才定义参数的那个h函数。这非常容易理解，我们编写JSX，然后调用h函数，我们要做的就是定义一个h函数，生成这样的对象。这个对象就是虚拟DOM，虚拟DOM就是一个嵌套对象。\n\n![](/css/images/107.jpg)\n\n令人惊讶的简单，我们要做的就是这个而已！一个只有一行代码的函数！当然，你可以在这里做更多的事情，如果你想扁平化children，去除空值，连接相邻的字符串节点等。但核心是，你可以通过这个函数编写一个虚拟DOM渲染器。\n\n![](/css/images/108.jpg)\n\n所以，让我们做这个吧！让我们编写一个虚拟DOM渲染器！第一件事，我们要传递给我们自己一个虚拟节点，这是我们之前见过的那个对象，看右上方的滚动框。所以，第一件事是我们需要创建一个DOM对象，匹配传递进来的虚拟节点的类型。所以我们使用`document.createElement`来做这个。然后我们循环给DOM赋予属性。接着，我们又写了一个递归来循环渲染子节点。最后，我们在类型为字符串时，直接返回DOM对象。这就是我们编写的虚拟DOM渲染器！\n\n![](/css/images/109.jpg)\n\n这里有个稍微复杂的地方，那就是attributes。如果有人用过React，那么你可能会怒气冲冲地说那不是attrbutes，那是properties！事实上应该叫“props”。attributes和properties是两个不同东东的抽象！大多HTML元素会接受数据作为attributes，它们也可以接受类似的，定型数据作为properties，通过一个叫DOM property reflection的东东。但事实上，这两种都是不太对的，有时候我们可以使用properties，不能使用attributes，有时候又反过来。\n\n![](/css/images/110.jpg)\n\n我们需要的是将两种写法都写出来！我们有一个DOM节点的引用，我们问它，你支持foo这个property吗？如果它支持，就用property，否则就用attributes。这对自定义元素很好，因为自定义元素倾向于为property定义getter setter对。\n\n![](/css/images/111.jpg)\n\n这时你可能想问，这能运行吗？这是个虚拟DOM，我们把它传给编写的渲染函数。右边显示的是结果，它可以运行哈哈。\n\n![](/css/images/112.jpg)\n\n\n## DIFF算法\n\n我们刚才编写了一个非常简单的虚拟DOM渲染器，也是个非常糟糕的虚拟DOM渲染器，这是版本0。说它糟糕是因为它不能DIFF，它不关注当前的DOM状态，只是完全替换了新dom。虚拟DOM中的DIFF算法是一个争议和神秘的主题，争议是有必要的，因为过程中充满了权衡，并不是非黑即白，而神秘是没有必要的，我试图去揭开它神秘的面纱！\n\n![](/css/images/113.jpg)\n\nDIFF舍弃从上到下渲染，创建新的DOM。我们将会传递给我们自己一个现在DOM，然后把它变为JSX中写的样子，只是应用一下差异而已。\n![](/css/images/114.jpg)\n\n在左边，你可以看到虚拟DOM长啥样，只是一个对象。在右边，是一个真实的DOM。你可以看到，名字都差不多。你可以比较一下，然后把差异应用到右边。\n\n![](/css/images/115.jpg)\n\n运行DIFF，只需要三步。第一步是type，在所有事情前，我们必须要创建一个准确类型的DOM。第二步是循环遍历children，去双向比较它们，然后找出我们是否需要添加、移除、重排它们等。最后一步是更新attributes/props。\n\n![](/css/images/116.jpg)\n\n所以，让我们从type 开始吧！第一件事是判断节点是否是组件创建的。如果不是，事情就简单了！如果同类型就更新，否则就抛弃原来的，创建一个新的。如果是组件创建的，事情会稍微复杂一点。我们需要创建一个实例，通过比较创建或更新组件的props，然后调用render方法。\n\n> 译者注：实际情况其实更加复杂，这里需要对组件、组件实例、组件生命周期非常熟悉才能理解。在组件生命周期中，真正操控大局的是组件实例，所以这里需要先创建一个组件实例。\n\n![](/css/images/117.jpg)\n\nchildren更加简单，只有三步。第一步是循环遍历所有的children，把它们放到列表中，没key的话就放到unkey列表，有key就放到keyed map中。第二步是我们把新的虚拟children转移过去，我们在列表中发现匹配的，然后和虚拟DOM做对比，最后把它插入到当前的index中。最后一步是最简单的，如果有kids剩余，就删除它们，因为它们已经用不到了。\n\n![](/css/images/118.jpg)\n\n你或许对keyed map和unkey list感兴趣。我今天很想讨论这个话题，我曾在stack overflow上回答过这个问题，这是我在stack overflow上回答的唯一的问题。所以，让我们用PPT来演示它。keys是一些虚拟DOM上有意义的顺序属性，当这些虚拟DOM拥有唯一的类型。我们可以在这个例子中看到，我们拥有三个列表项——one，two，three。在第二个渲染框中，我们只有两个列表项，对于你和我这样的人类而言，我们只需要删除two，把第三项移上去。但虚拟DOM渲染器不知道这个，没有任何东西说明two就是第二项，它就是每次接受一个新的树，没有什么事可以矫正它。这整个过程就是，看看第一项，没变，然后啥事也没发生，然后看看第二项，它说，不，内容不一样啊，然后它就更改了内容。第三项直接被删除了。默认情况下，虚拟DOM中的元素列表，它只会push和pop，没法移动改变中间的项。与此相反，在有key的方法中，我们给每个元素一个唯一的key，所以在第一个框中，我们看到了1，2，3，在第二个框中，我们看到了1，3。很明显，key2被移除了，现在，我们告诉虚拟DOM应该做什么，所以它知道当它循环到key2时，它就会删除该项。\n\n![](/css/images/119.jpg)\n\nDIFF的最后一步是attributes，这真的很简单，我们给我们自己老的属性和新的属性，从老的属性中找到不在新属性中的属性，然后把它们设置为undefined。对于新的属性，我们和老属性对比，然后设置新属性的值。我们解决了所有的问题，现在我们的app变得非常快！我们把所有问题都转移到了库中，这些库包括：react、preact、inferno等。\n\n![](/css/images/120.jpg)\n\n## 性能\n\n我想和大家讨论一些性能的话题。我编写Preact时，就想测试它的性能。\n\n![](/css/images/121.jpg)\n\n这句话是你经常在推特上看见人说的。我们经常听到有人抱怨说DOM太慢了，DOM是性能差的根源所在。确实，DOM没有immediate mode drawing API那么快，它设计的目的不是这个，这是完全不同的事。DOM本质上提供了内建的accessibility。你可以使用title和字体注释DOM，还可以得到屏幕阅读器的支持。其他平台也可以这么做，但是DOM做这种事情更加简单。你根本不需要理解它是如何运作的，只需要编写语意化的标记即可。DOM也可以拓展，人们经常忘记这点。如果我在windows上使用推特，我想为推特添加emoji，我就安装浏览器拓展，然后就hook到了每一个在推特上的输入文本，接下来我不依赖推特的输入字段就可以使用emoji了。推特不知道这个，也不需要知道，也不在乎这个。这就是DOM的价值之一，这种基质巩固了所有的应用，它是一种超越我们知识范畴的拓展。这就跟那个“框架不可知论”不谋而合。你可以编写两个不同的插件在两个不同的框架中，只要它们可以渲染元素，你可以假设这些元素拥有相同的祖先元素，它们彼此之间不需要相互在乎。所以，Preact本质上来说就是个DOM渲染器，它是虚拟DOM渲染器，但它就是一种DOM库。\n\n![](/css/images/122.jpg)\n\n接下来，我想分享我在编写DOM库过程中的一些经验，第一个是使用文本节点来表示文本。这听起来很傻，我意识到了这个。但是很惊讶的是，我们经常曲解这句话。\n\n![](/css/images/123.jpg)\n\nDOM拥有API去和文本打交道，我们却经常忽略这些API。我们可以通过这些API去创建文本，插入文本，反转文本等。\n\n![](/css/images/124.jpg)\n\n\n这是个benchmark showing，展示了`textContent`和`Text.nodeValue`的速度，后者很明显更快。如果你正在编写一个有处理文本的DOM库或框架，那么选择前者会让你发疯。`textContent`做了更多工作，只说它慢貌似不太公平。但大多情况下，我们不需要处理“更多的工作”。\n\n![](/css/images/125.jpg)\n\n下一个经验是，避免getters，完全的！别使用它们。Text的nodeType是undefined，但是它继承的Node的nodeType是个getter方法，性能不好。\n\n![](/css/images/126.jpg)\n\n如图所示，splitText更快，因为这只是检查某个属性是否存在，而不是调用getter。\n\n![](/css/images/127.jpg)\n\n这是一个性能测试，可以看到getters都很慢，而属性获取的速度却很快。\n\n![](/css/images/128.jpg)\n\n最后一个经验是避免Live NodeLists，不要试图去用它们，它们特别耗性能。\n\n![](/css/images/129.jpg)\n\n这是一个例子，试图去移除父元素的children。第一个你写了一个倒置的循环去移除，之所以倒置是因为这是个live NodeList，它的项数不停的在变化。第二个就快多了，因为我们只是在获取一个属性，不需要回头去请求子节点。我们不需要去获取数组的位移，我们只是在用一个引用。\n\n![](/css/images/130.jpg)\n\n这是测试结果。\n\n![](/css/images/131.jpg)\n\n\n## 性能测试\n\n我已经做性能优化很久了。Benchmark运行了五百万次循环，然后计算时间。\n\n![](/css/images/132.jpg)\n\nChrome开发工具优化了这个，使其更加可视化。\n\n![](/css/images/133.jpg)\n\n另一个工具是IRHydra。\n\n![](/css/images/134.jpg)\n\n最后一个工具是ESBench。这个工具的目的是给你一个非常简单的用户界面去使用Babel和benchmark。\n\n![](/css/images/135.jpg)\n\n\n## 其他经验\n\n第一个是尽量明确的。不要使用一些意外情况，如果你没有理由使用它们。这个例子中，我们检查一个对象的属性，它可能是0，空字符串，null，false等，第二种就清楚多了。\n\n![](/css/images/136.jpg)\n\n下一个经验是行内帮助函数。函数可以更加通用。\n\n![](/css/images/137.jpg)\n\n下一个是短路语法。最便宜的函数调用就是你不调用它。\n\n![](/css/images/138.jpg)\n\n所有这一切都是在说一个道理：基于数据去做决定。\n\n![](/css/images/139.jpg)\n\n---\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n","slug":"preact-into-the-void-0","published":1,"updated":"2019-05-01T08:10:30.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvm40027tgyt5rcgyvyg","content":"<p>本文整理自Jason Miller在JSConf上的talk。原视频地址：</p>\n<p><a href=\"https://www.youtube.com/watch?v=LY6y3HbDVmg\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=LY6y3HbDVmg</a></p>\n<p><img src=\"/css/images/96.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"开场白\"><a href=\"#开场白\" class=\"headerlink\" title=\"开场白\"></a>开场白</h2><p>嗨，大家好，我是Jason，Github上那个developit和推特上的_developit，是一系列库的作者（serial library author），我喜欢甜甜圈、肉汁乳酪薯条和斧头，这意味着我是加拿大人（枫叶国的人喜欢斧头——<a href=\"https://dushi.singtao.ca/toronto/%E8%B4%A2%E7%BB%8F-%E5%88%86%E7%B1%BB/%E5%88%9B%E4%B8%9A%E6%95%85%E4%BA%8B-%E5%88%86%E7%B1%BB/%E5%9C%A8%E5%8A%A0%E6%8B%BF%E5%A4%A7%E6%8A%8A%E6%89%94%E6%96%A7%E5%A4%B4%E5%81%9A%E6%88%9015%E4%B8%87%E7%94%A8%E6%88%B7%E7%9A%84%E5%A4%A7%E7%94%9F%E6%84%8F/\" target=\"_blank\" rel=\"noopener\">在加拿大把扔斧头做成15万用户的大生意</a>）。</p>\n<p><img src=\"/css/images/94.jpg\" alt=\"\"></p>\n<p>我也喜欢“限制”。我在移动web广泛应用前就开始开发它了，那时候还是windows mobile 5。我写了很多UI框架，遇到了很多问题，然后努力去解决它们。这样的理由是我发现“限制”是很有趣的“挑战”，我有些ADHD（注意（力）缺陷多动障碍），你或许熟悉这个东西，为了高效做一些事，最好可以非常专注在上面，这些有趣的“限制”挑战可以帮助我营造这个环境。</p>\n<p><img src=\"/css/images/95.jpg\" alt=\"\"></p>\n<h2 id=\"点题\"><a href=\"#点题\" class=\"headerlink\" title=\"点题\"></a>点题</h2><p>我写了Preact，这个展示叫“Preact: Into the void 0”，我觉得这么叫很聪明（这哥们太极客了，void(0)是js中返回undefined的最小脚本），这也是这个幻灯片中唯一的一个分号哦。</p>\n<p><img src=\"https://ww1.sinaimg.cn/mw690/83900b4egy1fj6o29y7yvj21gk0t8gp1.jpg\" alt=\"\"></p>\n<p>或许你会好奇啥是Preact，这就是Preact。我移除了源代码映射的注释，今天我们主要讲一下这几个圆圈圈中的部分。因为这是Preact的展示，所以我们需要一些紫色，不管那是啥，那都是我们最后要讲的东西。</p>\n<p><img src=\"/css/images/97.jpg\" alt=\"\"></p>\n<h2 id=\"JSX简介\"><a href=\"#JSX简介\" class=\"headerlink\" title=\"JSX简介\"></a>JSX简介</h2><p>不过在开始讲这些东西前，我们需要聊聊JSX。如果你对JSX不熟悉，我不知道你之前是靠在哪个山头。不过别担心，JSX真的非常容易理解。JSX的核心非常简单，等我讲完时候，你完全可以用JSX重写你Webpack配置，让它变得更长、更复杂，这是个好事。如果你不相信我，去看看webpack2的文档吧，都在里面写着呢。</p>\n<p><img src=\"/css/images/98.jpg\" alt=\"\"></p>\n<p>那么什么是JSX？JSX是一个XML风格的表达式，然后被编译为函数调用。我们编写左边的那个很像HTML的尖括号语法。右边是像babel这样的编译器输出的结果，现在貌似已经有十种编译器了。我最喜欢的JSX的点就是很喜欢这种写法，这种带有点DOM风格的写法，编译在前面做了一些事，好让我们可以更好地理解它。</p>\n<p><img src=\"/css/images/99.jpg\" alt=\"\"></p>\n<p>再来看一个稍微复杂一点的写法。这些尖括号语法被编译为了JavaScript，其中<code>one</code> 和变量 <code>world</code>都被保留了下来，另外一个复杂的地方是，如果你的标签名首字母大写，那么它在生成代码中将会是个变量引用。</p>\n<blockquote>\n<p>译者注：JSX中的标签名大小写是有讲究的，小写代表是HTML标签，大写代表一个组件，具体可以看JSX的文档。</p>\n</blockquote>\n<p><img src=\"/css/images/100.jpg\" alt=\"\"></p>\n<p>JSX的精髓就是我们看过的那个工厂函数，它非常简单，只有一个接受节点名称、属性、children的签名。节点名称就是之前说的标签名称，它可以是字符串或者函数，属性是可选的，它可以是个对象，剩余的参数就是children，这就是我们编写的形式。<br><img src=\"/css/images/101.jpg\" alt=\"\"></p>\n<p>你或许会想，我刚才编写不是hyperscript吗？你想的也不算错，hyperscript确实跟JSX很相似，有点JSX超集的意思。看看这两个例子吧！hyperscript支持这种附加的标签写法，本质上来说是CSS选择器的写法，去预定义元素上的属性，而JSX却不支持这种写法。</p>\n<p><img src=\"/css/images/102.jpg\" alt=\"\"></p>\n<p>JSX真正的能力是可以支持这种拓展标签名称。理解好JSX是很重要的，JSX是我们连接各种虚拟DOM库的接口，JSX不是DOM，它跟DOM没啥关联，它只是一种语法，它并不理解你的代码或它被用来做的事，你甚至可以用它编写Webpack配置，但还是别了。你可以用它编写XML，如果你想编写一个SOAP客户端，而且你想用解析和序列化，你就可以使用JSX做这个。总之，我想说JSX是问题的有趣解决方案。</p>\n<p><img src=\"/css/images/103.jpg\" alt=\"\"></p>\n<h2 id=\"虚拟DOM\"><a href=\"#虚拟DOM\" class=\"headerlink\" title=\"虚拟DOM\"></a>虚拟DOM</h2><p>下个话题是虚拟DOM。</p>\n<p><img src=\"/css/images/104.jpg\" alt=\"\"></p>\n<p>虚拟DOM仅仅只是个代表树状结构的对象而已，仅仅如此，没啥别的玄乎的！我经常把它想成一个传递给DOM构建器的一个配置，好让DOM构建器不那么理论化。</p>\n<p><img src=\"/css/images/105.jpg\" alt=\"\"></p>\n<p>不过，首先我们要理解的是，我们如何从JSX到虚拟DOM。</p>\n<p><img src=\"/css/images/106.jpg\" alt=\"\"></p>\n<p>我们所做的方式是调用刚才定义参数的那个h函数。这非常容易理解，我们编写JSX，然后调用h函数，我们要做的就是定义一个h函数，生成这样的对象。这个对象就是虚拟DOM，虚拟DOM就是一个嵌套对象。</p>\n<p><img src=\"/css/images/107.jpg\" alt=\"\"></p>\n<p>令人惊讶的简单，我们要做的就是这个而已！一个只有一行代码的函数！当然，你可以在这里做更多的事情，如果你想扁平化children，去除空值，连接相邻的字符串节点等。但核心是，你可以通过这个函数编写一个虚拟DOM渲染器。</p>\n<p><img src=\"/css/images/108.jpg\" alt=\"\"></p>\n<p>所以，让我们做这个吧！让我们编写一个虚拟DOM渲染器！第一件事，我们要传递给我们自己一个虚拟节点，这是我们之前见过的那个对象，看右上方的滚动框。所以，第一件事是我们需要创建一个DOM对象，匹配传递进来的虚拟节点的类型。所以我们使用<code>document.createElement</code>来做这个。然后我们循环给DOM赋予属性。接着，我们又写了一个递归来循环渲染子节点。最后，我们在类型为字符串时，直接返回DOM对象。这就是我们编写的虚拟DOM渲染器！</p>\n<p><img src=\"/css/images/109.jpg\" alt=\"\"></p>\n<p>这里有个稍微复杂的地方，那就是attributes。如果有人用过React，那么你可能会怒气冲冲地说那不是attrbutes，那是properties！事实上应该叫“props”。attributes和properties是两个不同东东的抽象！大多HTML元素会接受数据作为attributes，它们也可以接受类似的，定型数据作为properties，通过一个叫DOM property reflection的东东。但事实上，这两种都是不太对的，有时候我们可以使用properties，不能使用attributes，有时候又反过来。</p>\n<p><img src=\"/css/images/110.jpg\" alt=\"\"></p>\n<p>我们需要的是将两种写法都写出来！我们有一个DOM节点的引用，我们问它，你支持foo这个property吗？如果它支持，就用property，否则就用attributes。这对自定义元素很好，因为自定义元素倾向于为property定义getter setter对。</p>\n<p><img src=\"/css/images/111.jpg\" alt=\"\"></p>\n<p>这时你可能想问，这能运行吗？这是个虚拟DOM，我们把它传给编写的渲染函数。右边显示的是结果，它可以运行哈哈。</p>\n<p><img src=\"/css/images/112.jpg\" alt=\"\"></p>\n<h2 id=\"DIFF算法\"><a href=\"#DIFF算法\" class=\"headerlink\" title=\"DIFF算法\"></a>DIFF算法</h2><p>我们刚才编写了一个非常简单的虚拟DOM渲染器，也是个非常糟糕的虚拟DOM渲染器，这是版本0。说它糟糕是因为它不能DIFF，它不关注当前的DOM状态，只是完全替换了新dom。虚拟DOM中的DIFF算法是一个争议和神秘的主题，争议是有必要的，因为过程中充满了权衡，并不是非黑即白，而神秘是没有必要的，我试图去揭开它神秘的面纱！</p>\n<p><img src=\"/css/images/113.jpg\" alt=\"\"></p>\n<p>DIFF舍弃从上到下渲染，创建新的DOM。我们将会传递给我们自己一个现在DOM，然后把它变为JSX中写的样子，只是应用一下差异而已。<br><img src=\"/css/images/114.jpg\" alt=\"\"></p>\n<p>在左边，你可以看到虚拟DOM长啥样，只是一个对象。在右边，是一个真实的DOM。你可以看到，名字都差不多。你可以比较一下，然后把差异应用到右边。</p>\n<p><img src=\"/css/images/115.jpg\" alt=\"\"></p>\n<p>运行DIFF，只需要三步。第一步是type，在所有事情前，我们必须要创建一个准确类型的DOM。第二步是循环遍历children，去双向比较它们，然后找出我们是否需要添加、移除、重排它们等。最后一步是更新attributes/props。</p>\n<p><img src=\"/css/images/116.jpg\" alt=\"\"></p>\n<p>所以，让我们从type 开始吧！第一件事是判断节点是否是组件创建的。如果不是，事情就简单了！如果同类型就更新，否则就抛弃原来的，创建一个新的。如果是组件创建的，事情会稍微复杂一点。我们需要创建一个实例，通过比较创建或更新组件的props，然后调用render方法。</p>\n<blockquote>\n<p>译者注：实际情况其实更加复杂，这里需要对组件、组件实例、组件生命周期非常熟悉才能理解。在组件生命周期中，真正操控大局的是组件实例，所以这里需要先创建一个组件实例。</p>\n</blockquote>\n<p><img src=\"/css/images/117.jpg\" alt=\"\"></p>\n<p>children更加简单，只有三步。第一步是循环遍历所有的children，把它们放到列表中，没key的话就放到unkey列表，有key就放到keyed map中。第二步是我们把新的虚拟children转移过去，我们在列表中发现匹配的，然后和虚拟DOM做对比，最后把它插入到当前的index中。最后一步是最简单的，如果有kids剩余，就删除它们，因为它们已经用不到了。</p>\n<p><img src=\"/css/images/118.jpg\" alt=\"\"></p>\n<p>你或许对keyed map和unkey list感兴趣。我今天很想讨论这个话题，我曾在stack overflow上回答过这个问题，这是我在stack overflow上回答的唯一的问题。所以，让我们用PPT来演示它。keys是一些虚拟DOM上有意义的顺序属性，当这些虚拟DOM拥有唯一的类型。我们可以在这个例子中看到，我们拥有三个列表项——one，two，three。在第二个渲染框中，我们只有两个列表项，对于你和我这样的人类而言，我们只需要删除two，把第三项移上去。但虚拟DOM渲染器不知道这个，没有任何东西说明two就是第二项，它就是每次接受一个新的树，没有什么事可以矫正它。这整个过程就是，看看第一项，没变，然后啥事也没发生，然后看看第二项，它说，不，内容不一样啊，然后它就更改了内容。第三项直接被删除了。默认情况下，虚拟DOM中的元素列表，它只会push和pop，没法移动改变中间的项。与此相反，在有key的方法中，我们给每个元素一个唯一的key，所以在第一个框中，我们看到了1，2，3，在第二个框中，我们看到了1，3。很明显，key2被移除了，现在，我们告诉虚拟DOM应该做什么，所以它知道当它循环到key2时，它就会删除该项。</p>\n<p><img src=\"/css/images/119.jpg\" alt=\"\"></p>\n<p>DIFF的最后一步是attributes，这真的很简单，我们给我们自己老的属性和新的属性，从老的属性中找到不在新属性中的属性，然后把它们设置为undefined。对于新的属性，我们和老属性对比，然后设置新属性的值。我们解决了所有的问题，现在我们的app变得非常快！我们把所有问题都转移到了库中，这些库包括：react、preact、inferno等。</p>\n<p><img src=\"/css/images/120.jpg\" alt=\"\"></p>\n<h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2><p>我想和大家讨论一些性能的话题。我编写Preact时，就想测试它的性能。</p>\n<p><img src=\"/css/images/121.jpg\" alt=\"\"></p>\n<p>这句话是你经常在推特上看见人说的。我们经常听到有人抱怨说DOM太慢了，DOM是性能差的根源所在。确实，DOM没有immediate mode drawing API那么快，它设计的目的不是这个，这是完全不同的事。DOM本质上提供了内建的accessibility。你可以使用title和字体注释DOM，还可以得到屏幕阅读器的支持。其他平台也可以这么做，但是DOM做这种事情更加简单。你根本不需要理解它是如何运作的，只需要编写语意化的标记即可。DOM也可以拓展，人们经常忘记这点。如果我在windows上使用推特，我想为推特添加emoji，我就安装浏览器拓展，然后就hook到了每一个在推特上的输入文本，接下来我不依赖推特的输入字段就可以使用emoji了。推特不知道这个，也不需要知道，也不在乎这个。这就是DOM的价值之一，这种基质巩固了所有的应用，它是一种超越我们知识范畴的拓展。这就跟那个“框架不可知论”不谋而合。你可以编写两个不同的插件在两个不同的框架中，只要它们可以渲染元素，你可以假设这些元素拥有相同的祖先元素，它们彼此之间不需要相互在乎。所以，Preact本质上来说就是个DOM渲染器，它是虚拟DOM渲染器，但它就是一种DOM库。</p>\n<p><img src=\"/css/images/122.jpg\" alt=\"\"></p>\n<p>接下来，我想分享我在编写DOM库过程中的一些经验，第一个是使用文本节点来表示文本。这听起来很傻，我意识到了这个。但是很惊讶的是，我们经常曲解这句话。</p>\n<p><img src=\"/css/images/123.jpg\" alt=\"\"></p>\n<p>DOM拥有API去和文本打交道，我们却经常忽略这些API。我们可以通过这些API去创建文本，插入文本，反转文本等。</p>\n<p><img src=\"/css/images/124.jpg\" alt=\"\"></p>\n<p>这是个benchmark showing，展示了<code>textContent</code>和<code>Text.nodeValue</code>的速度，后者很明显更快。如果你正在编写一个有处理文本的DOM库或框架，那么选择前者会让你发疯。<code>textContent</code>做了更多工作，只说它慢貌似不太公平。但大多情况下，我们不需要处理“更多的工作”。</p>\n<p><img src=\"/css/images/125.jpg\" alt=\"\"></p>\n<p>下一个经验是，避免getters，完全的！别使用它们。Text的nodeType是undefined，但是它继承的Node的nodeType是个getter方法，性能不好。</p>\n<p><img src=\"/css/images/126.jpg\" alt=\"\"></p>\n<p>如图所示，splitText更快，因为这只是检查某个属性是否存在，而不是调用getter。</p>\n<p><img src=\"/css/images/127.jpg\" alt=\"\"></p>\n<p>这是一个性能测试，可以看到getters都很慢，而属性获取的速度却很快。</p>\n<p><img src=\"/css/images/128.jpg\" alt=\"\"></p>\n<p>最后一个经验是避免Live NodeLists，不要试图去用它们，它们特别耗性能。</p>\n<p><img src=\"/css/images/129.jpg\" alt=\"\"></p>\n<p>这是一个例子，试图去移除父元素的children。第一个你写了一个倒置的循环去移除，之所以倒置是因为这是个live NodeList，它的项数不停的在变化。第二个就快多了，因为我们只是在获取一个属性，不需要回头去请求子节点。我们不需要去获取数组的位移，我们只是在用一个引用。</p>\n<p><img src=\"/css/images/130.jpg\" alt=\"\"></p>\n<p>这是测试结果。</p>\n<p><img src=\"/css/images/131.jpg\" alt=\"\"></p>\n<h2 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h2><p>我已经做性能优化很久了。Benchmark运行了五百万次循环，然后计算时间。</p>\n<p><img src=\"/css/images/132.jpg\" alt=\"\"></p>\n<p>Chrome开发工具优化了这个，使其更加可视化。</p>\n<p><img src=\"/css/images/133.jpg\" alt=\"\"></p>\n<p>另一个工具是IRHydra。</p>\n<p><img src=\"/css/images/134.jpg\" alt=\"\"></p>\n<p>最后一个工具是ESBench。这个工具的目的是给你一个非常简单的用户界面去使用Babel和benchmark。</p>\n<p><img src=\"/css/images/135.jpg\" alt=\"\"></p>\n<h2 id=\"其他经验\"><a href=\"#其他经验\" class=\"headerlink\" title=\"其他经验\"></a>其他经验</h2><p>第一个是尽量明确的。不要使用一些意外情况，如果你没有理由使用它们。这个例子中，我们检查一个对象的属性，它可能是0，空字符串，null，false等，第二种就清楚多了。</p>\n<p><img src=\"/css/images/136.jpg\" alt=\"\"></p>\n<p>下一个经验是行内帮助函数。函数可以更加通用。</p>\n<p><img src=\"/css/images/137.jpg\" alt=\"\"></p>\n<p>下一个是短路语法。最便宜的函数调用就是你不调用它。</p>\n<p><img src=\"/css/images/138.jpg\" alt=\"\"></p>\n<p>所有这一切都是在说一个道理：基于数据去做决定。</p>\n<p><img src=\"/css/images/139.jpg\" alt=\"\"></p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>\n","site":{"data":{}},"excerpt":"<p>本文整理自Jason Miller在JSConf上的talk。原视频地址：</p>\n<p><a href=\"https://www.youtube.com/watch?v=LY6y3HbDVmg\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=LY6y3HbDVmg</a></p>\n<p><img src=\"/css/images/96.jpg\" alt=\"\"></p>","more":"<h2 id=\"开场白\"><a href=\"#开场白\" class=\"headerlink\" title=\"开场白\"></a>开场白</h2><p>嗨，大家好，我是Jason，Github上那个developit和推特上的_developit，是一系列库的作者（serial library author），我喜欢甜甜圈、肉汁乳酪薯条和斧头，这意味着我是加拿大人（枫叶国的人喜欢斧头——<a href=\"https://dushi.singtao.ca/toronto/%E8%B4%A2%E7%BB%8F-%E5%88%86%E7%B1%BB/%E5%88%9B%E4%B8%9A%E6%95%85%E4%BA%8B-%E5%88%86%E7%B1%BB/%E5%9C%A8%E5%8A%A0%E6%8B%BF%E5%A4%A7%E6%8A%8A%E6%89%94%E6%96%A7%E5%A4%B4%E5%81%9A%E6%88%9015%E4%B8%87%E7%94%A8%E6%88%B7%E7%9A%84%E5%A4%A7%E7%94%9F%E6%84%8F/\" target=\"_blank\" rel=\"noopener\">在加拿大把扔斧头做成15万用户的大生意</a>）。</p>\n<p><img src=\"/css/images/94.jpg\" alt=\"\"></p>\n<p>我也喜欢“限制”。我在移动web广泛应用前就开始开发它了，那时候还是windows mobile 5。我写了很多UI框架，遇到了很多问题，然后努力去解决它们。这样的理由是我发现“限制”是很有趣的“挑战”，我有些ADHD（注意（力）缺陷多动障碍），你或许熟悉这个东西，为了高效做一些事，最好可以非常专注在上面，这些有趣的“限制”挑战可以帮助我营造这个环境。</p>\n<p><img src=\"/css/images/95.jpg\" alt=\"\"></p>\n<h2 id=\"点题\"><a href=\"#点题\" class=\"headerlink\" title=\"点题\"></a>点题</h2><p>我写了Preact，这个展示叫“Preact: Into the void 0”，我觉得这么叫很聪明（这哥们太极客了，void(0)是js中返回undefined的最小脚本），这也是这个幻灯片中唯一的一个分号哦。</p>\n<p><img src=\"https://ww1.sinaimg.cn/mw690/83900b4egy1fj6o29y7yvj21gk0t8gp1.jpg\" alt=\"\"></p>\n<p>或许你会好奇啥是Preact，这就是Preact。我移除了源代码映射的注释，今天我们主要讲一下这几个圆圈圈中的部分。因为这是Preact的展示，所以我们需要一些紫色，不管那是啥，那都是我们最后要讲的东西。</p>\n<p><img src=\"/css/images/97.jpg\" alt=\"\"></p>\n<h2 id=\"JSX简介\"><a href=\"#JSX简介\" class=\"headerlink\" title=\"JSX简介\"></a>JSX简介</h2><p>不过在开始讲这些东西前，我们需要聊聊JSX。如果你对JSX不熟悉，我不知道你之前是靠在哪个山头。不过别担心，JSX真的非常容易理解。JSX的核心非常简单，等我讲完时候，你完全可以用JSX重写你Webpack配置，让它变得更长、更复杂，这是个好事。如果你不相信我，去看看webpack2的文档吧，都在里面写着呢。</p>\n<p><img src=\"/css/images/98.jpg\" alt=\"\"></p>\n<p>那么什么是JSX？JSX是一个XML风格的表达式，然后被编译为函数调用。我们编写左边的那个很像HTML的尖括号语法。右边是像babel这样的编译器输出的结果，现在貌似已经有十种编译器了。我最喜欢的JSX的点就是很喜欢这种写法，这种带有点DOM风格的写法，编译在前面做了一些事，好让我们可以更好地理解它。</p>\n<p><img src=\"/css/images/99.jpg\" alt=\"\"></p>\n<p>再来看一个稍微复杂一点的写法。这些尖括号语法被编译为了JavaScript，其中<code>one</code> 和变量 <code>world</code>都被保留了下来，另外一个复杂的地方是，如果你的标签名首字母大写，那么它在生成代码中将会是个变量引用。</p>\n<blockquote>\n<p>译者注：JSX中的标签名大小写是有讲究的，小写代表是HTML标签，大写代表一个组件，具体可以看JSX的文档。</p>\n</blockquote>\n<p><img src=\"/css/images/100.jpg\" alt=\"\"></p>\n<p>JSX的精髓就是我们看过的那个工厂函数，它非常简单，只有一个接受节点名称、属性、children的签名。节点名称就是之前说的标签名称，它可以是字符串或者函数，属性是可选的，它可以是个对象，剩余的参数就是children，这就是我们编写的形式。<br><img src=\"/css/images/101.jpg\" alt=\"\"></p>\n<p>你或许会想，我刚才编写不是hyperscript吗？你想的也不算错，hyperscript确实跟JSX很相似，有点JSX超集的意思。看看这两个例子吧！hyperscript支持这种附加的标签写法，本质上来说是CSS选择器的写法，去预定义元素上的属性，而JSX却不支持这种写法。</p>\n<p><img src=\"/css/images/102.jpg\" alt=\"\"></p>\n<p>JSX真正的能力是可以支持这种拓展标签名称。理解好JSX是很重要的，JSX是我们连接各种虚拟DOM库的接口，JSX不是DOM，它跟DOM没啥关联，它只是一种语法，它并不理解你的代码或它被用来做的事，你甚至可以用它编写Webpack配置，但还是别了。你可以用它编写XML，如果你想编写一个SOAP客户端，而且你想用解析和序列化，你就可以使用JSX做这个。总之，我想说JSX是问题的有趣解决方案。</p>\n<p><img src=\"/css/images/103.jpg\" alt=\"\"></p>\n<h2 id=\"虚拟DOM\"><a href=\"#虚拟DOM\" class=\"headerlink\" title=\"虚拟DOM\"></a>虚拟DOM</h2><p>下个话题是虚拟DOM。</p>\n<p><img src=\"/css/images/104.jpg\" alt=\"\"></p>\n<p>虚拟DOM仅仅只是个代表树状结构的对象而已，仅仅如此，没啥别的玄乎的！我经常把它想成一个传递给DOM构建器的一个配置，好让DOM构建器不那么理论化。</p>\n<p><img src=\"/css/images/105.jpg\" alt=\"\"></p>\n<p>不过，首先我们要理解的是，我们如何从JSX到虚拟DOM。</p>\n<p><img src=\"/css/images/106.jpg\" alt=\"\"></p>\n<p>我们所做的方式是调用刚才定义参数的那个h函数。这非常容易理解，我们编写JSX，然后调用h函数，我们要做的就是定义一个h函数，生成这样的对象。这个对象就是虚拟DOM，虚拟DOM就是一个嵌套对象。</p>\n<p><img src=\"/css/images/107.jpg\" alt=\"\"></p>\n<p>令人惊讶的简单，我们要做的就是这个而已！一个只有一行代码的函数！当然，你可以在这里做更多的事情，如果你想扁平化children，去除空值，连接相邻的字符串节点等。但核心是，你可以通过这个函数编写一个虚拟DOM渲染器。</p>\n<p><img src=\"/css/images/108.jpg\" alt=\"\"></p>\n<p>所以，让我们做这个吧！让我们编写一个虚拟DOM渲染器！第一件事，我们要传递给我们自己一个虚拟节点，这是我们之前见过的那个对象，看右上方的滚动框。所以，第一件事是我们需要创建一个DOM对象，匹配传递进来的虚拟节点的类型。所以我们使用<code>document.createElement</code>来做这个。然后我们循环给DOM赋予属性。接着，我们又写了一个递归来循环渲染子节点。最后，我们在类型为字符串时，直接返回DOM对象。这就是我们编写的虚拟DOM渲染器！</p>\n<p><img src=\"/css/images/109.jpg\" alt=\"\"></p>\n<p>这里有个稍微复杂的地方，那就是attributes。如果有人用过React，那么你可能会怒气冲冲地说那不是attrbutes，那是properties！事实上应该叫“props”。attributes和properties是两个不同东东的抽象！大多HTML元素会接受数据作为attributes，它们也可以接受类似的，定型数据作为properties，通过一个叫DOM property reflection的东东。但事实上，这两种都是不太对的，有时候我们可以使用properties，不能使用attributes，有时候又反过来。</p>\n<p><img src=\"/css/images/110.jpg\" alt=\"\"></p>\n<p>我们需要的是将两种写法都写出来！我们有一个DOM节点的引用，我们问它，你支持foo这个property吗？如果它支持，就用property，否则就用attributes。这对自定义元素很好，因为自定义元素倾向于为property定义getter setter对。</p>\n<p><img src=\"/css/images/111.jpg\" alt=\"\"></p>\n<p>这时你可能想问，这能运行吗？这是个虚拟DOM，我们把它传给编写的渲染函数。右边显示的是结果，它可以运行哈哈。</p>\n<p><img src=\"/css/images/112.jpg\" alt=\"\"></p>\n<h2 id=\"DIFF算法\"><a href=\"#DIFF算法\" class=\"headerlink\" title=\"DIFF算法\"></a>DIFF算法</h2><p>我们刚才编写了一个非常简单的虚拟DOM渲染器，也是个非常糟糕的虚拟DOM渲染器，这是版本0。说它糟糕是因为它不能DIFF，它不关注当前的DOM状态，只是完全替换了新dom。虚拟DOM中的DIFF算法是一个争议和神秘的主题，争议是有必要的，因为过程中充满了权衡，并不是非黑即白，而神秘是没有必要的，我试图去揭开它神秘的面纱！</p>\n<p><img src=\"/css/images/113.jpg\" alt=\"\"></p>\n<p>DIFF舍弃从上到下渲染，创建新的DOM。我们将会传递给我们自己一个现在DOM，然后把它变为JSX中写的样子，只是应用一下差异而已。<br><img src=\"/css/images/114.jpg\" alt=\"\"></p>\n<p>在左边，你可以看到虚拟DOM长啥样，只是一个对象。在右边，是一个真实的DOM。你可以看到，名字都差不多。你可以比较一下，然后把差异应用到右边。</p>\n<p><img src=\"/css/images/115.jpg\" alt=\"\"></p>\n<p>运行DIFF，只需要三步。第一步是type，在所有事情前，我们必须要创建一个准确类型的DOM。第二步是循环遍历children，去双向比较它们，然后找出我们是否需要添加、移除、重排它们等。最后一步是更新attributes/props。</p>\n<p><img src=\"/css/images/116.jpg\" alt=\"\"></p>\n<p>所以，让我们从type 开始吧！第一件事是判断节点是否是组件创建的。如果不是，事情就简单了！如果同类型就更新，否则就抛弃原来的，创建一个新的。如果是组件创建的，事情会稍微复杂一点。我们需要创建一个实例，通过比较创建或更新组件的props，然后调用render方法。</p>\n<blockquote>\n<p>译者注：实际情况其实更加复杂，这里需要对组件、组件实例、组件生命周期非常熟悉才能理解。在组件生命周期中，真正操控大局的是组件实例，所以这里需要先创建一个组件实例。</p>\n</blockquote>\n<p><img src=\"/css/images/117.jpg\" alt=\"\"></p>\n<p>children更加简单，只有三步。第一步是循环遍历所有的children，把它们放到列表中，没key的话就放到unkey列表，有key就放到keyed map中。第二步是我们把新的虚拟children转移过去，我们在列表中发现匹配的，然后和虚拟DOM做对比，最后把它插入到当前的index中。最后一步是最简单的，如果有kids剩余，就删除它们，因为它们已经用不到了。</p>\n<p><img src=\"/css/images/118.jpg\" alt=\"\"></p>\n<p>你或许对keyed map和unkey list感兴趣。我今天很想讨论这个话题，我曾在stack overflow上回答过这个问题，这是我在stack overflow上回答的唯一的问题。所以，让我们用PPT来演示它。keys是一些虚拟DOM上有意义的顺序属性，当这些虚拟DOM拥有唯一的类型。我们可以在这个例子中看到，我们拥有三个列表项——one，two，three。在第二个渲染框中，我们只有两个列表项，对于你和我这样的人类而言，我们只需要删除two，把第三项移上去。但虚拟DOM渲染器不知道这个，没有任何东西说明two就是第二项，它就是每次接受一个新的树，没有什么事可以矫正它。这整个过程就是，看看第一项，没变，然后啥事也没发生，然后看看第二项，它说，不，内容不一样啊，然后它就更改了内容。第三项直接被删除了。默认情况下，虚拟DOM中的元素列表，它只会push和pop，没法移动改变中间的项。与此相反，在有key的方法中，我们给每个元素一个唯一的key，所以在第一个框中，我们看到了1，2，3，在第二个框中，我们看到了1，3。很明显，key2被移除了，现在，我们告诉虚拟DOM应该做什么，所以它知道当它循环到key2时，它就会删除该项。</p>\n<p><img src=\"/css/images/119.jpg\" alt=\"\"></p>\n<p>DIFF的最后一步是attributes，这真的很简单，我们给我们自己老的属性和新的属性，从老的属性中找到不在新属性中的属性，然后把它们设置为undefined。对于新的属性，我们和老属性对比，然后设置新属性的值。我们解决了所有的问题，现在我们的app变得非常快！我们把所有问题都转移到了库中，这些库包括：react、preact、inferno等。</p>\n<p><img src=\"/css/images/120.jpg\" alt=\"\"></p>\n<h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2><p>我想和大家讨论一些性能的话题。我编写Preact时，就想测试它的性能。</p>\n<p><img src=\"/css/images/121.jpg\" alt=\"\"></p>\n<p>这句话是你经常在推特上看见人说的。我们经常听到有人抱怨说DOM太慢了，DOM是性能差的根源所在。确实，DOM没有immediate mode drawing API那么快，它设计的目的不是这个，这是完全不同的事。DOM本质上提供了内建的accessibility。你可以使用title和字体注释DOM，还可以得到屏幕阅读器的支持。其他平台也可以这么做，但是DOM做这种事情更加简单。你根本不需要理解它是如何运作的，只需要编写语意化的标记即可。DOM也可以拓展，人们经常忘记这点。如果我在windows上使用推特，我想为推特添加emoji，我就安装浏览器拓展，然后就hook到了每一个在推特上的输入文本，接下来我不依赖推特的输入字段就可以使用emoji了。推特不知道这个，也不需要知道，也不在乎这个。这就是DOM的价值之一，这种基质巩固了所有的应用，它是一种超越我们知识范畴的拓展。这就跟那个“框架不可知论”不谋而合。你可以编写两个不同的插件在两个不同的框架中，只要它们可以渲染元素，你可以假设这些元素拥有相同的祖先元素，它们彼此之间不需要相互在乎。所以，Preact本质上来说就是个DOM渲染器，它是虚拟DOM渲染器，但它就是一种DOM库。</p>\n<p><img src=\"/css/images/122.jpg\" alt=\"\"></p>\n<p>接下来，我想分享我在编写DOM库过程中的一些经验，第一个是使用文本节点来表示文本。这听起来很傻，我意识到了这个。但是很惊讶的是，我们经常曲解这句话。</p>\n<p><img src=\"/css/images/123.jpg\" alt=\"\"></p>\n<p>DOM拥有API去和文本打交道，我们却经常忽略这些API。我们可以通过这些API去创建文本，插入文本，反转文本等。</p>\n<p><img src=\"/css/images/124.jpg\" alt=\"\"></p>\n<p>这是个benchmark showing，展示了<code>textContent</code>和<code>Text.nodeValue</code>的速度，后者很明显更快。如果你正在编写一个有处理文本的DOM库或框架，那么选择前者会让你发疯。<code>textContent</code>做了更多工作，只说它慢貌似不太公平。但大多情况下，我们不需要处理“更多的工作”。</p>\n<p><img src=\"/css/images/125.jpg\" alt=\"\"></p>\n<p>下一个经验是，避免getters，完全的！别使用它们。Text的nodeType是undefined，但是它继承的Node的nodeType是个getter方法，性能不好。</p>\n<p><img src=\"/css/images/126.jpg\" alt=\"\"></p>\n<p>如图所示，splitText更快，因为这只是检查某个属性是否存在，而不是调用getter。</p>\n<p><img src=\"/css/images/127.jpg\" alt=\"\"></p>\n<p>这是一个性能测试，可以看到getters都很慢，而属性获取的速度却很快。</p>\n<p><img src=\"/css/images/128.jpg\" alt=\"\"></p>\n<p>最后一个经验是避免Live NodeLists，不要试图去用它们，它们特别耗性能。</p>\n<p><img src=\"/css/images/129.jpg\" alt=\"\"></p>\n<p>这是一个例子，试图去移除父元素的children。第一个你写了一个倒置的循环去移除，之所以倒置是因为这是个live NodeList，它的项数不停的在变化。第二个就快多了，因为我们只是在获取一个属性，不需要回头去请求子节点。我们不需要去获取数组的位移，我们只是在用一个引用。</p>\n<p><img src=\"/css/images/130.jpg\" alt=\"\"></p>\n<p>这是测试结果。</p>\n<p><img src=\"/css/images/131.jpg\" alt=\"\"></p>\n<h2 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h2><p>我已经做性能优化很久了。Benchmark运行了五百万次循环，然后计算时间。</p>\n<p><img src=\"/css/images/132.jpg\" alt=\"\"></p>\n<p>Chrome开发工具优化了这个，使其更加可视化。</p>\n<p><img src=\"/css/images/133.jpg\" alt=\"\"></p>\n<p>另一个工具是IRHydra。</p>\n<p><img src=\"/css/images/134.jpg\" alt=\"\"></p>\n<p>最后一个工具是ESBench。这个工具的目的是给你一个非常简单的用户界面去使用Babel和benchmark。</p>\n<p><img src=\"/css/images/135.jpg\" alt=\"\"></p>\n<h2 id=\"其他经验\"><a href=\"#其他经验\" class=\"headerlink\" title=\"其他经验\"></a>其他经验</h2><p>第一个是尽量明确的。不要使用一些意外情况，如果你没有理由使用它们。这个例子中，我们检查一个对象的属性，它可能是0，空字符串，null，false等，第二种就清楚多了。</p>\n<p><img src=\"/css/images/136.jpg\" alt=\"\"></p>\n<p>下一个经验是行内帮助函数。函数可以更加通用。</p>\n<p><img src=\"/css/images/137.jpg\" alt=\"\"></p>\n<p>下一个是短路语法。最便宜的函数调用就是你不调用它。</p>\n<p><img src=\"/css/images/138.jpg\" alt=\"\"></p>\n<p>所有这一切都是在说一个道理：基于数据去做决定。</p>\n<p><img src=\"/css/images/139.jpg\" alt=\"\"></p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>"},{"title":"JavaScript 版数据结构与算法（二）队列","date":"2017-02-15T05:53:00.000Z","_content":"\n今天，我们要讲的是数据结构与算法中的队列。\n\n<!--more-->\n\n## 队列简介\n\n队列是什么？队列是一种先进先出（FIFO）的数据结构。队列有什么用呢？队列通常用来描述算法或生活中的一些先进先出的场景，比如：\n\n- 在图的广度优先遍历中，我们需要使用队列来记录每个节点的相邻节点，以便可以在接下来最先访问它们，从而实现广度优先遍历。\n- 在 JavaScript 事件循环（Event Loop）中有一个事件队列（Task Queue），也是先进先出来处理各种异步事件。\n- 在生活中，队列可以映射排队打饭等先来后到的场景。\n\n![](https://ws1.sinaimg.cn/mw690/83900b4ely1fcr48hfps7j20c40drglj)\n\n## 用 JavaScript 编写队列类\n\n和[《JavaScript 版数据结构与算法（一）栈》](https://lewis617.github.io/2017/02/15/stack/)中编写栈类的方法类似，编写队列类也使用了构造器函数。\n\n编写一个队列类，可以跑通如下测试：\n\n```js\nvar queue = new Queue();\nexpect(queue.isEmpty()).toBeTruthy();\nqueue.enqueue('张三');\nqueue.enqueue('李四');\nqueue.enqueue('王五');\nexpect(queue.front()).toBe('张三');\nexpect(queue.toString()).toBe('张三,李四,王五');\nexpect(queue.size()).toBe(3);\nexpect(queue.isEmpty()).toBeFalsy();\nqueue.dequeue();\nqueue.dequeue();\nexpect(queue.toString()).toBe('王五');\n```\n\n队列类比较简单，直接上代码：\n\n```js\nfunction Queue() {\n  // 私有变量 items，用于记录数组\n  var items = [];\n  // 入队\n  this.enqueue = function (element) {\n    items.push(element);\n  };\n  // 出队\n  this.dequeue = function () {\n    return items.shift();\n  };\n  // 查看队列的第一个元素\n  this.front = function () {\n    return items[0];\n  };\n  // 查看队列是否为空\n  this.isEmpty = function () {\n    return items.length == 0;\n  };\n  // 查看队列的长度\n  this.size = function () {\n    return items.length;\n  };\n  // 将数组转为字符串并返回\n  this.toString = function () {\n    return items.toString();\n  };\n}\n\n// 导出队列类\nmodule.exports = Queue;\n```\n\n请注意数组增删的四个方法，别搞混淆了：\n\n- push：在尾部添加新元素\n- pop：删除并返回尾部元素\n- unshift：在头部添加新元素\n- shift：删除并返回头部元素\n\n所以，出队的方法用的是 shift。另外，如果考虑时间复杂度，使用数组创建队列并不是一个好方法，因为出队时，所有的元素都会移动位置，造成较差的性能。而使用链表则会更好，因为链表不是连续存储的，增删元素只需要改变相关的指向即可。\n\n## 优先队列：加队就是这么任性\n\n普通的队列类就是调用原生 Array 对象的方法，比较简单，但是还有一种队列叫优先队列。在优先队列里面，有些人比较霸道，可以加队。不过，如果遇到比他更霸道的人，他也得老实在后面排着。举个例子吧！假设有三个人：张三、李四、王五。王五是个没本事的老实人。张三是个小流氓，经常欺负王五。李四呢？是个官老爷。他们三个排队，小流氓张三先来，官老爷李四第二个来，老实人王五最后来。结果，张三给李四让道，王五还是排在最后。在优先队列里，我们使用优先级（priority）来描述霸道程度。\n\n```js\nvar priorityQueue = new PriorityQueue();\npriorityQueue.enqueue('张三', 2);\npriorityQueue.enqueue('李四', 1);\npriorityQueue.enqueue('王五', 3);\nexpect(priorityQueue.toString()).toBe('李四-1,张三-2,王五-3');\n```\n\n上述代码中，名字后面的数字就是优先级。排队结果就如最后一个断言所示：`'李四-1,张三-2,王五-3'`。\n\n为了实现上述测试用例，我们需要改写 `enqueue` 方法和`toString`方法：\n\n```js\nfunction PriorityQueue() {\n  var items = [];\n\n  // 利用构造器函数创建队列元素\n  var QueueElement = function (element, priority) {\n    this.element = element;\n    this.priority = priority;\n  };\n\n  this.enqueue = function (element, priority) {\n    var queueElement = new QueueElement(element, priority);\n\n    // 张三的情况\n    if (this.isEmpty()) {\n      items.push(queueElement);\n    } else {\n      var added = false;\n      for (var i = 0; i < items.length; i++) {\n        if (queueElement.priority < items[i].priority) {\n          // 李四的情况\n          items.splice(i, 0, queueElement);\n          added = true;\n          break;\n        }\n      }\n      // 王五的情况\n      if (!added) {\n        items.push(queueElement);\n      }\n    }\n  };\n\n  ...\n  \n  this.toString = function () {\n    var string = '';\n    for (var i = 0; i < items.length; i++) {\n      string += items[i].element + '-' + items[i].priority + (items.length - i > 1 ? ',' : '');\n    }\n    return string;\n  };\n}\n\nmodule.exports = PriorityQueue;\n```\n\n因为这三个人正好代表了所有的情况，所以只要将测试用例跑通，逻辑就写完了。为何会如此？其实我当时在写测试用例时，故意将代码覆盖率刷到100%。也就是说，测试用例涵盖了所有的情况。`toString` 方法则是则是多打印了一个优先级而已，其他方法与普通队列一样，不再赘述。\n\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","source":"_posts/queue.md","raw":"---\ntitle: JavaScript 版数据结构与算法（二）队列\ndate: 2017-02-15 13:53:00\ntags: [数据结构与算法]\n---\n\n今天，我们要讲的是数据结构与算法中的队列。\n\n<!--more-->\n\n## 队列简介\n\n队列是什么？队列是一种先进先出（FIFO）的数据结构。队列有什么用呢？队列通常用来描述算法或生活中的一些先进先出的场景，比如：\n\n- 在图的广度优先遍历中，我们需要使用队列来记录每个节点的相邻节点，以便可以在接下来最先访问它们，从而实现广度优先遍历。\n- 在 JavaScript 事件循环（Event Loop）中有一个事件队列（Task Queue），也是先进先出来处理各种异步事件。\n- 在生活中，队列可以映射排队打饭等先来后到的场景。\n\n![](https://ws1.sinaimg.cn/mw690/83900b4ely1fcr48hfps7j20c40drglj)\n\n## 用 JavaScript 编写队列类\n\n和[《JavaScript 版数据结构与算法（一）栈》](https://lewis617.github.io/2017/02/15/stack/)中编写栈类的方法类似，编写队列类也使用了构造器函数。\n\n编写一个队列类，可以跑通如下测试：\n\n```js\nvar queue = new Queue();\nexpect(queue.isEmpty()).toBeTruthy();\nqueue.enqueue('张三');\nqueue.enqueue('李四');\nqueue.enqueue('王五');\nexpect(queue.front()).toBe('张三');\nexpect(queue.toString()).toBe('张三,李四,王五');\nexpect(queue.size()).toBe(3);\nexpect(queue.isEmpty()).toBeFalsy();\nqueue.dequeue();\nqueue.dequeue();\nexpect(queue.toString()).toBe('王五');\n```\n\n队列类比较简单，直接上代码：\n\n```js\nfunction Queue() {\n  // 私有变量 items，用于记录数组\n  var items = [];\n  // 入队\n  this.enqueue = function (element) {\n    items.push(element);\n  };\n  // 出队\n  this.dequeue = function () {\n    return items.shift();\n  };\n  // 查看队列的第一个元素\n  this.front = function () {\n    return items[0];\n  };\n  // 查看队列是否为空\n  this.isEmpty = function () {\n    return items.length == 0;\n  };\n  // 查看队列的长度\n  this.size = function () {\n    return items.length;\n  };\n  // 将数组转为字符串并返回\n  this.toString = function () {\n    return items.toString();\n  };\n}\n\n// 导出队列类\nmodule.exports = Queue;\n```\n\n请注意数组增删的四个方法，别搞混淆了：\n\n- push：在尾部添加新元素\n- pop：删除并返回尾部元素\n- unshift：在头部添加新元素\n- shift：删除并返回头部元素\n\n所以，出队的方法用的是 shift。另外，如果考虑时间复杂度，使用数组创建队列并不是一个好方法，因为出队时，所有的元素都会移动位置，造成较差的性能。而使用链表则会更好，因为链表不是连续存储的，增删元素只需要改变相关的指向即可。\n\n## 优先队列：加队就是这么任性\n\n普通的队列类就是调用原生 Array 对象的方法，比较简单，但是还有一种队列叫优先队列。在优先队列里面，有些人比较霸道，可以加队。不过，如果遇到比他更霸道的人，他也得老实在后面排着。举个例子吧！假设有三个人：张三、李四、王五。王五是个没本事的老实人。张三是个小流氓，经常欺负王五。李四呢？是个官老爷。他们三个排队，小流氓张三先来，官老爷李四第二个来，老实人王五最后来。结果，张三给李四让道，王五还是排在最后。在优先队列里，我们使用优先级（priority）来描述霸道程度。\n\n```js\nvar priorityQueue = new PriorityQueue();\npriorityQueue.enqueue('张三', 2);\npriorityQueue.enqueue('李四', 1);\npriorityQueue.enqueue('王五', 3);\nexpect(priorityQueue.toString()).toBe('李四-1,张三-2,王五-3');\n```\n\n上述代码中，名字后面的数字就是优先级。排队结果就如最后一个断言所示：`'李四-1,张三-2,王五-3'`。\n\n为了实现上述测试用例，我们需要改写 `enqueue` 方法和`toString`方法：\n\n```js\nfunction PriorityQueue() {\n  var items = [];\n\n  // 利用构造器函数创建队列元素\n  var QueueElement = function (element, priority) {\n    this.element = element;\n    this.priority = priority;\n  };\n\n  this.enqueue = function (element, priority) {\n    var queueElement = new QueueElement(element, priority);\n\n    // 张三的情况\n    if (this.isEmpty()) {\n      items.push(queueElement);\n    } else {\n      var added = false;\n      for (var i = 0; i < items.length; i++) {\n        if (queueElement.priority < items[i].priority) {\n          // 李四的情况\n          items.splice(i, 0, queueElement);\n          added = true;\n          break;\n        }\n      }\n      // 王五的情况\n      if (!added) {\n        items.push(queueElement);\n      }\n    }\n  };\n\n  ...\n  \n  this.toString = function () {\n    var string = '';\n    for (var i = 0; i < items.length; i++) {\n      string += items[i].element + '-' + items[i].priority + (items.length - i > 1 ? ',' : '');\n    }\n    return string;\n  };\n}\n\nmodule.exports = PriorityQueue;\n```\n\n因为这三个人正好代表了所有的情况，所以只要将测试用例跑通，逻辑就写完了。为何会如此？其实我当时在写测试用例时，故意将代码覆盖率刷到100%。也就是说，测试用例涵盖了所有的情况。`toString` 方法则是则是多打印了一个优先级而已，其他方法与普通队列一样，不再赘述。\n\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","slug":"queue","published":1,"updated":"2019-05-01T08:02:11.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvm50029tgyto8p2oe6q","content":"<p>今天，我们要讲的是数据结构与算法中的队列。</p>\n<a id=\"more\"></a>\n<h2 id=\"队列简介\"><a href=\"#队列简介\" class=\"headerlink\" title=\"队列简介\"></a>队列简介</h2><p>队列是什么？队列是一种先进先出（FIFO）的数据结构。队列有什么用呢？队列通常用来描述算法或生活中的一些先进先出的场景，比如：</p>\n<ul>\n<li>在图的广度优先遍历中，我们需要使用队列来记录每个节点的相邻节点，以便可以在接下来最先访问它们，从而实现广度优先遍历。</li>\n<li>在 JavaScript 事件循环（Event Loop）中有一个事件队列（Task Queue），也是先进先出来处理各种异步事件。</li>\n<li>在生活中，队列可以映射排队打饭等先来后到的场景。</li>\n</ul>\n<p><img src=\"https://ws1.sinaimg.cn/mw690/83900b4ely1fcr48hfps7j20c40drglj\" alt=\"\"></p>\n<h2 id=\"用-JavaScript-编写队列类\"><a href=\"#用-JavaScript-编写队列类\" class=\"headerlink\" title=\"用 JavaScript 编写队列类\"></a>用 JavaScript 编写队列类</h2><p>和<a href=\"https://lewis617.github.io/2017/02/15/stack/\" target=\"_blank\" rel=\"noopener\">《JavaScript 版数据结构与算法（一）栈》</a>中编写栈类的方法类似，编写队列类也使用了构造器函数。</p>\n<p>编写一个队列类，可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> queue = <span class=\"keyword\">new</span> Queue();</span><br><span class=\"line\">expect(queue.isEmpty()).toBeTruthy();</span><br><span class=\"line\">queue.enqueue(<span class=\"string\">'张三'</span>);</span><br><span class=\"line\">queue.enqueue(<span class=\"string\">'李四'</span>);</span><br><span class=\"line\">queue.enqueue(<span class=\"string\">'王五'</span>);</span><br><span class=\"line\">expect(queue.front()).toBe(<span class=\"string\">'张三'</span>);</span><br><span class=\"line\">expect(queue.toString()).toBe(<span class=\"string\">'张三,李四,王五'</span>);</span><br><span class=\"line\">expect(queue.size()).toBe(<span class=\"number\">3</span>);</span><br><span class=\"line\">expect(queue.isEmpty()).toBeFalsy();</span><br><span class=\"line\">queue.dequeue();</span><br><span class=\"line\">queue.dequeue();</span><br><span class=\"line\">expect(queue.toString()).toBe(<span class=\"string\">'王五'</span>);</span><br></pre></td></tr></table></figure>\n<p>队列类比较简单，直接上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Queue</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量 items，用于记录数组</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">  <span class=\"comment\">// 入队</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.enqueue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">    items.push(element);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 出队</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.dequeue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.shift();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 查看队列的第一个元素</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.front = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 查看队列是否为空</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.isEmpty = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.length == <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 查看队列的长度</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.size = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.length;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 将数组转为字符串并返回</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.toString();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 导出队列类</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = Queue;</span><br></pre></td></tr></table></figure>\n<p>请注意数组增删的四个方法，别搞混淆了：</p>\n<ul>\n<li>push：在尾部添加新元素</li>\n<li>pop：删除并返回尾部元素</li>\n<li>unshift：在头部添加新元素</li>\n<li>shift：删除并返回头部元素</li>\n</ul>\n<p>所以，出队的方法用的是 shift。另外，如果考虑时间复杂度，使用数组创建队列并不是一个好方法，因为出队时，所有的元素都会移动位置，造成较差的性能。而使用链表则会更好，因为链表不是连续存储的，增删元素只需要改变相关的指向即可。</p>\n<h2 id=\"优先队列：加队就是这么任性\"><a href=\"#优先队列：加队就是这么任性\" class=\"headerlink\" title=\"优先队列：加队就是这么任性\"></a>优先队列：加队就是这么任性</h2><p>普通的队列类就是调用原生 Array 对象的方法，比较简单，但是还有一种队列叫优先队列。在优先队列里面，有些人比较霸道，可以加队。不过，如果遇到比他更霸道的人，他也得老实在后面排着。举个例子吧！假设有三个人：张三、李四、王五。王五是个没本事的老实人。张三是个小流氓，经常欺负王五。李四呢？是个官老爷。他们三个排队，小流氓张三先来，官老爷李四第二个来，老实人王五最后来。结果，张三给李四让道，王五还是排在最后。在优先队列里，我们使用优先级（priority）来描述霸道程度。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> priorityQueue = <span class=\"keyword\">new</span> PriorityQueue();</span><br><span class=\"line\">priorityQueue.enqueue(<span class=\"string\">'张三'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">priorityQueue.enqueue(<span class=\"string\">'李四'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">priorityQueue.enqueue(<span class=\"string\">'王五'</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">expect(priorityQueue.toString()).toBe(<span class=\"string\">'李四-1,张三-2,王五-3'</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码中，名字后面的数字就是优先级。排队结果就如最后一个断言所示：<code>&#39;李四-1,张三-2,王五-3&#39;</code>。</p>\n<p>为了实现上述测试用例，我们需要改写 <code>enqueue</code> 方法和<code>toString</code>方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">PriorityQueue</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 利用构造器函数创建队列元素</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> QueueElement = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element, priority</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element = element;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.priority = priority;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.enqueue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element, priority</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> queueElement = <span class=\"keyword\">new</span> QueueElement(element, priority);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 张三的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      items.push(queueElement);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> added = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; items.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queueElement.priority &lt; items[i].priority) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 李四的情况</span></span><br><span class=\"line\">          items.splice(i, <span class=\"number\">0</span>, queueElement);</span><br><span class=\"line\">          added = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 王五的情况</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!added) &#123;</span><br><span class=\"line\">        items.push(queueElement);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> string = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; items.length; i++) &#123;</span><br><span class=\"line\">      string += items[i].element + <span class=\"string\">'-'</span> + items[i].priority + (items.length - i &gt; <span class=\"number\">1</span> ? <span class=\"string\">','</span> : <span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> string;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = PriorityQueue;</span><br></pre></td></tr></table></figure>\n<p>因为这三个人正好代表了所有的情况，所以只要将测试用例跑通，逻辑就写完了。为何会如此？其实我当时在写测试用例时，故意将代码覆盖率刷到100%。也就是说，测试用例涵盖了所有的情况。<code>toString</code> 方法则是则是多打印了一个优先级而已，其他方法与普通队列一样，不再赘述。</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是数据结构与算法中的队列。</p>","more":"<h2 id=\"队列简介\"><a href=\"#队列简介\" class=\"headerlink\" title=\"队列简介\"></a>队列简介</h2><p>队列是什么？队列是一种先进先出（FIFO）的数据结构。队列有什么用呢？队列通常用来描述算法或生活中的一些先进先出的场景，比如：</p>\n<ul>\n<li>在图的广度优先遍历中，我们需要使用队列来记录每个节点的相邻节点，以便可以在接下来最先访问它们，从而实现广度优先遍历。</li>\n<li>在 JavaScript 事件循环（Event Loop）中有一个事件队列（Task Queue），也是先进先出来处理各种异步事件。</li>\n<li>在生活中，队列可以映射排队打饭等先来后到的场景。</li>\n</ul>\n<p><img src=\"https://ws1.sinaimg.cn/mw690/83900b4ely1fcr48hfps7j20c40drglj\" alt=\"\"></p>\n<h2 id=\"用-JavaScript-编写队列类\"><a href=\"#用-JavaScript-编写队列类\" class=\"headerlink\" title=\"用 JavaScript 编写队列类\"></a>用 JavaScript 编写队列类</h2><p>和<a href=\"https://lewis617.github.io/2017/02/15/stack/\" target=\"_blank\" rel=\"noopener\">《JavaScript 版数据结构与算法（一）栈》</a>中编写栈类的方法类似，编写队列类也使用了构造器函数。</p>\n<p>编写一个队列类，可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> queue = <span class=\"keyword\">new</span> Queue();</span><br><span class=\"line\">expect(queue.isEmpty()).toBeTruthy();</span><br><span class=\"line\">queue.enqueue(<span class=\"string\">'张三'</span>);</span><br><span class=\"line\">queue.enqueue(<span class=\"string\">'李四'</span>);</span><br><span class=\"line\">queue.enqueue(<span class=\"string\">'王五'</span>);</span><br><span class=\"line\">expect(queue.front()).toBe(<span class=\"string\">'张三'</span>);</span><br><span class=\"line\">expect(queue.toString()).toBe(<span class=\"string\">'张三,李四,王五'</span>);</span><br><span class=\"line\">expect(queue.size()).toBe(<span class=\"number\">3</span>);</span><br><span class=\"line\">expect(queue.isEmpty()).toBeFalsy();</span><br><span class=\"line\">queue.dequeue();</span><br><span class=\"line\">queue.dequeue();</span><br><span class=\"line\">expect(queue.toString()).toBe(<span class=\"string\">'王五'</span>);</span><br></pre></td></tr></table></figure>\n<p>队列类比较简单，直接上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Queue</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量 items，用于记录数组</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">  <span class=\"comment\">// 入队</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.enqueue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">    items.push(element);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 出队</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.dequeue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.shift();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 查看队列的第一个元素</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.front = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 查看队列是否为空</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.isEmpty = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.length == <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 查看队列的长度</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.size = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.length;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 将数组转为字符串并返回</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.toString();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 导出队列类</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = Queue;</span><br></pre></td></tr></table></figure>\n<p>请注意数组增删的四个方法，别搞混淆了：</p>\n<ul>\n<li>push：在尾部添加新元素</li>\n<li>pop：删除并返回尾部元素</li>\n<li>unshift：在头部添加新元素</li>\n<li>shift：删除并返回头部元素</li>\n</ul>\n<p>所以，出队的方法用的是 shift。另外，如果考虑时间复杂度，使用数组创建队列并不是一个好方法，因为出队时，所有的元素都会移动位置，造成较差的性能。而使用链表则会更好，因为链表不是连续存储的，增删元素只需要改变相关的指向即可。</p>\n<h2 id=\"优先队列：加队就是这么任性\"><a href=\"#优先队列：加队就是这么任性\" class=\"headerlink\" title=\"优先队列：加队就是这么任性\"></a>优先队列：加队就是这么任性</h2><p>普通的队列类就是调用原生 Array 对象的方法，比较简单，但是还有一种队列叫优先队列。在优先队列里面，有些人比较霸道，可以加队。不过，如果遇到比他更霸道的人，他也得老实在后面排着。举个例子吧！假设有三个人：张三、李四、王五。王五是个没本事的老实人。张三是个小流氓，经常欺负王五。李四呢？是个官老爷。他们三个排队，小流氓张三先来，官老爷李四第二个来，老实人王五最后来。结果，张三给李四让道，王五还是排在最后。在优先队列里，我们使用优先级（priority）来描述霸道程度。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> priorityQueue = <span class=\"keyword\">new</span> PriorityQueue();</span><br><span class=\"line\">priorityQueue.enqueue(<span class=\"string\">'张三'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">priorityQueue.enqueue(<span class=\"string\">'李四'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">priorityQueue.enqueue(<span class=\"string\">'王五'</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">expect(priorityQueue.toString()).toBe(<span class=\"string\">'李四-1,张三-2,王五-3'</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码中，名字后面的数字就是优先级。排队结果就如最后一个断言所示：<code>&#39;李四-1,张三-2,王五-3&#39;</code>。</p>\n<p>为了实现上述测试用例，我们需要改写 <code>enqueue</code> 方法和<code>toString</code>方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">PriorityQueue</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 利用构造器函数创建队列元素</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> QueueElement = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element, priority</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element = element;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.priority = priority;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.enqueue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element, priority</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> queueElement = <span class=\"keyword\">new</span> QueueElement(element, priority);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 张三的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">      items.push(queueElement);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> added = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; items.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queueElement.priority &lt; items[i].priority) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 李四的情况</span></span><br><span class=\"line\">          items.splice(i, <span class=\"number\">0</span>, queueElement);</span><br><span class=\"line\">          added = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 王五的情况</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!added) &#123;</span><br><span class=\"line\">        items.push(queueElement);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> string = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; items.length; i++) &#123;</span><br><span class=\"line\">      string += items[i].element + <span class=\"string\">'-'</span> + items[i].priority + (items.length - i &gt; <span class=\"number\">1</span> ? <span class=\"string\">','</span> : <span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> string;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = PriorityQueue;</span><br></pre></td></tr></table></figure>\n<p>因为这三个人正好代表了所有的情况，所以只要将测试用例跑通，逻辑就写完了。为何会如此？其实我当时在写测试用例时，故意将代码覆盖率刷到100%。也就是说，测试用例涵盖了所有的情况。<code>toString</code> 方法则是则是多打印了一个优先级而已，其他方法与普通队列一样，不再赘述。</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>"},{"title":"React 与 Redux 教程（三）reduce()、filter()、map()、some()、every()、...展开属性","date":"2016-01-21T01:23:00.000Z","_content":"\nreduce()、filter()、map()、some()、every()、...展开属性这些概念属于es5、es6中的语法，跟React+Redux并没有什么联系，我们直接在<https://developer.mozilla.org/en-US/> 这里可以搜索到相关api文档。\n\n但是Redux的官方示例中包含了这些语法的用法，我们正好可以在程序中学习这些语法。这里全部默认使用es6的写法。\n\n<!--more-->\n\n## 例子\n\n这是官方的todomvc的例子（<https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/todomvc>）：\n\n![](/css/images/140.jpg)\n\n## reduce()\n\n遍历数组，在每一项元素后面触发一个回调函数，经过计算返回一个累加的值。\n\ncomponents/MainSection.js 62行\n\n```js \nconst completedCount = todos.reduce((count, todo) =>\n      todo.completed ? count + 1 : count,\n      0\n    )\n```\n\n`todos`是个数组，`reduce()`的第一个参数是个箭头语法，也就是个回调函数，这个回调函数的第一个参数是上一个返回值（但是这里被初始化为`0`）,第二个参数是当前元素的值。`reduce()`的第二个参数是个初始化值（不必需），初始化了上一个元素的值（这里是`count`）\n\n遍历数组`todos`的第一个值的时候，`count`为0，`todo`是`todos`的第一项，返回值加一或者不变。（**条件 ? 结果1 : 结果2三元运算）**\n\n遍历数组`todos`的第二个值的时候，`count`为上一个返回值，`todo`是`todos`的第二项，返回值加一或者不变。\n\n……\n\n遍历结束后，即可得到数组中，`completed`属性为`true`的个数，也就是已完成的任务的个数。\n\n## filter()\n\n遍历数组，在每一项元素后面触发一个回调函数，通过判断，保留或移除当前项，最后返回一个新数组。\n\n顾名思义就是过滤。\n\nreducers/todos.js 24行\n\n```js\nreturn state.filter(todo =>\n        todo.id !== action.id\n      )\n```\n\n`state`是个任务数组，`filter()`里面只有一个参数，就是个箭头函数，该函数只有一个参数是`todo`，也就是数组的每一项元素，箭头后面那个判断语句，如果返回`true`则保留当前项，反之移除当前项。\n\n有的同学会问，`todo.id !==action.id`前为什么没有`return`，这是箭头函数的语法，箭头两端就是输入输出，不用写`return`。如果用es5的写法就是：\n\n```js\nreturn state.filter(function(todo) {  \n　　return todo.id !== action.id  \n　　}  \n)\n```\n该代码段的作用是，过滤掉任务数组中，`id`与指定`id`相同的任务。返回一个新的任务数组。\n\n## map()\n\n遍历数组，在每一项元素后面触发一个回调函数，通过计算，返回一个新的当前项，最后返回一个新数组。\n\nreducers/todos.js 29行\n\n```js\nreturn state.map(todo =>\n        todo.id === action.id ?\n          Object.assign({}, todo, { text: action.text }) :\n          todo\n      )\n```\n\n箭头后面的值是个三元运算符，也就是`return`的新元素。如果`id`匹配，则通过`Object.assign()`合并一个新的属性，也就是给`todo`添加或者重写一个`text`属性，属性值为`action.text`。\n\n`Object.assign()`第一个参数是`target`，就是目标，第二个第三个以及后面的参数都是`source`，也就是拷贝的源，是不是很像jquery插件中的`extend`？\n\n这个代码的作用是给数组中指定的任务更新`text`属性。\n\n## some()、every()\n\n遍历数组，在每一项元素后面触发一个回调函数，通过判断，返回一个布尔值。`some()`是只要有一个满足判断，就返回`true`，`every()`是只要有一项不满足判断，就返回`false`。\n\ncomponents/MainSection.js  19 行\n\n```js\nconst atLeastOneCompleted = this.props.todos.some(todo => todo.completed)\n```\n遍历任务数组，有一个任务的属性`completed`为`true`，就返回`true`。\n\nreducers/todos.js 43行\n\n```js\nconst areAllMarked = state.every(todo => todo.completed)\n```\n遍历任务数组，每一项任务的`completed`属性均为`true`时候，返回`true`。\n\n## ...展开属性\n\nreducers/todos.js 20行\n\n```js\n    \n    \nreturn [\n        {\n          id: state.reduce((maxId, todo) => Math.max(todo.id, maxId), -1) + 1,\n          completed: false,\n          text: action.text\n        }, \n        ...state\n      ]\n```\n\n展开`state`数组的每一项到当前的数组\n\ncomponents/MainSection.js  72 行\n\n```jsx harmony\n<TodoItem key={todo.id} todo={todo} {...actions} />\n```\n\n展开`actions`的每一个属性到组件中，最后在props上可以获取到。\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n\n\n\n","source":"_posts/r2-array.md","raw":"---\ntitle: React 与 Redux 教程（三）reduce()、filter()、map()、some()、every()、...展开属性\ndate: 2016-01-21 09:23:00\ntags: [React, Redux]\n---\n\nreduce()、filter()、map()、some()、every()、...展开属性这些概念属于es5、es6中的语法，跟React+Redux并没有什么联系，我们直接在<https://developer.mozilla.org/en-US/> 这里可以搜索到相关api文档。\n\n但是Redux的官方示例中包含了这些语法的用法，我们正好可以在程序中学习这些语法。这里全部默认使用es6的写法。\n\n<!--more-->\n\n## 例子\n\n这是官方的todomvc的例子（<https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/todomvc>）：\n\n![](/css/images/140.jpg)\n\n## reduce()\n\n遍历数组，在每一项元素后面触发一个回调函数，经过计算返回一个累加的值。\n\ncomponents/MainSection.js 62行\n\n```js \nconst completedCount = todos.reduce((count, todo) =>\n      todo.completed ? count + 1 : count,\n      0\n    )\n```\n\n`todos`是个数组，`reduce()`的第一个参数是个箭头语法，也就是个回调函数，这个回调函数的第一个参数是上一个返回值（但是这里被初始化为`0`）,第二个参数是当前元素的值。`reduce()`的第二个参数是个初始化值（不必需），初始化了上一个元素的值（这里是`count`）\n\n遍历数组`todos`的第一个值的时候，`count`为0，`todo`是`todos`的第一项，返回值加一或者不变。（**条件 ? 结果1 : 结果2三元运算）**\n\n遍历数组`todos`的第二个值的时候，`count`为上一个返回值，`todo`是`todos`的第二项，返回值加一或者不变。\n\n……\n\n遍历结束后，即可得到数组中，`completed`属性为`true`的个数，也就是已完成的任务的个数。\n\n## filter()\n\n遍历数组，在每一项元素后面触发一个回调函数，通过判断，保留或移除当前项，最后返回一个新数组。\n\n顾名思义就是过滤。\n\nreducers/todos.js 24行\n\n```js\nreturn state.filter(todo =>\n        todo.id !== action.id\n      )\n```\n\n`state`是个任务数组，`filter()`里面只有一个参数，就是个箭头函数，该函数只有一个参数是`todo`，也就是数组的每一项元素，箭头后面那个判断语句，如果返回`true`则保留当前项，反之移除当前项。\n\n有的同学会问，`todo.id !==action.id`前为什么没有`return`，这是箭头函数的语法，箭头两端就是输入输出，不用写`return`。如果用es5的写法就是：\n\n```js\nreturn state.filter(function(todo) {  \n　　return todo.id !== action.id  \n　　}  \n)\n```\n该代码段的作用是，过滤掉任务数组中，`id`与指定`id`相同的任务。返回一个新的任务数组。\n\n## map()\n\n遍历数组，在每一项元素后面触发一个回调函数，通过计算，返回一个新的当前项，最后返回一个新数组。\n\nreducers/todos.js 29行\n\n```js\nreturn state.map(todo =>\n        todo.id === action.id ?\n          Object.assign({}, todo, { text: action.text }) :\n          todo\n      )\n```\n\n箭头后面的值是个三元运算符，也就是`return`的新元素。如果`id`匹配，则通过`Object.assign()`合并一个新的属性，也就是给`todo`添加或者重写一个`text`属性，属性值为`action.text`。\n\n`Object.assign()`第一个参数是`target`，就是目标，第二个第三个以及后面的参数都是`source`，也就是拷贝的源，是不是很像jquery插件中的`extend`？\n\n这个代码的作用是给数组中指定的任务更新`text`属性。\n\n## some()、every()\n\n遍历数组，在每一项元素后面触发一个回调函数，通过判断，返回一个布尔值。`some()`是只要有一个满足判断，就返回`true`，`every()`是只要有一项不满足判断，就返回`false`。\n\ncomponents/MainSection.js  19 行\n\n```js\nconst atLeastOneCompleted = this.props.todos.some(todo => todo.completed)\n```\n遍历任务数组，有一个任务的属性`completed`为`true`，就返回`true`。\n\nreducers/todos.js 43行\n\n```js\nconst areAllMarked = state.every(todo => todo.completed)\n```\n遍历任务数组，每一项任务的`completed`属性均为`true`时候，返回`true`。\n\n## ...展开属性\n\nreducers/todos.js 20行\n\n```js\n    \n    \nreturn [\n        {\n          id: state.reduce((maxId, todo) => Math.max(todo.id, maxId), -1) + 1,\n          completed: false,\n          text: action.text\n        }, \n        ...state\n      ]\n```\n\n展开`state`数组的每一项到当前的数组\n\ncomponents/MainSection.js  72 行\n\n```jsx harmony\n<TodoItem key={todo.id} todo={todo} {...actions} />\n```\n\n展开`actions`的每一个属性到组件中，最后在props上可以获取到。\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n\n\n\n","slug":"r2-array","published":1,"updated":"2019-05-01T08:10:30.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvm6002ctgytglfh2c6c","content":"<p>reduce()、filter()、map()、some()、every()、…展开属性这些概念属于es5、es6中的语法，跟React+Redux并没有什么联系，我们直接在<a href=\"https://developer.mozilla.org/en-US/\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/</a> 这里可以搜索到相关api文档。</p>\n<p>但是Redux的官方示例中包含了这些语法的用法，我们正好可以在程序中学习这些语法。这里全部默认使用es6的写法。</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>这是官方的todomvc的例子（<a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/todomvc\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/todomvc</a>）：</p>\n<p><img src=\"/css/images/140.jpg\" alt=\"\"></p>\n<h2 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce()\"></a>reduce()</h2><p>遍历数组，在每一项元素后面触发一个回调函数，经过计算返回一个累加的值。</p>\n<p>components/MainSection.js 62行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> completedCount = todos.reduce(<span class=\"function\">(<span class=\"params\">count, todo</span>) =&gt;</span></span><br><span class=\"line\">      todo.completed ? count + <span class=\"number\">1</span> : count,</span><br><span class=\"line\">      <span class=\"number\">0</span></span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n<p><code>todos</code>是个数组，<code>reduce()</code>的第一个参数是个箭头语法，也就是个回调函数，这个回调函数的第一个参数是上一个返回值（但是这里被初始化为<code>0</code>）,第二个参数是当前元素的值。<code>reduce()</code>的第二个参数是个初始化值（不必需），初始化了上一个元素的值（这里是<code>count</code>）</p>\n<p>遍历数组<code>todos</code>的第一个值的时候，<code>count</code>为0，<code>todo</code>是<code>todos</code>的第一项，返回值加一或者不变。（<strong>条件 ? 结果1 : 结果2三元运算）</strong></p>\n<p>遍历数组<code>todos</code>的第二个值的时候，<code>count</code>为上一个返回值，<code>todo</code>是<code>todos</code>的第二项，返回值加一或者不变。</p>\n<p>……</p>\n<p>遍历结束后，即可得到数组中，<code>completed</code>属性为<code>true</code>的个数，也就是已完成的任务的个数。</p>\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h2><p>遍历数组，在每一项元素后面触发一个回调函数，通过判断，保留或移除当前项，最后返回一个新数组。</p>\n<p>顾名思义就是过滤。</p>\n<p>reducers/todos.js 24行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> state.filter(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span></span><br><span class=\"line\">        todo.id !== action.id</span><br><span class=\"line\">      )</span><br></pre></td></tr></table></figure>\n<p><code>state</code>是个任务数组，<code>filter()</code>里面只有一个参数，就是个箭头函数，该函数只有一个参数是<code>todo</code>，也就是数组的每一项元素，箭头后面那个判断语句，如果返回<code>true</code>则保留当前项，反之移除当前项。</p>\n<p>有的同学会问，<code>todo.id !==action.id</code>前为什么没有<code>return</code>，这是箭头函数的语法，箭头两端就是输入输出，不用写<code>return</code>。如果用es5的写法就是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> state.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">todo</span>) </span>&#123;  </span><br><span class=\"line\">　　<span class=\"keyword\">return</span> todo.id !== action.id  </span><br><span class=\"line\">　　&#125;  </span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>该代码段的作用是，过滤掉任务数组中，<code>id</code>与指定<code>id</code>相同的任务。返回一个新的任务数组。</p>\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map()\"></a>map()</h2><p>遍历数组，在每一项元素后面触发一个回调函数，通过计算，返回一个新的当前项，最后返回一个新数组。</p>\n<p>reducers/todos.js 29行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> state.map(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span></span><br><span class=\"line\">        todo.id === action.id ?</span><br><span class=\"line\">          <span class=\"built_in\">Object</span>.assign(&#123;&#125;, todo, &#123; <span class=\"attr\">text</span>: action.text &#125;) :</span><br><span class=\"line\">          todo</span><br><span class=\"line\">      )</span><br></pre></td></tr></table></figure>\n<p>箭头后面的值是个三元运算符，也就是<code>return</code>的新元素。如果<code>id</code>匹配，则通过<code>Object.assign()</code>合并一个新的属性，也就是给<code>todo</code>添加或者重写一个<code>text</code>属性，属性值为<code>action.text</code>。</p>\n<p><code>Object.assign()</code>第一个参数是<code>target</code>，就是目标，第二个第三个以及后面的参数都是<code>source</code>，也就是拷贝的源，是不是很像jquery插件中的<code>extend</code>？</p>\n<p>这个代码的作用是给数组中指定的任务更新<code>text</code>属性。</p>\n<h2 id=\"some-、every\"><a href=\"#some-、every\" class=\"headerlink\" title=\"some()、every()\"></a>some()、every()</h2><p>遍历数组，在每一项元素后面触发一个回调函数，通过判断，返回一个布尔值。<code>some()</code>是只要有一个满足判断，就返回<code>true</code>，<code>every()</code>是只要有一项不满足判断，就返回<code>false</code>。</p>\n<p>components/MainSection.js  19 行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> atLeastOneCompleted = <span class=\"keyword\">this</span>.props.todos.some(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.completed)</span><br></pre></td></tr></table></figure>\n<p>遍历任务数组，有一个任务的属性<code>completed</code>为<code>true</code>，就返回<code>true</code>。</p>\n<p>reducers/todos.js 43行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> areAllMarked = state.every(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.completed)</span><br></pre></td></tr></table></figure>\n<p>遍历任务数组，每一项任务的<code>completed</code>属性均为<code>true</code>时候，返回<code>true</code>。</p>\n<h2 id=\"…展开属性\"><a href=\"#…展开属性\" class=\"headerlink\" title=\"…展开属性\"></a>…展开属性</h2><p>reducers/todos.js 20行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">return</span> [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          id: state.reduce(<span class=\"function\">(<span class=\"params\">maxId, todo</span>) =&gt;</span> <span class=\"built_in\">Math</span>.max(todo.id, maxId), <span class=\"number\">-1</span>) + <span class=\"number\">1</span>,</span><br><span class=\"line\">          completed: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          text: action.text</span><br><span class=\"line\">        &#125;, </span><br><span class=\"line\">        ...state</span><br><span class=\"line\">      ]</span><br></pre></td></tr></table></figure>\n<p>展开<code>state</code>数组的每一项到当前的数组</p>\n<p>components/MainSection.js  72 行</p>\n<figure class=\"highlight jsx\"><figcaption><span>harmony</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; &#123;...actions&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>展开<code>actions</code>的每一个属性到组件中，最后在props上可以获取到。</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>\n","site":{"data":{}},"excerpt":"<p>reduce()、filter()、map()、some()、every()、…展开属性这些概念属于es5、es6中的语法，跟React+Redux并没有什么联系，我们直接在<a href=\"https://developer.mozilla.org/en-US/\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/</a> 这里可以搜索到相关api文档。</p>\n<p>但是Redux的官方示例中包含了这些语法的用法，我们正好可以在程序中学习这些语法。这里全部默认使用es6的写法。</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>这是官方的todomvc的例子（<a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/todomvc\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/todomvc</a>）：</p>\n<p><img src=\"/css/images/140.jpg\" alt=\"\"></p>\n<h2 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce()\"></a>reduce()</h2><p>遍历数组，在每一项元素后面触发一个回调函数，经过计算返回一个累加的值。</p>\n<p>components/MainSection.js 62行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> completedCount = todos.reduce(<span class=\"function\">(<span class=\"params\">count, todo</span>) =&gt;</span></span><br><span class=\"line\">      todo.completed ? count + <span class=\"number\">1</span> : count,</span><br><span class=\"line\">      <span class=\"number\">0</span></span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n<p><code>todos</code>是个数组，<code>reduce()</code>的第一个参数是个箭头语法，也就是个回调函数，这个回调函数的第一个参数是上一个返回值（但是这里被初始化为<code>0</code>）,第二个参数是当前元素的值。<code>reduce()</code>的第二个参数是个初始化值（不必需），初始化了上一个元素的值（这里是<code>count</code>）</p>\n<p>遍历数组<code>todos</code>的第一个值的时候，<code>count</code>为0，<code>todo</code>是<code>todos</code>的第一项，返回值加一或者不变。（<strong>条件 ? 结果1 : 结果2三元运算）</strong></p>\n<p>遍历数组<code>todos</code>的第二个值的时候，<code>count</code>为上一个返回值，<code>todo</code>是<code>todos</code>的第二项，返回值加一或者不变。</p>\n<p>……</p>\n<p>遍历结束后，即可得到数组中，<code>completed</code>属性为<code>true</code>的个数，也就是已完成的任务的个数。</p>\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h2><p>遍历数组，在每一项元素后面触发一个回调函数，通过判断，保留或移除当前项，最后返回一个新数组。</p>\n<p>顾名思义就是过滤。</p>\n<p>reducers/todos.js 24行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> state.filter(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span></span><br><span class=\"line\">        todo.id !== action.id</span><br><span class=\"line\">      )</span><br></pre></td></tr></table></figure>\n<p><code>state</code>是个任务数组，<code>filter()</code>里面只有一个参数，就是个箭头函数，该函数只有一个参数是<code>todo</code>，也就是数组的每一项元素，箭头后面那个判断语句，如果返回<code>true</code>则保留当前项，反之移除当前项。</p>\n<p>有的同学会问，<code>todo.id !==action.id</code>前为什么没有<code>return</code>，这是箭头函数的语法，箭头两端就是输入输出，不用写<code>return</code>。如果用es5的写法就是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> state.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">todo</span>) </span>&#123;  </span><br><span class=\"line\">　　<span class=\"keyword\">return</span> todo.id !== action.id  </span><br><span class=\"line\">　　&#125;  </span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>该代码段的作用是，过滤掉任务数组中，<code>id</code>与指定<code>id</code>相同的任务。返回一个新的任务数组。</p>\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map()\"></a>map()</h2><p>遍历数组，在每一项元素后面触发一个回调函数，通过计算，返回一个新的当前项，最后返回一个新数组。</p>\n<p>reducers/todos.js 29行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> state.map(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span></span><br><span class=\"line\">        todo.id === action.id ?</span><br><span class=\"line\">          <span class=\"built_in\">Object</span>.assign(&#123;&#125;, todo, &#123; <span class=\"attr\">text</span>: action.text &#125;) :</span><br><span class=\"line\">          todo</span><br><span class=\"line\">      )</span><br></pre></td></tr></table></figure>\n<p>箭头后面的值是个三元运算符，也就是<code>return</code>的新元素。如果<code>id</code>匹配，则通过<code>Object.assign()</code>合并一个新的属性，也就是给<code>todo</code>添加或者重写一个<code>text</code>属性，属性值为<code>action.text</code>。</p>\n<p><code>Object.assign()</code>第一个参数是<code>target</code>，就是目标，第二个第三个以及后面的参数都是<code>source</code>，也就是拷贝的源，是不是很像jquery插件中的<code>extend</code>？</p>\n<p>这个代码的作用是给数组中指定的任务更新<code>text</code>属性。</p>\n<h2 id=\"some-、every\"><a href=\"#some-、every\" class=\"headerlink\" title=\"some()、every()\"></a>some()、every()</h2><p>遍历数组，在每一项元素后面触发一个回调函数，通过判断，返回一个布尔值。<code>some()</code>是只要有一个满足判断，就返回<code>true</code>，<code>every()</code>是只要有一项不满足判断，就返回<code>false</code>。</p>\n<p>components/MainSection.js  19 行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> atLeastOneCompleted = <span class=\"keyword\">this</span>.props.todos.some(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.completed)</span><br></pre></td></tr></table></figure>\n<p>遍历任务数组，有一个任务的属性<code>completed</code>为<code>true</code>，就返回<code>true</code>。</p>\n<p>reducers/todos.js 43行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> areAllMarked = state.every(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.completed)</span><br></pre></td></tr></table></figure>\n<p>遍历任务数组，每一项任务的<code>completed</code>属性均为<code>true</code>时候，返回<code>true</code>。</p>\n<h2 id=\"…展开属性\"><a href=\"#…展开属性\" class=\"headerlink\" title=\"…展开属性\"></a>…展开属性</h2><p>reducers/todos.js 20行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">return</span> [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          id: state.reduce(<span class=\"function\">(<span class=\"params\">maxId, todo</span>) =&gt;</span> <span class=\"built_in\">Math</span>.max(todo.id, maxId), <span class=\"number\">-1</span>) + <span class=\"number\">1</span>,</span><br><span class=\"line\">          completed: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          text: action.text</span><br><span class=\"line\">        &#125;, </span><br><span class=\"line\">        ...state</span><br><span class=\"line\">      ]</span><br></pre></td></tr></table></figure>\n<p>展开<code>state</code>数组的每一项到当前的数组</p>\n<p>components/MainSection.js  72 行</p>\n<figure class=\"highlight jsx\"><figcaption><span>harmony</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; &#123;...actions&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>展开<code>actions</code>的每一个属性到组件中，最后在props上可以获取到。</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>"},{"title":"Angular2 系列教程（二）模板语法","date":"2016-02-15T23:40:00.000Z","_content":"\n今天我们要讲的是ng2的模板语法，[官网](https://angular.io/docs/ts/latest/guide/template-syntax.html)写的很清楚，但我也用通俗易懂的讲法再罗列一下吧！\n\n<!--more-->\n\n## 例子\n\n![](/css/images/84.jpg)\n\n[源代码](https://github.com/lewis617/angular2-tutorial/tree/gh-pages/template-syntax)\n\n## 属性绑定\n\n不需要特别的指令，只需要用`[value]`就可以了，并不只有`value`，`[]`里面可以是任何常用的html元素的属性！\n\napp/app.html\n\n```html\n<input [value]=\"firstName\" [placeholder]=\"firstNamePlaceholder\" />\n```\n\n也可以用双花括号：\n\napp/app.html\n\n```html\n<input value=\"{{firstName}}\" placeholder=\"{{firstNamePlaceholder}}\" />\n```\n绑定的属性从何而来？从我们定义的类中：\n\napp/app.ts\n\n```ts\nfirstName: string = 'lewis';\n```\n\n## 事件\n\n你可以在ng2中监听任何html5原生的元素事件，只需要使用这个语法： `(eventName)`\n\napp/app.html\n\n```html\n<button (click)=\"doSomething($event)\" >点击</button>\n```\n\n`doSomething`从何而来？跟属性`firstName`一样，在类中定义：\n\napp/app.ts\n\n```ts\ndoSomething($event){\n    console.log('点击了这个按钮：',$event.target);\n}\n```\n\n## 双向数据绑定\n\n刚才讲的是单向数据绑定，不信你可以改变input的值看看，别的绑定会不会变动。答案是不会！这次我们来做双向数据绑定：\n\napp/app.html\n\n```html\n<input type=\"text\" [value]=\"firstName (input)=\"firstName=$event.target.value\" />\n<input type=\"text\" [(ngModel)]=\"firstName\" />\n```\n\n使用单向绑定加事件绑定可以，使用`[(ngModel)]`也可以！这样你再改变`input`的值，所有绑定`firstName`的值都会跟着变化！\n\nng2的双向数据绑定没有用\"脏检查\"，而是用了zone.js。这是个什么库呢？\n\n> A zone is an execution context that persists across async tasks.\n\n用来维持切换上下文的库。用来替代`$apply()`的一个库。告诉你何时更新视图！\n\n## 局部变量\n\n局部变量 `#` 是一个对象或者dom元素的指针，什么意思？看代码：\n\napp/app.html\n\n```html\n<!-- phone refers to the input element; pass its `value` to an event handler -->\n<input #phone placeholder=\"phone number\">\n<button (click)=\"callPhone(phone.value)\">Call</button>\n\n<!-- fax refers to the input element; pass its `value` to an event handler -->\n<input var-fax placeholder=\"fax number\">\n<button (click)=\"callFax(fax.value)\">Fax</button>\n```\n一切尽在不言中！\n\n## *语法与template标签\n\n先看一个*语法与template标签的应用：\n\n```html\n<p *ngIf=\"isActive\">我是段落</p>\n```\n相当于\n\n```html    \n<template [ngIf]=\"isActive\"><p>我是段落</p></template>\n```\n这段代码的意思是，如果`isActive`为`true`则渲染`p`元素。\n\n`template`标签声明了一段 DOM ，这段DOM在runtime后会被实例化。\n\n使用`template`我们可以将一段DOM包裹起来，声明它，然后决定要不要渲染他们。不渲染的话，里面的元素就不会加载，可以节省运算。如果你用`div`和隐藏效果的话，里面的元素还得加载，浪费了运算。\n\n我们也使用`*`语法替代`template`标签。起到同样的作用。\n\n用`*`装饰的自带指令还有：`NgFor`, `NgIf`和`NgSwitch`。都是控制是否渲染的指令。我们用`*`来装饰后，就可以产生类似`template`的效果！\n\n## 更多语法\n\n以上只是介绍了常用的语法，还有更多的语法参考可以直接去[官网](https://angular.io/docs/ts/latest/guide/template-syntax.html)\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n","source":"_posts/ng2-temlate.md","raw":"---\ntitle: Angular2 系列教程（二）模板语法\ndate: 2016-02-16 07:40:00\ntags: [Angular2]\n---\n\n今天我们要讲的是ng2的模板语法，[官网](https://angular.io/docs/ts/latest/guide/template-syntax.html)写的很清楚，但我也用通俗易懂的讲法再罗列一下吧！\n\n<!--more-->\n\n## 例子\n\n![](/css/images/84.jpg)\n\n[源代码](https://github.com/lewis617/angular2-tutorial/tree/gh-pages/template-syntax)\n\n## 属性绑定\n\n不需要特别的指令，只需要用`[value]`就可以了，并不只有`value`，`[]`里面可以是任何常用的html元素的属性！\n\napp/app.html\n\n```html\n<input [value]=\"firstName\" [placeholder]=\"firstNamePlaceholder\" />\n```\n\n也可以用双花括号：\n\napp/app.html\n\n```html\n<input value=\"{{firstName}}\" placeholder=\"{{firstNamePlaceholder}}\" />\n```\n绑定的属性从何而来？从我们定义的类中：\n\napp/app.ts\n\n```ts\nfirstName: string = 'lewis';\n```\n\n## 事件\n\n你可以在ng2中监听任何html5原生的元素事件，只需要使用这个语法： `(eventName)`\n\napp/app.html\n\n```html\n<button (click)=\"doSomething($event)\" >点击</button>\n```\n\n`doSomething`从何而来？跟属性`firstName`一样，在类中定义：\n\napp/app.ts\n\n```ts\ndoSomething($event){\n    console.log('点击了这个按钮：',$event.target);\n}\n```\n\n## 双向数据绑定\n\n刚才讲的是单向数据绑定，不信你可以改变input的值看看，别的绑定会不会变动。答案是不会！这次我们来做双向数据绑定：\n\napp/app.html\n\n```html\n<input type=\"text\" [value]=\"firstName (input)=\"firstName=$event.target.value\" />\n<input type=\"text\" [(ngModel)]=\"firstName\" />\n```\n\n使用单向绑定加事件绑定可以，使用`[(ngModel)]`也可以！这样你再改变`input`的值，所有绑定`firstName`的值都会跟着变化！\n\nng2的双向数据绑定没有用\"脏检查\"，而是用了zone.js。这是个什么库呢？\n\n> A zone is an execution context that persists across async tasks.\n\n用来维持切换上下文的库。用来替代`$apply()`的一个库。告诉你何时更新视图！\n\n## 局部变量\n\n局部变量 `#` 是一个对象或者dom元素的指针，什么意思？看代码：\n\napp/app.html\n\n```html\n<!-- phone refers to the input element; pass its `value` to an event handler -->\n<input #phone placeholder=\"phone number\">\n<button (click)=\"callPhone(phone.value)\">Call</button>\n\n<!-- fax refers to the input element; pass its `value` to an event handler -->\n<input var-fax placeholder=\"fax number\">\n<button (click)=\"callFax(fax.value)\">Fax</button>\n```\n一切尽在不言中！\n\n## *语法与template标签\n\n先看一个*语法与template标签的应用：\n\n```html\n<p *ngIf=\"isActive\">我是段落</p>\n```\n相当于\n\n```html    \n<template [ngIf]=\"isActive\"><p>我是段落</p></template>\n```\n这段代码的意思是，如果`isActive`为`true`则渲染`p`元素。\n\n`template`标签声明了一段 DOM ，这段DOM在runtime后会被实例化。\n\n使用`template`我们可以将一段DOM包裹起来，声明它，然后决定要不要渲染他们。不渲染的话，里面的元素就不会加载，可以节省运算。如果你用`div`和隐藏效果的话，里面的元素还得加载，浪费了运算。\n\n我们也使用`*`语法替代`template`标签。起到同样的作用。\n\n用`*`装饰的自带指令还有：`NgFor`, `NgIf`和`NgSwitch`。都是控制是否渲染的指令。我们用`*`来装饰后，就可以产生类似`template`的效果！\n\n## 更多语法\n\n以上只是介绍了常用的语法，还有更多的语法参考可以直接去[官网](https://angular.io/docs/ts/latest/guide/template-syntax.html)\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n","slug":"ng2-temlate","published":1,"updated":"2019-05-01T08:10:29.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvm7002etgytzw7l2am1","content":"<p>今天我们要讲的是ng2的模板语法，<a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html\" target=\"_blank\" rel=\"noopener\">官网</a>写的很清楚，但我也用通俗易懂的讲法再罗列一下吧！</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/84.jpg\" alt=\"\"></p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/template-syntax\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<h2 id=\"属性绑定\"><a href=\"#属性绑定\" class=\"headerlink\" title=\"属性绑定\"></a>属性绑定</h2><p>不需要特别的指令，只需要用<code>[value]</code>就可以了，并不只有<code>value</code>，<code>[]</code>里面可以是任何常用的html元素的属性！</p>\n<p>app/app.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> [<span class=\"attr\">value</span>]=<span class=\"string\">\"firstName\"</span> [<span class=\"attr\">placeholder</span>]=<span class=\"string\">\"firstNamePlaceholder\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>也可以用双花括号：</p>\n<p>app/app.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">\"&#123;&#123;firstName&#125;&#125;\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"&#123;&#123;firstNamePlaceholder&#125;&#125;\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>绑定的属性从何而来？从我们定义的类中：</p>\n<p>app/app.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firstName: <span class=\"built_in\">string</span> = <span class=\"string\">'lewis'</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><p>你可以在ng2中监听任何html5原生的元素事件，只需要使用这个语法： <code>(eventName)</code></p>\n<p>app/app.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"doSomething($event)\"</span> &gt;</span>点击<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>doSomething</code>从何而来？跟属性<code>firstName</code>一样，在类中定义：</p>\n<p>app/app.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething($event)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'点击了这个按钮：'</span>,$event.target);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"双向数据绑定\"><a href=\"#双向数据绑定\" class=\"headerlink\" title=\"双向数据绑定\"></a>双向数据绑定</h2><p>刚才讲的是单向数据绑定，不信你可以改变input的值看看，别的绑定会不会变动。答案是不会！这次我们来做双向数据绑定：</p>\n<p>app/app.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> [<span class=\"attr\">value</span>]=<span class=\"string\">\"firstName (input)=\"</span><span class=\"attr\">firstName</span>=<span class=\"string\">$event.target.value</span>\" /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"firstName\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>使用单向绑定加事件绑定可以，使用<code>[(ngModel)]</code>也可以！这样你再改变<code>input</code>的值，所有绑定<code>firstName</code>的值都会跟着变化！</p>\n<p>ng2的双向数据绑定没有用”脏检查”，而是用了zone.js。这是个什么库呢？</p>\n<blockquote>\n<p>A zone is an execution context that persists across async tasks.</p>\n</blockquote>\n<p>用来维持切换上下文的库。用来替代<code>$apply()</code>的一个库。告诉你何时更新视图！</p>\n<h2 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h2><p>局部变量 <code>#</code> 是一个对象或者dom元素的指针，什么意思？看代码：</p>\n<p>app/app.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- phone refers to the input element; pass its `value` to an event handler --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">phone</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"phone number\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"callPhone(phone.value)\"</span>&gt;</span>Call<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- fax refers to the input element; pass its `value` to an event handler --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">var-fax</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"fax number\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"callFax(fax.value)\"</span>&gt;</span>Fax<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>一切尽在不言中！</p>\n<h2 id=\"语法与template标签\"><a href=\"#语法与template标签\" class=\"headerlink\" title=\"*语法与template标签\"></a>*语法与template标签</h2><p>先看一个*语法与template标签的应用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"isActive\"</span>&gt;</span>我是段落<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>相当于</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> [<span class=\"attr\">ngIf</span>]=<span class=\"string\">\"isActive\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>我是段落<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这段代码的意思是，如果<code>isActive</code>为<code>true</code>则渲染<code>p</code>元素。</p>\n<p><code>template</code>标签声明了一段 DOM ，这段DOM在runtime后会被实例化。</p>\n<p>使用<code>template</code>我们可以将一段DOM包裹起来，声明它，然后决定要不要渲染他们。不渲染的话，里面的元素就不会加载，可以节省运算。如果你用<code>div</code>和隐藏效果的话，里面的元素还得加载，浪费了运算。</p>\n<p>我们也使用<code>*</code>语法替代<code>template</code>标签。起到同样的作用。</p>\n<p>用<code>*</code>装饰的自带指令还有：<code>NgFor</code>, <code>NgIf</code>和<code>NgSwitch</code>。都是控制是否渲染的指令。我们用<code>*</code>来装饰后，就可以产生类似<code>template</code>的效果！</p>\n<h2 id=\"更多语法\"><a href=\"#更多语法\" class=\"headerlink\" title=\"更多语法\"></a>更多语法</h2><p>以上只是介绍了常用的语法，还有更多的语法参考可以直接去<a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天我们要讲的是ng2的模板语法，<a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html\" target=\"_blank\" rel=\"noopener\">官网</a>写的很清楚，但我也用通俗易懂的讲法再罗列一下吧！</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/84.jpg\" alt=\"\"></p>\n<p><a href=\"https://github.com/lewis617/angular2-tutorial/tree/gh-pages/template-syntax\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<h2 id=\"属性绑定\"><a href=\"#属性绑定\" class=\"headerlink\" title=\"属性绑定\"></a>属性绑定</h2><p>不需要特别的指令，只需要用<code>[value]</code>就可以了，并不只有<code>value</code>，<code>[]</code>里面可以是任何常用的html元素的属性！</p>\n<p>app/app.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> [<span class=\"attr\">value</span>]=<span class=\"string\">\"firstName\"</span> [<span class=\"attr\">placeholder</span>]=<span class=\"string\">\"firstNamePlaceholder\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>也可以用双花括号：</p>\n<p>app/app.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">\"&#123;&#123;firstName&#125;&#125;\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"&#123;&#123;firstNamePlaceholder&#125;&#125;\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>绑定的属性从何而来？从我们定义的类中：</p>\n<p>app/app.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firstName: <span class=\"built_in\">string</span> = <span class=\"string\">'lewis'</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><p>你可以在ng2中监听任何html5原生的元素事件，只需要使用这个语法： <code>(eventName)</code></p>\n<p>app/app.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"doSomething($event)\"</span> &gt;</span>点击<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>doSomething</code>从何而来？跟属性<code>firstName</code>一样，在类中定义：</p>\n<p>app/app.ts</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething($event)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'点击了这个按钮：'</span>,$event.target);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"双向数据绑定\"><a href=\"#双向数据绑定\" class=\"headerlink\" title=\"双向数据绑定\"></a>双向数据绑定</h2><p>刚才讲的是单向数据绑定，不信你可以改变input的值看看，别的绑定会不会变动。答案是不会！这次我们来做双向数据绑定：</p>\n<p>app/app.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> [<span class=\"attr\">value</span>]=<span class=\"string\">\"firstName (input)=\"</span><span class=\"attr\">firstName</span>=<span class=\"string\">$event.target.value</span>\" /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"firstName\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>使用单向绑定加事件绑定可以，使用<code>[(ngModel)]</code>也可以！这样你再改变<code>input</code>的值，所有绑定<code>firstName</code>的值都会跟着变化！</p>\n<p>ng2的双向数据绑定没有用”脏检查”，而是用了zone.js。这是个什么库呢？</p>\n<blockquote>\n<p>A zone is an execution context that persists across async tasks.</p>\n</blockquote>\n<p>用来维持切换上下文的库。用来替代<code>$apply()</code>的一个库。告诉你何时更新视图！</p>\n<h2 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h2><p>局部变量 <code>#</code> 是一个对象或者dom元素的指针，什么意思？看代码：</p>\n<p>app/app.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- phone refers to the input element; pass its `value` to an event handler --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">phone</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"phone number\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"callPhone(phone.value)\"</span>&gt;</span>Call<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- fax refers to the input element; pass its `value` to an event handler --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">var-fax</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"fax number\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"callFax(fax.value)\"</span>&gt;</span>Fax<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>一切尽在不言中！</p>\n<h2 id=\"语法与template标签\"><a href=\"#语法与template标签\" class=\"headerlink\" title=\"*语法与template标签\"></a>*语法与template标签</h2><p>先看一个*语法与template标签的应用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"isActive\"</span>&gt;</span>我是段落<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>相当于</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> [<span class=\"attr\">ngIf</span>]=<span class=\"string\">\"isActive\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>我是段落<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这段代码的意思是，如果<code>isActive</code>为<code>true</code>则渲染<code>p</code>元素。</p>\n<p><code>template</code>标签声明了一段 DOM ，这段DOM在runtime后会被实例化。</p>\n<p>使用<code>template</code>我们可以将一段DOM包裹起来，声明它，然后决定要不要渲染他们。不渲染的话，里面的元素就不会加载，可以节省运算。如果你用<code>div</code>和隐藏效果的话，里面的元素还得加载，浪费了运算。</p>\n<p>我们也使用<code>*</code>语法替代<code>template</code>标签。起到同样的作用。</p>\n<p>用<code>*</code>装饰的自带指令还有：<code>NgFor</code>, <code>NgIf</code>和<code>NgSwitch</code>。都是控制是否渲染的指令。我们用<code>*</code>来装饰后，就可以产生类似<code>template</code>的效果！</p>\n<h2 id=\"更多语法\"><a href=\"#更多语法\" class=\"headerlink\" title=\"更多语法\"></a>更多语法</h2><p>以上只是介绍了常用的语法，还有更多的语法参考可以直接去<a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>"},{"title":"React 与 Redux 教程（五）异步、单一state树结构、componentWillReceiveProps","date":"2016-01-29T20:18:00.000Z","_content":"\n今天，我们要讲解的是异步、单一state树结构、componentWillReceiveProps这三个知识点。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/141.gif)\n\n这个例子是官方的例子，主要是从Reddit中请求新闻列表来显示，可以切换react和frontend关键词来切换新闻列表，可以刷新当前新闻列表。\n\n源代码：\n\nhttps://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async\n\n## 异步\n\n异步本身 这个概念，本文不详细叙述，但可以简单说一下，Javascript是通过自身的\"事件循环（event loop）\"机制来实现异步的，将耗时的IO等操作跳过，当事件完成后再发个信号过来执行回调。这使得单线程的js变的非常高效，这也是为什么\nNodejs在多并发场景下特别牛逼的原因。\n\nRedux只能实现同步操作，但是可以通过thunk中间件实现异步。thunk的作用看[React 与 Redux 教程（一）connect、applyMiddleware、thunk、webpackHotMiddleware](https://lewis617.github.io/2016/01/19/r2-counter/)\n\n**_主要的异步操作（ajax请求）均在action中进行。_**\n\n本例子的异步操作在`fetchPosts`中，就是使用`fetch`这个方法，进行ajax请求，然后使用promise进行完成后的回调操作。看代码：\n\nactions/index.js\n\n```js\nimport fetch from 'isomorphic-fetch'\n\nexport const REQUEST_POSTS = 'REQUEST_POSTS'\nexport const RECEIVE_POSTS = 'RECEIVE_POSTS'\nexport const SELECT_REDDIT = 'SELECT_REDDIT'\nexport const INVALIDATE_REDDIT = 'INVALIDATE_REDDIT'\n//选择新闻类型action\nexport function selectReddit(reddit) {\n  return {\n    type: SELECT_REDDIT,\n    reddit\n  }\n}\n//废弃新闻类型action\nexport function invalidateReddit(reddit) {\n  return {\n    type: INVALIDATE_REDDIT,\n    reddit\n  }\n}\n//开始获取新闻action\nfunction requestPosts(reddit) {\n  return {\n    type: REQUEST_POSTS,\n    reddit\n  }\n}\n//获取新闻成功的action\nfunction receivePosts(reddit, json) {\n  return {\n    type: RECEIVE_POSTS,\n    reddit: reddit,\n    posts: json.data.children.map(child => child.data),\n    receivedAt: Date.now()\n  }\n}\n\n//获取文章，先触发requestPosts开始获取action，完成后触发receivePosts获取成功的action\nfunction fetchPosts(reddit) {\n  return dispatch => {\n    dispatch(requestPosts(reddit))\n    return fetch(`https://www.reddit.com/r/${reddit}.json`)\n      .then(response => response.json())\n      .then(json => dispatch(receivePosts(reddit, json)))\n  }\n}\n\n//是否需要获取文章\nfunction shouldFetchPosts(state, reddit) {\n  const posts = state.postsByReddit[reddit]\n  if (!posts) {\n    return true\n  }\n  if (posts.isFetching) {\n    return false\n  }\n  return posts.didInvalidate\n}\n\n//如果需要则开始获取文章\nexport function fetchPostsIfNeeded(reddit) {\n  return (dispatch, getState) => {\n    if (shouldFetchPosts(getState(), reddit)) {\n      return dispatch(fetchPosts(reddit))\n    }\n  }\n}\n```\n异步这个概念比较简单，不再赘述了。\n\n## 单一state树结构\n\n单一state树结构是Redux的最大特点。我们今天主要讲解state的树结构长什么样？首先，我们可以通过React的chrome插件，来看下这个state树：\n\n![](/css/images/142.jpg)\n\n我们点击Connect(App)，可以查看整个程序的state树，但是这棵树是从storeState开始的。我们在第一课中讲到，只能通过Redux的devtools来查看全局单一state，其实是片面的，通过React的chrome插件同样可以看到这棵树。\n\n那么这棵树为什么长这个样子，我们是如何构建这棵树的呢？答案都在reducer里面：\n\nreducers/index.js\n\n```js\nimport { combineReducers } from 'redux'\nimport {\n  SELECT_REDDIT, INVALIDATE_REDDIT,\n  REQUEST_POSTS, RECEIVE_POSTS\n} from '../actions'\n\n//选择新闻后，将state.selectedReddit设为所选选项\nfunction selectedReddit(state = 'reactjs', action) {\n  switch (action.type) {\n    case SELECT_REDDIT:\n      return action.reddit\n    default:\n      return state\n  }\n}\n\nfunction posts(state = {\n  //是否正在获取最新\n  isFetching: false,\n  //是否废弃\n  didInvalidate: false,\n  //内容\n  items: []\n}, action) {\n  switch (action.type) {\n    case INVALIDATE_REDDIT:\n      return Object.assign({}, state, {\n        didInvalidate: true\n      })\n    case REQUEST_POSTS:\n      return Object.assign({}, state, {\n        isFetching: true,\n        didInvalidate: false\n      })\n    case RECEIVE_POSTS:\n      return Object.assign({}, state, {\n        isFetching: false,\n        didInvalidate: false,\n        items: action.posts,\n        lastUpdated: action.receivedAt\n      })\n    default:\n      return state\n  }\n}\n//废弃、接收到、开始接受新闻后，将state.postsByReddit设为相关参数\nfunction postsByReddit(state = { }, action) {\n  switch (action.type) {\n    case INVALIDATE_REDDIT:\n    case RECEIVE_POSTS:\n    case REQUEST_POSTS:\n      return Object.assign({}, state, {\n        [action.reddit]: posts(state[action.reddit], action)\n      })\n    default:\n      return state\n  }\n}\n//将两个reducer合并成一个reducer,也就将全局的state加上postsByReddit,selectedReddit两个属性，每个属性都有自己的state\nconst rootReducer = combineReducers({\n  postsByReddit,\n  selectedReddit\n})\n\nexport default rootReducer\n```\n\n我们写了两个reducer，`postsByReddit`, `selectedReddit`，最后把它们合并起来。所以我们的全局单一state树的第一级节点是`postsByReddit`, `selectedReddit`。\n\n`postsByReddit`节点下面就是`postsByReddit`返回的`state`，也就是`[action.reddit]:posts(state[action.reddit], action)`。`posts()`就是`{ isFetching:false,didInvalidate: false, items: [] }`\n\n现在明白了全局单一state树是如何构建了的吧？----通过reducer。\n\n## componentWillReceiveProps\n\n这是React组件生命周期里面的一个时间节点的回调函数。通常在组件接收新的props时触发。我们在componentDidMount()和componentWillReceiveProps()这两个回调里面加上console.log，来追踪这两个事件的触发：\n\ncontainers/App.js（部分代码）\n\n```js\n//初始化渲染后触发\ncomponentDidMount() {\n  console.log('执行componentDidMount');\n  const { dispatch, selectedReddit } = this.props\n  dispatch(fetchPostsIfNeeded(selectedReddit))\n}\n\n//每次接受新的props触发\ncomponentWillReceiveProps(nextProps) {\n  console.log('执行componentWillReceiveProps',nextProps);\n  if (nextProps.selectedReddit !== this.props.selectedReddit) {\n    const { dispatch, selectedReddit } = nextProps\n    dispatch(fetchPostsIfNeeded(selectedReddit))\n  }\n}\n```\n\n然后我们打开浏览器，执行下面的用户操作，查看console里面的打印信息：\n\n1，刷新页面：\n\n![](/css/images/143.jpg)\n\n首先，执行了`componentDidMount`，也就是渲染了组件。然后执行`request_post`的action，这个action改变了state，state和props就是部分绑定关系，所以触发了`componentWillReceiveProps`。\n\n然后那个`[HMR]`是热替换的意思，这里不详细叙述。\n\n接下来又执行了`componentWillReceiveProps`，为什么呢？因为获取新闻数据成功了，state改变了，被绑定的props也变了，所以执行了`componentWillReceiveProps`。我们可以看到posts里面已经有值了，这时触发了`receive_posts`的action。\n\n\n\n2，切换新闻类型\n\n![](/css/images/145.jpg)\n\n\n\n切换下拉框，触发了`select_reddit`的action，改变了state，改变了被绑定的props，所以触发了`componentWillReceiveProps`\n\n`componentWillReceiveProps`的回调又触发了`request_posts`的action，自己看代码。这个action改变了state,改变了被绑定的props，所以又触发了`componentWillReceiveProps`。\n\n获取新闻数据成功后，又改变了state,改变了被绑定的props，又触发了`componentWillReceiveProps`，也触发了`receive_posts`这个action。\n\n3，点击刷新按钮\n\n![](https://ws4.sinaimg.cn/mw690/83900b4egw1f9xsvkukugj20qr089wis.jpg)\n\n\n\n首先，触发了`invalidate_reddit`废弃新闻的action，然后触发了`request_posts`的action，state的`isFetching`被改变了，所以触发了一次`componentWillReceiveProps`\n\n接受完成，又触发一次`componentWillReceiveProps`。\n\n\n\n由此可见，`componentWillReceiveProps`在Redux+React的程序中，是个非常常用的概念，甚至可以说，只要能监听每次的`componentWillReceiveProps`，就可以清楚的了解React和Redux的交互过程。\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n","source":"_posts/r2-async.md","raw":"---\ntitle: React 与 Redux 教程（五）异步、单一state树结构、componentWillReceiveProps\ndate: 2016-01-30 04:18:00\ntags: [React, Redux]\n---\n\n今天，我们要讲解的是异步、单一state树结构、componentWillReceiveProps这三个知识点。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/141.gif)\n\n这个例子是官方的例子，主要是从Reddit中请求新闻列表来显示，可以切换react和frontend关键词来切换新闻列表，可以刷新当前新闻列表。\n\n源代码：\n\nhttps://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async\n\n## 异步\n\n异步本身 这个概念，本文不详细叙述，但可以简单说一下，Javascript是通过自身的\"事件循环（event loop）\"机制来实现异步的，将耗时的IO等操作跳过，当事件完成后再发个信号过来执行回调。这使得单线程的js变的非常高效，这也是为什么\nNodejs在多并发场景下特别牛逼的原因。\n\nRedux只能实现同步操作，但是可以通过thunk中间件实现异步。thunk的作用看[React 与 Redux 教程（一）connect、applyMiddleware、thunk、webpackHotMiddleware](https://lewis617.github.io/2016/01/19/r2-counter/)\n\n**_主要的异步操作（ajax请求）均在action中进行。_**\n\n本例子的异步操作在`fetchPosts`中，就是使用`fetch`这个方法，进行ajax请求，然后使用promise进行完成后的回调操作。看代码：\n\nactions/index.js\n\n```js\nimport fetch from 'isomorphic-fetch'\n\nexport const REQUEST_POSTS = 'REQUEST_POSTS'\nexport const RECEIVE_POSTS = 'RECEIVE_POSTS'\nexport const SELECT_REDDIT = 'SELECT_REDDIT'\nexport const INVALIDATE_REDDIT = 'INVALIDATE_REDDIT'\n//选择新闻类型action\nexport function selectReddit(reddit) {\n  return {\n    type: SELECT_REDDIT,\n    reddit\n  }\n}\n//废弃新闻类型action\nexport function invalidateReddit(reddit) {\n  return {\n    type: INVALIDATE_REDDIT,\n    reddit\n  }\n}\n//开始获取新闻action\nfunction requestPosts(reddit) {\n  return {\n    type: REQUEST_POSTS,\n    reddit\n  }\n}\n//获取新闻成功的action\nfunction receivePosts(reddit, json) {\n  return {\n    type: RECEIVE_POSTS,\n    reddit: reddit,\n    posts: json.data.children.map(child => child.data),\n    receivedAt: Date.now()\n  }\n}\n\n//获取文章，先触发requestPosts开始获取action，完成后触发receivePosts获取成功的action\nfunction fetchPosts(reddit) {\n  return dispatch => {\n    dispatch(requestPosts(reddit))\n    return fetch(`https://www.reddit.com/r/${reddit}.json`)\n      .then(response => response.json())\n      .then(json => dispatch(receivePosts(reddit, json)))\n  }\n}\n\n//是否需要获取文章\nfunction shouldFetchPosts(state, reddit) {\n  const posts = state.postsByReddit[reddit]\n  if (!posts) {\n    return true\n  }\n  if (posts.isFetching) {\n    return false\n  }\n  return posts.didInvalidate\n}\n\n//如果需要则开始获取文章\nexport function fetchPostsIfNeeded(reddit) {\n  return (dispatch, getState) => {\n    if (shouldFetchPosts(getState(), reddit)) {\n      return dispatch(fetchPosts(reddit))\n    }\n  }\n}\n```\n异步这个概念比较简单，不再赘述了。\n\n## 单一state树结构\n\n单一state树结构是Redux的最大特点。我们今天主要讲解state的树结构长什么样？首先，我们可以通过React的chrome插件，来看下这个state树：\n\n![](/css/images/142.jpg)\n\n我们点击Connect(App)，可以查看整个程序的state树，但是这棵树是从storeState开始的。我们在第一课中讲到，只能通过Redux的devtools来查看全局单一state，其实是片面的，通过React的chrome插件同样可以看到这棵树。\n\n那么这棵树为什么长这个样子，我们是如何构建这棵树的呢？答案都在reducer里面：\n\nreducers/index.js\n\n```js\nimport { combineReducers } from 'redux'\nimport {\n  SELECT_REDDIT, INVALIDATE_REDDIT,\n  REQUEST_POSTS, RECEIVE_POSTS\n} from '../actions'\n\n//选择新闻后，将state.selectedReddit设为所选选项\nfunction selectedReddit(state = 'reactjs', action) {\n  switch (action.type) {\n    case SELECT_REDDIT:\n      return action.reddit\n    default:\n      return state\n  }\n}\n\nfunction posts(state = {\n  //是否正在获取最新\n  isFetching: false,\n  //是否废弃\n  didInvalidate: false,\n  //内容\n  items: []\n}, action) {\n  switch (action.type) {\n    case INVALIDATE_REDDIT:\n      return Object.assign({}, state, {\n        didInvalidate: true\n      })\n    case REQUEST_POSTS:\n      return Object.assign({}, state, {\n        isFetching: true,\n        didInvalidate: false\n      })\n    case RECEIVE_POSTS:\n      return Object.assign({}, state, {\n        isFetching: false,\n        didInvalidate: false,\n        items: action.posts,\n        lastUpdated: action.receivedAt\n      })\n    default:\n      return state\n  }\n}\n//废弃、接收到、开始接受新闻后，将state.postsByReddit设为相关参数\nfunction postsByReddit(state = { }, action) {\n  switch (action.type) {\n    case INVALIDATE_REDDIT:\n    case RECEIVE_POSTS:\n    case REQUEST_POSTS:\n      return Object.assign({}, state, {\n        [action.reddit]: posts(state[action.reddit], action)\n      })\n    default:\n      return state\n  }\n}\n//将两个reducer合并成一个reducer,也就将全局的state加上postsByReddit,selectedReddit两个属性，每个属性都有自己的state\nconst rootReducer = combineReducers({\n  postsByReddit,\n  selectedReddit\n})\n\nexport default rootReducer\n```\n\n我们写了两个reducer，`postsByReddit`, `selectedReddit`，最后把它们合并起来。所以我们的全局单一state树的第一级节点是`postsByReddit`, `selectedReddit`。\n\n`postsByReddit`节点下面就是`postsByReddit`返回的`state`，也就是`[action.reddit]:posts(state[action.reddit], action)`。`posts()`就是`{ isFetching:false,didInvalidate: false, items: [] }`\n\n现在明白了全局单一state树是如何构建了的吧？----通过reducer。\n\n## componentWillReceiveProps\n\n这是React组件生命周期里面的一个时间节点的回调函数。通常在组件接收新的props时触发。我们在componentDidMount()和componentWillReceiveProps()这两个回调里面加上console.log，来追踪这两个事件的触发：\n\ncontainers/App.js（部分代码）\n\n```js\n//初始化渲染后触发\ncomponentDidMount() {\n  console.log('执行componentDidMount');\n  const { dispatch, selectedReddit } = this.props\n  dispatch(fetchPostsIfNeeded(selectedReddit))\n}\n\n//每次接受新的props触发\ncomponentWillReceiveProps(nextProps) {\n  console.log('执行componentWillReceiveProps',nextProps);\n  if (nextProps.selectedReddit !== this.props.selectedReddit) {\n    const { dispatch, selectedReddit } = nextProps\n    dispatch(fetchPostsIfNeeded(selectedReddit))\n  }\n}\n```\n\n然后我们打开浏览器，执行下面的用户操作，查看console里面的打印信息：\n\n1，刷新页面：\n\n![](/css/images/143.jpg)\n\n首先，执行了`componentDidMount`，也就是渲染了组件。然后执行`request_post`的action，这个action改变了state，state和props就是部分绑定关系，所以触发了`componentWillReceiveProps`。\n\n然后那个`[HMR]`是热替换的意思，这里不详细叙述。\n\n接下来又执行了`componentWillReceiveProps`，为什么呢？因为获取新闻数据成功了，state改变了，被绑定的props也变了，所以执行了`componentWillReceiveProps`。我们可以看到posts里面已经有值了，这时触发了`receive_posts`的action。\n\n\n\n2，切换新闻类型\n\n![](/css/images/145.jpg)\n\n\n\n切换下拉框，触发了`select_reddit`的action，改变了state，改变了被绑定的props，所以触发了`componentWillReceiveProps`\n\n`componentWillReceiveProps`的回调又触发了`request_posts`的action，自己看代码。这个action改变了state,改变了被绑定的props，所以又触发了`componentWillReceiveProps`。\n\n获取新闻数据成功后，又改变了state,改变了被绑定的props，又触发了`componentWillReceiveProps`，也触发了`receive_posts`这个action。\n\n3，点击刷新按钮\n\n![](https://ws4.sinaimg.cn/mw690/83900b4egw1f9xsvkukugj20qr089wis.jpg)\n\n\n\n首先，触发了`invalidate_reddit`废弃新闻的action，然后触发了`request_posts`的action，state的`isFetching`被改变了，所以触发了一次`componentWillReceiveProps`\n\n接受完成，又触发一次`componentWillReceiveProps`。\n\n\n\n由此可见，`componentWillReceiveProps`在Redux+React的程序中，是个非常常用的概念，甚至可以说，只要能监听每次的`componentWillReceiveProps`，就可以清楚的了解React和Redux的交互过程。\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n","slug":"r2-async","published":1,"updated":"2019-05-01T08:10:30.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvm8002gtgytjj70h966","content":"<p>今天，我们要讲解的是异步、单一state树结构、componentWillReceiveProps这三个知识点。</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/141.gif\" alt=\"\"></p>\n<p>这个例子是官方的例子，主要是从Reddit中请求新闻列表来显示，可以切换react和frontend关键词来切换新闻列表，可以刷新当前新闻列表。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async</a></p>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><p>异步本身 这个概念，本文不详细叙述，但可以简单说一下，Javascript是通过自身的”事件循环（event loop）”机制来实现异步的，将耗时的IO等操作跳过，当事件完成后再发个信号过来执行回调。这使得单线程的js变的非常高效，这也是为什么<br>Nodejs在多并发场景下特别牛逼的原因。</p>\n<p>Redux只能实现同步操作，但是可以通过thunk中间件实现异步。thunk的作用看<a href=\"https://lewis617.github.io/2016/01/19/r2-counter/\" target=\"_blank\" rel=\"noopener\">React 与 Redux 教程（一）connect、applyMiddleware、thunk、webpackHotMiddleware</a></p>\n<p><strong><em>主要的异步操作（ajax请求）均在action中进行。</em></strong></p>\n<p>本例子的异步操作在<code>fetchPosts</code>中，就是使用<code>fetch</code>这个方法，进行ajax请求，然后使用promise进行完成后的回调操作。看代码：</p>\n<p>actions/index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> fetch <span class=\"keyword\">from</span> <span class=\"string\">'isomorphic-fetch'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> REQUEST_POSTS = <span class=\"string\">'REQUEST_POSTS'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> RECEIVE_POSTS = <span class=\"string\">'RECEIVE_POSTS'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SELECT_REDDIT = <span class=\"string\">'SELECT_REDDIT'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> INVALIDATE_REDDIT = <span class=\"string\">'INVALIDATE_REDDIT'</span></span><br><span class=\"line\"><span class=\"comment\">//选择新闻类型action</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectReddit</span>(<span class=\"params\">reddit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: SELECT_REDDIT,</span><br><span class=\"line\">    reddit</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//废弃新闻类型action</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">invalidateReddit</span>(<span class=\"params\">reddit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: INVALIDATE_REDDIT,</span><br><span class=\"line\">    reddit</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//开始获取新闻action</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">requestPosts</span>(<span class=\"params\">reddit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: REQUEST_POSTS,</span><br><span class=\"line\">    reddit</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取新闻成功的action</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">receivePosts</span>(<span class=\"params\">reddit, json</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: RECEIVE_POSTS,</span><br><span class=\"line\">    reddit: reddit,</span><br><span class=\"line\">    posts: json.data.children.map(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span> child.data),</span><br><span class=\"line\">    receivedAt: <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取文章，先触发requestPosts开始获取action，完成后触发receivePosts获取成功的action</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchPosts</span>(<span class=\"params\">reddit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> &#123;</span><br><span class=\"line\">    dispatch(requestPosts(reddit))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetch(<span class=\"string\">`https://www.reddit.com/r/<span class=\"subst\">$&#123;reddit&#125;</span>.json`</span>)</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.json())</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">json</span> =&gt;</span> dispatch(receivePosts(reddit, json)))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//是否需要获取文章</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shouldFetchPosts</span>(<span class=\"params\">state, reddit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> posts = state.postsByReddit[reddit]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!posts) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (posts.isFetching) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> posts.didInvalidate</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果需要则开始获取文章</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchPostsIfNeeded</span>(<span class=\"params\">reddit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shouldFetchPosts(getState(), reddit)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dispatch(fetchPosts(reddit))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>异步这个概念比较简单，不再赘述了。</p>\n<h2 id=\"单一state树结构\"><a href=\"#单一state树结构\" class=\"headerlink\" title=\"单一state树结构\"></a>单一state树结构</h2><p>单一state树结构是Redux的最大特点。我们今天主要讲解state的树结构长什么样？首先，我们可以通过React的chrome插件，来看下这个state树：</p>\n<p><img src=\"/css/images/142.jpg\" alt=\"\"></p>\n<p>我们点击Connect(App)，可以查看整个程序的state树，但是这棵树是从storeState开始的。我们在第一课中讲到，只能通过Redux的devtools来查看全局单一state，其实是片面的，通过React的chrome插件同样可以看到这棵树。</p>\n<p>那么这棵树为什么长这个样子，我们是如何构建这棵树的呢？答案都在reducer里面：</p>\n<p>reducers/index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  SELECT_REDDIT, INVALIDATE_REDDIT,</span><br><span class=\"line\">  REQUEST_POSTS, RECEIVE_POSTS</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//选择新闻后，将state.selectedReddit设为所选选项</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectedReddit</span>(<span class=\"params\">state = <span class=\"string\">'reactjs'</span>, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SELECT_REDDIT:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> action.reddit</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">posts</span>(<span class=\"params\">state = &#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"regexp\">//</span>是否正在获取最新</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  isFetching: false,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"regexp\">//</span>是否废弃</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  didInvalidate: false,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"regexp\">//</span>内容</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  items: []</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">&#125;, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> INVALIDATE_REDDIT:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        didInvalidate: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> REQUEST_POSTS:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        isFetching: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        didInvalidate: <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> RECEIVE_POSTS:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        isFetching: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        didInvalidate: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        items: action.posts,</span><br><span class=\"line\">        lastUpdated: action.receivedAt</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//废弃、接收到、开始接受新闻后，将state.postsByReddit设为相关参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postsByReddit</span>(<span class=\"params\">state = &#123; &#125;, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> INVALIDATE_REDDIT:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> RECEIVE_POSTS:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> REQUEST_POSTS:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        [action.reddit]: posts(state[action.reddit], action)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//将两个reducer合并成一个reducer,也就将全局的state加上postsByReddit,selectedReddit两个属性，每个属性都有自己的state</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> rootReducer = combineReducers(&#123;</span><br><span class=\"line\">  postsByReddit,</span><br><span class=\"line\">  selectedReddit</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> rootReducer</span><br></pre></td></tr></table></figure>\n<p>我们写了两个reducer，<code>postsByReddit</code>, <code>selectedReddit</code>，最后把它们合并起来。所以我们的全局单一state树的第一级节点是<code>postsByReddit</code>, <code>selectedReddit</code>。</p>\n<p><code>postsByReddit</code>节点下面就是<code>postsByReddit</code>返回的<code>state</code>，也就是<code>[action.reddit]:posts(state[action.reddit], action)</code>。<code>posts()</code>就是<code>{ isFetching:false,didInvalidate: false, items: [] }</code></p>\n<p>现在明白了全局单一state树是如何构建了的吧？—-通过reducer。</p>\n<h2 id=\"componentWillReceiveProps\"><a href=\"#componentWillReceiveProps\" class=\"headerlink\" title=\"componentWillReceiveProps\"></a>componentWillReceiveProps</h2><p>这是React组件生命周期里面的一个时间节点的回调函数。通常在组件接收新的props时触发。我们在componentDidMount()和componentWillReceiveProps()这两个回调里面加上console.log，来追踪这两个事件的触发：</p>\n<p>containers/App.js（部分代码）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化渲染后触发</span></span><br><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'执行componentDidMount'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; dispatch, selectedReddit &#125; = <span class=\"keyword\">this</span>.props</span><br><span class=\"line\">  dispatch(fetchPostsIfNeeded(selectedReddit))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//每次接受新的props触发</span></span><br><span class=\"line\">componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'执行componentWillReceiveProps'</span>,nextProps);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nextProps.selectedReddit !== <span class=\"keyword\">this</span>.props.selectedReddit) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; dispatch, selectedReddit &#125; = nextProps</span><br><span class=\"line\">    dispatch(fetchPostsIfNeeded(selectedReddit))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们打开浏览器，执行下面的用户操作，查看console里面的打印信息：</p>\n<p>1，刷新页面：</p>\n<p><img src=\"/css/images/143.jpg\" alt=\"\"></p>\n<p>首先，执行了<code>componentDidMount</code>，也就是渲染了组件。然后执行<code>request_post</code>的action，这个action改变了state，state和props就是部分绑定关系，所以触发了<code>componentWillReceiveProps</code>。</p>\n<p>然后那个<code>[HMR]</code>是热替换的意思，这里不详细叙述。</p>\n<p>接下来又执行了<code>componentWillReceiveProps</code>，为什么呢？因为获取新闻数据成功了，state改变了，被绑定的props也变了，所以执行了<code>componentWillReceiveProps</code>。我们可以看到posts里面已经有值了，这时触发了<code>receive_posts</code>的action。</p>\n<p>2，切换新闻类型</p>\n<p><img src=\"/css/images/145.jpg\" alt=\"\"></p>\n<p>切换下拉框，触发了<code>select_reddit</code>的action，改变了state，改变了被绑定的props，所以触发了<code>componentWillReceiveProps</code></p>\n<p><code>componentWillReceiveProps</code>的回调又触发了<code>request_posts</code>的action，自己看代码。这个action改变了state,改变了被绑定的props，所以又触发了<code>componentWillReceiveProps</code>。</p>\n<p>获取新闻数据成功后，又改变了state,改变了被绑定的props，又触发了<code>componentWillReceiveProps</code>，也触发了<code>receive_posts</code>这个action。</p>\n<p>3，点击刷新按钮</p>\n<p><img src=\"https://ws4.sinaimg.cn/mw690/83900b4egw1f9xsvkukugj20qr089wis.jpg\" alt=\"\"></p>\n<p>首先，触发了<code>invalidate_reddit</code>废弃新闻的action，然后触发了<code>request_posts</code>的action，state的<code>isFetching</code>被改变了，所以触发了一次<code>componentWillReceiveProps</code></p>\n<p>接受完成，又触发一次<code>componentWillReceiveProps</code>。</p>\n<p>由此可见，<code>componentWillReceiveProps</code>在Redux+React的程序中，是个非常常用的概念，甚至可以说，只要能监听每次的<code>componentWillReceiveProps</code>，就可以清楚的了解React和Redux的交互过程。</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲解的是异步、单一state树结构、componentWillReceiveProps这三个知识点。</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/141.gif\" alt=\"\"></p>\n<p>这个例子是官方的例子，主要是从Reddit中请求新闻列表来显示，可以切换react和frontend关键词来切换新闻列表，可以刷新当前新闻列表。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async</a></p>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><p>异步本身 这个概念，本文不详细叙述，但可以简单说一下，Javascript是通过自身的”事件循环（event loop）”机制来实现异步的，将耗时的IO等操作跳过，当事件完成后再发个信号过来执行回调。这使得单线程的js变的非常高效，这也是为什么<br>Nodejs在多并发场景下特别牛逼的原因。</p>\n<p>Redux只能实现同步操作，但是可以通过thunk中间件实现异步。thunk的作用看<a href=\"https://lewis617.github.io/2016/01/19/r2-counter/\" target=\"_blank\" rel=\"noopener\">React 与 Redux 教程（一）connect、applyMiddleware、thunk、webpackHotMiddleware</a></p>\n<p><strong><em>主要的异步操作（ajax请求）均在action中进行。</em></strong></p>\n<p>本例子的异步操作在<code>fetchPosts</code>中，就是使用<code>fetch</code>这个方法，进行ajax请求，然后使用promise进行完成后的回调操作。看代码：</p>\n<p>actions/index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> fetch <span class=\"keyword\">from</span> <span class=\"string\">'isomorphic-fetch'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> REQUEST_POSTS = <span class=\"string\">'REQUEST_POSTS'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> RECEIVE_POSTS = <span class=\"string\">'RECEIVE_POSTS'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SELECT_REDDIT = <span class=\"string\">'SELECT_REDDIT'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> INVALIDATE_REDDIT = <span class=\"string\">'INVALIDATE_REDDIT'</span></span><br><span class=\"line\"><span class=\"comment\">//选择新闻类型action</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectReddit</span>(<span class=\"params\">reddit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: SELECT_REDDIT,</span><br><span class=\"line\">    reddit</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//废弃新闻类型action</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">invalidateReddit</span>(<span class=\"params\">reddit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: INVALIDATE_REDDIT,</span><br><span class=\"line\">    reddit</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//开始获取新闻action</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">requestPosts</span>(<span class=\"params\">reddit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: REQUEST_POSTS,</span><br><span class=\"line\">    reddit</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取新闻成功的action</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">receivePosts</span>(<span class=\"params\">reddit, json</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: RECEIVE_POSTS,</span><br><span class=\"line\">    reddit: reddit,</span><br><span class=\"line\">    posts: json.data.children.map(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span> child.data),</span><br><span class=\"line\">    receivedAt: <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取文章，先触发requestPosts开始获取action，完成后触发receivePosts获取成功的action</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchPosts</span>(<span class=\"params\">reddit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> &#123;</span><br><span class=\"line\">    dispatch(requestPosts(reddit))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetch(<span class=\"string\">`https://www.reddit.com/r/<span class=\"subst\">$&#123;reddit&#125;</span>.json`</span>)</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.json())</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">json</span> =&gt;</span> dispatch(receivePosts(reddit, json)))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//是否需要获取文章</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shouldFetchPosts</span>(<span class=\"params\">state, reddit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> posts = state.postsByReddit[reddit]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!posts) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (posts.isFetching) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> posts.didInvalidate</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果需要则开始获取文章</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchPostsIfNeeded</span>(<span class=\"params\">reddit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shouldFetchPosts(getState(), reddit)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dispatch(fetchPosts(reddit))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>异步这个概念比较简单，不再赘述了。</p>\n<h2 id=\"单一state树结构\"><a href=\"#单一state树结构\" class=\"headerlink\" title=\"单一state树结构\"></a>单一state树结构</h2><p>单一state树结构是Redux的最大特点。我们今天主要讲解state的树结构长什么样？首先，我们可以通过React的chrome插件，来看下这个state树：</p>\n<p><img src=\"/css/images/142.jpg\" alt=\"\"></p>\n<p>我们点击Connect(App)，可以查看整个程序的state树，但是这棵树是从storeState开始的。我们在第一课中讲到，只能通过Redux的devtools来查看全局单一state，其实是片面的，通过React的chrome插件同样可以看到这棵树。</p>\n<p>那么这棵树为什么长这个样子，我们是如何构建这棵树的呢？答案都在reducer里面：</p>\n<p>reducers/index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  SELECT_REDDIT, INVALIDATE_REDDIT,</span><br><span class=\"line\">  REQUEST_POSTS, RECEIVE_POSTS</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//选择新闻后，将state.selectedReddit设为所选选项</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectedReddit</span>(<span class=\"params\">state = <span class=\"string\">'reactjs'</span>, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SELECT_REDDIT:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> action.reddit</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">posts</span>(<span class=\"params\">state = &#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"regexp\">//</span>是否正在获取最新</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  isFetching: false,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"regexp\">//</span>是否废弃</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  didInvalidate: false,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"regexp\">//</span>内容</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  items: []</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">&#125;, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> INVALIDATE_REDDIT:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        didInvalidate: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> REQUEST_POSTS:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        isFetching: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        didInvalidate: <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> RECEIVE_POSTS:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        isFetching: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        didInvalidate: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        items: action.posts,</span><br><span class=\"line\">        lastUpdated: action.receivedAt</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//废弃、接收到、开始接受新闻后，将state.postsByReddit设为相关参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postsByReddit</span>(<span class=\"params\">state = &#123; &#125;, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> INVALIDATE_REDDIT:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> RECEIVE_POSTS:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> REQUEST_POSTS:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        [action.reddit]: posts(state[action.reddit], action)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//将两个reducer合并成一个reducer,也就将全局的state加上postsByReddit,selectedReddit两个属性，每个属性都有自己的state</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> rootReducer = combineReducers(&#123;</span><br><span class=\"line\">  postsByReddit,</span><br><span class=\"line\">  selectedReddit</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> rootReducer</span><br></pre></td></tr></table></figure>\n<p>我们写了两个reducer，<code>postsByReddit</code>, <code>selectedReddit</code>，最后把它们合并起来。所以我们的全局单一state树的第一级节点是<code>postsByReddit</code>, <code>selectedReddit</code>。</p>\n<p><code>postsByReddit</code>节点下面就是<code>postsByReddit</code>返回的<code>state</code>，也就是<code>[action.reddit]:posts(state[action.reddit], action)</code>。<code>posts()</code>就是<code>{ isFetching:false,didInvalidate: false, items: [] }</code></p>\n<p>现在明白了全局单一state树是如何构建了的吧？—-通过reducer。</p>\n<h2 id=\"componentWillReceiveProps\"><a href=\"#componentWillReceiveProps\" class=\"headerlink\" title=\"componentWillReceiveProps\"></a>componentWillReceiveProps</h2><p>这是React组件生命周期里面的一个时间节点的回调函数。通常在组件接收新的props时触发。我们在componentDidMount()和componentWillReceiveProps()这两个回调里面加上console.log，来追踪这两个事件的触发：</p>\n<p>containers/App.js（部分代码）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化渲染后触发</span></span><br><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'执行componentDidMount'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; dispatch, selectedReddit &#125; = <span class=\"keyword\">this</span>.props</span><br><span class=\"line\">  dispatch(fetchPostsIfNeeded(selectedReddit))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//每次接受新的props触发</span></span><br><span class=\"line\">componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'执行componentWillReceiveProps'</span>,nextProps);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nextProps.selectedReddit !== <span class=\"keyword\">this</span>.props.selectedReddit) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; dispatch, selectedReddit &#125; = nextProps</span><br><span class=\"line\">    dispatch(fetchPostsIfNeeded(selectedReddit))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们打开浏览器，执行下面的用户操作，查看console里面的打印信息：</p>\n<p>1，刷新页面：</p>\n<p><img src=\"/css/images/143.jpg\" alt=\"\"></p>\n<p>首先，执行了<code>componentDidMount</code>，也就是渲染了组件。然后执行<code>request_post</code>的action，这个action改变了state，state和props就是部分绑定关系，所以触发了<code>componentWillReceiveProps</code>。</p>\n<p>然后那个<code>[HMR]</code>是热替换的意思，这里不详细叙述。</p>\n<p>接下来又执行了<code>componentWillReceiveProps</code>，为什么呢？因为获取新闻数据成功了，state改变了，被绑定的props也变了，所以执行了<code>componentWillReceiveProps</code>。我们可以看到posts里面已经有值了，这时触发了<code>receive_posts</code>的action。</p>\n<p>2，切换新闻类型</p>\n<p><img src=\"/css/images/145.jpg\" alt=\"\"></p>\n<p>切换下拉框，触发了<code>select_reddit</code>的action，改变了state，改变了被绑定的props，所以触发了<code>componentWillReceiveProps</code></p>\n<p><code>componentWillReceiveProps</code>的回调又触发了<code>request_posts</code>的action，自己看代码。这个action改变了state,改变了被绑定的props，所以又触发了<code>componentWillReceiveProps</code>。</p>\n<p>获取新闻数据成功后，又改变了state,改变了被绑定的props，又触发了<code>componentWillReceiveProps</code>，也触发了<code>receive_posts</code>这个action。</p>\n<p>3，点击刷新按钮</p>\n<p><img src=\"https://ws4.sinaimg.cn/mw690/83900b4egw1f9xsvkukugj20qr089wis.jpg\" alt=\"\"></p>\n<p>首先，触发了<code>invalidate_reddit</code>废弃新闻的action，然后触发了<code>request_posts</code>的action，state的<code>isFetching</code>被改变了，所以触发了一次<code>componentWillReceiveProps</code></p>\n<p>接受完成，又触发一次<code>componentWillReceiveProps</code>。</p>\n<p>由此可见，<code>componentWillReceiveProps</code>在Redux+React的程序中，是个非常常用的概念，甚至可以说，只要能监听每次的<code>componentWillReceiveProps</code>，就可以清楚的了解React和Redux的交互过程。</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>"},{"title":"《React 与 Redux 开发实例精解》出版了！","date":"2016-11-20T08:14:00.000Z","_content":"\n《React 与 Redux 开发实例精解》出版了！\n\n<!--more-->\n\n![](/css/images/146.jpg)\n\n## 关于 React 与 Redux\n\nReact 与 Redux， 一个快如鬼魅，一个清晰明了，各个巨头在生产环境对其进行了无数次的测试，强大的社区又为其提供了无数个场景的解决方案，是目前国际上最主流，最先进的前端技术选型。\n\n## 关于这本书\n\n《React 与 Redux 开发实例精解》这本书不仅讲解了 React 与 Redux 的基础和实战，更注重 Universal 渲染、函数式编程和项目架构的介绍。笔者一直在360的生产环境中使用这本书上的技术，感觉非常靠谱。希望读者可以喜欢这本书，也希望这本书能帮到更多的人，更希望国内有更多的基于 React 与 Redux 搭建的优秀项目出现！\n\n## 本书的目标读者\n\n本书适合有一定的 ES6/7、Node 开发经验，想要使用 React 与 Redux 开发应用的前/后端程序员阅读参考。零基础的同学请先补习 ES6/7 和 Node 的基础知识。\n\n## 本书的推荐读法\n\n- **跑例子：**本书名为《React 与 Redux 开发实例精解》，因此请务必将示例代码克隆到本地，一边运行例子，一边阅读本书。\n- **看文档：**本书因篇幅有限等原因，无法对每一项技术的讲解都做到完整而详尽。因此，你还需要根据书中的提示和推荐，去阅读参考相应技术的官方文档。\n- **提问题：**如果在阅读过程中遇到解决不了的问题，可以到 GitHub 提交 Issue，或给我发邮件（lewis617@163.com），我会第一时间解答你的问题。\n\n## 本书的目录结构\n\n温馨提示：点击子节点可使其居中放大。\n\n<iframe src=\"https://lewis617.github.io/books-tree/?hideMenu=true&lazy=200&zooming=0&panning=0#react-redux-book\" \n\twidth=\"850\" height=\"850\"></iframe>\n\n## 售书链接\n\n[京东](https://item.jd.com/12010463.html)\n\n[当当](http://product.dangdang.com/24145390.html)\n","source":"_posts/r2-book.md","raw":"---\ntitle: 《React 与 Redux 开发实例精解》出版了！\ndate: 2016-11-20 16:14:00\ntags: [React, Redux, Babel, Webpack, Node, Universal, 函数式编程, 图书]\n---\n\n《React 与 Redux 开发实例精解》出版了！\n\n<!--more-->\n\n![](/css/images/146.jpg)\n\n## 关于 React 与 Redux\n\nReact 与 Redux， 一个快如鬼魅，一个清晰明了，各个巨头在生产环境对其进行了无数次的测试，强大的社区又为其提供了无数个场景的解决方案，是目前国际上最主流，最先进的前端技术选型。\n\n## 关于这本书\n\n《React 与 Redux 开发实例精解》这本书不仅讲解了 React 与 Redux 的基础和实战，更注重 Universal 渲染、函数式编程和项目架构的介绍。笔者一直在360的生产环境中使用这本书上的技术，感觉非常靠谱。希望读者可以喜欢这本书，也希望这本书能帮到更多的人，更希望国内有更多的基于 React 与 Redux 搭建的优秀项目出现！\n\n## 本书的目标读者\n\n本书适合有一定的 ES6/7、Node 开发经验，想要使用 React 与 Redux 开发应用的前/后端程序员阅读参考。零基础的同学请先补习 ES6/7 和 Node 的基础知识。\n\n## 本书的推荐读法\n\n- **跑例子：**本书名为《React 与 Redux 开发实例精解》，因此请务必将示例代码克隆到本地，一边运行例子，一边阅读本书。\n- **看文档：**本书因篇幅有限等原因，无法对每一项技术的讲解都做到完整而详尽。因此，你还需要根据书中的提示和推荐，去阅读参考相应技术的官方文档。\n- **提问题：**如果在阅读过程中遇到解决不了的问题，可以到 GitHub 提交 Issue，或给我发邮件（lewis617@163.com），我会第一时间解答你的问题。\n\n## 本书的目录结构\n\n温馨提示：点击子节点可使其居中放大。\n\n<iframe src=\"https://lewis617.github.io/books-tree/?hideMenu=true&lazy=200&zooming=0&panning=0#react-redux-book\" \n\twidth=\"850\" height=\"850\"></iframe>\n\n## 售书链接\n\n[京东](https://item.jd.com/12010463.html)\n\n[当当](http://product.dangdang.com/24145390.html)\n","slug":"r2-book","published":1,"updated":"2019-05-01T08:10:30.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvma002jtgytwkaah8z1","content":"<p>《React 与 Redux 开发实例精解》出版了！</p>\n<a id=\"more\"></a>\n<p><img src=\"/css/images/146.jpg\" alt=\"\"></p>\n<h2 id=\"关于-React-与-Redux\"><a href=\"#关于-React-与-Redux\" class=\"headerlink\" title=\"关于 React 与 Redux\"></a>关于 React 与 Redux</h2><p>React 与 Redux， 一个快如鬼魅，一个清晰明了，各个巨头在生产环境对其进行了无数次的测试，强大的社区又为其提供了无数个场景的解决方案，是目前国际上最主流，最先进的前端技术选型。</p>\n<h2 id=\"关于这本书\"><a href=\"#关于这本书\" class=\"headerlink\" title=\"关于这本书\"></a>关于这本书</h2><p>《React 与 Redux 开发实例精解》这本书不仅讲解了 React 与 Redux 的基础和实战，更注重 Universal 渲染、函数式编程和项目架构的介绍。笔者一直在360的生产环境中使用这本书上的技术，感觉非常靠谱。希望读者可以喜欢这本书，也希望这本书能帮到更多的人，更希望国内有更多的基于 React 与 Redux 搭建的优秀项目出现！</p>\n<h2 id=\"本书的目标读者\"><a href=\"#本书的目标读者\" class=\"headerlink\" title=\"本书的目标读者\"></a>本书的目标读者</h2><p>本书适合有一定的 ES6/7、Node 开发经验，想要使用 React 与 Redux 开发应用的前/后端程序员阅读参考。零基础的同学请先补习 ES6/7 和 Node 的基础知识。</p>\n<h2 id=\"本书的推荐读法\"><a href=\"#本书的推荐读法\" class=\"headerlink\" title=\"本书的推荐读法\"></a>本书的推荐读法</h2><ul>\n<li><strong>跑例子：</strong>本书名为《React 与 Redux 开发实例精解》，因此请务必将示例代码克隆到本地，一边运行例子，一边阅读本书。</li>\n<li><strong>看文档：</strong>本书因篇幅有限等原因，无法对每一项技术的讲解都做到完整而详尽。因此，你还需要根据书中的提示和推荐，去阅读参考相应技术的官方文档。</li>\n<li><strong>提问题：</strong>如果在阅读过程中遇到解决不了的问题，可以到 GitHub 提交 Issue，或给我发邮件（<a href=\"mailto:lewis617@163.com\" target=\"_blank\" rel=\"noopener\">lewis617@163.com</a>），我会第一时间解答你的问题。</li>\n</ul>\n<h2 id=\"本书的目录结构\"><a href=\"#本书的目录结构\" class=\"headerlink\" title=\"本书的目录结构\"></a>本书的目录结构</h2><p>温馨提示：点击子节点可使其居中放大。</p>\n<iframe src=\"https://lewis617.github.io/books-tree/?hideMenu=true&lazy=200&zooming=0&panning=0#react-redux-book\" width=\"850\" height=\"850\"></iframe>\n\n<h2 id=\"售书链接\"><a href=\"#售书链接\" class=\"headerlink\" title=\"售书链接\"></a>售书链接</h2><p><a href=\"https://item.jd.com/12010463.html\" target=\"_blank\" rel=\"noopener\">京东</a></p>\n<p><a href=\"http://product.dangdang.com/24145390.html\" target=\"_blank\" rel=\"noopener\">当当</a></p>\n","site":{"data":{}},"excerpt":"<p>《React 与 Redux 开发实例精解》出版了！</p>","more":"<p><img src=\"/css/images/146.jpg\" alt=\"\"></p>\n<h2 id=\"关于-React-与-Redux\"><a href=\"#关于-React-与-Redux\" class=\"headerlink\" title=\"关于 React 与 Redux\"></a>关于 React 与 Redux</h2><p>React 与 Redux， 一个快如鬼魅，一个清晰明了，各个巨头在生产环境对其进行了无数次的测试，强大的社区又为其提供了无数个场景的解决方案，是目前国际上最主流，最先进的前端技术选型。</p>\n<h2 id=\"关于这本书\"><a href=\"#关于这本书\" class=\"headerlink\" title=\"关于这本书\"></a>关于这本书</h2><p>《React 与 Redux 开发实例精解》这本书不仅讲解了 React 与 Redux 的基础和实战，更注重 Universal 渲染、函数式编程和项目架构的介绍。笔者一直在360的生产环境中使用这本书上的技术，感觉非常靠谱。希望读者可以喜欢这本书，也希望这本书能帮到更多的人，更希望国内有更多的基于 React 与 Redux 搭建的优秀项目出现！</p>\n<h2 id=\"本书的目标读者\"><a href=\"#本书的目标读者\" class=\"headerlink\" title=\"本书的目标读者\"></a>本书的目标读者</h2><p>本书适合有一定的 ES6/7、Node 开发经验，想要使用 React 与 Redux 开发应用的前/后端程序员阅读参考。零基础的同学请先补习 ES6/7 和 Node 的基础知识。</p>\n<h2 id=\"本书的推荐读法\"><a href=\"#本书的推荐读法\" class=\"headerlink\" title=\"本书的推荐读法\"></a>本书的推荐读法</h2><ul>\n<li><strong>跑例子：</strong>本书名为《React 与 Redux 开发实例精解》，因此请务必将示例代码克隆到本地，一边运行例子，一边阅读本书。</li>\n<li><strong>看文档：</strong>本书因篇幅有限等原因，无法对每一项技术的讲解都做到完整而详尽。因此，你还需要根据书中的提示和推荐，去阅读参考相应技术的官方文档。</li>\n<li><strong>提问题：</strong>如果在阅读过程中遇到解决不了的问题，可以到 GitHub 提交 Issue，或给我发邮件（<a href=\"mailto:lewis617@163.com\" target=\"_blank\" rel=\"noopener\">lewis617@163.com</a>），我会第一时间解答你的问题。</li>\n</ul>\n<h2 id=\"本书的目录结构\"><a href=\"#本书的目录结构\" class=\"headerlink\" title=\"本书的目录结构\"></a>本书的目录结构</h2><p>温馨提示：点击子节点可使其居中放大。</p>\n<iframe src=\"https://lewis617.github.io/books-tree/?hideMenu=true&lazy=200&zooming=0&panning=0#react-redux-book\" width=\"850\" height=\"850\"></iframe>\n\n<h2 id=\"售书链接\"><a href=\"#售书链接\" class=\"headerlink\" title=\"售书链接\"></a>售书链接</h2><p><a href=\"https://item.jd.com/12010463.html\" target=\"_blank\" rel=\"noopener\">京东</a></p>\n<p><a href=\"http://product.dangdang.com/24145390.html\" target=\"_blank\" rel=\"noopener\">当当</a></p>"},{"title":"React 与 Redux 教程（一）connect、applyMiddleware、thunk、webpackHotMiddleware","date":"2016-01-19T23:52:00.000Z","_content":"\n今天，我们通过解读官方示例代码（counter）的方式来学习React+Redux。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/147.gif)\n\n这个例子是官方的例子，计数器程序。前两个按钮是加减，第三个是如果当前数字是奇数则加一，第四个按钮是异步加一（延迟一秒）。\n\n源代码：\n\nhttps://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/counter\n\n## 组件\n\ncomponents/Counter.js\n\n```js\nimport React, { Component, PropTypes } from 'react'\n\nclass Counter extends Component {\n  render() {\n    //从组件的props属性中导入四个方法和一个变量\n    const { increment, incrementIfOdd, incrementAsync, decrement, counter } = this.props;\n    //渲染组件，包括一个数字，四个按钮\n    return (\n      <p>\n        Clicked: {counter} times\n        {' '}\n        <button onClick={increment}>+</button>\n        {' '}\n        <button onClick={decrement}>-</button>\n        {' '}\n        <button onClick={incrementIfOdd}>Increment if odd</button>\n        {' '}\n        <button onClick={() => incrementAsync()}>Increment async</button>\n      </p>\n    )\n  }\n}\n//限制组件的props安全\nCounter.propTypes = {\n  //increment必须为fucntion,且必须存在\n  increment: PropTypes.func.isRequired,\n  incrementIfOdd: PropTypes.func.isRequired,\n  incrementAsync: PropTypes.func.isRequired,\n  decrement: PropTypes.func.isRequired,\n  //counter必须为数字，且必须存在\n  counter: PropTypes.number.isRequired\n};\n\nexport default Counter\n```\n\n上述代码，我们干了几件事：\n\n  1. 从props中导入变量和方法\n  2. 渲染组件\n\n有的同学可能会急于想知道props的方法和变量是怎么来，下面我们继续解读。\n\n## 容器\n\ncontainers/App.js\n\n```js\nimport { bindActionCreators } from 'redux'\nimport { connect } from 'react-redux'\nimport Counter from '../components/Counter'\nimport * as CounterActions from '../actions/counter'\n\n//将state.counter绑定到props的counter\nfunction mapStateToProps(state) {\n  return {\n    counter: state.counter\n  }\n}\n//将action的所有方法绑定到props上\nfunction mapDispatchToProps(dispatch) {\n  return bindActionCreators(CounterActions, dispatch)\n}\n\n//通过react-redux提供的connect方法将我们需要的state中的数据和actions中的方法绑定到props上\nexport default connect(mapStateToProps, mapDispatchToProps)(Counter)\n\n```\n\n看到这里，很多刚接触Redux同学可能已经晕了，我来图解下Redux的流程。\n\n![](/css/images/148.jpg)\n\nstate就是数据，组件就是数据的呈现形式，action是动作，action是通过reducer来更新state的。\n\n上述代码，我们干了几件事：\n\n  1. 把`state`的`counter`值绑定到props上\n  2. 把四个action创建函数绑定到props上\n\n## connect\n\n那么为什么就绑定上去了呢？因为有`connect`这个方法。这个方法是如何实现的，或者我们该怎么用这个方法呢？`connect`这个方法的用法，可以直接看[api文档](http://camsong.github.io/redux-in-chinese/docs/react-redux/api.html)。我也可以简单描述一下：\n\n  1. 第一个参数，必须是function，作用是绑定state的指定值到props上面。这里绑定的是counter\n  2. 第二个参数，可以是function，也可以是对象，作用是绑定action创建函数到props上。\n  3. 返回值，是绑定后的组件\n\n这里还有很多种其他写法，我喜欢在第二个参数绑定一个对象，即\n\n```js\nimport { bindActionCreators } from 'redux'\nimport { connect } from 'react-redux'\nimport Counter from '../components/Counter'\nimport * as CounterActions from '../actions/counter'\n\n//将state.counter绑定到props的counter\nfunction mapStateToProps(state) {\n  return {\n    counter: state.counter\n  }\n}\n\n//通过react-redux提供的connect方法将我们需要的state中的数据和actions中的方法绑定到props上\nexport default connect(mapStateToProps, CounterActions)(Counter)\n\n```\n还可以不写第二个参数，后面用dispatch来触发action的方法，即\n\n```js\nimport { bindActionCreators } from 'redux'\nimport { connect } from 'react-redux'\nimport Counter from '../components/Counter'\nimport * as CounterActions from '../actions/counter'\n\n//将state.counter绑定到props的counter\nfunction mapStateToProps(state) {\n  return {\n    counter: state.counter\n  }\n}\n\n//通过react-redux提供的connect方法将我们需要的state中的数据绑定到props上\nexport default connect(mapStateToProps)(Counter)\n```\n\n后面在组件中直接使用`dispatch()`来触发action创建函数。\n\n## action和reducer两个好基友负责更新state\n\nactions/counter.js\n\n```js\nexport const INCREMENT_COUNTER = 'INCREMENT_COUNTER'\nexport const DECREMENT_COUNTER = 'DECREMENT_COUNTER'\n//导出加一的方法\nexport function increment() {\n  return {\n    type: INCREMENT_COUNTER\n  }\n}\n//导出减一的方法\nexport function decrement() {\n  return {\n    type: DECREMENT_COUNTER\n  }\n}\n//导出奇数加一的方法，该方法返回一个方法，包含dispatch和getState两个参数，dispatch用于执行action的方法，getState返回state\nexport function incrementIfOdd() {\n  return (dispatch, getState) => {\n    //获取state对象中的counter属性值\n    const { counter } = getState()\n\n    //偶数则返回\n    if (counter % 2 === 0) {\n      return\n    }\n    //没有返回就执行加一\n    dispatch(increment())\n  }\n}\n//导出一个方法,包含一个默认参数delay,返回一个方法,一秒后加一\nexport function incrementAsync(delay = 1000) {\n  return dispatch => {\n    setTimeout(() => {\n      dispatch(increment())\n    }, delay)\n  }\n}\n\n//这些方法都导出,在其他文件导入时候,使用import * as actions 就可以生成一个actions对象包含所有的export\n```\n\nreducers/counter.js\n\n```js\nimport { INCREMENT_COUNTER, DECREMENT_COUNTER } from '../actions/counter'\n\n//reducer其实也是个方法而已,参数是state和action,返回值是新的state\nexport default function counter(state = 0, action) {\n  switch (action.type) {\n    case INCREMENT_COUNTER:\n      return state + 1\n    case DECREMENT_COUNTER:\n      return state - 1\n    default:\n      return state\n  }\n}\n```\n\nreducers/index.js\n\n```js\nimport { combineReducers } from 'redux'\nimport counter from './counter'\n\n//使用redux的combineReducers方法将所有reducer打包起来\nconst rootReducer = combineReducers({\n  counter\n})\n\nexport default rootReducer\n```\n\n上述代码我们干了几件事:\n\n  1. 写了四个action创建函数\n  2. 写了reducer用于更新state\n  3. 将所有reducer(这里只有一个)打包成一个reducer\n\n看到这里，有很多初次接触redux的同学可能已经晕了，怎么那么多概念？为了形象直观，我们在开发工具（React dev tools）上看看这些state，props什么的：\n\n![](/css/images/149.jpg)\n\naction的方法和state的变量是不是都绑定上去了啊。state怎么看呢？这个需要借助Redux的开发工具，也可以通过`Connect(Counter)`组件的State来查看redux那颗全局唯一的状态树：\n\n![](/css/images/150.jpg)\n\n那个`storeState`就是全局唯一的状态树。我们可以看到只有一个`counter`而已。\n\n## 注册store\n\nstore/configureStore.js\n\n```js \nimport { createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\nimport reducer from '../reducers'\n\n//applyMiddleware来自redux可以包装 store 的 dispatch\n//thunk作用是使action创建函数可以返回一个function代替一个action对象\nconst createStoreWithMiddleware = applyMiddleware(\n  thunk\n)(createStore)\n\nexport default function configureStore(initialState) {\n  const store = createStoreWithMiddleware(reducer, initialState)\n\n  //热替换选项\n  if (module.hot) {\n    // Enable Webpack hot module replacement for reducers\n    module.hot.accept('../reducers', () => {\n      const nextReducer = require('../reducers')\n      store.replaceReducer(nextReducer)\n    })\n  }\n\n  return store\n}\n```\nindex.js\n\n```js\nimport React from 'react'\nimport { render } from 'react-dom'\nimport { Provider } from 'react-redux'\nimport App from './containers/App'\nimport configureStore from './store/configureStore'\n\nconst store = configureStore()\n\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)\n```\n上述代码，我们干了几件事：\n\n  1. 用中间件使action创建函数可以返回一个function代替一个action对象\n  2. 如果在热替换状态（Webpack hot module replacement）下，允许替换reducer\n  3. 导出`store`\n  4. 将`store`放进`Provider`\n  5. 将`Provider`放在组件顶层，并渲染\n\n## applyMiddleware、thunk\n\n`applyMiddleware`来自Redux可以包装 store 的 `dispatch()`\n\n`thunk`作用使action创建函数可以返回一个function代替一个action对象\n\n## 服务\n\nserver.js\n\n```js\nvar webpack = require('webpack')\nvar webpackDevMiddleware = require('webpack-dev-middleware')\nvar webpackHotMiddleware = require('webpack-hot-middleware')\nvar config = require('./webpack.config')\n\nvar app = new (require('express'))()\nvar port = 3000\n\nvar compiler = webpack(config)\napp.use(webpackDevMiddleware(compiler, { noInfo: true, publicPath: config.output.publicPath }))\napp.use(webpackHotMiddleware(compiler))\n\napp.get(\"/\", function(req, res) {\n  res.sendFile(__dirname + '/index.html')\n})\n\napp.listen(port, function(error) {\n  if (error) {\n    console.error(error)\n  } else {\n    console.info(\"==> 🌎  Listening on port %s. Open up http://localhost:%s/ in your browser.\", port, port)\n  }\n})\n```\n\nwebpack.config.js\n\n```js\nvar path = require('path')\nvar webpack = require('webpack')\n\nmodule.exports = {\n  devtool: 'cheap-module-eval-source-map',\n  entry: [\n    'webpack-hot-middleware/client',\n    './index'\n  ],\n  output: {\n    path: path.join(__dirname, 'dist'),\n    filename: 'bundle.js',\n    publicPath: '/static/'\n  },\n  plugins: [\n    new webpack.optimize.OccurenceOrderPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin()\n  ],\n  module: {\n    loaders: [\n      {\n        test: /\\.js$/,\n        loaders: [ 'babel' ],\n        exclude: /node_modules/,\n        include: __dirname\n      }\n    ]\n  }\n}\n```\n\n\n`npm start` 后执行`node server` ，触发webpack。webpack插件功能如下：\n\n  1. `OccurenceOrderPlugin`的作用是给经常使用的模块分配最小长度的id。\n  2. `HotModuleReplacementPlugin`是热替换，热替换和dev-server的`hot`有什么区别？不用刷新页面，可用于生产环境。\n  3. `NoErrorsPlugin`用于保证编译后的代码永远是对的，因为不对的话会自动停掉。\n\n## webpackHotMiddleware\n\n  \nserver.js中`webpackHotMiddleware`的用法是参考[官网](https://www.npmjs.com/package/webpack-hot-middleware)的，没有为什么，Express中间件就是在请求后执行某些操作。\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n\n","source":"_posts/r2-counter.md","raw":"---\ntitle: React 与 Redux 教程（一）connect、applyMiddleware、thunk、webpackHotMiddleware\ndate: 2016-01-20 07:52:00\ntags: [React, Redux]\n---\n\n今天，我们通过解读官方示例代码（counter）的方式来学习React+Redux。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/147.gif)\n\n这个例子是官方的例子，计数器程序。前两个按钮是加减，第三个是如果当前数字是奇数则加一，第四个按钮是异步加一（延迟一秒）。\n\n源代码：\n\nhttps://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/counter\n\n## 组件\n\ncomponents/Counter.js\n\n```js\nimport React, { Component, PropTypes } from 'react'\n\nclass Counter extends Component {\n  render() {\n    //从组件的props属性中导入四个方法和一个变量\n    const { increment, incrementIfOdd, incrementAsync, decrement, counter } = this.props;\n    //渲染组件，包括一个数字，四个按钮\n    return (\n      <p>\n        Clicked: {counter} times\n        {' '}\n        <button onClick={increment}>+</button>\n        {' '}\n        <button onClick={decrement}>-</button>\n        {' '}\n        <button onClick={incrementIfOdd}>Increment if odd</button>\n        {' '}\n        <button onClick={() => incrementAsync()}>Increment async</button>\n      </p>\n    )\n  }\n}\n//限制组件的props安全\nCounter.propTypes = {\n  //increment必须为fucntion,且必须存在\n  increment: PropTypes.func.isRequired,\n  incrementIfOdd: PropTypes.func.isRequired,\n  incrementAsync: PropTypes.func.isRequired,\n  decrement: PropTypes.func.isRequired,\n  //counter必须为数字，且必须存在\n  counter: PropTypes.number.isRequired\n};\n\nexport default Counter\n```\n\n上述代码，我们干了几件事：\n\n  1. 从props中导入变量和方法\n  2. 渲染组件\n\n有的同学可能会急于想知道props的方法和变量是怎么来，下面我们继续解读。\n\n## 容器\n\ncontainers/App.js\n\n```js\nimport { bindActionCreators } from 'redux'\nimport { connect } from 'react-redux'\nimport Counter from '../components/Counter'\nimport * as CounterActions from '../actions/counter'\n\n//将state.counter绑定到props的counter\nfunction mapStateToProps(state) {\n  return {\n    counter: state.counter\n  }\n}\n//将action的所有方法绑定到props上\nfunction mapDispatchToProps(dispatch) {\n  return bindActionCreators(CounterActions, dispatch)\n}\n\n//通过react-redux提供的connect方法将我们需要的state中的数据和actions中的方法绑定到props上\nexport default connect(mapStateToProps, mapDispatchToProps)(Counter)\n\n```\n\n看到这里，很多刚接触Redux同学可能已经晕了，我来图解下Redux的流程。\n\n![](/css/images/148.jpg)\n\nstate就是数据，组件就是数据的呈现形式，action是动作，action是通过reducer来更新state的。\n\n上述代码，我们干了几件事：\n\n  1. 把`state`的`counter`值绑定到props上\n  2. 把四个action创建函数绑定到props上\n\n## connect\n\n那么为什么就绑定上去了呢？因为有`connect`这个方法。这个方法是如何实现的，或者我们该怎么用这个方法呢？`connect`这个方法的用法，可以直接看[api文档](http://camsong.github.io/redux-in-chinese/docs/react-redux/api.html)。我也可以简单描述一下：\n\n  1. 第一个参数，必须是function，作用是绑定state的指定值到props上面。这里绑定的是counter\n  2. 第二个参数，可以是function，也可以是对象，作用是绑定action创建函数到props上。\n  3. 返回值，是绑定后的组件\n\n这里还有很多种其他写法，我喜欢在第二个参数绑定一个对象，即\n\n```js\nimport { bindActionCreators } from 'redux'\nimport { connect } from 'react-redux'\nimport Counter from '../components/Counter'\nimport * as CounterActions from '../actions/counter'\n\n//将state.counter绑定到props的counter\nfunction mapStateToProps(state) {\n  return {\n    counter: state.counter\n  }\n}\n\n//通过react-redux提供的connect方法将我们需要的state中的数据和actions中的方法绑定到props上\nexport default connect(mapStateToProps, CounterActions)(Counter)\n\n```\n还可以不写第二个参数，后面用dispatch来触发action的方法，即\n\n```js\nimport { bindActionCreators } from 'redux'\nimport { connect } from 'react-redux'\nimport Counter from '../components/Counter'\nimport * as CounterActions from '../actions/counter'\n\n//将state.counter绑定到props的counter\nfunction mapStateToProps(state) {\n  return {\n    counter: state.counter\n  }\n}\n\n//通过react-redux提供的connect方法将我们需要的state中的数据绑定到props上\nexport default connect(mapStateToProps)(Counter)\n```\n\n后面在组件中直接使用`dispatch()`来触发action创建函数。\n\n## action和reducer两个好基友负责更新state\n\nactions/counter.js\n\n```js\nexport const INCREMENT_COUNTER = 'INCREMENT_COUNTER'\nexport const DECREMENT_COUNTER = 'DECREMENT_COUNTER'\n//导出加一的方法\nexport function increment() {\n  return {\n    type: INCREMENT_COUNTER\n  }\n}\n//导出减一的方法\nexport function decrement() {\n  return {\n    type: DECREMENT_COUNTER\n  }\n}\n//导出奇数加一的方法，该方法返回一个方法，包含dispatch和getState两个参数，dispatch用于执行action的方法，getState返回state\nexport function incrementIfOdd() {\n  return (dispatch, getState) => {\n    //获取state对象中的counter属性值\n    const { counter } = getState()\n\n    //偶数则返回\n    if (counter % 2 === 0) {\n      return\n    }\n    //没有返回就执行加一\n    dispatch(increment())\n  }\n}\n//导出一个方法,包含一个默认参数delay,返回一个方法,一秒后加一\nexport function incrementAsync(delay = 1000) {\n  return dispatch => {\n    setTimeout(() => {\n      dispatch(increment())\n    }, delay)\n  }\n}\n\n//这些方法都导出,在其他文件导入时候,使用import * as actions 就可以生成一个actions对象包含所有的export\n```\n\nreducers/counter.js\n\n```js\nimport { INCREMENT_COUNTER, DECREMENT_COUNTER } from '../actions/counter'\n\n//reducer其实也是个方法而已,参数是state和action,返回值是新的state\nexport default function counter(state = 0, action) {\n  switch (action.type) {\n    case INCREMENT_COUNTER:\n      return state + 1\n    case DECREMENT_COUNTER:\n      return state - 1\n    default:\n      return state\n  }\n}\n```\n\nreducers/index.js\n\n```js\nimport { combineReducers } from 'redux'\nimport counter from './counter'\n\n//使用redux的combineReducers方法将所有reducer打包起来\nconst rootReducer = combineReducers({\n  counter\n})\n\nexport default rootReducer\n```\n\n上述代码我们干了几件事:\n\n  1. 写了四个action创建函数\n  2. 写了reducer用于更新state\n  3. 将所有reducer(这里只有一个)打包成一个reducer\n\n看到这里，有很多初次接触redux的同学可能已经晕了，怎么那么多概念？为了形象直观，我们在开发工具（React dev tools）上看看这些state，props什么的：\n\n![](/css/images/149.jpg)\n\naction的方法和state的变量是不是都绑定上去了啊。state怎么看呢？这个需要借助Redux的开发工具，也可以通过`Connect(Counter)`组件的State来查看redux那颗全局唯一的状态树：\n\n![](/css/images/150.jpg)\n\n那个`storeState`就是全局唯一的状态树。我们可以看到只有一个`counter`而已。\n\n## 注册store\n\nstore/configureStore.js\n\n```js \nimport { createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\nimport reducer from '../reducers'\n\n//applyMiddleware来自redux可以包装 store 的 dispatch\n//thunk作用是使action创建函数可以返回一个function代替一个action对象\nconst createStoreWithMiddleware = applyMiddleware(\n  thunk\n)(createStore)\n\nexport default function configureStore(initialState) {\n  const store = createStoreWithMiddleware(reducer, initialState)\n\n  //热替换选项\n  if (module.hot) {\n    // Enable Webpack hot module replacement for reducers\n    module.hot.accept('../reducers', () => {\n      const nextReducer = require('../reducers')\n      store.replaceReducer(nextReducer)\n    })\n  }\n\n  return store\n}\n```\nindex.js\n\n```js\nimport React from 'react'\nimport { render } from 'react-dom'\nimport { Provider } from 'react-redux'\nimport App from './containers/App'\nimport configureStore from './store/configureStore'\n\nconst store = configureStore()\n\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)\n```\n上述代码，我们干了几件事：\n\n  1. 用中间件使action创建函数可以返回一个function代替一个action对象\n  2. 如果在热替换状态（Webpack hot module replacement）下，允许替换reducer\n  3. 导出`store`\n  4. 将`store`放进`Provider`\n  5. 将`Provider`放在组件顶层，并渲染\n\n## applyMiddleware、thunk\n\n`applyMiddleware`来自Redux可以包装 store 的 `dispatch()`\n\n`thunk`作用使action创建函数可以返回一个function代替一个action对象\n\n## 服务\n\nserver.js\n\n```js\nvar webpack = require('webpack')\nvar webpackDevMiddleware = require('webpack-dev-middleware')\nvar webpackHotMiddleware = require('webpack-hot-middleware')\nvar config = require('./webpack.config')\n\nvar app = new (require('express'))()\nvar port = 3000\n\nvar compiler = webpack(config)\napp.use(webpackDevMiddleware(compiler, { noInfo: true, publicPath: config.output.publicPath }))\napp.use(webpackHotMiddleware(compiler))\n\napp.get(\"/\", function(req, res) {\n  res.sendFile(__dirname + '/index.html')\n})\n\napp.listen(port, function(error) {\n  if (error) {\n    console.error(error)\n  } else {\n    console.info(\"==> 🌎  Listening on port %s. Open up http://localhost:%s/ in your browser.\", port, port)\n  }\n})\n```\n\nwebpack.config.js\n\n```js\nvar path = require('path')\nvar webpack = require('webpack')\n\nmodule.exports = {\n  devtool: 'cheap-module-eval-source-map',\n  entry: [\n    'webpack-hot-middleware/client',\n    './index'\n  ],\n  output: {\n    path: path.join(__dirname, 'dist'),\n    filename: 'bundle.js',\n    publicPath: '/static/'\n  },\n  plugins: [\n    new webpack.optimize.OccurenceOrderPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin()\n  ],\n  module: {\n    loaders: [\n      {\n        test: /\\.js$/,\n        loaders: [ 'babel' ],\n        exclude: /node_modules/,\n        include: __dirname\n      }\n    ]\n  }\n}\n```\n\n\n`npm start` 后执行`node server` ，触发webpack。webpack插件功能如下：\n\n  1. `OccurenceOrderPlugin`的作用是给经常使用的模块分配最小长度的id。\n  2. `HotModuleReplacementPlugin`是热替换，热替换和dev-server的`hot`有什么区别？不用刷新页面，可用于生产环境。\n  3. `NoErrorsPlugin`用于保证编译后的代码永远是对的，因为不对的话会自动停掉。\n\n## webpackHotMiddleware\n\n  \nserver.js中`webpackHotMiddleware`的用法是参考[官网](https://www.npmjs.com/package/webpack-hot-middleware)的，没有为什么，Express中间件就是在请求后执行某些操作。\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n\n","slug":"r2-counter","published":1,"updated":"2019-05-01T08:10:30.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmb002ltgytz4hwaazf","content":"<p>今天，我们通过解读官方示例代码（counter）的方式来学习React+Redux。</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/147.gif\" alt=\"\"></p>\n<p>这个例子是官方的例子，计数器程序。前两个按钮是加减，第三个是如果当前数字是奇数则加一，第四个按钮是异步加一（延迟一秒）。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/counter\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/counter</a></p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><p>components/Counter.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component, PropTypes &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//从组件的props属性中导入四个方法和一个变量</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; increment, incrementIfOdd, incrementAsync, decrement, counter &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">    <span class=\"comment\">//渲染组件，包括一个数字，四个按钮</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;p&gt;</span><br><span class=\"line\">        Clicked: &#123;counter&#125; times</span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;increment&#125;&gt;+<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;decrement&#125;&gt;-<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;incrementIfOdd&#125;&gt;Increment <span class=\"keyword\">if</span> odd&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;' '&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;button onClick=&#123;() =&gt; incrementAsync()&#125;&gt;Increment async&lt;/</span>button&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/限制组件的props安全</span></span><br><span class=\"line\"><span class=\"regexp\">Counter.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/increment必须为fucntion,且必须存在</span></span><br><span class=\"line\"><span class=\"regexp\">  increment: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  incrementIfOdd: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  incrementAsync: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  decrement: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/counter必须为数字，且必须存在</span></span><br><span class=\"line\"><span class=\"regexp\">  counter: PropTypes.number.isRequired</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Counter</span></span><br></pre></td></tr></table></figure>\n<p>上述代码，我们干了几件事：</p>\n<ol>\n<li>从props中导入变量和方法</li>\n<li>渲染组件</li>\n</ol>\n<p>有的同学可能会急于想知道props的方法和变量是怎么来，下面我们继续解读。</p>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><p>containers/App.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'../components/Counter'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> CounterActions <span class=\"keyword\">from</span> <span class=\"string\">'../actions/counter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将state.counter绑定到props的counter</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    counter: state.counter</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//将action的所有方法绑定到props上</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bindActionCreators(CounterActions, dispatch)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过react-redux提供的connect方法将我们需要的state中的数据和actions中的方法绑定到props上</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps, mapDispatchToProps)(Counter)</span><br></pre></td></tr></table></figure>\n<p>看到这里，很多刚接触Redux同学可能已经晕了，我来图解下Redux的流程。</p>\n<p><img src=\"/css/images/148.jpg\" alt=\"\"></p>\n<p>state就是数据，组件就是数据的呈现形式，action是动作，action是通过reducer来更新state的。</p>\n<p>上述代码，我们干了几件事：</p>\n<ol>\n<li>把<code>state</code>的<code>counter</code>值绑定到props上</li>\n<li>把四个action创建函数绑定到props上</li>\n</ol>\n<h2 id=\"connect\"><a href=\"#connect\" class=\"headerlink\" title=\"connect\"></a>connect</h2><p>那么为什么就绑定上去了呢？因为有<code>connect</code>这个方法。这个方法是如何实现的，或者我们该怎么用这个方法呢？<code>connect</code>这个方法的用法，可以直接看<a href=\"http://camsong.github.io/redux-in-chinese/docs/react-redux/api.html\" target=\"_blank\" rel=\"noopener\">api文档</a>。我也可以简单描述一下：</p>\n<ol>\n<li>第一个参数，必须是function，作用是绑定state的指定值到props上面。这里绑定的是counter</li>\n<li>第二个参数，可以是function，也可以是对象，作用是绑定action创建函数到props上。</li>\n<li>返回值，是绑定后的组件</li>\n</ol>\n<p>这里还有很多种其他写法，我喜欢在第二个参数绑定一个对象，即</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'../components/Counter'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> CounterActions <span class=\"keyword\">from</span> <span class=\"string\">'../actions/counter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将state.counter绑定到props的counter</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    counter: state.counter</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过react-redux提供的connect方法将我们需要的state中的数据和actions中的方法绑定到props上</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps, CounterActions)(Counter)</span><br></pre></td></tr></table></figure>\n<p>还可以不写第二个参数，后面用dispatch来触发action的方法，即</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'../components/Counter'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> CounterActions <span class=\"keyword\">from</span> <span class=\"string\">'../actions/counter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将state.counter绑定到props的counter</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    counter: state.counter</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过react-redux提供的connect方法将我们需要的state中的数据绑定到props上</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps)(Counter)</span><br></pre></td></tr></table></figure>\n<p>后面在组件中直接使用<code>dispatch()</code>来触发action创建函数。</p>\n<h2 id=\"action和reducer两个好基友负责更新state\"><a href=\"#action和reducer两个好基友负责更新state\" class=\"headerlink\" title=\"action和reducer两个好基友负责更新state\"></a>action和reducer两个好基友负责更新state</h2><p>actions/counter.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> INCREMENT_COUNTER = <span class=\"string\">'INCREMENT_COUNTER'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DECREMENT_COUNTER = <span class=\"string\">'DECREMENT_COUNTER'</span></span><br><span class=\"line\"><span class=\"comment\">//导出加一的方法</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">increment</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: INCREMENT_COUNTER</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//导出减一的方法</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">decrement</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: DECREMENT_COUNTER</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//导出奇数加一的方法，该方法返回一个方法，包含dispatch和getState两个参数，dispatch用于执行action的方法，getState返回state</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incrementIfOdd</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取state对象中的counter属性值</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; counter &#125; = getState()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//偶数则返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (counter % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//没有返回就执行加一</span></span><br><span class=\"line\">    dispatch(increment())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//导出一个方法,包含一个默认参数delay,返回一个方法,一秒后加一</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incrementAsync</span>(<span class=\"params\">delay = <span class=\"number\">1000</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dispatch(increment())</span><br><span class=\"line\">    &#125;, delay)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这些方法都导出,在其他文件导入时候,使用import * as actions 就可以生成一个actions对象包含所有的export</span></span><br></pre></td></tr></table></figure>\n<p>reducers/counter.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; INCREMENT_COUNTER, DECREMENT_COUNTER &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions/counter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//reducer其实也是个方法而已,参数是state和action,返回值是新的state</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\">state = <span class=\"number\">0</span>, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> INCREMENT_COUNTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> DECREMENT_COUNTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>reducers/index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./counter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用redux的combineReducers方法将所有reducer打包起来</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> rootReducer = combineReducers(&#123;</span><br><span class=\"line\">  counter</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> rootReducer</span><br></pre></td></tr></table></figure>\n<p>上述代码我们干了几件事:</p>\n<ol>\n<li>写了四个action创建函数</li>\n<li>写了reducer用于更新state</li>\n<li>将所有reducer(这里只有一个)打包成一个reducer</li>\n</ol>\n<p>看到这里，有很多初次接触redux的同学可能已经晕了，怎么那么多概念？为了形象直观，我们在开发工具（React dev tools）上看看这些state，props什么的：</p>\n<p><img src=\"/css/images/149.jpg\" alt=\"\"></p>\n<p>action的方法和state的变量是不是都绑定上去了啊。state怎么看呢？这个需要借助Redux的开发工具，也可以通过<code>Connect(Counter)</code>组件的State来查看redux那颗全局唯一的状态树：</p>\n<p><img src=\"/css/images/150.jpg\" alt=\"\"></p>\n<p>那个<code>storeState</code>就是全局唯一的状态树。我们可以看到只有一个<code>counter</code>而已。</p>\n<h2 id=\"注册store\"><a href=\"#注册store\" class=\"headerlink\" title=\"注册store\"></a>注册store</h2><p>store/configureStore.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> thunk <span class=\"keyword\">from</span> <span class=\"string\">'redux-thunk'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">'../reducers'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//applyMiddleware来自redux可以包装 store 的 dispatch</span></span><br><span class=\"line\"><span class=\"comment\">//thunk作用是使action创建函数可以返回一个function代替一个action对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> createStoreWithMiddleware = applyMiddleware(</span><br><span class=\"line\">  thunk</span><br><span class=\"line\">)(createStore)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">configureStore</span>(<span class=\"params\">initialState</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> store = createStoreWithMiddleware(reducer, initialState)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//热替换选项</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Enable Webpack hot module replacement for reducers</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'../reducers'</span>, () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextReducer = <span class=\"built_in\">require</span>(<span class=\"string\">'../reducers'</span>)</span><br><span class=\"line\">      store.replaceReducer(nextReducer)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> store</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; render &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./containers/App'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> configureStore <span class=\"keyword\">from</span> <span class=\"string\">'./store/configureStore'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = configureStore()</span><br><span class=\"line\"></span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App /&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n<p>上述代码，我们干了几件事：</p>\n<ol>\n<li>用中间件使action创建函数可以返回一个function代替一个action对象</li>\n<li>如果在热替换状态（Webpack hot module replacement）下，允许替换reducer</li>\n<li>导出<code>store</code></li>\n<li>将<code>store</code>放进<code>Provider</code></li>\n<li>将<code>Provider</code>放在组件顶层，并渲染</li>\n</ol>\n<h2 id=\"applyMiddleware、thunk\"><a href=\"#applyMiddleware、thunk\" class=\"headerlink\" title=\"applyMiddleware、thunk\"></a>applyMiddleware、thunk</h2><p><code>applyMiddleware</code>来自Redux可以包装 store 的 <code>dispatch()</code></p>\n<p><code>thunk</code>作用使action创建函数可以返回一个function代替一个action对象</p>\n<h2 id=\"服务\"><a href=\"#服务\" class=\"headerlink\" title=\"服务\"></a>服务</h2><p>server.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackDevMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-dev-middleware'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackHotMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-hot-middleware'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.config'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> (<span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>))()</span><br><span class=\"line\"><span class=\"keyword\">var</span> port = <span class=\"number\">3000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> compiler = webpack(config)</span><br><span class=\"line\">app.use(webpackDevMiddleware(compiler, &#123; <span class=\"attr\">noInfo</span>: <span class=\"literal\">true</span>, <span class=\"attr\">publicPath</span>: config.output.publicPath &#125;))</span><br><span class=\"line\">app.use(webpackHotMiddleware(compiler))</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">\"/\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  res.sendFile(__dirname + <span class=\"string\">'/index.html'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(port, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(error)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(<span class=\"string\">\"==&gt; 🌎  Listening on port %s. Open up http://localhost:%s/ in your browser.\"</span>, port, port)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>webpack.config.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  devtool: <span class=\"string\">'cheap-module-eval-source-map'</span>,</span><br><span class=\"line\">  entry: [</span><br><span class=\"line\">    <span class=\"string\">'webpack-hot-middleware/client'</span>,</span><br><span class=\"line\">    <span class=\"string\">'./index'</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.join(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span>,</span><br><span class=\"line\">    publicPath: <span class=\"string\">'/static/'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.OccurenceOrderPlugin(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.NoErrorsPlugin()</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    loaders: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        loaders: [ <span class=\"string\">'babel'</span> ],</span><br><span class=\"line\">        exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">        include: __dirname</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>npm start</code> 后执行<code>node server</code> ，触发webpack。webpack插件功能如下：</p>\n<ol>\n<li><code>OccurenceOrderPlugin</code>的作用是给经常使用的模块分配最小长度的id。</li>\n<li><code>HotModuleReplacementPlugin</code>是热替换，热替换和dev-server的<code>hot</code>有什么区别？不用刷新页面，可用于生产环境。</li>\n<li><code>NoErrorsPlugin</code>用于保证编译后的代码永远是对的，因为不对的话会自动停掉。</li>\n</ol>\n<h2 id=\"webpackHotMiddleware\"><a href=\"#webpackHotMiddleware\" class=\"headerlink\" title=\"webpackHotMiddleware\"></a>webpackHotMiddleware</h2><p>server.js中<code>webpackHotMiddleware</code>的用法是参考<a href=\"https://www.npmjs.com/package/webpack-hot-middleware\" target=\"_blank\" rel=\"noopener\">官网</a>的，没有为什么，Express中间件就是在请求后执行某些操作。</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们通过解读官方示例代码（counter）的方式来学习React+Redux。</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/147.gif\" alt=\"\"></p>\n<p>这个例子是官方的例子，计数器程序。前两个按钮是加减，第三个是如果当前数字是奇数则加一，第四个按钮是异步加一（延迟一秒）。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/counter\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/counter</a></p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><p>components/Counter.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component, PropTypes &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//从组件的props属性中导入四个方法和一个变量</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; increment, incrementIfOdd, incrementAsync, decrement, counter &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">    <span class=\"comment\">//渲染组件，包括一个数字，四个按钮</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;p&gt;</span><br><span class=\"line\">        Clicked: &#123;counter&#125; times</span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;increment&#125;&gt;+<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;decrement&#125;&gt;-<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\">        &#123;<span class=\"string\">' '</span>&#125;</span><br><span class=\"line\">        &lt;button onClick=&#123;incrementIfOdd&#125;&gt;Increment <span class=\"keyword\">if</span> odd&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;' '&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;button onClick=&#123;() =&gt; incrementAsync()&#125;&gt;Increment async&lt;/</span>button&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/限制组件的props安全</span></span><br><span class=\"line\"><span class=\"regexp\">Counter.propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/increment必须为fucntion,且必须存在</span></span><br><span class=\"line\"><span class=\"regexp\">  increment: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  incrementIfOdd: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  incrementAsync: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  decrement: PropTypes.func.isRequired,</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/counter必须为数字，且必须存在</span></span><br><span class=\"line\"><span class=\"regexp\">  counter: PropTypes.number.isRequired</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default Counter</span></span><br></pre></td></tr></table></figure>\n<p>上述代码，我们干了几件事：</p>\n<ol>\n<li>从props中导入变量和方法</li>\n<li>渲染组件</li>\n</ol>\n<p>有的同学可能会急于想知道props的方法和变量是怎么来，下面我们继续解读。</p>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><p>containers/App.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'../components/Counter'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> CounterActions <span class=\"keyword\">from</span> <span class=\"string\">'../actions/counter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将state.counter绑定到props的counter</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    counter: state.counter</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//将action的所有方法绑定到props上</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bindActionCreators(CounterActions, dispatch)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过react-redux提供的connect方法将我们需要的state中的数据和actions中的方法绑定到props上</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps, mapDispatchToProps)(Counter)</span><br></pre></td></tr></table></figure>\n<p>看到这里，很多刚接触Redux同学可能已经晕了，我来图解下Redux的流程。</p>\n<p><img src=\"/css/images/148.jpg\" alt=\"\"></p>\n<p>state就是数据，组件就是数据的呈现形式，action是动作，action是通过reducer来更新state的。</p>\n<p>上述代码，我们干了几件事：</p>\n<ol>\n<li>把<code>state</code>的<code>counter</code>值绑定到props上</li>\n<li>把四个action创建函数绑定到props上</li>\n</ol>\n<h2 id=\"connect\"><a href=\"#connect\" class=\"headerlink\" title=\"connect\"></a>connect</h2><p>那么为什么就绑定上去了呢？因为有<code>connect</code>这个方法。这个方法是如何实现的，或者我们该怎么用这个方法呢？<code>connect</code>这个方法的用法，可以直接看<a href=\"http://camsong.github.io/redux-in-chinese/docs/react-redux/api.html\" target=\"_blank\" rel=\"noopener\">api文档</a>。我也可以简单描述一下：</p>\n<ol>\n<li>第一个参数，必须是function，作用是绑定state的指定值到props上面。这里绑定的是counter</li>\n<li>第二个参数，可以是function，也可以是对象，作用是绑定action创建函数到props上。</li>\n<li>返回值，是绑定后的组件</li>\n</ol>\n<p>这里还有很多种其他写法，我喜欢在第二个参数绑定一个对象，即</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'../components/Counter'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> CounterActions <span class=\"keyword\">from</span> <span class=\"string\">'../actions/counter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将state.counter绑定到props的counter</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    counter: state.counter</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过react-redux提供的connect方法将我们需要的state中的数据和actions中的方法绑定到props上</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps, CounterActions)(Counter)</span><br></pre></td></tr></table></figure>\n<p>还可以不写第二个参数，后面用dispatch来触发action的方法，即</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'../components/Counter'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> CounterActions <span class=\"keyword\">from</span> <span class=\"string\">'../actions/counter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将state.counter绑定到props的counter</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    counter: state.counter</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过react-redux提供的connect方法将我们需要的state中的数据绑定到props上</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps)(Counter)</span><br></pre></td></tr></table></figure>\n<p>后面在组件中直接使用<code>dispatch()</code>来触发action创建函数。</p>\n<h2 id=\"action和reducer两个好基友负责更新state\"><a href=\"#action和reducer两个好基友负责更新state\" class=\"headerlink\" title=\"action和reducer两个好基友负责更新state\"></a>action和reducer两个好基友负责更新state</h2><p>actions/counter.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> INCREMENT_COUNTER = <span class=\"string\">'INCREMENT_COUNTER'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DECREMENT_COUNTER = <span class=\"string\">'DECREMENT_COUNTER'</span></span><br><span class=\"line\"><span class=\"comment\">//导出加一的方法</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">increment</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: INCREMENT_COUNTER</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//导出减一的方法</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">decrement</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: DECREMENT_COUNTER</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//导出奇数加一的方法，该方法返回一个方法，包含dispatch和getState两个参数，dispatch用于执行action的方法，getState返回state</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incrementIfOdd</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取state对象中的counter属性值</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; counter &#125; = getState()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//偶数则返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (counter % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//没有返回就执行加一</span></span><br><span class=\"line\">    dispatch(increment())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//导出一个方法,包含一个默认参数delay,返回一个方法,一秒后加一</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incrementAsync</span>(<span class=\"params\">delay = <span class=\"number\">1000</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dispatch(increment())</span><br><span class=\"line\">    &#125;, delay)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这些方法都导出,在其他文件导入时候,使用import * as actions 就可以生成一个actions对象包含所有的export</span></span><br></pre></td></tr></table></figure>\n<p>reducers/counter.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; INCREMENT_COUNTER, DECREMENT_COUNTER &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions/counter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//reducer其实也是个方法而已,参数是state和action,返回值是新的state</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\">state = <span class=\"number\">0</span>, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> INCREMENT_COUNTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> DECREMENT_COUNTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>reducers/index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./counter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用redux的combineReducers方法将所有reducer打包起来</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> rootReducer = combineReducers(&#123;</span><br><span class=\"line\">  counter</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> rootReducer</span><br></pre></td></tr></table></figure>\n<p>上述代码我们干了几件事:</p>\n<ol>\n<li>写了四个action创建函数</li>\n<li>写了reducer用于更新state</li>\n<li>将所有reducer(这里只有一个)打包成一个reducer</li>\n</ol>\n<p>看到这里，有很多初次接触redux的同学可能已经晕了，怎么那么多概念？为了形象直观，我们在开发工具（React dev tools）上看看这些state，props什么的：</p>\n<p><img src=\"/css/images/149.jpg\" alt=\"\"></p>\n<p>action的方法和state的变量是不是都绑定上去了啊。state怎么看呢？这个需要借助Redux的开发工具，也可以通过<code>Connect(Counter)</code>组件的State来查看redux那颗全局唯一的状态树：</p>\n<p><img src=\"/css/images/150.jpg\" alt=\"\"></p>\n<p>那个<code>storeState</code>就是全局唯一的状态树。我们可以看到只有一个<code>counter</code>而已。</p>\n<h2 id=\"注册store\"><a href=\"#注册store\" class=\"headerlink\" title=\"注册store\"></a>注册store</h2><p>store/configureStore.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> thunk <span class=\"keyword\">from</span> <span class=\"string\">'redux-thunk'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">'../reducers'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//applyMiddleware来自redux可以包装 store 的 dispatch</span></span><br><span class=\"line\"><span class=\"comment\">//thunk作用是使action创建函数可以返回一个function代替一个action对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> createStoreWithMiddleware = applyMiddleware(</span><br><span class=\"line\">  thunk</span><br><span class=\"line\">)(createStore)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">configureStore</span>(<span class=\"params\">initialState</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> store = createStoreWithMiddleware(reducer, initialState)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//热替换选项</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Enable Webpack hot module replacement for reducers</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'../reducers'</span>, () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextReducer = <span class=\"built_in\">require</span>(<span class=\"string\">'../reducers'</span>)</span><br><span class=\"line\">      store.replaceReducer(nextReducer)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> store</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; render &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./containers/App'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> configureStore <span class=\"keyword\">from</span> <span class=\"string\">'./store/configureStore'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = configureStore()</span><br><span class=\"line\"></span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App /&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n<p>上述代码，我们干了几件事：</p>\n<ol>\n<li>用中间件使action创建函数可以返回一个function代替一个action对象</li>\n<li>如果在热替换状态（Webpack hot module replacement）下，允许替换reducer</li>\n<li>导出<code>store</code></li>\n<li>将<code>store</code>放进<code>Provider</code></li>\n<li>将<code>Provider</code>放在组件顶层，并渲染</li>\n</ol>\n<h2 id=\"applyMiddleware、thunk\"><a href=\"#applyMiddleware、thunk\" class=\"headerlink\" title=\"applyMiddleware、thunk\"></a>applyMiddleware、thunk</h2><p><code>applyMiddleware</code>来自Redux可以包装 store 的 <code>dispatch()</code></p>\n<p><code>thunk</code>作用使action创建函数可以返回一个function代替一个action对象</p>\n<h2 id=\"服务\"><a href=\"#服务\" class=\"headerlink\" title=\"服务\"></a>服务</h2><p>server.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackDevMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-dev-middleware'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackHotMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-hot-middleware'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.config'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> (<span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>))()</span><br><span class=\"line\"><span class=\"keyword\">var</span> port = <span class=\"number\">3000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> compiler = webpack(config)</span><br><span class=\"line\">app.use(webpackDevMiddleware(compiler, &#123; <span class=\"attr\">noInfo</span>: <span class=\"literal\">true</span>, <span class=\"attr\">publicPath</span>: config.output.publicPath &#125;))</span><br><span class=\"line\">app.use(webpackHotMiddleware(compiler))</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">\"/\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  res.sendFile(__dirname + <span class=\"string\">'/index.html'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(port, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(error)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(<span class=\"string\">\"==&gt; 🌎  Listening on port %s. Open up http://localhost:%s/ in your browser.\"</span>, port, port)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>webpack.config.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  devtool: <span class=\"string\">'cheap-module-eval-source-map'</span>,</span><br><span class=\"line\">  entry: [</span><br><span class=\"line\">    <span class=\"string\">'webpack-hot-middleware/client'</span>,</span><br><span class=\"line\">    <span class=\"string\">'./index'</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.join(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span>,</span><br><span class=\"line\">    publicPath: <span class=\"string\">'/static/'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.OccurenceOrderPlugin(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.NoErrorsPlugin()</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    loaders: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        loaders: [ <span class=\"string\">'babel'</span> ],</span><br><span class=\"line\">        exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">        include: __dirname</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>npm start</code> 后执行<code>node server</code> ，触发webpack。webpack插件功能如下：</p>\n<ol>\n<li><code>OccurenceOrderPlugin</code>的作用是给经常使用的模块分配最小长度的id。</li>\n<li><code>HotModuleReplacementPlugin</code>是热替换，热替换和dev-server的<code>hot</code>有什么区别？不用刷新页面，可用于生产环境。</li>\n<li><code>NoErrorsPlugin</code>用于保证编译后的代码永远是对的，因为不对的话会自动停掉。</li>\n</ol>\n<h2 id=\"webpackHotMiddleware\"><a href=\"#webpackHotMiddleware\" class=\"headerlink\" title=\"webpackHotMiddleware\"></a>webpackHotMiddleware</h2><p>server.js中<code>webpackHotMiddleware</code>的用法是参考<a href=\"https://www.npmjs.com/package/webpack-hot-middleware\" target=\"_blank\" rel=\"noopener\">官网</a>的，没有为什么，Express中间件就是在请求后执行某些操作。</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>"},{"title":"React 与 Redux 教程（八）连接数据库的Redux程序","date":"2016-02-03T01:00:00.000Z","_content":"\n前面所有的教程都是解读官方的示例代码，是时候我们自己写个连接数据库的Redux程序了！\n\n<!--more-->\n\n## 例子\n\n![](/css/images/151.gif)\n\n这个例子代码，是我自己写的程序，一个非常简单的todo，但是包含了Redux插件的用法，中间件的用法，连接数据库的方法等多个知识点。\n\n源代码：\n\nhttps://github.com/lewis617/react-redux-tutorial/tree/master/redux-wilddog-todos\n\n运行方法：\n\n```sh\nnpm install\n\nnpm run build\n```\n手动打开index.html\n\n## Wilddog数据库\n\n作为一名曾经的Angular开发者，我非常喜欢用Firebase来做自己的数据库，并结合Angular实现酷炫的\"三向数据绑定\"。Wilddog是中国的\"Firebase\"，不仅语法兼容，而且国内速度更快。\n\n下面的程序都是基于Wilddog和Angular的程序，也用了我曾经的最爱Requirejs，有兴趣的同学可以看看，顺便给我点star哈哈！\n\nhttps://github.com/lewis617/wild-angular-seed\n\nhttps://github.com/lewis617/daily-task\n\n如今写React程序，仍然可以使用Wilddog或者Firebase，不仅不用配置数据库服务，也不用写数据库增删改查的API程序了，可以让我们前端工程师专注于写前端程序！\n\nhttps://www.wilddog.com/\n\n## Redux的Chrome插件\n\n本程序也用到了Redux的chrome插件，可以帮助我们自动生成Redux的devtool界面，非常好用啊！只需要在你的程序store注册中，加入一行代码：\n\n```js \nexport default (initialState) => {\n  const store = compose(\n      applyMiddleware(\n          thunk,\n          createLogger()\n      ),\n      window.devToolsExtension ? window.devToolsExtension() : f => f\n  )(createStore)(reducers, initialState);\n\n  return store;\n};\n```\n\n就是这行代码：\n\n```js\nwindow.devToolsExtension ? window.devToolsExtension() : f => f\n```\n\n安装方法，就是去chrome的市场搜索Redux关键字就可以了！\n\n## 没有服务端渲染和热替换\n\n为什么要把这个单独提起来说呢？这是一个历史遗留问题。我们研究所用的Web框架是Flask，一个Python框架，包括前端也是用Flask的Jinja模板。没有Node.js也就意味着无法使用服务端渲染和热替换这两个炫酷的功能。\n\n那么不是基于Node.js的前端程序，还能否使用Redux和React呢？当然可以，我只通过Webpack生成一个js文件，将js文件放进html里面。其他所有的功能都不要。这也是可以的。这也算是结合非Node平台的一个实践经验吧！当然你的包管理还得用NPM。\n\n从另一个方面来说，基于Node.js的前端时代已经来临，如果你拒绝它，将会失去很多，或者寸步难行！\n\n## 获取所有的todos\n\n我们在action中进行http请求和服务端交互，即便是在中间件中执行http请求，其实质也是dispatch的封装。那么这个程序的关键就是action的编写。\n\n实例化Wilddog，定义action类型:\n\nactions.js\n\n```js\nimport Wilddog from 'wilddog/lib/wilddog-node'\n/*\n * action 类型\n */\nexport const GET_TODO_ERROR = 'GET_TODO_ERROR';\nexport const GET_TODO_OK = 'GET_TODO_OK';\nexport const ADD_TODO_ERROR = 'ADD_TODO_ERROR';\nexport const ADD_TODO_OK = 'ADD_TODO_OK';\nexport const REMOVE_TODO_OK = 'REMOVE_TODO_OK';\nexport const REMOVE_TODO_ERROR = 'REMOVE_TODO_ERROR';\n\nlet wilddog=new Wilddog('https://redux-wilddog-todos.wilddogio.com')\n```\n从Wilddog数据库中获取所有的todos，因为Wilddog数据库是树状结构，生成的列表，其实质也是个对象，所以我们需要将其转化为数组：\n\n```js\n    \n    \nexport function getTodo() {\n  return (dispatch,getState)=>{\n\n    wilddog.child('todos').once('value',(snapshot)=>{\n      let obj=snapshot.val();\n      let array=[];\n      for(let key in obj){\n        array.push({key:key,text:obj[key].text})\n      }\n      dispatch({\n        type: GET_TODO_OK,\n        payload: array\n      })\n    },(err)=>{\n      dispatch({\n        type: GET_TODO_ERROR,\n        payload: err\n      })\n    });\n\n\n  }\n}\n```\n\n`wilddog.child('todos').once('value',function)`是获取`'todos'`节点数据的方法。获取到数据后，转化为数组。然后dispatch一个`GET_TODO_OK`，告诉reducer获取数据成功，可以更新state了。数据都装在`payload`中。如果失败，则dispatch一`GET_TODO_ERROR`。\n\n就是这么简单，不用写后台程序，在js中直接操作数据库！\n\n那么在哪里执行这个getTodo呢？你可以在组件渲染后dispatch它，也可以在初始化store后，立即执行它。我用的是后面一种：\n\nindex.js\n\n```js\nimport { getTodo,registerListeners} from './actions'\n\nlet store = createStore();\n\nstore.dispatch(getTodo())\n```    \n\n## 添加新的todo\n\n在action中定义添加todo的方法：\n\nactions.js\n\n```js\nexport function addTodo(text) {\n  return (dispatch,getState)=>{\n\n    wilddog.child('todos').push({\n      text\n    },(err)=>{\n      if(err){dispatch({type:ADD_TODO_ERROR,payload:err})}\n    });\n  }\n}\n```\n\n通过`wilddog.child('todos').push()`方法，直接往数据库中插入数据，第二参数是回调，失败的话，dispatch相应的action。\n\n那么成功后的action在哪执行？我们需要再写一个function，绑定数据变动的回调。其实正常情况下，我们在这个function中就直接写成功后的回调了，主要是因为Wilddog数据库的成功回调不在`push`这个方法中。\n\nactions.js\n\n```js\nexport function registerListeners() {\n  return (dispatch, getState) => {\n\n    wilddog.child('todos').on('child_removed', snapshot => {\n      dispatch({\n        type: REMOVE_TODO_OK,\n        payload: snapshot.key()\n      })\n    });\n\n    wilddog.child('todos').on('child_added', snapshot => dispatch({\n      type: ADD_TODO_OK,\n      payload: Object.assign({},snapshot.val(),{key:snapshot.key()})\n    }));\n\n  };\n}\n```\n`wilddog.child('todos').on('child_added')`这个方法定义了添加todo成功后的回调，我们执行了一个`ADD_TODO_OK` 的action，并把新的todo对象放在`payload`中返回给reducer。\n\n你也看到了，我们顺便把移除todo成功的回调也定义了。\n\n我们在哪执行这个绑定函数呢？就在获取所有todos的后面吧！其实放在组件渲染完也可以！\n\nindex.js\n\n```js\nstore.dispatch(registerListeners())\n```\n\n## 移除指定todo\n\n在action中添加移除todo的方法：\n\nactions.js\n\n```js\nexport function removeTodo(key) {\n  return (dispatch,getState)=>{\n\n    wilddog.child(`todos/${key}`).remove((err)=>{\n      if(err)dispatch({type:REMOVE_TODO_ERROR,payload:err})\n    });\n  }\n}\n```\n通过Wilddog的`remove`方法移除数据库的指定节点。就是这么简单！然后编写失败后的回调以及action！\n\n## 数据库在action中完事，state还需要reducer\n\n数据库我们是操作完啦，不过组件的显示是基于state的，我们还要同步更新state，那么reducer就出场了！\n\nreducers.js\n\n```js    \n    \nimport { combineReducers } from 'redux'\nimport { ADD_TODO_OK, REMOVE_TODO_OK ,GET_TODO_OK} from './actions'\n\nfunction todos(state=[], action) {\n  switch (action.type) {\n    case GET_TODO_OK:\n      return action.payload\n    case ADD_TODO_OK:\n      return [\n        ...state,\n        action.payload\n      ]\n    case REMOVE_TODO_OK:\n      return state.filter((todo)=>todo.key!==action.payload\n      )\n    default:\n      return state\n  }\n}\n\nconst todoApp = combineReducers({\n  todos\n})\n\nexport default todoApp\n```\n\n很简单，如果你还不会，可以去前面几节教程补课。\n\n来个图吧：\n\n![](/css/images/152.jpg)\n\naction操作数据库后，要在回调中返回信号，让reducer更新state，因为只有state变了，组件才会变。state变了，组件自动就变了，至少不用苦逼地操作dom了，还是挺开心的！\n\n## 为什么不提React组件\n\n说了这么多我们的Redux容器算是搞定了，为什么不提组件？不是不提，是要让大家知道，组件和Redux容器的耦合度很低，我们可以完全将它们隔离开来编写，通过一些固定的套路将它们连接起来。什么套路？\n\n  1. 绑定state到props\n  2. 绑定action到props（可选）\n  3. 将store注入，并用provider在顶层包住组件\n\nRedux是个状态容器，只能通过发起action改变state，这种集中管控的做法让状态管理和预测变的简单。组件只是state的展现形式而已！React只是一个界面库而已！\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n","source":"_posts/r2-database.md","raw":"---\ntitle: React 与 Redux 教程（八）连接数据库的Redux程序\ndate: 2016-02-03 09:00:00\ntags: [React, Redux]\n---\n\n前面所有的教程都是解读官方的示例代码，是时候我们自己写个连接数据库的Redux程序了！\n\n<!--more-->\n\n## 例子\n\n![](/css/images/151.gif)\n\n这个例子代码，是我自己写的程序，一个非常简单的todo，但是包含了Redux插件的用法，中间件的用法，连接数据库的方法等多个知识点。\n\n源代码：\n\nhttps://github.com/lewis617/react-redux-tutorial/tree/master/redux-wilddog-todos\n\n运行方法：\n\n```sh\nnpm install\n\nnpm run build\n```\n手动打开index.html\n\n## Wilddog数据库\n\n作为一名曾经的Angular开发者，我非常喜欢用Firebase来做自己的数据库，并结合Angular实现酷炫的\"三向数据绑定\"。Wilddog是中国的\"Firebase\"，不仅语法兼容，而且国内速度更快。\n\n下面的程序都是基于Wilddog和Angular的程序，也用了我曾经的最爱Requirejs，有兴趣的同学可以看看，顺便给我点star哈哈！\n\nhttps://github.com/lewis617/wild-angular-seed\n\nhttps://github.com/lewis617/daily-task\n\n如今写React程序，仍然可以使用Wilddog或者Firebase，不仅不用配置数据库服务，也不用写数据库增删改查的API程序了，可以让我们前端工程师专注于写前端程序！\n\nhttps://www.wilddog.com/\n\n## Redux的Chrome插件\n\n本程序也用到了Redux的chrome插件，可以帮助我们自动生成Redux的devtool界面，非常好用啊！只需要在你的程序store注册中，加入一行代码：\n\n```js \nexport default (initialState) => {\n  const store = compose(\n      applyMiddleware(\n          thunk,\n          createLogger()\n      ),\n      window.devToolsExtension ? window.devToolsExtension() : f => f\n  )(createStore)(reducers, initialState);\n\n  return store;\n};\n```\n\n就是这行代码：\n\n```js\nwindow.devToolsExtension ? window.devToolsExtension() : f => f\n```\n\n安装方法，就是去chrome的市场搜索Redux关键字就可以了！\n\n## 没有服务端渲染和热替换\n\n为什么要把这个单独提起来说呢？这是一个历史遗留问题。我们研究所用的Web框架是Flask，一个Python框架，包括前端也是用Flask的Jinja模板。没有Node.js也就意味着无法使用服务端渲染和热替换这两个炫酷的功能。\n\n那么不是基于Node.js的前端程序，还能否使用Redux和React呢？当然可以，我只通过Webpack生成一个js文件，将js文件放进html里面。其他所有的功能都不要。这也是可以的。这也算是结合非Node平台的一个实践经验吧！当然你的包管理还得用NPM。\n\n从另一个方面来说，基于Node.js的前端时代已经来临，如果你拒绝它，将会失去很多，或者寸步难行！\n\n## 获取所有的todos\n\n我们在action中进行http请求和服务端交互，即便是在中间件中执行http请求，其实质也是dispatch的封装。那么这个程序的关键就是action的编写。\n\n实例化Wilddog，定义action类型:\n\nactions.js\n\n```js\nimport Wilddog from 'wilddog/lib/wilddog-node'\n/*\n * action 类型\n */\nexport const GET_TODO_ERROR = 'GET_TODO_ERROR';\nexport const GET_TODO_OK = 'GET_TODO_OK';\nexport const ADD_TODO_ERROR = 'ADD_TODO_ERROR';\nexport const ADD_TODO_OK = 'ADD_TODO_OK';\nexport const REMOVE_TODO_OK = 'REMOVE_TODO_OK';\nexport const REMOVE_TODO_ERROR = 'REMOVE_TODO_ERROR';\n\nlet wilddog=new Wilddog('https://redux-wilddog-todos.wilddogio.com')\n```\n从Wilddog数据库中获取所有的todos，因为Wilddog数据库是树状结构，生成的列表，其实质也是个对象，所以我们需要将其转化为数组：\n\n```js\n    \n    \nexport function getTodo() {\n  return (dispatch,getState)=>{\n\n    wilddog.child('todos').once('value',(snapshot)=>{\n      let obj=snapshot.val();\n      let array=[];\n      for(let key in obj){\n        array.push({key:key,text:obj[key].text})\n      }\n      dispatch({\n        type: GET_TODO_OK,\n        payload: array\n      })\n    },(err)=>{\n      dispatch({\n        type: GET_TODO_ERROR,\n        payload: err\n      })\n    });\n\n\n  }\n}\n```\n\n`wilddog.child('todos').once('value',function)`是获取`'todos'`节点数据的方法。获取到数据后，转化为数组。然后dispatch一个`GET_TODO_OK`，告诉reducer获取数据成功，可以更新state了。数据都装在`payload`中。如果失败，则dispatch一`GET_TODO_ERROR`。\n\n就是这么简单，不用写后台程序，在js中直接操作数据库！\n\n那么在哪里执行这个getTodo呢？你可以在组件渲染后dispatch它，也可以在初始化store后，立即执行它。我用的是后面一种：\n\nindex.js\n\n```js\nimport { getTodo,registerListeners} from './actions'\n\nlet store = createStore();\n\nstore.dispatch(getTodo())\n```    \n\n## 添加新的todo\n\n在action中定义添加todo的方法：\n\nactions.js\n\n```js\nexport function addTodo(text) {\n  return (dispatch,getState)=>{\n\n    wilddog.child('todos').push({\n      text\n    },(err)=>{\n      if(err){dispatch({type:ADD_TODO_ERROR,payload:err})}\n    });\n  }\n}\n```\n\n通过`wilddog.child('todos').push()`方法，直接往数据库中插入数据，第二参数是回调，失败的话，dispatch相应的action。\n\n那么成功后的action在哪执行？我们需要再写一个function，绑定数据变动的回调。其实正常情况下，我们在这个function中就直接写成功后的回调了，主要是因为Wilddog数据库的成功回调不在`push`这个方法中。\n\nactions.js\n\n```js\nexport function registerListeners() {\n  return (dispatch, getState) => {\n\n    wilddog.child('todos').on('child_removed', snapshot => {\n      dispatch({\n        type: REMOVE_TODO_OK,\n        payload: snapshot.key()\n      })\n    });\n\n    wilddog.child('todos').on('child_added', snapshot => dispatch({\n      type: ADD_TODO_OK,\n      payload: Object.assign({},snapshot.val(),{key:snapshot.key()})\n    }));\n\n  };\n}\n```\n`wilddog.child('todos').on('child_added')`这个方法定义了添加todo成功后的回调，我们执行了一个`ADD_TODO_OK` 的action，并把新的todo对象放在`payload`中返回给reducer。\n\n你也看到了，我们顺便把移除todo成功的回调也定义了。\n\n我们在哪执行这个绑定函数呢？就在获取所有todos的后面吧！其实放在组件渲染完也可以！\n\nindex.js\n\n```js\nstore.dispatch(registerListeners())\n```\n\n## 移除指定todo\n\n在action中添加移除todo的方法：\n\nactions.js\n\n```js\nexport function removeTodo(key) {\n  return (dispatch,getState)=>{\n\n    wilddog.child(`todos/${key}`).remove((err)=>{\n      if(err)dispatch({type:REMOVE_TODO_ERROR,payload:err})\n    });\n  }\n}\n```\n通过Wilddog的`remove`方法移除数据库的指定节点。就是这么简单！然后编写失败后的回调以及action！\n\n## 数据库在action中完事，state还需要reducer\n\n数据库我们是操作完啦，不过组件的显示是基于state的，我们还要同步更新state，那么reducer就出场了！\n\nreducers.js\n\n```js    \n    \nimport { combineReducers } from 'redux'\nimport { ADD_TODO_OK, REMOVE_TODO_OK ,GET_TODO_OK} from './actions'\n\nfunction todos(state=[], action) {\n  switch (action.type) {\n    case GET_TODO_OK:\n      return action.payload\n    case ADD_TODO_OK:\n      return [\n        ...state,\n        action.payload\n      ]\n    case REMOVE_TODO_OK:\n      return state.filter((todo)=>todo.key!==action.payload\n      )\n    default:\n      return state\n  }\n}\n\nconst todoApp = combineReducers({\n  todos\n})\n\nexport default todoApp\n```\n\n很简单，如果你还不会，可以去前面几节教程补课。\n\n来个图吧：\n\n![](/css/images/152.jpg)\n\naction操作数据库后，要在回调中返回信号，让reducer更新state，因为只有state变了，组件才会变。state变了，组件自动就变了，至少不用苦逼地操作dom了，还是挺开心的！\n\n## 为什么不提React组件\n\n说了这么多我们的Redux容器算是搞定了，为什么不提组件？不是不提，是要让大家知道，组件和Redux容器的耦合度很低，我们可以完全将它们隔离开来编写，通过一些固定的套路将它们连接起来。什么套路？\n\n  1. 绑定state到props\n  2. 绑定action到props（可选）\n  3. 将store注入，并用provider在顶层包住组件\n\nRedux是个状态容器，只能通过发起action改变state，这种集中管控的做法让状态管理和预测变的简单。组件只是state的展现形式而已！React只是一个界面库而已！\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n","slug":"r2-database","published":1,"updated":"2019-05-01T08:10:30.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmc002ntgytfauad7uo","content":"<p>前面所有的教程都是解读官方的示例代码，是时候我们自己写个连接数据库的Redux程序了！</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/151.gif\" alt=\"\"></p>\n<p>这个例子代码，是我自己写的程序，一个非常简单的todo，但是包含了Redux插件的用法，中间件的用法，连接数据库的方法等多个知识点。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/redux-wilddog-todos\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/redux-wilddog-todos</a></p>\n<p>运行方法：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n<p>手动打开index.html</p>\n<h2 id=\"Wilddog数据库\"><a href=\"#Wilddog数据库\" class=\"headerlink\" title=\"Wilddog数据库\"></a>Wilddog数据库</h2><p>作为一名曾经的Angular开发者，我非常喜欢用Firebase来做自己的数据库，并结合Angular实现酷炫的”三向数据绑定”。Wilddog是中国的”Firebase”，不仅语法兼容，而且国内速度更快。</p>\n<p>下面的程序都是基于Wilddog和Angular的程序，也用了我曾经的最爱Requirejs，有兴趣的同学可以看看，顺便给我点star哈哈！</p>\n<p><a href=\"https://github.com/lewis617/wild-angular-seed\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/wild-angular-seed</a></p>\n<p><a href=\"https://github.com/lewis617/daily-task\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/daily-task</a></p>\n<p>如今写React程序，仍然可以使用Wilddog或者Firebase，不仅不用配置数据库服务，也不用写数据库增删改查的API程序了，可以让我们前端工程师专注于写前端程序！</p>\n<p><a href=\"https://www.wilddog.com/\" target=\"_blank\" rel=\"noopener\">https://www.wilddog.com/</a></p>\n<h2 id=\"Redux的Chrome插件\"><a href=\"#Redux的Chrome插件\" class=\"headerlink\" title=\"Redux的Chrome插件\"></a>Redux的Chrome插件</h2><p>本程序也用到了Redux的chrome插件，可以帮助我们自动生成Redux的devtool界面，非常好用啊！只需要在你的程序store注册中，加入一行代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (initialState) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> store = compose(</span><br><span class=\"line\">      applyMiddleware(</span><br><span class=\"line\">          thunk,</span><br><span class=\"line\">          createLogger()</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      <span class=\"built_in\">window</span>.devToolsExtension ? <span class=\"built_in\">window</span>.devToolsExtension() : <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> f</span><br><span class=\"line\">  )(createStore)(reducers, initialState);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> store;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>就是这行代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.devToolsExtension ? <span class=\"built_in\">window</span>.devToolsExtension() : <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> f</span><br></pre></td></tr></table></figure>\n<p>安装方法，就是去chrome的市场搜索Redux关键字就可以了！</p>\n<h2 id=\"没有服务端渲染和热替换\"><a href=\"#没有服务端渲染和热替换\" class=\"headerlink\" title=\"没有服务端渲染和热替换\"></a>没有服务端渲染和热替换</h2><p>为什么要把这个单独提起来说呢？这是一个历史遗留问题。我们研究所用的Web框架是Flask，一个Python框架，包括前端也是用Flask的Jinja模板。没有Node.js也就意味着无法使用服务端渲染和热替换这两个炫酷的功能。</p>\n<p>那么不是基于Node.js的前端程序，还能否使用Redux和React呢？当然可以，我只通过Webpack生成一个js文件，将js文件放进html里面。其他所有的功能都不要。这也是可以的。这也算是结合非Node平台的一个实践经验吧！当然你的包管理还得用NPM。</p>\n<p>从另一个方面来说，基于Node.js的前端时代已经来临，如果你拒绝它，将会失去很多，或者寸步难行！</p>\n<h2 id=\"获取所有的todos\"><a href=\"#获取所有的todos\" class=\"headerlink\" title=\"获取所有的todos\"></a>获取所有的todos</h2><p>我们在action中进行http请求和服务端交互，即便是在中间件中执行http请求，其实质也是dispatch的封装。那么这个程序的关键就是action的编写。</p>\n<p>实例化Wilddog，定义action类型:</p>\n<p>actions.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Wilddog <span class=\"keyword\">from</span> <span class=\"string\">'wilddog/lib/wilddog-node'</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * action 类型</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> GET_TODO_ERROR = <span class=\"string\">'GET_TODO_ERROR'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> GET_TODO_OK = <span class=\"string\">'GET_TODO_OK'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD_TODO_ERROR = <span class=\"string\">'ADD_TODO_ERROR'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD_TODO_OK = <span class=\"string\">'ADD_TODO_OK'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> REMOVE_TODO_OK = <span class=\"string\">'REMOVE_TODO_OK'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> REMOVE_TODO_ERROR = <span class=\"string\">'REMOVE_TODO_ERROR'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> wilddog=<span class=\"keyword\">new</span> Wilddog(<span class=\"string\">'https://redux-wilddog-todos.wilddogio.com'</span>)</span><br></pre></td></tr></table></figure>\n<p>从Wilddog数据库中获取所有的todos，因为Wilddog数据库是树状结构，生成的列表，其实质也是个对象，所以我们需要将其转化为数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTodo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch,getState</span>)=&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    wilddog.child(<span class=\"string\">'todos'</span>).once(<span class=\"string\">'value'</span>,(snapshot)=&gt;&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> obj=snapshot.val();</span><br><span class=\"line\">      <span class=\"keyword\">let</span> array=[];</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">        array.push(&#123;<span class=\"attr\">key</span>:key,<span class=\"attr\">text</span>:obj[key].text&#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">        type: GET_TODO_OK,</span><br><span class=\"line\">        payload: array</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,(err)=&gt;&#123;</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">        type: GET_TODO_ERROR,</span><br><span class=\"line\">        payload: err</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>wilddog.child(&#39;todos&#39;).once(&#39;value&#39;,function)</code>是获取<code>&#39;todos&#39;</code>节点数据的方法。获取到数据后，转化为数组。然后dispatch一个<code>GET_TODO_OK</code>，告诉reducer获取数据成功，可以更新state了。数据都装在<code>payload</code>中。如果失败，则dispatch一<code>GET_TODO_ERROR</code>。</p>\n<p>就是这么简单，不用写后台程序，在js中直接操作数据库！</p>\n<p>那么在哪里执行这个getTodo呢？你可以在组件渲染后dispatch它，也可以在初始化store后，立即执行它。我用的是后面一种：</p>\n<p>index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; getTodo,registerListeners&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore();</span><br><span class=\"line\"></span><br><span class=\"line\">store.dispatch(getTodo())</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`    </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">## 添加新的todo</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">在action中定义添加todo的方法：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">actions.js</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch,getState</span>)=&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    wilddog.child(<span class=\"string\">'todos'</span>).push(&#123;</span><br><span class=\"line\">      text</span><br><span class=\"line\">    &#125;,(err)=&gt;&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(err)&#123;dispatch(&#123;<span class=\"attr\">type</span>:ADD_TODO_ERROR,<span class=\"attr\">payload</span>:err&#125;)&#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>wilddog.child(&#39;todos&#39;).push()</code>方法，直接往数据库中插入数据，第二参数是回调，失败的话，dispatch相应的action。</p>\n<p>那么成功后的action在哪执行？我们需要再写一个function，绑定数据变动的回调。其实正常情况下，我们在这个function中就直接写成功后的回调了，主要是因为Wilddog数据库的成功回调不在<code>push</code>这个方法中。</p>\n<p>actions.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerListeners</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    wilddog.child(<span class=\"string\">'todos'</span>).on(<span class=\"string\">'child_removed'</span>, snapshot =&gt; &#123;</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">        type: REMOVE_TODO_OK,</span><br><span class=\"line\">        payload: snapshot.key()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    wilddog.child(<span class=\"string\">'todos'</span>).on(<span class=\"string\">'child_added'</span>, snapshot =&gt; dispatch(&#123;</span><br><span class=\"line\">      type: ADD_TODO_OK,</span><br><span class=\"line\">      payload: <span class=\"built_in\">Object</span>.assign(&#123;&#125;,snapshot.val(),&#123;<span class=\"attr\">key</span>:snapshot.key()&#125;)</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>wilddog.child(&#39;todos&#39;).on(&#39;child_added&#39;)</code>这个方法定义了添加todo成功后的回调，我们执行了一个<code>ADD_TODO_OK</code> 的action，并把新的todo对象放在<code>payload</code>中返回给reducer。</p>\n<p>你也看到了，我们顺便把移除todo成功的回调也定义了。</p>\n<p>我们在哪执行这个绑定函数呢？就在获取所有todos的后面吧！其实放在组件渲染完也可以！</p>\n<p>index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(registerListeners())</span><br></pre></td></tr></table></figure>\n<h2 id=\"移除指定todo\"><a href=\"#移除指定todo\" class=\"headerlink\" title=\"移除指定todo\"></a>移除指定todo</h2><p>在action中添加移除todo的方法：</p>\n<p>actions.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeTodo</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch,getState</span>)=&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    wilddog.child(<span class=\"string\">`todos/<span class=\"subst\">$&#123;key&#125;</span>`</span>).remove(<span class=\"function\">(<span class=\"params\">err</span>)=&gt;</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(err)dispatch(&#123;<span class=\"attr\">type</span>:REMOVE_TODO_ERROR,<span class=\"attr\">payload</span>:err&#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过Wilddog的<code>remove</code>方法移除数据库的指定节点。就是这么简单！然后编写失败后的回调以及action！</p>\n<h2 id=\"数据库在action中完事，state还需要reducer\"><a href=\"#数据库在action中完事，state还需要reducer\" class=\"headerlink\" title=\"数据库在action中完事，state还需要reducer\"></a>数据库在action中完事，state还需要reducer</h2><p>数据库我们是操作完啦，不过组件的显示是基于state的，我们还要同步更新state，那么reducer就出场了！</p>\n<p>reducers.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ADD_TODO_OK, REMOVE_TODO_OK ,GET_TODO_OK&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todos</span>(<span class=\"params\">state=[], action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> GET_TODO_OK:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> action.payload</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ADD_TODO_OK:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        action.payload</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    <span class=\"keyword\">case</span> REMOVE_TODO_OK:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.filter(<span class=\"function\">(<span class=\"params\">todo</span>)=&gt;</span>todo.key!==action.payload</span><br><span class=\"line\">      )</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todoApp = combineReducers(&#123;</span><br><span class=\"line\">  todos</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todoApp</span><br></pre></td></tr></table></figure>\n<p>很简单，如果你还不会，可以去前面几节教程补课。</p>\n<p>来个图吧：</p>\n<p><img src=\"/css/images/152.jpg\" alt=\"\"></p>\n<p>action操作数据库后，要在回调中返回信号，让reducer更新state，因为只有state变了，组件才会变。state变了，组件自动就变了，至少不用苦逼地操作dom了，还是挺开心的！</p>\n<h2 id=\"为什么不提React组件\"><a href=\"#为什么不提React组件\" class=\"headerlink\" title=\"为什么不提React组件\"></a>为什么不提React组件</h2><p>说了这么多我们的Redux容器算是搞定了，为什么不提组件？不是不提，是要让大家知道，组件和Redux容器的耦合度很低，我们可以完全将它们隔离开来编写，通过一些固定的套路将它们连接起来。什么套路？</p>\n<ol>\n<li>绑定state到props</li>\n<li>绑定action到props（可选）</li>\n<li>将store注入，并用provider在顶层包住组件</li>\n</ol>\n<p>Redux是个状态容器，只能通过发起action改变state，这种集中管控的做法让状态管理和预测变的简单。组件只是state的展现形式而已！React只是一个界面库而已！</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>\n","site":{"data":{}},"excerpt":"<p>前面所有的教程都是解读官方的示例代码，是时候我们自己写个连接数据库的Redux程序了！</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/151.gif\" alt=\"\"></p>\n<p>这个例子代码，是我自己写的程序，一个非常简单的todo，但是包含了Redux插件的用法，中间件的用法，连接数据库的方法等多个知识点。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/redux-wilddog-todos\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/redux-wilddog-todos</a></p>\n<p>运行方法：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n<p>手动打开index.html</p>\n<h2 id=\"Wilddog数据库\"><a href=\"#Wilddog数据库\" class=\"headerlink\" title=\"Wilddog数据库\"></a>Wilddog数据库</h2><p>作为一名曾经的Angular开发者，我非常喜欢用Firebase来做自己的数据库，并结合Angular实现酷炫的”三向数据绑定”。Wilddog是中国的”Firebase”，不仅语法兼容，而且国内速度更快。</p>\n<p>下面的程序都是基于Wilddog和Angular的程序，也用了我曾经的最爱Requirejs，有兴趣的同学可以看看，顺便给我点star哈哈！</p>\n<p><a href=\"https://github.com/lewis617/wild-angular-seed\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/wild-angular-seed</a></p>\n<p><a href=\"https://github.com/lewis617/daily-task\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/daily-task</a></p>\n<p>如今写React程序，仍然可以使用Wilddog或者Firebase，不仅不用配置数据库服务，也不用写数据库增删改查的API程序了，可以让我们前端工程师专注于写前端程序！</p>\n<p><a href=\"https://www.wilddog.com/\" target=\"_blank\" rel=\"noopener\">https://www.wilddog.com/</a></p>\n<h2 id=\"Redux的Chrome插件\"><a href=\"#Redux的Chrome插件\" class=\"headerlink\" title=\"Redux的Chrome插件\"></a>Redux的Chrome插件</h2><p>本程序也用到了Redux的chrome插件，可以帮助我们自动生成Redux的devtool界面，非常好用啊！只需要在你的程序store注册中，加入一行代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (initialState) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> store = compose(</span><br><span class=\"line\">      applyMiddleware(</span><br><span class=\"line\">          thunk,</span><br><span class=\"line\">          createLogger()</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      <span class=\"built_in\">window</span>.devToolsExtension ? <span class=\"built_in\">window</span>.devToolsExtension() : <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> f</span><br><span class=\"line\">  )(createStore)(reducers, initialState);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> store;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>就是这行代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.devToolsExtension ? <span class=\"built_in\">window</span>.devToolsExtension() : <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> f</span><br></pre></td></tr></table></figure>\n<p>安装方法，就是去chrome的市场搜索Redux关键字就可以了！</p>\n<h2 id=\"没有服务端渲染和热替换\"><a href=\"#没有服务端渲染和热替换\" class=\"headerlink\" title=\"没有服务端渲染和热替换\"></a>没有服务端渲染和热替换</h2><p>为什么要把这个单独提起来说呢？这是一个历史遗留问题。我们研究所用的Web框架是Flask，一个Python框架，包括前端也是用Flask的Jinja模板。没有Node.js也就意味着无法使用服务端渲染和热替换这两个炫酷的功能。</p>\n<p>那么不是基于Node.js的前端程序，还能否使用Redux和React呢？当然可以，我只通过Webpack生成一个js文件，将js文件放进html里面。其他所有的功能都不要。这也是可以的。这也算是结合非Node平台的一个实践经验吧！当然你的包管理还得用NPM。</p>\n<p>从另一个方面来说，基于Node.js的前端时代已经来临，如果你拒绝它，将会失去很多，或者寸步难行！</p>\n<h2 id=\"获取所有的todos\"><a href=\"#获取所有的todos\" class=\"headerlink\" title=\"获取所有的todos\"></a>获取所有的todos</h2><p>我们在action中进行http请求和服务端交互，即便是在中间件中执行http请求，其实质也是dispatch的封装。那么这个程序的关键就是action的编写。</p>\n<p>实例化Wilddog，定义action类型:</p>\n<p>actions.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Wilddog <span class=\"keyword\">from</span> <span class=\"string\">'wilddog/lib/wilddog-node'</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * action 类型</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> GET_TODO_ERROR = <span class=\"string\">'GET_TODO_ERROR'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> GET_TODO_OK = <span class=\"string\">'GET_TODO_OK'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD_TODO_ERROR = <span class=\"string\">'ADD_TODO_ERROR'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD_TODO_OK = <span class=\"string\">'ADD_TODO_OK'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> REMOVE_TODO_OK = <span class=\"string\">'REMOVE_TODO_OK'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> REMOVE_TODO_ERROR = <span class=\"string\">'REMOVE_TODO_ERROR'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> wilddog=<span class=\"keyword\">new</span> Wilddog(<span class=\"string\">'https://redux-wilddog-todos.wilddogio.com'</span>)</span><br></pre></td></tr></table></figure>\n<p>从Wilddog数据库中获取所有的todos，因为Wilddog数据库是树状结构，生成的列表，其实质也是个对象，所以我们需要将其转化为数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTodo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch,getState</span>)=&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    wilddog.child(<span class=\"string\">'todos'</span>).once(<span class=\"string\">'value'</span>,(snapshot)=&gt;&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> obj=snapshot.val();</span><br><span class=\"line\">      <span class=\"keyword\">let</span> array=[];</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">        array.push(&#123;<span class=\"attr\">key</span>:key,<span class=\"attr\">text</span>:obj[key].text&#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">        type: GET_TODO_OK,</span><br><span class=\"line\">        payload: array</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,(err)=&gt;&#123;</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">        type: GET_TODO_ERROR,</span><br><span class=\"line\">        payload: err</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>wilddog.child(&#39;todos&#39;).once(&#39;value&#39;,function)</code>是获取<code>&#39;todos&#39;</code>节点数据的方法。获取到数据后，转化为数组。然后dispatch一个<code>GET_TODO_OK</code>，告诉reducer获取数据成功，可以更新state了。数据都装在<code>payload</code>中。如果失败，则dispatch一<code>GET_TODO_ERROR</code>。</p>\n<p>就是这么简单，不用写后台程序，在js中直接操作数据库！</p>\n<p>那么在哪里执行这个getTodo呢？你可以在组件渲染后dispatch它，也可以在初始化store后，立即执行它。我用的是后面一种：</p>\n<p>index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; getTodo,registerListeners&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore();</span><br><span class=\"line\"></span><br><span class=\"line\">store.dispatch(getTodo())</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`    </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">## 添加新的todo</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">在action中定义添加todo的方法：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">actions.js</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch,getState</span>)=&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    wilddog.child(<span class=\"string\">'todos'</span>).push(&#123;</span><br><span class=\"line\">      text</span><br><span class=\"line\">    &#125;,(err)=&gt;&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(err)&#123;dispatch(&#123;<span class=\"attr\">type</span>:ADD_TODO_ERROR,<span class=\"attr\">payload</span>:err&#125;)&#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>wilddog.child(&#39;todos&#39;).push()</code>方法，直接往数据库中插入数据，第二参数是回调，失败的话，dispatch相应的action。</p>\n<p>那么成功后的action在哪执行？我们需要再写一个function，绑定数据变动的回调。其实正常情况下，我们在这个function中就直接写成功后的回调了，主要是因为Wilddog数据库的成功回调不在<code>push</code>这个方法中。</p>\n<p>actions.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerListeners</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    wilddog.child(<span class=\"string\">'todos'</span>).on(<span class=\"string\">'child_removed'</span>, snapshot =&gt; &#123;</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">        type: REMOVE_TODO_OK,</span><br><span class=\"line\">        payload: snapshot.key()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    wilddog.child(<span class=\"string\">'todos'</span>).on(<span class=\"string\">'child_added'</span>, snapshot =&gt; dispatch(&#123;</span><br><span class=\"line\">      type: ADD_TODO_OK,</span><br><span class=\"line\">      payload: <span class=\"built_in\">Object</span>.assign(&#123;&#125;,snapshot.val(),&#123;<span class=\"attr\">key</span>:snapshot.key()&#125;)</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>wilddog.child(&#39;todos&#39;).on(&#39;child_added&#39;)</code>这个方法定义了添加todo成功后的回调，我们执行了一个<code>ADD_TODO_OK</code> 的action，并把新的todo对象放在<code>payload</code>中返回给reducer。</p>\n<p>你也看到了，我们顺便把移除todo成功的回调也定义了。</p>\n<p>我们在哪执行这个绑定函数呢？就在获取所有todos的后面吧！其实放在组件渲染完也可以！</p>\n<p>index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(registerListeners())</span><br></pre></td></tr></table></figure>\n<h2 id=\"移除指定todo\"><a href=\"#移除指定todo\" class=\"headerlink\" title=\"移除指定todo\"></a>移除指定todo</h2><p>在action中添加移除todo的方法：</p>\n<p>actions.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeTodo</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch,getState</span>)=&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    wilddog.child(<span class=\"string\">`todos/<span class=\"subst\">$&#123;key&#125;</span>`</span>).remove(<span class=\"function\">(<span class=\"params\">err</span>)=&gt;</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(err)dispatch(&#123;<span class=\"attr\">type</span>:REMOVE_TODO_ERROR,<span class=\"attr\">payload</span>:err&#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过Wilddog的<code>remove</code>方法移除数据库的指定节点。就是这么简单！然后编写失败后的回调以及action！</p>\n<h2 id=\"数据库在action中完事，state还需要reducer\"><a href=\"#数据库在action中完事，state还需要reducer\" class=\"headerlink\" title=\"数据库在action中完事，state还需要reducer\"></a>数据库在action中完事，state还需要reducer</h2><p>数据库我们是操作完啦，不过组件的显示是基于state的，我们还要同步更新state，那么reducer就出场了！</p>\n<p>reducers.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ADD_TODO_OK, REMOVE_TODO_OK ,GET_TODO_OK&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todos</span>(<span class=\"params\">state=[], action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> GET_TODO_OK:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> action.payload</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ADD_TODO_OK:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        action.payload</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    <span class=\"keyword\">case</span> REMOVE_TODO_OK:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.filter(<span class=\"function\">(<span class=\"params\">todo</span>)=&gt;</span>todo.key!==action.payload</span><br><span class=\"line\">      )</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todoApp = combineReducers(&#123;</span><br><span class=\"line\">  todos</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todoApp</span><br></pre></td></tr></table></figure>\n<p>很简单，如果你还不会，可以去前面几节教程补课。</p>\n<p>来个图吧：</p>\n<p><img src=\"/css/images/152.jpg\" alt=\"\"></p>\n<p>action操作数据库后，要在回调中返回信号，让reducer更新state，因为只有state变了，组件才会变。state变了，组件自动就变了，至少不用苦逼地操作dom了，还是挺开心的！</p>\n<h2 id=\"为什么不提React组件\"><a href=\"#为什么不提React组件\" class=\"headerlink\" title=\"为什么不提React组件\"></a>为什么不提React组件</h2><p>说了这么多我们的Redux容器算是搞定了，为什么不提组件？不是不提，是要让大家知道，组件和Redux容器的耦合度很低，我们可以完全将它们隔离开来编写，通过一些固定的套路将它们连接起来。什么套路？</p>\n<ol>\n<li>绑定state到props</li>\n<li>绑定action到props（可选）</li>\n<li>将store注入，并用provider在顶层包住组件</li>\n</ol>\n<p>Redux是个状态容器，只能通过发起action改变state，这种集中管控的做法让状态管理和预测变的简单。组件只是state的展现形式而已！React只是一个界面库而已！</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>"},{"title":"React 与 Redux 教程（七）自定义Redux中间件","date":"2016-02-02T00:20:00.000Z","_content":"\n今天，我们要讲解的是自定义Redux中间件这个知识点。本节内容非常抽象，特别是中间件的定义原理，那多层的函数嵌套和串联，需要极强逻辑思维能力才能完全消化吸收。不过我会多罗嗦几句，所以不用担心。\n\n<!--more-->\n\n# 例子\n\n例子是官方的例子real-world，做的是一个获取github用户、仓库的程序。\n\n![](/css/images/153.jpg)\n\n本例子源代码：\n\nhttps://github.com/lewis617/react-redux-tutorialt/tree/master/redux-examples/real-world\n\n# Redux中间件就是个嵌套函数\n\nRedux中间一共嵌套了三层函数，分别传递了`store`、`next`、`action`这三个参数。是不是想到了函数式编程中的柯里化？\n\n为什么要嵌套函数？为何不在一层函数中传递三个参数，而要在一层函数中传递一个参数，一共传递三层？因为中间件是要多个首尾相连的，对`next`进行一层层的\"加工\"，所以`next`必须独立一层。那么`store`和`action`呢？`store`的话，我们要在中间件顶层放上`store`，因为我们要用`store`的`dispatch`和`getState`两个方法。`action`的话，是因为我们封装了这么多层，其实就是为了作出更高级的`dispatch`方法，但是在高级也是`dispatch`，是`dispatch`，就得接受`action`这个参数。\n\n看我们例子中的代码：\n\nmiddleware/api.js\n\n```js\n// A Redux middleware that interprets actions with CALL_API info specified.\n// Performs the call and promises when such actions are dispatched.\nexport default store => next => action => {\n  const callAPI = action[CALL_API]\n  if (typeof callAPI === 'undefined') {\n    return next(action)\n  }\n\n  let { endpoint } = callAPI\n  const { schema, types } = callAPI\n\n  if (typeof endpoint === 'function') {\n    endpoint = endpoint(store.getState())\n  }\n\n  if (typeof endpoint !== 'string') {\n    throw new Error('Specify a string endpoint URL.')\n  }\n  if (!schema) {\n    throw new Error('Specify one of the exported Schemas.')\n  }\n  if (!Array.isArray(types) || types.length !== 3) {\n    throw new Error('Expected an array of three action types.')\n  }\n  if (!types.every(type => typeof type === 'string')) {\n    throw new Error('Expected action types to be strings.')\n  }\n\n  function actionWith(data) {\n    const finalAction = Object.assign({}, action, data)\n    delete finalAction[CALL_API]\n    return finalAction\n  }\n\n  const [ requestType, successType, failureType ] = types\n  next(actionWith({ type: requestType }))\n\n  return callApi(endpoint, schema).then(\n    response => next(actionWith({\n      response,\n      type: successType\n    })),\n    error => next(actionWith({\n      type: failureType,\n      error: error.message || 'Something bad happened'\n    }))\n  )\n}\n```\n\n例子中，我们用`store => next => action =>`实现了三层函数嵌套。箭头语法很好的代替了丑陋的function嵌套方法。最后指向的那个{}里面，我们就可以写关于`dispatch`的装饰了，不过记得返回`next`，给下一个中间件使用。\n\n# 中间件的执行\n\n嵌套函数也是函数，是函数就要运行。我们知道，js里面，我们用`()`来执行一个函数。那么三层嵌套函数我们要怎么执行呢？写三个`()`呗！`aaa()()()`就可以了。`aaa()`返回了一个函数，`aaa()()`又返回一个函数，`aaa()()()`终于执行完成。\n\n我们来看下，我们编写的中间件是怎么运行的。首先中间件的使用是在`configStore`里面的`applyMiddleware`里面写的。\n\n```js\napplyMiddleware(thunk, api)\n```\n我们看下Redux的源代码：\n\nnode_modules/redux/src/applyMiddleware.js\n\n```js\nexport default function applyMiddleware(...middlewares) {\n  return (createStore) => (reducer, initialState, enhancer) => {\n    var store = createStore(reducer, initialState, enhancer)\n    var dispatch = store.dispatch\n    var chain = []\n\n    var middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action) => dispatch(action)\n    }\n    chain = middlewares.map(middleware => middleware(middlewareAPI))\n    dispatch = compose(...chain)(store.dispatch)\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```\n好短好开心！不过看起来还是挺复杂的，不用担心，不就是个三层嵌套函数嘛，我们先找最外层的执行代码：\n\n```js\nchain = middlewares.map(middleware => middleware(middlewareAPI))\n```\n\n`middlewares`使用展开语法，将我们写进去的中间件，生成一个中间件数组。遍历每个中间件，在中间件最外层执行第一次，也就是参数为`store`那一次。我们发现`store`是`middlewareAPI`。\n\n```js\nvar middlewareAPI = {\n  getState: store.getState,\n  dispatch: (action) => dispatch(action)\n}\n```\n是个对象，包含了我们需要的两个方法，这就够了。\n\n好了，我们开始寻找第二层函数的执行代码：\n\n```js\ndispatch = compose(...chain)(store.dispatch)\n```\n这是什么鬼？`compose`是种函数嵌套的写法，源代码清单就不展示了，我们知道它可以帮我们将嵌套的函数，写成逗号隔开的样子就可以了。有点类似Promise解决回调地狱的做法。都是将嵌套写成平行的样子。\n\n`chain`就是我们的第二层函数，...就是展开语法，用逗号隔开放进`compose`参数里。后面那个`(store.dispatch)`就是入口参数。是个未经任何加工的`dispatch`，这个可怜的家伙进去后，将被我们的中间件层层加工，经历风雨，变成更加牛逼的`dispatch`。\n\n第三层函数的执行代码在哪？不在这里面，因为到了第三层函数，就是新的`dispatch`了，我们要在组件里面使用它，所以第三层函数的执行在组件中。参数是什么？当然是可爱的`action`啊！\n\n# 中间件的连接\n\n我们知道，中间件是可以首尾相连使用的，那么我们如何实现首尾相连？答案就在`next()`，写过express中间件的同学对它一定不陌生。那么Redux中间件的`next()`是个什么鬼？也是个`dispatch`。\n\n我们写中间件时候，一定要写`next()`，当前中间件对`dispatch`加工后返回给后面的中间件继续加工。这也是为什么中间件的顺序有讲究的原因。\n\n# 解读例子中的中间件的业务流程\n\n中间件的原理讲完了，我们来走一遍例子中的中间件业务流程吧！\n\n## 获取指定action\n\n我们在定义action的时候，在`fetchUser`等函数中返回了这些我们需要的东西：\n\nactions/index.js\n\n```js\nimport { CALL_API, Schemas } from '../middleware/api'\n\nexport const USER_REQUEST = 'USER_REQUEST'\nexport const USER_SUCCESS = 'USER_SUCCESS'\nexport const USER_FAILURE = 'USER_FAILURE'\n\n// Fetches a single user from Github API.\n// Relies on the custom API middleware defined in ../middleware/api.js.\nfunction fetchUser(login) {\n  return {\n    [CALL_API]: {\n      types: [ USER_REQUEST, USER_SUCCESS, USER_FAILURE ],\n      endpoint: `users/${login}`,\n      schema: Schemas.USER\n    }\n  }\n}\n\n// Fetches a single user from Github API unless it is cached.\n// Relies on Redux Thunk middleware.\nexport function loadUser(login, requiredFields = []) {\n  return (dispatch, getState) => {\n    const user = getState().entities.users[login]\n    if (user && requiredFields.every(key => user.hasOwnProperty(key))) {\n      return null\n    }\n\n    return dispatch(fetchUser(login))\n  }\n}\n```\n我们也就是指定这些action来进行\"包装的\"。除了`fetchUser`，还有其他的，不列出代码清单了。\n\n我们添加`console.log`来查看action的真正样子：\n\n```js\nconsole.log('当前执行的action:',action);\nconst callAPI = action[CALL_API]\n```\n![](/css/images/154.jpg)\n\n在执行initRoutes的action时候，我们得到了一个包含Symbol的action对象，这就是我们想要的action。\n\n## Symbol\n\nSymbol是什么？上述代码中的`CALL_API`就是Symbol。\n\nmiddleware/api.js\n\n```js    \n// Action key that carries API call info interpreted by this Redux middleware.\nexport const CALL_API = Symbol('Call API')\n```\n\n为什么要用Symbol，为了不冲突，Symbol是个唯一的不变的标识，可以用于对象的key。为了避免冲突而生，这里也可以用字符串来代替，但是不好，\n因为字符串很容易命名冲突，你每次都要想个奇葩的长名字，所以还是用Symbol吧。再罗嗦一句，我们写Object.assign的时候，\n第一个参数设为{},第二个参数设为源，第三个参数设为拓展属性的写法，就是为了兼容包含Symbol的对象。\n\n## 消毒\n\n获取到指定的action后，我们要做一系列的异常处理：\n\nmiddleware/api.js\n\n```js\nif (typeof endpoint === 'function') {\nendpoint = endpoint(store.getState())\n}\n\nif (typeof endpoint !== 'string') {\n  throw new Error('Specify a string endpoint URL.')\n}\nif (!schema) {\n  throw new Error('Specify one of the exported Schemas.')\n}\nif (!Array.isArray(types) || types.length !== 3) {\n  throw new Error('Expected an array of three action types.')\n}\nif (!types.every(type => typeof type === 'string')) {\n  throw new Error('Expected action types to be strings.')\n}\n```\n\n\n比较简单，不罗嗦了。\n\n## 执行请求action\n\n获取完action，也进行过消毒了，可以开始ajax请求了，首先发一个请求action\n\n```js\n    \nfunction actionWith(data) {\n  const finalAction = Object.assign({}, action, data)\n  delete finalAction[CALL_API]\n  return finalAction\n}\n\nconst [ requestType, successType, failureType ] = types\nnext(actionWith({ type: requestType }))\n\n```   \n\n## 执行ajax请求，结束后发出成功或者失败action\n\n```js\n    \nreturn callApi(endpoint, schema).then(\n\tresponse => next(actionWith({\n\t  response,\n\t  type: successType\n\t})),\n\terror => next(actionWith({\n\t  type: failureType,\n\t  error: error.message || 'Something bad happened'\n\t}))\n  )\n```\n    \n\n## 图解流程\n\n本来一个action，经过中间件的加工后，变成了一系列的流程。\n\n![](/css/images/155.jpg)\n\n\n* * *\n\n# 教程示例代码及目录\n\nhttp://www.liuyiqi.cn/2016/12/10/react-redux-tutorial-catalog/\n\n\n\n","source":"_posts/r2-middleware.md","raw":"---\ntitle: React 与 Redux 教程（七）自定义Redux中间件\ndate: 2016-02-02 08:20:00\ntags: [React, Redux]\n---\n\n今天，我们要讲解的是自定义Redux中间件这个知识点。本节内容非常抽象，特别是中间件的定义原理，那多层的函数嵌套和串联，需要极强逻辑思维能力才能完全消化吸收。不过我会多罗嗦几句，所以不用担心。\n\n<!--more-->\n\n# 例子\n\n例子是官方的例子real-world，做的是一个获取github用户、仓库的程序。\n\n![](/css/images/153.jpg)\n\n本例子源代码：\n\nhttps://github.com/lewis617/react-redux-tutorialt/tree/master/redux-examples/real-world\n\n# Redux中间件就是个嵌套函数\n\nRedux中间一共嵌套了三层函数，分别传递了`store`、`next`、`action`这三个参数。是不是想到了函数式编程中的柯里化？\n\n为什么要嵌套函数？为何不在一层函数中传递三个参数，而要在一层函数中传递一个参数，一共传递三层？因为中间件是要多个首尾相连的，对`next`进行一层层的\"加工\"，所以`next`必须独立一层。那么`store`和`action`呢？`store`的话，我们要在中间件顶层放上`store`，因为我们要用`store`的`dispatch`和`getState`两个方法。`action`的话，是因为我们封装了这么多层，其实就是为了作出更高级的`dispatch`方法，但是在高级也是`dispatch`，是`dispatch`，就得接受`action`这个参数。\n\n看我们例子中的代码：\n\nmiddleware/api.js\n\n```js\n// A Redux middleware that interprets actions with CALL_API info specified.\n// Performs the call and promises when such actions are dispatched.\nexport default store => next => action => {\n  const callAPI = action[CALL_API]\n  if (typeof callAPI === 'undefined') {\n    return next(action)\n  }\n\n  let { endpoint } = callAPI\n  const { schema, types } = callAPI\n\n  if (typeof endpoint === 'function') {\n    endpoint = endpoint(store.getState())\n  }\n\n  if (typeof endpoint !== 'string') {\n    throw new Error('Specify a string endpoint URL.')\n  }\n  if (!schema) {\n    throw new Error('Specify one of the exported Schemas.')\n  }\n  if (!Array.isArray(types) || types.length !== 3) {\n    throw new Error('Expected an array of three action types.')\n  }\n  if (!types.every(type => typeof type === 'string')) {\n    throw new Error('Expected action types to be strings.')\n  }\n\n  function actionWith(data) {\n    const finalAction = Object.assign({}, action, data)\n    delete finalAction[CALL_API]\n    return finalAction\n  }\n\n  const [ requestType, successType, failureType ] = types\n  next(actionWith({ type: requestType }))\n\n  return callApi(endpoint, schema).then(\n    response => next(actionWith({\n      response,\n      type: successType\n    })),\n    error => next(actionWith({\n      type: failureType,\n      error: error.message || 'Something bad happened'\n    }))\n  )\n}\n```\n\n例子中，我们用`store => next => action =>`实现了三层函数嵌套。箭头语法很好的代替了丑陋的function嵌套方法。最后指向的那个{}里面，我们就可以写关于`dispatch`的装饰了，不过记得返回`next`，给下一个中间件使用。\n\n# 中间件的执行\n\n嵌套函数也是函数，是函数就要运行。我们知道，js里面，我们用`()`来执行一个函数。那么三层嵌套函数我们要怎么执行呢？写三个`()`呗！`aaa()()()`就可以了。`aaa()`返回了一个函数，`aaa()()`又返回一个函数，`aaa()()()`终于执行完成。\n\n我们来看下，我们编写的中间件是怎么运行的。首先中间件的使用是在`configStore`里面的`applyMiddleware`里面写的。\n\n```js\napplyMiddleware(thunk, api)\n```\n我们看下Redux的源代码：\n\nnode_modules/redux/src/applyMiddleware.js\n\n```js\nexport default function applyMiddleware(...middlewares) {\n  return (createStore) => (reducer, initialState, enhancer) => {\n    var store = createStore(reducer, initialState, enhancer)\n    var dispatch = store.dispatch\n    var chain = []\n\n    var middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action) => dispatch(action)\n    }\n    chain = middlewares.map(middleware => middleware(middlewareAPI))\n    dispatch = compose(...chain)(store.dispatch)\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```\n好短好开心！不过看起来还是挺复杂的，不用担心，不就是个三层嵌套函数嘛，我们先找最外层的执行代码：\n\n```js\nchain = middlewares.map(middleware => middleware(middlewareAPI))\n```\n\n`middlewares`使用展开语法，将我们写进去的中间件，生成一个中间件数组。遍历每个中间件，在中间件最外层执行第一次，也就是参数为`store`那一次。我们发现`store`是`middlewareAPI`。\n\n```js\nvar middlewareAPI = {\n  getState: store.getState,\n  dispatch: (action) => dispatch(action)\n}\n```\n是个对象，包含了我们需要的两个方法，这就够了。\n\n好了，我们开始寻找第二层函数的执行代码：\n\n```js\ndispatch = compose(...chain)(store.dispatch)\n```\n这是什么鬼？`compose`是种函数嵌套的写法，源代码清单就不展示了，我们知道它可以帮我们将嵌套的函数，写成逗号隔开的样子就可以了。有点类似Promise解决回调地狱的做法。都是将嵌套写成平行的样子。\n\n`chain`就是我们的第二层函数，...就是展开语法，用逗号隔开放进`compose`参数里。后面那个`(store.dispatch)`就是入口参数。是个未经任何加工的`dispatch`，这个可怜的家伙进去后，将被我们的中间件层层加工，经历风雨，变成更加牛逼的`dispatch`。\n\n第三层函数的执行代码在哪？不在这里面，因为到了第三层函数，就是新的`dispatch`了，我们要在组件里面使用它，所以第三层函数的执行在组件中。参数是什么？当然是可爱的`action`啊！\n\n# 中间件的连接\n\n我们知道，中间件是可以首尾相连使用的，那么我们如何实现首尾相连？答案就在`next()`，写过express中间件的同学对它一定不陌生。那么Redux中间件的`next()`是个什么鬼？也是个`dispatch`。\n\n我们写中间件时候，一定要写`next()`，当前中间件对`dispatch`加工后返回给后面的中间件继续加工。这也是为什么中间件的顺序有讲究的原因。\n\n# 解读例子中的中间件的业务流程\n\n中间件的原理讲完了，我们来走一遍例子中的中间件业务流程吧！\n\n## 获取指定action\n\n我们在定义action的时候，在`fetchUser`等函数中返回了这些我们需要的东西：\n\nactions/index.js\n\n```js\nimport { CALL_API, Schemas } from '../middleware/api'\n\nexport const USER_REQUEST = 'USER_REQUEST'\nexport const USER_SUCCESS = 'USER_SUCCESS'\nexport const USER_FAILURE = 'USER_FAILURE'\n\n// Fetches a single user from Github API.\n// Relies on the custom API middleware defined in ../middleware/api.js.\nfunction fetchUser(login) {\n  return {\n    [CALL_API]: {\n      types: [ USER_REQUEST, USER_SUCCESS, USER_FAILURE ],\n      endpoint: `users/${login}`,\n      schema: Schemas.USER\n    }\n  }\n}\n\n// Fetches a single user from Github API unless it is cached.\n// Relies on Redux Thunk middleware.\nexport function loadUser(login, requiredFields = []) {\n  return (dispatch, getState) => {\n    const user = getState().entities.users[login]\n    if (user && requiredFields.every(key => user.hasOwnProperty(key))) {\n      return null\n    }\n\n    return dispatch(fetchUser(login))\n  }\n}\n```\n我们也就是指定这些action来进行\"包装的\"。除了`fetchUser`，还有其他的，不列出代码清单了。\n\n我们添加`console.log`来查看action的真正样子：\n\n```js\nconsole.log('当前执行的action:',action);\nconst callAPI = action[CALL_API]\n```\n![](/css/images/154.jpg)\n\n在执行initRoutes的action时候，我们得到了一个包含Symbol的action对象，这就是我们想要的action。\n\n## Symbol\n\nSymbol是什么？上述代码中的`CALL_API`就是Symbol。\n\nmiddleware/api.js\n\n```js    \n// Action key that carries API call info interpreted by this Redux middleware.\nexport const CALL_API = Symbol('Call API')\n```\n\n为什么要用Symbol，为了不冲突，Symbol是个唯一的不变的标识，可以用于对象的key。为了避免冲突而生，这里也可以用字符串来代替，但是不好，\n因为字符串很容易命名冲突，你每次都要想个奇葩的长名字，所以还是用Symbol吧。再罗嗦一句，我们写Object.assign的时候，\n第一个参数设为{},第二个参数设为源，第三个参数设为拓展属性的写法，就是为了兼容包含Symbol的对象。\n\n## 消毒\n\n获取到指定的action后，我们要做一系列的异常处理：\n\nmiddleware/api.js\n\n```js\nif (typeof endpoint === 'function') {\nendpoint = endpoint(store.getState())\n}\n\nif (typeof endpoint !== 'string') {\n  throw new Error('Specify a string endpoint URL.')\n}\nif (!schema) {\n  throw new Error('Specify one of the exported Schemas.')\n}\nif (!Array.isArray(types) || types.length !== 3) {\n  throw new Error('Expected an array of three action types.')\n}\nif (!types.every(type => typeof type === 'string')) {\n  throw new Error('Expected action types to be strings.')\n}\n```\n\n\n比较简单，不罗嗦了。\n\n## 执行请求action\n\n获取完action，也进行过消毒了，可以开始ajax请求了，首先发一个请求action\n\n```js\n    \nfunction actionWith(data) {\n  const finalAction = Object.assign({}, action, data)\n  delete finalAction[CALL_API]\n  return finalAction\n}\n\nconst [ requestType, successType, failureType ] = types\nnext(actionWith({ type: requestType }))\n\n```   \n\n## 执行ajax请求，结束后发出成功或者失败action\n\n```js\n    \nreturn callApi(endpoint, schema).then(\n\tresponse => next(actionWith({\n\t  response,\n\t  type: successType\n\t})),\n\terror => next(actionWith({\n\t  type: failureType,\n\t  error: error.message || 'Something bad happened'\n\t}))\n  )\n```\n    \n\n## 图解流程\n\n本来一个action，经过中间件的加工后，变成了一系列的流程。\n\n![](/css/images/155.jpg)\n\n\n* * *\n\n# 教程示例代码及目录\n\nhttp://www.liuyiqi.cn/2016/12/10/react-redux-tutorial-catalog/\n\n\n\n","slug":"r2-middleware","published":1,"updated":"2019-05-01T08:10:30.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmd002otgytcjvygyxg","content":"<p>今天，我们要讲解的是自定义Redux中间件这个知识点。本节内容非常抽象，特别是中间件的定义原理，那多层的函数嵌套和串联，需要极强逻辑思维能力才能完全消化吸收。不过我会多罗嗦几句，所以不用担心。</p>\n<a id=\"more\"></a>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p>例子是官方的例子real-world，做的是一个获取github用户、仓库的程序。</p>\n<p><img src=\"/css/images/153.jpg\" alt=\"\"></p>\n<p>本例子源代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorialt/tree/master/redux-examples/real-world\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorialt/tree/master/redux-examples/real-world</a></p>\n<h1 id=\"Redux中间件就是个嵌套函数\"><a href=\"#Redux中间件就是个嵌套函数\" class=\"headerlink\" title=\"Redux中间件就是个嵌套函数\"></a>Redux中间件就是个嵌套函数</h1><p>Redux中间一共嵌套了三层函数，分别传递了<code>store</code>、<code>next</code>、<code>action</code>这三个参数。是不是想到了函数式编程中的柯里化？</p>\n<p>为什么要嵌套函数？为何不在一层函数中传递三个参数，而要在一层函数中传递一个参数，一共传递三层？因为中间件是要多个首尾相连的，对<code>next</code>进行一层层的”加工”，所以<code>next</code>必须独立一层。那么<code>store</code>和<code>action</code>呢？<code>store</code>的话，我们要在中间件顶层放上<code>store</code>，因为我们要用<code>store</code>的<code>dispatch</code>和<code>getState</code>两个方法。<code>action</code>的话，是因为我们封装了这么多层，其实就是为了作出更高级的<code>dispatch</code>方法，但是在高级也是<code>dispatch</code>，是<code>dispatch</code>，就得接受<code>action</code>这个参数。</p>\n<p>看我们例子中的代码：</p>\n<p>middleware/api.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A Redux middleware that interprets actions with CALL_API info specified.</span></span><br><span class=\"line\"><span class=\"comment\">// Performs the call and promises when such actions are dispatched.</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store =&gt; <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> callAPI = action[CALL_API]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callAPI === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next(action)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; endpoint &#125; = callAPI</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; schema, types &#125; = callAPI</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> endpoint === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    endpoint = endpoint(store.getState())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> endpoint !== <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Specify a string endpoint URL.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!schema) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Specify one of the exported Schemas.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">Array</span>.isArray(types) || types.length !== <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected an array of three action types.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!types.every(<span class=\"function\"><span class=\"params\">type</span> =&gt;</span> <span class=\"keyword\">typeof</span> type === <span class=\"string\">'string'</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected action types to be strings.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">actionWith</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> finalAction = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, action, data)</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> finalAction[CALL_API]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> finalAction</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [ requestType, successType, failureType ] = types</span><br><span class=\"line\">  next(actionWith(&#123; <span class=\"attr\">type</span>: requestType &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> callApi(endpoint, schema).then(</span><br><span class=\"line\">    response =&gt; next(actionWith(&#123;</span><br><span class=\"line\">      response,</span><br><span class=\"line\">      type: successType</span><br><span class=\"line\">    &#125;)),</span><br><span class=\"line\">    error =&gt; next(actionWith(&#123;</span><br><span class=\"line\">      type: failureType,</span><br><span class=\"line\">      error: error.message || <span class=\"string\">'Something bad happened'</span></span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例子中，我们用<code>store =&gt; next =&gt; action =&gt;</code>实现了三层函数嵌套。箭头语法很好的代替了丑陋的function嵌套方法。最后指向的那个{}里面，我们就可以写关于<code>dispatch</code>的装饰了，不过记得返回<code>next</code>，给下一个中间件使用。</p>\n<h1 id=\"中间件的执行\"><a href=\"#中间件的执行\" class=\"headerlink\" title=\"中间件的执行\"></a>中间件的执行</h1><p>嵌套函数也是函数，是函数就要运行。我们知道，js里面，我们用<code>()</code>来执行一个函数。那么三层嵌套函数我们要怎么执行呢？写三个<code>()</code>呗！<code>aaa()()()</code>就可以了。<code>aaa()</code>返回了一个函数，<code>aaa()()</code>又返回一个函数，<code>aaa()()()</code>终于执行完成。</p>\n<p>我们来看下，我们编写的中间件是怎么运行的。首先中间件的使用是在<code>configStore</code>里面的<code>applyMiddleware</code>里面写的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applyMiddleware(thunk, api)</span><br></pre></td></tr></table></figure>\n<p>我们看下Redux的源代码：</p>\n<p>node_modules/redux/src/applyMiddleware.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">createStore</span>) =&gt;</span> (reducer, initialState, enhancer) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> store = createStore(reducer, initialState, enhancer)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dispatch = store.dispatch</span><br><span class=\"line\">    <span class=\"keyword\">var</span> chain = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> middlewareAPI = &#123;</span><br><span class=\"line\">      getState: store.getState,</span><br><span class=\"line\">      dispatch: <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> dispatch(action)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class=\"line\">    dispatch = compose(...chain)(store.dispatch)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好短好开心！不过看起来还是挺复杂的，不用担心，不就是个三层嵌套函数嘛，我们先找最外层的执行代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br></pre></td></tr></table></figure>\n<p><code>middlewares</code>使用展开语法，将我们写进去的中间件，生成一个中间件数组。遍历每个中间件，在中间件最外层执行第一次，也就是参数为<code>store</code>那一次。我们发现<code>store</code>是<code>middlewareAPI</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> middlewareAPI = &#123;</span><br><span class=\"line\">  getState: store.getState,</span><br><span class=\"line\">  dispatch: <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> dispatch(action)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是个对象，包含了我们需要的两个方法，这就够了。</p>\n<p>好了，我们开始寻找第二层函数的执行代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch = compose(...chain)(store.dispatch)</span><br></pre></td></tr></table></figure>\n<p>这是什么鬼？<code>compose</code>是种函数嵌套的写法，源代码清单就不展示了，我们知道它可以帮我们将嵌套的函数，写成逗号隔开的样子就可以了。有点类似Promise解决回调地狱的做法。都是将嵌套写成平行的样子。</p>\n<p><code>chain</code>就是我们的第二层函数，…就是展开语法，用逗号隔开放进<code>compose</code>参数里。后面那个<code>(store.dispatch)</code>就是入口参数。是个未经任何加工的<code>dispatch</code>，这个可怜的家伙进去后，将被我们的中间件层层加工，经历风雨，变成更加牛逼的<code>dispatch</code>。</p>\n<p>第三层函数的执行代码在哪？不在这里面，因为到了第三层函数，就是新的<code>dispatch</code>了，我们要在组件里面使用它，所以第三层函数的执行在组件中。参数是什么？当然是可爱的<code>action</code>啊！</p>\n<h1 id=\"中间件的连接\"><a href=\"#中间件的连接\" class=\"headerlink\" title=\"中间件的连接\"></a>中间件的连接</h1><p>我们知道，中间件是可以首尾相连使用的，那么我们如何实现首尾相连？答案就在<code>next()</code>，写过express中间件的同学对它一定不陌生。那么Redux中间件的<code>next()</code>是个什么鬼？也是个<code>dispatch</code>。</p>\n<p>我们写中间件时候，一定要写<code>next()</code>，当前中间件对<code>dispatch</code>加工后返回给后面的中间件继续加工。这也是为什么中间件的顺序有讲究的原因。</p>\n<h1 id=\"解读例子中的中间件的业务流程\"><a href=\"#解读例子中的中间件的业务流程\" class=\"headerlink\" title=\"解读例子中的中间件的业务流程\"></a>解读例子中的中间件的业务流程</h1><p>中间件的原理讲完了，我们来走一遍例子中的中间件业务流程吧！</p>\n<h2 id=\"获取指定action\"><a href=\"#获取指定action\" class=\"headerlink\" title=\"获取指定action\"></a>获取指定action</h2><p>我们在定义action的时候，在<code>fetchUser</code>等函数中返回了这些我们需要的东西：</p>\n<p>actions/index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; CALL_API, Schemas &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../middleware/api'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> USER_REQUEST = <span class=\"string\">'USER_REQUEST'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> USER_SUCCESS = <span class=\"string\">'USER_SUCCESS'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> USER_FAILURE = <span class=\"string\">'USER_FAILURE'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Fetches a single user from Github API.</span></span><br><span class=\"line\"><span class=\"comment\">// Relies on the custom API middleware defined in ../middleware/api.js.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchUser</span>(<span class=\"params\">login</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    [CALL_API]: &#123;</span><br><span class=\"line\">      types: [ USER_REQUEST, USER_SUCCESS, USER_FAILURE ],</span><br><span class=\"line\">      endpoint: <span class=\"string\">`users/<span class=\"subst\">$&#123;login&#125;</span>`</span>,</span><br><span class=\"line\">      schema: Schemas.USER</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Fetches a single user from Github API unless it is cached.</span></span><br><span class=\"line\"><span class=\"comment\">// Relies on Redux Thunk middleware.</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadUser</span>(<span class=\"params\">login, requiredFields = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> user = getState().entities.users[login]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user &amp;&amp; requiredFields.every(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> user.hasOwnProperty(key))) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dispatch(fetchUser(login))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们也就是指定这些action来进行”包装的”。除了<code>fetchUser</code>，还有其他的，不列出代码清单了。</p>\n<p>我们添加<code>console.log</code>来查看action的真正样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'当前执行的action:'</span>,action);</span><br><span class=\"line\"><span class=\"keyword\">const</span> callAPI = action[CALL_API]</span><br></pre></td></tr></table></figure>\n<p><img src=\"/css/images/154.jpg\" alt=\"\"></p>\n<p>在执行initRoutes的action时候，我们得到了一个包含Symbol的action对象，这就是我们想要的action。</p>\n<h2 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h2><p>Symbol是什么？上述代码中的<code>CALL_API</code>就是Symbol。</p>\n<p>middleware/api.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Action key that carries API call info interpreted by this Redux middleware.</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> CALL_API = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'Call API'</span>)</span><br></pre></td></tr></table></figure>\n<p>为什么要用Symbol，为了不冲突，Symbol是个唯一的不变的标识，可以用于对象的key。为了避免冲突而生，这里也可以用字符串来代替，但是不好，<br>因为字符串很容易命名冲突，你每次都要想个奇葩的长名字，所以还是用Symbol吧。再罗嗦一句，我们写Object.assign的时候，<br>第一个参数设为{},第二个参数设为源，第三个参数设为拓展属性的写法，就是为了兼容包含Symbol的对象。</p>\n<h2 id=\"消毒\"><a href=\"#消毒\" class=\"headerlink\" title=\"消毒\"></a>消毒</h2><p>获取到指定的action后，我们要做一系列的异常处理：</p>\n<p>middleware/api.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> endpoint === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">endpoint = endpoint(store.getState())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> endpoint !== <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Specify a string endpoint URL.'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!schema) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Specify one of the exported Schemas.'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"built_in\">Array</span>.isArray(types) || types.length !== <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected an array of three action types.'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!types.every(<span class=\"function\"><span class=\"params\">type</span> =&gt;</span> <span class=\"keyword\">typeof</span> type === <span class=\"string\">'string'</span>)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected action types to be strings.'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比较简单，不罗嗦了。</p>\n<h2 id=\"执行请求action\"><a href=\"#执行请求action\" class=\"headerlink\" title=\"执行请求action\"></a>执行请求action</h2><p>获取完action，也进行过消毒了，可以开始ajax请求了，首先发一个请求action</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">actionWith</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalAction = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, action, data)</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> finalAction[CALL_API]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> finalAction</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> [ requestType, successType, failureType ] = types</span><br><span class=\"line\">next(actionWith(&#123; <span class=\"attr\">type</span>: requestType &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">## 执行ajax请求，结束后发出成功或者失败action</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">return</span> callApi(endpoint, schema).then(</span><br><span class=\"line\">\tresponse =&gt; next(actionWith(&#123;</span><br><span class=\"line\">\t  response,</span><br><span class=\"line\">\t  type: successType</span><br><span class=\"line\">\t&#125;)),</span><br><span class=\"line\">\terror =&gt; next(actionWith(&#123;</span><br><span class=\"line\">\t  type: failureType,</span><br><span class=\"line\">\t  error: error.message || <span class=\"string\">'Something bad happened'</span></span><br><span class=\"line\">\t&#125;))</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n<h2 id=\"图解流程\"><a href=\"#图解流程\" class=\"headerlink\" title=\"图解流程\"></a>图解流程</h2><p>本来一个action，经过中间件的加工后，变成了一系列的流程。</p>\n<p><img src=\"/css/images/155.jpg\" alt=\"\"></p>\n<hr>\n<h1 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h1><p><a href=\"http://www.liuyiqi.cn/2016/12/10/react-redux-tutorial-catalog/\">http://www.liuyiqi.cn/2016/12/10/react-redux-tutorial-catalog/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲解的是自定义Redux中间件这个知识点。本节内容非常抽象，特别是中间件的定义原理，那多层的函数嵌套和串联，需要极强逻辑思维能力才能完全消化吸收。不过我会多罗嗦几句，所以不用担心。</p>","more":"<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p>例子是官方的例子real-world，做的是一个获取github用户、仓库的程序。</p>\n<p><img src=\"/css/images/153.jpg\" alt=\"\"></p>\n<p>本例子源代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorialt/tree/master/redux-examples/real-world\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorialt/tree/master/redux-examples/real-world</a></p>\n<h1 id=\"Redux中间件就是个嵌套函数\"><a href=\"#Redux中间件就是个嵌套函数\" class=\"headerlink\" title=\"Redux中间件就是个嵌套函数\"></a>Redux中间件就是个嵌套函数</h1><p>Redux中间一共嵌套了三层函数，分别传递了<code>store</code>、<code>next</code>、<code>action</code>这三个参数。是不是想到了函数式编程中的柯里化？</p>\n<p>为什么要嵌套函数？为何不在一层函数中传递三个参数，而要在一层函数中传递一个参数，一共传递三层？因为中间件是要多个首尾相连的，对<code>next</code>进行一层层的”加工”，所以<code>next</code>必须独立一层。那么<code>store</code>和<code>action</code>呢？<code>store</code>的话，我们要在中间件顶层放上<code>store</code>，因为我们要用<code>store</code>的<code>dispatch</code>和<code>getState</code>两个方法。<code>action</code>的话，是因为我们封装了这么多层，其实就是为了作出更高级的<code>dispatch</code>方法，但是在高级也是<code>dispatch</code>，是<code>dispatch</code>，就得接受<code>action</code>这个参数。</p>\n<p>看我们例子中的代码：</p>\n<p>middleware/api.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A Redux middleware that interprets actions with CALL_API info specified.</span></span><br><span class=\"line\"><span class=\"comment\">// Performs the call and promises when such actions are dispatched.</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store =&gt; <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> callAPI = action[CALL_API]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callAPI === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next(action)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; endpoint &#125; = callAPI</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; schema, types &#125; = callAPI</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> endpoint === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    endpoint = endpoint(store.getState())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> endpoint !== <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Specify a string endpoint URL.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!schema) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Specify one of the exported Schemas.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">Array</span>.isArray(types) || types.length !== <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected an array of three action types.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!types.every(<span class=\"function\"><span class=\"params\">type</span> =&gt;</span> <span class=\"keyword\">typeof</span> type === <span class=\"string\">'string'</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected action types to be strings.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">actionWith</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> finalAction = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, action, data)</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> finalAction[CALL_API]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> finalAction</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [ requestType, successType, failureType ] = types</span><br><span class=\"line\">  next(actionWith(&#123; <span class=\"attr\">type</span>: requestType &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> callApi(endpoint, schema).then(</span><br><span class=\"line\">    response =&gt; next(actionWith(&#123;</span><br><span class=\"line\">      response,</span><br><span class=\"line\">      type: successType</span><br><span class=\"line\">    &#125;)),</span><br><span class=\"line\">    error =&gt; next(actionWith(&#123;</span><br><span class=\"line\">      type: failureType,</span><br><span class=\"line\">      error: error.message || <span class=\"string\">'Something bad happened'</span></span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例子中，我们用<code>store =&gt; next =&gt; action =&gt;</code>实现了三层函数嵌套。箭头语法很好的代替了丑陋的function嵌套方法。最后指向的那个{}里面，我们就可以写关于<code>dispatch</code>的装饰了，不过记得返回<code>next</code>，给下一个中间件使用。</p>\n<h1 id=\"中间件的执行\"><a href=\"#中间件的执行\" class=\"headerlink\" title=\"中间件的执行\"></a>中间件的执行</h1><p>嵌套函数也是函数，是函数就要运行。我们知道，js里面，我们用<code>()</code>来执行一个函数。那么三层嵌套函数我们要怎么执行呢？写三个<code>()</code>呗！<code>aaa()()()</code>就可以了。<code>aaa()</code>返回了一个函数，<code>aaa()()</code>又返回一个函数，<code>aaa()()()</code>终于执行完成。</p>\n<p>我们来看下，我们编写的中间件是怎么运行的。首先中间件的使用是在<code>configStore</code>里面的<code>applyMiddleware</code>里面写的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applyMiddleware(thunk, api)</span><br></pre></td></tr></table></figure>\n<p>我们看下Redux的源代码：</p>\n<p>node_modules/redux/src/applyMiddleware.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">createStore</span>) =&gt;</span> (reducer, initialState, enhancer) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> store = createStore(reducer, initialState, enhancer)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dispatch = store.dispatch</span><br><span class=\"line\">    <span class=\"keyword\">var</span> chain = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> middlewareAPI = &#123;</span><br><span class=\"line\">      getState: store.getState,</span><br><span class=\"line\">      dispatch: <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> dispatch(action)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class=\"line\">    dispatch = compose(...chain)(store.dispatch)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好短好开心！不过看起来还是挺复杂的，不用担心，不就是个三层嵌套函数嘛，我们先找最外层的执行代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br></pre></td></tr></table></figure>\n<p><code>middlewares</code>使用展开语法，将我们写进去的中间件，生成一个中间件数组。遍历每个中间件，在中间件最外层执行第一次，也就是参数为<code>store</code>那一次。我们发现<code>store</code>是<code>middlewareAPI</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> middlewareAPI = &#123;</span><br><span class=\"line\">  getState: store.getState,</span><br><span class=\"line\">  dispatch: <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> dispatch(action)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是个对象，包含了我们需要的两个方法，这就够了。</p>\n<p>好了，我们开始寻找第二层函数的执行代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch = compose(...chain)(store.dispatch)</span><br></pre></td></tr></table></figure>\n<p>这是什么鬼？<code>compose</code>是种函数嵌套的写法，源代码清单就不展示了，我们知道它可以帮我们将嵌套的函数，写成逗号隔开的样子就可以了。有点类似Promise解决回调地狱的做法。都是将嵌套写成平行的样子。</p>\n<p><code>chain</code>就是我们的第二层函数，…就是展开语法，用逗号隔开放进<code>compose</code>参数里。后面那个<code>(store.dispatch)</code>就是入口参数。是个未经任何加工的<code>dispatch</code>，这个可怜的家伙进去后，将被我们的中间件层层加工，经历风雨，变成更加牛逼的<code>dispatch</code>。</p>\n<p>第三层函数的执行代码在哪？不在这里面，因为到了第三层函数，就是新的<code>dispatch</code>了，我们要在组件里面使用它，所以第三层函数的执行在组件中。参数是什么？当然是可爱的<code>action</code>啊！</p>\n<h1 id=\"中间件的连接\"><a href=\"#中间件的连接\" class=\"headerlink\" title=\"中间件的连接\"></a>中间件的连接</h1><p>我们知道，中间件是可以首尾相连使用的，那么我们如何实现首尾相连？答案就在<code>next()</code>，写过express中间件的同学对它一定不陌生。那么Redux中间件的<code>next()</code>是个什么鬼？也是个<code>dispatch</code>。</p>\n<p>我们写中间件时候，一定要写<code>next()</code>，当前中间件对<code>dispatch</code>加工后返回给后面的中间件继续加工。这也是为什么中间件的顺序有讲究的原因。</p>\n<h1 id=\"解读例子中的中间件的业务流程\"><a href=\"#解读例子中的中间件的业务流程\" class=\"headerlink\" title=\"解读例子中的中间件的业务流程\"></a>解读例子中的中间件的业务流程</h1><p>中间件的原理讲完了，我们来走一遍例子中的中间件业务流程吧！</p>\n<h2 id=\"获取指定action\"><a href=\"#获取指定action\" class=\"headerlink\" title=\"获取指定action\"></a>获取指定action</h2><p>我们在定义action的时候，在<code>fetchUser</code>等函数中返回了这些我们需要的东西：</p>\n<p>actions/index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; CALL_API, Schemas &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../middleware/api'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> USER_REQUEST = <span class=\"string\">'USER_REQUEST'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> USER_SUCCESS = <span class=\"string\">'USER_SUCCESS'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> USER_FAILURE = <span class=\"string\">'USER_FAILURE'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Fetches a single user from Github API.</span></span><br><span class=\"line\"><span class=\"comment\">// Relies on the custom API middleware defined in ../middleware/api.js.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchUser</span>(<span class=\"params\">login</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    [CALL_API]: &#123;</span><br><span class=\"line\">      types: [ USER_REQUEST, USER_SUCCESS, USER_FAILURE ],</span><br><span class=\"line\">      endpoint: <span class=\"string\">`users/<span class=\"subst\">$&#123;login&#125;</span>`</span>,</span><br><span class=\"line\">      schema: Schemas.USER</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Fetches a single user from Github API unless it is cached.</span></span><br><span class=\"line\"><span class=\"comment\">// Relies on Redux Thunk middleware.</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadUser</span>(<span class=\"params\">login, requiredFields = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> user = getState().entities.users[login]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user &amp;&amp; requiredFields.every(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> user.hasOwnProperty(key))) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dispatch(fetchUser(login))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们也就是指定这些action来进行”包装的”。除了<code>fetchUser</code>，还有其他的，不列出代码清单了。</p>\n<p>我们添加<code>console.log</code>来查看action的真正样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'当前执行的action:'</span>,action);</span><br><span class=\"line\"><span class=\"keyword\">const</span> callAPI = action[CALL_API]</span><br></pre></td></tr></table></figure>\n<p><img src=\"/css/images/154.jpg\" alt=\"\"></p>\n<p>在执行initRoutes的action时候，我们得到了一个包含Symbol的action对象，这就是我们想要的action。</p>\n<h2 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h2><p>Symbol是什么？上述代码中的<code>CALL_API</code>就是Symbol。</p>\n<p>middleware/api.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Action key that carries API call info interpreted by this Redux middleware.</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> CALL_API = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'Call API'</span>)</span><br></pre></td></tr></table></figure>\n<p>为什么要用Symbol，为了不冲突，Symbol是个唯一的不变的标识，可以用于对象的key。为了避免冲突而生，这里也可以用字符串来代替，但是不好，<br>因为字符串很容易命名冲突，你每次都要想个奇葩的长名字，所以还是用Symbol吧。再罗嗦一句，我们写Object.assign的时候，<br>第一个参数设为{},第二个参数设为源，第三个参数设为拓展属性的写法，就是为了兼容包含Symbol的对象。</p>\n<h2 id=\"消毒\"><a href=\"#消毒\" class=\"headerlink\" title=\"消毒\"></a>消毒</h2><p>获取到指定的action后，我们要做一系列的异常处理：</p>\n<p>middleware/api.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> endpoint === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">endpoint = endpoint(store.getState())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> endpoint !== <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Specify a string endpoint URL.'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!schema) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Specify one of the exported Schemas.'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"built_in\">Array</span>.isArray(types) || types.length !== <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected an array of three action types.'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!types.every(<span class=\"function\"><span class=\"params\">type</span> =&gt;</span> <span class=\"keyword\">typeof</span> type === <span class=\"string\">'string'</span>)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected action types to be strings.'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比较简单，不罗嗦了。</p>\n<h2 id=\"执行请求action\"><a href=\"#执行请求action\" class=\"headerlink\" title=\"执行请求action\"></a>执行请求action</h2><p>获取完action，也进行过消毒了，可以开始ajax请求了，首先发一个请求action</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">actionWith</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalAction = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, action, data)</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> finalAction[CALL_API]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> finalAction</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> [ requestType, successType, failureType ] = types</span><br><span class=\"line\">next(actionWith(&#123; <span class=\"attr\">type</span>: requestType &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">## 执行ajax请求，结束后发出成功或者失败action</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">return</span> callApi(endpoint, schema).then(</span><br><span class=\"line\">\tresponse =&gt; next(actionWith(&#123;</span><br><span class=\"line\">\t  response,</span><br><span class=\"line\">\t  type: successType</span><br><span class=\"line\">\t&#125;)),</span><br><span class=\"line\">\terror =&gt; next(actionWith(&#123;</span><br><span class=\"line\">\t  type: failureType,</span><br><span class=\"line\">\t  error: error.message || <span class=\"string\">'Something bad happened'</span></span><br><span class=\"line\">\t&#125;))</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n<h2 id=\"图解流程\"><a href=\"#图解流程\" class=\"headerlink\" title=\"图解流程\"></a>图解流程</h2><p>本来一个action，经过中间件的加工后，变成了一系列的流程。</p>\n<p><img src=\"/css/images/155.jpg\" alt=\"\"></p>\n<hr>\n<h1 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h1><p><a href=\"http://www.liuyiqi.cn/2016/12/10/react-redux-tutorial-catalog/\">http://www.liuyiqi.cn/2016/12/10/react-redux-tutorial-catalog/</a></p>"},{"title":"React 与 Redux 教程（六）redux服务端渲染流程","date":"2016-01-31T19:20:00.000Z","_content":"\n今天，我们要讲解的是React 与 Redux 服务端渲染。个人认为，React击败Angular1的真正\"杀手锏\"就是服务端渲染。我们为什么要实现服务端渲染，主要是为了首屏渲染速度和SEO。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/156.gif)\n\n例子仍然是官方的计数器例子，不过我们实现了服务端渲染和state预加载。\n\n源代码：\n\nhttps://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/universal\n\n## 虚拟API\n\n首先，我们要模拟一个api，用于异步请求数据。代码如下：\n\ncommon/api/counter.js\n\n```js\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min)) + min\n}\n\nexport function fetchCounter(callback) {\n  // Rather than immediately returning, we delay our code with a timeout to simulate asynchronous behavior\n  setTimeout(() => {\n    callback(getRandomInt(1, 100))\n  }, 500)\n\n  // In the case of a real world API call, you'll normally run into a Promise like this:\n  // API.getUser().then(user => callback(user))\n}\n```\n\n## 服务端请求api，发送html串和state\n\nserver/server.js（部分代码）\n\n```js\n// This is fired every time the server side receives a request\napp.use(handleRender)\n\nfunction handleRender(req, res) {\n  // Query our mock API asynchronously\n  fetchCounter(apiResult => {\n    // Read the counter from the request, if provided\n    const params = qs.parse(req.query)\n    const counter = parseInt(params.counter, 10) || apiResult || 0\n\n    // Compile an initial state\n    const initialState = { counter }\n\n    // Create a new Redux store instance\n    const store = configureStore(initialState)\n\n    // Render the component to a string\n    const html = renderToString(\n      <Provider store={store}>\n        <App />\n      </Provider>\n    )\n\n    // Grab the initial state from our Redux store\n    const finalState = store.getState()\n\n    // Send the rendered page back to the client\n    res.send(renderFullPage(html, finalState))\n  })\n}\n\nfunction renderFullPage(html, initialState) {\n  return `\n    <!doctype html>\n    <html>\n      <head>\n        <title>Redux Universal Example</title>\n      </head>\n      <body>\n        <div id=\"app\">${html}</div>\n        <script>\n          window.__INITIAL_STATE__ = ${JSON.stringify(initialState)}\n        </script>\n        <script src=\"/static/bundle.js\"></script>\n      </body>\n    </html>\n    `\n}\n```\n  1. api写好了，我们调用了这个api，即`fetchCounter`，这个api函数也会产生一个回调，我们在回调中获取`counter`值\n  2. 如果中间件请求中有参数，则`const params = qs.parse(req.query)`，`counter`为`parseInt(params.counter, 10)`。否则`counter`为api的回调中返回的值`apiResult`，如果前两个都没有则为`0`。`qs`用于解析http请求中的querystring，就是`？param=sth`。\n  3. 得到`counter`，我们就得到了state，用state作为参数，重新生成一个store实例，每次都要重新生成一个新的store实例。然后用react的服务端渲染生成一个html串，把它发送出去\n  4. 同时，我们还要发送一个`const finalState = store.getState()`出去，让客户端拿到这个state渲染，为什么？因为要保证客户端和服务端渲染的组件一样。\n\n## 服务端渲染\n\n既然有了服务端渲染，为何还要用客户端渲染，因为服务端渲染完，我们的程序就不会动了（因为是一堆字符串）,客户端则可以让程序继续动起来，因为客户端有js，可以调用方法重绘浏览器界面。\n\n## 客户端拿到state再渲染一次\n\n既然要再渲染一次，为何还要服务端渲染？为了首屏渲染速度和seo，我们的服务端渲染不只是给用户看的，主要是给那些\"低能\"的网络爬虫看的。\n\n好吧，忍忍火，我们继续工作，客户端再渲染一次。\n\n```js\nconst initialState = window.__INITIAL_STATE__\nconst store = configureStore(initialState)\nconst rootElement = document.getElementById('app')\n\nrender(\n  <Provider store={store}>\n    <App/>\n  </Provider>,\n  rootElement\n)\n```\n其实客户端渲染也就拿到个初始state，然后render而已，没有很多代码。\n\n我们的state是从`window.__INITIAL_STATE__`获取的，因为服务端把要给客户端的state放在了这个全局变量上面。\n\n## \"玄乎\"的预载state\n\n预载state，说得这么\"玄乎\"，好像很高大上，其实就是把state在服务器那边就生成好，然后传过来直接给客户端用。没有那么\"玄乎\"。\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n","source":"_posts/r2-ssr.md","raw":"---\ntitle: React 与 Redux 教程（六）redux服务端渲染流程\ndate: 2016-02-01 03:20:00\ntags: [React, Redux]\n---\n\n今天，我们要讲解的是React 与 Redux 服务端渲染。个人认为，React击败Angular1的真正\"杀手锏\"就是服务端渲染。我们为什么要实现服务端渲染，主要是为了首屏渲染速度和SEO。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/156.gif)\n\n例子仍然是官方的计数器例子，不过我们实现了服务端渲染和state预加载。\n\n源代码：\n\nhttps://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/universal\n\n## 虚拟API\n\n首先，我们要模拟一个api，用于异步请求数据。代码如下：\n\ncommon/api/counter.js\n\n```js\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min)) + min\n}\n\nexport function fetchCounter(callback) {\n  // Rather than immediately returning, we delay our code with a timeout to simulate asynchronous behavior\n  setTimeout(() => {\n    callback(getRandomInt(1, 100))\n  }, 500)\n\n  // In the case of a real world API call, you'll normally run into a Promise like this:\n  // API.getUser().then(user => callback(user))\n}\n```\n\n## 服务端请求api，发送html串和state\n\nserver/server.js（部分代码）\n\n```js\n// This is fired every time the server side receives a request\napp.use(handleRender)\n\nfunction handleRender(req, res) {\n  // Query our mock API asynchronously\n  fetchCounter(apiResult => {\n    // Read the counter from the request, if provided\n    const params = qs.parse(req.query)\n    const counter = parseInt(params.counter, 10) || apiResult || 0\n\n    // Compile an initial state\n    const initialState = { counter }\n\n    // Create a new Redux store instance\n    const store = configureStore(initialState)\n\n    // Render the component to a string\n    const html = renderToString(\n      <Provider store={store}>\n        <App />\n      </Provider>\n    )\n\n    // Grab the initial state from our Redux store\n    const finalState = store.getState()\n\n    // Send the rendered page back to the client\n    res.send(renderFullPage(html, finalState))\n  })\n}\n\nfunction renderFullPage(html, initialState) {\n  return `\n    <!doctype html>\n    <html>\n      <head>\n        <title>Redux Universal Example</title>\n      </head>\n      <body>\n        <div id=\"app\">${html}</div>\n        <script>\n          window.__INITIAL_STATE__ = ${JSON.stringify(initialState)}\n        </script>\n        <script src=\"/static/bundle.js\"></script>\n      </body>\n    </html>\n    `\n}\n```\n  1. api写好了，我们调用了这个api，即`fetchCounter`，这个api函数也会产生一个回调，我们在回调中获取`counter`值\n  2. 如果中间件请求中有参数，则`const params = qs.parse(req.query)`，`counter`为`parseInt(params.counter, 10)`。否则`counter`为api的回调中返回的值`apiResult`，如果前两个都没有则为`0`。`qs`用于解析http请求中的querystring，就是`？param=sth`。\n  3. 得到`counter`，我们就得到了state，用state作为参数，重新生成一个store实例，每次都要重新生成一个新的store实例。然后用react的服务端渲染生成一个html串，把它发送出去\n  4. 同时，我们还要发送一个`const finalState = store.getState()`出去，让客户端拿到这个state渲染，为什么？因为要保证客户端和服务端渲染的组件一样。\n\n## 服务端渲染\n\n既然有了服务端渲染，为何还要用客户端渲染，因为服务端渲染完，我们的程序就不会动了（因为是一堆字符串）,客户端则可以让程序继续动起来，因为客户端有js，可以调用方法重绘浏览器界面。\n\n## 客户端拿到state再渲染一次\n\n既然要再渲染一次，为何还要服务端渲染？为了首屏渲染速度和seo，我们的服务端渲染不只是给用户看的，主要是给那些\"低能\"的网络爬虫看的。\n\n好吧，忍忍火，我们继续工作，客户端再渲染一次。\n\n```js\nconst initialState = window.__INITIAL_STATE__\nconst store = configureStore(initialState)\nconst rootElement = document.getElementById('app')\n\nrender(\n  <Provider store={store}>\n    <App/>\n  </Provider>,\n  rootElement\n)\n```\n其实客户端渲染也就拿到个初始state，然后render而已，没有很多代码。\n\n我们的state是从`window.__INITIAL_STATE__`获取的，因为服务端把要给客户端的state放在了这个全局变量上面。\n\n## \"玄乎\"的预载state\n\n预载state，说得这么\"玄乎\"，好像很高大上，其实就是把state在服务器那边就生成好，然后传过来直接给客户端用。没有那么\"玄乎\"。\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n","slug":"r2-ssr","published":1,"updated":"2019-05-01T08:10:30.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvme002qtgyt8og0s0lq","content":"<p>今天，我们要讲解的是React 与 Redux 服务端渲染。个人认为，React击败Angular1的真正”杀手锏”就是服务端渲染。我们为什么要实现服务端渲染，主要是为了首屏渲染速度和SEO。</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/156.gif\" alt=\"\"></p>\n<p>例子仍然是官方的计数器例子，不过我们实现了服务端渲染和state预加载。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/universal\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/universal</a></p>\n<h2 id=\"虚拟API\"><a href=\"#虚拟API\" class=\"headerlink\" title=\"虚拟API\"></a>虚拟API</h2><p>首先，我们要模拟一个api，用于异步请求数据。代码如下：</p>\n<p>common/api/counter.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandomInt</span>(<span class=\"params\">min, max</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (max - min)) + min</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchCounter</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Rather than immediately returning, we delay our code with a timeout to simulate asynchronous behavior</span></span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    callback(getRandomInt(<span class=\"number\">1</span>, <span class=\"number\">100</span>))</span><br><span class=\"line\">  &#125;, <span class=\"number\">500</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// In the case of a real world API call, you'll normally run into a Promise like this:</span></span><br><span class=\"line\">  <span class=\"comment\">// API.getUser().then(user =&gt; callback(user))</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"服务端请求api，发送html串和state\"><a href=\"#服务端请求api，发送html串和state\" class=\"headerlink\" title=\"服务端请求api，发送html串和state\"></a>服务端请求api，发送html串和state</h2><p>server/server.js（部分代码）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This is fired every time the server side receives a request</span></span><br><span class=\"line\">app.use(handleRender)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleRender</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Query our mock API asynchronously</span></span><br><span class=\"line\">  fetchCounter(<span class=\"function\"><span class=\"params\">apiResult</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read the counter from the request, if provided</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> params = qs.parse(req.query)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> counter = <span class=\"built_in\">parseInt</span>(params.counter, <span class=\"number\">10</span>) || apiResult || <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Compile an initial state</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> initialState = &#123; counter &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Create a new Redux store instance</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = configureStore(initialState)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Render the component to a string</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> html = renderToString(</span><br><span class=\"line\">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">        &lt;App /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/Provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ Grab the initial state from our Redux store</span></span><br><span class=\"line\"><span class=\"regexp\">    const finalState = store.getState()</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ Send the rendered page back to the client</span></span><br><span class=\"line\"><span class=\"regexp\">    res.send(renderFullPage(html, finalState))</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function renderFullPage(html, initialState) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return `</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;!doctype html&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;html&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;head&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;title&gt;Redux Universal Example&lt;/</span>title&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/head&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;div id=\"app\"&gt;$&#123;html&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;script&gt;</span><br><span class=\"line\">          <span class=\"built_in\">window</span>.__INITIAL_STATE__ = $&#123;<span class=\"built_in\">JSON</span>.stringify(initialState)&#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;script src=\"/</span><span class=\"keyword\">static</span>/bundle.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/html&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>api写好了，我们调用了这个api，即<code>fetchCounter</code>，这个api函数也会产生一个回调，我们在回调中获取<code>counter</code>值</li>\n<li>如果中间件请求中有参数，则<code>const params = qs.parse(req.query)</code>，<code>counter</code>为<code>parseInt(params.counter, 10)</code>。否则<code>counter</code>为api的回调中返回的值<code>apiResult</code>，如果前两个都没有则为<code>0</code>。<code>qs</code>用于解析http请求中的querystring，就是<code>？param=sth</code>。</li>\n<li>得到<code>counter</code>，我们就得到了state，用state作为参数，重新生成一个store实例，每次都要重新生成一个新的store实例。然后用react的服务端渲染生成一个html串，把它发送出去</li>\n<li>同时，我们还要发送一个<code>const finalState = store.getState()</code>出去，让客户端拿到这个state渲染，为什么？因为要保证客户端和服务端渲染的组件一样。</li>\n</ol>\n<h2 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h2><p>既然有了服务端渲染，为何还要用客户端渲染，因为服务端渲染完，我们的程序就不会动了（因为是一堆字符串）,客户端则可以让程序继续动起来，因为客户端有js，可以调用方法重绘浏览器界面。</p>\n<h2 id=\"客户端拿到state再渲染一次\"><a href=\"#客户端拿到state再渲染一次\" class=\"headerlink\" title=\"客户端拿到state再渲染一次\"></a>客户端拿到state再渲染一次</h2><p>既然要再渲染一次，为何还要服务端渲染？为了首屏渲染速度和seo，我们的服务端渲染不只是给用户看的，主要是给那些”低能”的网络爬虫看的。</p>\n<p>好吧，忍忍火，我们继续工作，客户端再渲染一次。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> initialState = <span class=\"built_in\">window</span>.__INITIAL_STATE__</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = configureStore(initialState)</span><br><span class=\"line\"><span class=\"keyword\">const</span> rootElement = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App/&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  rootElement</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n<p>其实客户端渲染也就拿到个初始state，然后render而已，没有很多代码。</p>\n<p>我们的state是从<code>window.__INITIAL_STATE__</code>获取的，因为服务端把要给客户端的state放在了这个全局变量上面。</p>\n<h2 id=\"“玄乎”的预载state\"><a href=\"#“玄乎”的预载state\" class=\"headerlink\" title=\"“玄乎”的预载state\"></a>“玄乎”的预载state</h2><p>预载state，说得这么”玄乎”，好像很高大上，其实就是把state在服务器那边就生成好，然后传过来直接给客户端用。没有那么”玄乎”。</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲解的是React 与 Redux 服务端渲染。个人认为，React击败Angular1的真正”杀手锏”就是服务端渲染。我们为什么要实现服务端渲染，主要是为了首屏渲染速度和SEO。</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/156.gif\" alt=\"\"></p>\n<p>例子仍然是官方的计数器例子，不过我们实现了服务端渲染和state预加载。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/universal\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/universal</a></p>\n<h2 id=\"虚拟API\"><a href=\"#虚拟API\" class=\"headerlink\" title=\"虚拟API\"></a>虚拟API</h2><p>首先，我们要模拟一个api，用于异步请求数据。代码如下：</p>\n<p>common/api/counter.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandomInt</span>(<span class=\"params\">min, max</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (max - min)) + min</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchCounter</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Rather than immediately returning, we delay our code with a timeout to simulate asynchronous behavior</span></span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    callback(getRandomInt(<span class=\"number\">1</span>, <span class=\"number\">100</span>))</span><br><span class=\"line\">  &#125;, <span class=\"number\">500</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// In the case of a real world API call, you'll normally run into a Promise like this:</span></span><br><span class=\"line\">  <span class=\"comment\">// API.getUser().then(user =&gt; callback(user))</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"服务端请求api，发送html串和state\"><a href=\"#服务端请求api，发送html串和state\" class=\"headerlink\" title=\"服务端请求api，发送html串和state\"></a>服务端请求api，发送html串和state</h2><p>server/server.js（部分代码）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This is fired every time the server side receives a request</span></span><br><span class=\"line\">app.use(handleRender)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleRender</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Query our mock API asynchronously</span></span><br><span class=\"line\">  fetchCounter(<span class=\"function\"><span class=\"params\">apiResult</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read the counter from the request, if provided</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> params = qs.parse(req.query)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> counter = <span class=\"built_in\">parseInt</span>(params.counter, <span class=\"number\">10</span>) || apiResult || <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Compile an initial state</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> initialState = &#123; counter &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Create a new Redux store instance</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = configureStore(initialState)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Render the component to a string</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> html = renderToString(</span><br><span class=\"line\">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">        &lt;App /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/Provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ Grab the initial state from our Redux store</span></span><br><span class=\"line\"><span class=\"regexp\">    const finalState = store.getState()</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ Send the rendered page back to the client</span></span><br><span class=\"line\"><span class=\"regexp\">    res.send(renderFullPage(html, finalState))</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function renderFullPage(html, initialState) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return `</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;!doctype html&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;html&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;head&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;title&gt;Redux Universal Example&lt;/</span>title&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/head&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;div id=\"app\"&gt;$&#123;html&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;script&gt;</span><br><span class=\"line\">          <span class=\"built_in\">window</span>.__INITIAL_STATE__ = $&#123;<span class=\"built_in\">JSON</span>.stringify(initialState)&#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;script src=\"/</span><span class=\"keyword\">static</span>/bundle.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/html&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>api写好了，我们调用了这个api，即<code>fetchCounter</code>，这个api函数也会产生一个回调，我们在回调中获取<code>counter</code>值</li>\n<li>如果中间件请求中有参数，则<code>const params = qs.parse(req.query)</code>，<code>counter</code>为<code>parseInt(params.counter, 10)</code>。否则<code>counter</code>为api的回调中返回的值<code>apiResult</code>，如果前两个都没有则为<code>0</code>。<code>qs</code>用于解析http请求中的querystring，就是<code>？param=sth</code>。</li>\n<li>得到<code>counter</code>，我们就得到了state，用state作为参数，重新生成一个store实例，每次都要重新生成一个新的store实例。然后用react的服务端渲染生成一个html串，把它发送出去</li>\n<li>同时，我们还要发送一个<code>const finalState = store.getState()</code>出去，让客户端拿到这个state渲染，为什么？因为要保证客户端和服务端渲染的组件一样。</li>\n</ol>\n<h2 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h2><p>既然有了服务端渲染，为何还要用客户端渲染，因为服务端渲染完，我们的程序就不会动了（因为是一堆字符串）,客户端则可以让程序继续动起来，因为客户端有js，可以调用方法重绘浏览器界面。</p>\n<h2 id=\"客户端拿到state再渲染一次\"><a href=\"#客户端拿到state再渲染一次\" class=\"headerlink\" title=\"客户端拿到state再渲染一次\"></a>客户端拿到state再渲染一次</h2><p>既然要再渲染一次，为何还要服务端渲染？为了首屏渲染速度和seo，我们的服务端渲染不只是给用户看的，主要是给那些”低能”的网络爬虫看的。</p>\n<p>好吧，忍忍火，我们继续工作，客户端再渲染一次。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> initialState = <span class=\"built_in\">window</span>.__INITIAL_STATE__</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = configureStore(initialState)</span><br><span class=\"line\"><span class=\"keyword\">const</span> rootElement = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App/&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  rootElement</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n<p>其实客户端渲染也就拿到个初始state，然后render而已，没有很多代码。</p>\n<p>我们的state是从<code>window.__INITIAL_STATE__</code>获取的，因为服务端把要给客户端的state放在了这个全局变量上面。</p>\n<h2 id=\"“玄乎”的预载state\"><a href=\"#“玄乎”的预载state\" class=\"headerlink\" title=\"“玄乎”的预载state\"></a>“玄乎”的预载state</h2><p>预载state，说得这么”玄乎”，好像很高大上，其实就是把state在服务器那边就生成好，然后传过来直接给客户端用。没有那么”玄乎”。</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>"},{"title":"React 与 Redux 教程（二）Redux的单一状态树完全替代了React的状态机？","date":"2016-01-20T18:30:00.000Z","_content":"\n上篇React 与 Redux 教程，我们讲解了官方计数器的代码实现，[React 与 Redux 教程（一）](https://lewis617.github.io/2016/01/19/r2-counter/)。我们发现我们没有用到React组件本身的state，而是通过props来导入数据和操作的。\n\n我们知道React本身是个状态机，也就是说组件是state的表现形式。那么Redux提供了一个全局的唯一的状态树，是不是就不需要组件本身的state了呢？\n\n<!--more-->\n\n#### 当然不是！\n\n有图为证，这是官方的todomvc的例子：\n\n![](/css/images/157.jpg)\n\n我们直接看React开发工具截图：\n\nApp组件没有state\n\n![](/css/images/158.jpg)\n\nHeader组件没有state\n\n![](/css/images/159.jpg)\n\nMainSection组件有state\n\n![](/css/images/160.jpg)\n\nTodoItem组件有state\n\n![](/css/images/161.jpg)\n\nFooter组件没有state\n\n![](/css/images/162.jpg)\n\n## 何时用React组件的state、props？\n\n从上面的截图我们可以发现，state只应用了两个功能：\n\n  1. 列表的过滤功能，即完成、未完成、全部的选择\n  2. 每一项的编辑与查看功能，即双击每一项，即可进入编辑状态\n\n有此我们可以得出结论，state只表示一些\"临时的\"\"内部的\"状态数据。\n\n临时的，代表你可以临时改变这个数据，比如显示完成、未完成、全部的任务，这都是临时的状态，还有任务处于编辑状态或者查看状态都是临时的。\n\n内部的，代表如果你的数据只需要在这一个组件中使用，那么你应该使用组件的内部状态。\n\n\n\nprops则正好相反，它通常存储一些方法，一些可能需要存库的长期数据和一些需要传递和共享的数据。\n\n比如`App`组件中的`todos`代表任务数组，`actions`代表一些操作的方法，这些我们都存进了props中。还有`Footer`组件中的`activeCount`以及`completedCount`都是长期存在的数据，而且可能不止一个组件在使用。\n\n## 对比Redux的全局唯一的state\n\n我们在开发工具上查看全局唯一状态树，发现是个todos数组。对应的是长期数据（并不一定要求是长期数据）和用于在多个组件中共享的数据。\n\n![](/css/images/163.jpg)\n\n## 再看Redux与React流程\n\nRedux和React两个搭档之间，基本只有两种联系：\n\n  1. React从Redux的state读取数据\n  2. React能dispatch分发actions到Redux，Redux的reducer来返回一个新的state\n\nReact组件就像是个婴儿，Redux就像是奶妈：\n\n  1. 婴儿饿了，哭着要要奶喝，就是dispatch actions的过程\n  2. 奶妈准备好给婴儿喂奶就是，React从Redux的state读取数据的过程\n\n## 结论：Redux的state和React组件的state没有半毛钱关系\n\n现在我们知道Redux的state装得是全局的，长期数据（并不一定要求是长期数据）也就是对应props的数据。而React组件的state，官方建议不要放这类数据，而应该是临时的内部状态数据。所以两个state没有半毛钱关系！\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>","source":"_posts/r2-state.md","raw":"---\ntitle: React 与 Redux 教程（二）Redux的单一状态树完全替代了React的状态机？\ndate: 2016-01-21 02:30:00\ntags: [React, Redux]\n---\n\n上篇React 与 Redux 教程，我们讲解了官方计数器的代码实现，[React 与 Redux 教程（一）](https://lewis617.github.io/2016/01/19/r2-counter/)。我们发现我们没有用到React组件本身的state，而是通过props来导入数据和操作的。\n\n我们知道React本身是个状态机，也就是说组件是state的表现形式。那么Redux提供了一个全局的唯一的状态树，是不是就不需要组件本身的state了呢？\n\n<!--more-->\n\n#### 当然不是！\n\n有图为证，这是官方的todomvc的例子：\n\n![](/css/images/157.jpg)\n\n我们直接看React开发工具截图：\n\nApp组件没有state\n\n![](/css/images/158.jpg)\n\nHeader组件没有state\n\n![](/css/images/159.jpg)\n\nMainSection组件有state\n\n![](/css/images/160.jpg)\n\nTodoItem组件有state\n\n![](/css/images/161.jpg)\n\nFooter组件没有state\n\n![](/css/images/162.jpg)\n\n## 何时用React组件的state、props？\n\n从上面的截图我们可以发现，state只应用了两个功能：\n\n  1. 列表的过滤功能，即完成、未完成、全部的选择\n  2. 每一项的编辑与查看功能，即双击每一项，即可进入编辑状态\n\n有此我们可以得出结论，state只表示一些\"临时的\"\"内部的\"状态数据。\n\n临时的，代表你可以临时改变这个数据，比如显示完成、未完成、全部的任务，这都是临时的状态，还有任务处于编辑状态或者查看状态都是临时的。\n\n内部的，代表如果你的数据只需要在这一个组件中使用，那么你应该使用组件的内部状态。\n\n\n\nprops则正好相反，它通常存储一些方法，一些可能需要存库的长期数据和一些需要传递和共享的数据。\n\n比如`App`组件中的`todos`代表任务数组，`actions`代表一些操作的方法，这些我们都存进了props中。还有`Footer`组件中的`activeCount`以及`completedCount`都是长期存在的数据，而且可能不止一个组件在使用。\n\n## 对比Redux的全局唯一的state\n\n我们在开发工具上查看全局唯一状态树，发现是个todos数组。对应的是长期数据（并不一定要求是长期数据）和用于在多个组件中共享的数据。\n\n![](/css/images/163.jpg)\n\n## 再看Redux与React流程\n\nRedux和React两个搭档之间，基本只有两种联系：\n\n  1. React从Redux的state读取数据\n  2. React能dispatch分发actions到Redux，Redux的reducer来返回一个新的state\n\nReact组件就像是个婴儿，Redux就像是奶妈：\n\n  1. 婴儿饿了，哭着要要奶喝，就是dispatch actions的过程\n  2. 奶妈准备好给婴儿喂奶就是，React从Redux的state读取数据的过程\n\n## 结论：Redux的state和React组件的state没有半毛钱关系\n\n现在我们知道Redux的state装得是全局的，长期数据（并不一定要求是长期数据）也就是对应props的数据。而React组件的state，官方建议不要放这类数据，而应该是临时的内部状态数据。所以两个state没有半毛钱关系！\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>","slug":"r2-state","published":1,"updated":"2019-05-01T08:10:30.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmg002rtgyt27nd9c56","content":"<p>上篇React 与 Redux 教程，我们讲解了官方计数器的代码实现，<a href=\"https://lewis617.github.io/2016/01/19/r2-counter/\" target=\"_blank\" rel=\"noopener\">React 与 Redux 教程（一）</a>。我们发现我们没有用到React组件本身的state，而是通过props来导入数据和操作的。</p>\n<p>我们知道React本身是个状态机，也就是说组件是state的表现形式。那么Redux提供了一个全局的唯一的状态树，是不是就不需要组件本身的state了呢？</p>\n<a id=\"more\"></a>\n<h4 id=\"当然不是！\"><a href=\"#当然不是！\" class=\"headerlink\" title=\"当然不是！\"></a>当然不是！</h4><p>有图为证，这是官方的todomvc的例子：</p>\n<p><img src=\"/css/images/157.jpg\" alt=\"\"></p>\n<p>我们直接看React开发工具截图：</p>\n<p>App组件没有state</p>\n<p><img src=\"/css/images/158.jpg\" alt=\"\"></p>\n<p>Header组件没有state</p>\n<p><img src=\"/css/images/159.jpg\" alt=\"\"></p>\n<p>MainSection组件有state</p>\n<p><img src=\"/css/images/160.jpg\" alt=\"\"></p>\n<p>TodoItem组件有state</p>\n<p><img src=\"/css/images/161.jpg\" alt=\"\"></p>\n<p>Footer组件没有state</p>\n<p><img src=\"/css/images/162.jpg\" alt=\"\"></p>\n<h2 id=\"何时用React组件的state、props？\"><a href=\"#何时用React组件的state、props？\" class=\"headerlink\" title=\"何时用React组件的state、props？\"></a>何时用React组件的state、props？</h2><p>从上面的截图我们可以发现，state只应用了两个功能：</p>\n<ol>\n<li>列表的过滤功能，即完成、未完成、全部的选择</li>\n<li>每一项的编辑与查看功能，即双击每一项，即可进入编辑状态</li>\n</ol>\n<p>有此我们可以得出结论，state只表示一些”临时的””内部的”状态数据。</p>\n<p>临时的，代表你可以临时改变这个数据，比如显示完成、未完成、全部的任务，这都是临时的状态，还有任务处于编辑状态或者查看状态都是临时的。</p>\n<p>内部的，代表如果你的数据只需要在这一个组件中使用，那么你应该使用组件的内部状态。</p>\n<p>props则正好相反，它通常存储一些方法，一些可能需要存库的长期数据和一些需要传递和共享的数据。</p>\n<p>比如<code>App</code>组件中的<code>todos</code>代表任务数组，<code>actions</code>代表一些操作的方法，这些我们都存进了props中。还有<code>Footer</code>组件中的<code>activeCount</code>以及<code>completedCount</code>都是长期存在的数据，而且可能不止一个组件在使用。</p>\n<h2 id=\"对比Redux的全局唯一的state\"><a href=\"#对比Redux的全局唯一的state\" class=\"headerlink\" title=\"对比Redux的全局唯一的state\"></a>对比Redux的全局唯一的state</h2><p>我们在开发工具上查看全局唯一状态树，发现是个todos数组。对应的是长期数据（并不一定要求是长期数据）和用于在多个组件中共享的数据。</p>\n<p><img src=\"/css/images/163.jpg\" alt=\"\"></p>\n<h2 id=\"再看Redux与React流程\"><a href=\"#再看Redux与React流程\" class=\"headerlink\" title=\"再看Redux与React流程\"></a>再看Redux与React流程</h2><p>Redux和React两个搭档之间，基本只有两种联系：</p>\n<ol>\n<li>React从Redux的state读取数据</li>\n<li>React能dispatch分发actions到Redux，Redux的reducer来返回一个新的state</li>\n</ol>\n<p>React组件就像是个婴儿，Redux就像是奶妈：</p>\n<ol>\n<li>婴儿饿了，哭着要要奶喝，就是dispatch actions的过程</li>\n<li>奶妈准备好给婴儿喂奶就是，React从Redux的state读取数据的过程</li>\n</ol>\n<h2 id=\"结论：Redux的state和React组件的state没有半毛钱关系\"><a href=\"#结论：Redux的state和React组件的state没有半毛钱关系\" class=\"headerlink\" title=\"结论：Redux的state和React组件的state没有半毛钱关系\"></a>结论：Redux的state和React组件的state没有半毛钱关系</h2><p>现在我们知道Redux的state装得是全局的，长期数据（并不一定要求是长期数据）也就是对应props的数据。而React组件的state，官方建议不要放这类数据，而应该是临时的内部状态数据。所以两个state没有半毛钱关系！</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>\n","site":{"data":{}},"excerpt":"<p>上篇React 与 Redux 教程，我们讲解了官方计数器的代码实现，<a href=\"https://lewis617.github.io/2016/01/19/r2-counter/\" target=\"_blank\" rel=\"noopener\">React 与 Redux 教程（一）</a>。我们发现我们没有用到React组件本身的state，而是通过props来导入数据和操作的。</p>\n<p>我们知道React本身是个状态机，也就是说组件是state的表现形式。那么Redux提供了一个全局的唯一的状态树，是不是就不需要组件本身的state了呢？</p>","more":"<h4 id=\"当然不是！\"><a href=\"#当然不是！\" class=\"headerlink\" title=\"当然不是！\"></a>当然不是！</h4><p>有图为证，这是官方的todomvc的例子：</p>\n<p><img src=\"/css/images/157.jpg\" alt=\"\"></p>\n<p>我们直接看React开发工具截图：</p>\n<p>App组件没有state</p>\n<p><img src=\"/css/images/158.jpg\" alt=\"\"></p>\n<p>Header组件没有state</p>\n<p><img src=\"/css/images/159.jpg\" alt=\"\"></p>\n<p>MainSection组件有state</p>\n<p><img src=\"/css/images/160.jpg\" alt=\"\"></p>\n<p>TodoItem组件有state</p>\n<p><img src=\"/css/images/161.jpg\" alt=\"\"></p>\n<p>Footer组件没有state</p>\n<p><img src=\"/css/images/162.jpg\" alt=\"\"></p>\n<h2 id=\"何时用React组件的state、props？\"><a href=\"#何时用React组件的state、props？\" class=\"headerlink\" title=\"何时用React组件的state、props？\"></a>何时用React组件的state、props？</h2><p>从上面的截图我们可以发现，state只应用了两个功能：</p>\n<ol>\n<li>列表的过滤功能，即完成、未完成、全部的选择</li>\n<li>每一项的编辑与查看功能，即双击每一项，即可进入编辑状态</li>\n</ol>\n<p>有此我们可以得出结论，state只表示一些”临时的””内部的”状态数据。</p>\n<p>临时的，代表你可以临时改变这个数据，比如显示完成、未完成、全部的任务，这都是临时的状态，还有任务处于编辑状态或者查看状态都是临时的。</p>\n<p>内部的，代表如果你的数据只需要在这一个组件中使用，那么你应该使用组件的内部状态。</p>\n<p>props则正好相反，它通常存储一些方法，一些可能需要存库的长期数据和一些需要传递和共享的数据。</p>\n<p>比如<code>App</code>组件中的<code>todos</code>代表任务数组，<code>actions</code>代表一些操作的方法，这些我们都存进了props中。还有<code>Footer</code>组件中的<code>activeCount</code>以及<code>completedCount</code>都是长期存在的数据，而且可能不止一个组件在使用。</p>\n<h2 id=\"对比Redux的全局唯一的state\"><a href=\"#对比Redux的全局唯一的state\" class=\"headerlink\" title=\"对比Redux的全局唯一的state\"></a>对比Redux的全局唯一的state</h2><p>我们在开发工具上查看全局唯一状态树，发现是个todos数组。对应的是长期数据（并不一定要求是长期数据）和用于在多个组件中共享的数据。</p>\n<p><img src=\"/css/images/163.jpg\" alt=\"\"></p>\n<h2 id=\"再看Redux与React流程\"><a href=\"#再看Redux与React流程\" class=\"headerlink\" title=\"再看Redux与React流程\"></a>再看Redux与React流程</h2><p>Redux和React两个搭档之间，基本只有两种联系：</p>\n<ol>\n<li>React从Redux的state读取数据</li>\n<li>React能dispatch分发actions到Redux，Redux的reducer来返回一个新的state</li>\n</ol>\n<p>React组件就像是个婴儿，Redux就像是奶妈：</p>\n<ol>\n<li>婴儿饿了，哭着要要奶喝，就是dispatch actions的过程</li>\n<li>奶妈准备好给婴儿喂奶就是，React从Redux的state读取数据的过程</li>\n</ol>\n<h2 id=\"结论：Redux的state和React组件的state没有半毛钱关系\"><a href=\"#结论：Redux的state和React组件的state没有半毛钱关系\" class=\"headerlink\" title=\"结论：Redux的state和React组件的state没有半毛钱关系\"></a>结论：Redux的state和React组件的state没有半毛钱关系</h2><p>现在我们知道Redux的state装得是全局的，长期数据（并不一定要求是长期数据）也就是对应props的数据。而React组件的state，官方建议不要放这类数据，而应该是临时的内部状态数据。所以两个state没有半毛钱关系！</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>"},{"title":"React 与 Redux 教程（四）undo、devtools、router","date":"2016-01-26T19:39:00.000Z","_content":"\n上节课，我们介绍了一些es6的新语法：[React 与 Redux 教程（三）reduce()、filter()、map()、some()、every()、...展开属性](https://lewis617.github.io/2016/01/21/r2-array/)\n\n今天我们通过解读redux-undo的官方示例代码来学习，在Redux中使用撤销功能、devtools功能、以及router。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/164.gif)\n\n这个例子是个计数器程序，包含计数器、右边的Redux开发工具、还有一个路由（不过只有\"/\"这一个地址）。\n\n源代码：\n\nhttps://github.com/lewis617/react-redux-tutorial/tree/master/redux-undo-boilerplate\n\n##  撤销\n\n实现撤销功能非常简单，你只需要使你的reducers可以撤销就可以了。这是什么意思呢？看代码\n\nreducers/index.js\n\n```js\nimport { combineReducers } from 'redux'\nimport counter from './counter'\nimport {\n  INCREMENT_COUNTER, DECREMENT_COUNTER,\n  UNDO_COUNTER, REDO_COUNTER\n} from '../actions/counter'\nimport undoable, { includeAction } from 'redux-undo'\n\nconst rootReducer = combineReducers({\n  counter: undoable(counter, {\n    filter: includeAction([INCREMENT_COUNTER, DECREMENT_COUNTER]),\n    limit: 10,\n    debug: true,\n    undoType: UNDO_COUNTER,\n    redoType: REDO_COUNTER\n  })\n})\n\nexport default rootReducer\n```\n\n我们使用`redux-undo`这个包给我们提供的`undoable`和`includeAction`，就可以可以给指定reducer（counter）添加撤销功能。`filter`是选择过滤的action有哪些，这里我们只撤销重做加减action，也就是`INCREMENT_COUNTER`, `DECREMENT_COUNTER`，  `limit`是次数限制，`debug`是是否调试码，`undotype`和`redotype`是撤销重做的action。\n\n如此以来，我只需要触发撤销重做的action便可以实现撤销重做功能，就是这么简单！\n\n## devtools\n\n接下来，我们开始学习使用devtools这个功能，devtools是什么？devtools的实质其实也是组件。devtools能干什么？devtools可以帮助我们看到整个程序的状态和整个程序的触发的action的日志记录。我们如何安装devtools呢？首先，我们知道devtools是个组件，那么我们直接把devtools放在容器中渲染出来不就可以了吗？\n\ncontainers/DevTools.js\n\n```js\n/*eslint-disable*/\nimport React from 'react'\nimport { createDevTools } from 'redux-devtools'\nimport LogMonitor from 'redux-devtools-log-monitor'\nimport DockMonitor from 'redux-devtools-dock-monitor'\n/*eslint-enable*/\n\nexport default createDevTools(\n  <DockMonitor toggleVisibilityKey=\"H\"\n               changePositionKey=\"Q\">\n    <LogMonitor />\n  </DockMonitor>\n)\n```\n\n这是一个可以复用的容器代码，也就意味着，你可以直接把这个js文件，复制粘贴到你的项目中。这段代码我们输出了一个devtools组件。\n\ncontainers/Root.js\n\n```js\n/* global __DEVTOOLS__ */\n/*eslint-disable*/\nimport React, { Component, PropTypes } from 'react'\nimport { Provider } from 'react-redux'\nimport { Router } from 'react-router'\nimport configureStore from '../store/configureStore'\nimport routes from '../routes'\n/*eslint-enable*/\n\nconst store = configureStore()\n\nfunction createElements (history) {\n  const elements = [\n    <Router key=\"router\" history={history} children={routes} />\n  ]\n\n  if (typeof __DEVTOOLS__ !== 'undefined' && __DEVTOOLS__) {\n    /*eslint-disable*/\n    const DevTools = require('./DevTools')\n    /*eslint-enable*/\n    elements.push(<DevTools key=\"devtools\" />)\n  }\n\n  return elements\n}\n\nexport default class Root extends Component {\n\n  static propTypes = {\n    history: PropTypes.object.isRequired\n  }\n\n  render () {\n    return (\n      <Provider store={store} key=\"provider\">\n        <div>\n          {createElements(this.props.history)}\n        </div>\n      </Provider>\n    )\n  }\n}\n```\n\n这段代码，我们将我们导出的devtools组件放在了`router`这个组件的下面，不过我们加了一个`typeof DEVTOOLS !=='undefined' && DEVTOOLS`的判断，如果条件成立，我们将渲染devtools，否则不渲染。这样做，意味着我们可以通过参数控制devtools在开发环境中显示，在生产环境中不显示。\n\n是不是渲染出来，就可以了？当然不是！我们还需要在`store`里面注册！\n\nstore/configureStore.js\n\n```js\n/* global __DEVTOOLS__ */\nimport { createStore, applyMiddleware, compose } from 'redux'\n// reducer\nimport rootReducer from '../reducers'\n// middleware\nimport thunkMiddleware from 'redux-thunk'\nimport promiseMiddleware from 'redux-promise'\nimport createLogger from 'redux-logger'\n\nconst loggerMiddleware = createLogger({\n  level: 'info',\n  collapsed: true\n})\n\nconst enforceImmutableMiddleware = require('redux-immutable-state-invariant')()\n\nlet createStoreWithMiddleware\n\nif (typeof __DEVTOOLS__ !== 'undefined' && __DEVTOOLS__) {\n  const { persistState } = require('redux-devtools')\n  const DevTools = require('../containers/DevTools')\n  createStoreWithMiddleware = compose(\n    applyMiddleware(\n      enforceImmutableMiddleware,\n      thunkMiddleware,\n      promiseMiddleware,\n      loggerMiddleware\n    ),\n    DevTools.instrument(),\n    persistState(window.location.href.match(/[?&]debug_session=([^&]+)\\b/))\n  )(createStore)\n} else {\n  createStoreWithMiddleware = compose(\n    applyMiddleware(thunkMiddleware, promiseMiddleware)\n  )(createStore)\n}\n\n/**\n * Creates a preconfigured store.\n */\nexport default function configureStore (initialState) {\n  const store = createStoreWithMiddleware(rootReducer, initialState)\n\n  if (module.hot) {\n    // Enable Webpack hot module replacement for reducers\n    module.hot.accept('../reducers', () => {\n      const nextRootReducer = require('../reducers/index')\n      store.replaceReducer(nextRootReducer)\n    })\n  }\n\n  return store\n}\n\n```\n\n到此为止，devtools我们就安装好了，就是这么简单！把它渲染出来就可以了，可以放在整个程序的下面就可以了！\n\n## store enhancer\n\n`DevTools.instrument()` 这行代码使得devtools可以使用了！有的同学会问，这个`instrument()`是什么鬼？官方称之为store enhancer，翻译过来就是store加强器，跟`applymiddleware`是一类，都是store加强器。那么store加强器，能干什么？store加强器可以重新构建一个更牛逼的store，来替换之前的基础版的store，让你的程序可以增加很多别的功能，比如`appllymiddleware`可以给你的Redux增加中间件，使之可以拥有异步功能，日志功能等！\n\n\n## enforceImmutableMiddleware,thunkMiddleware, promiseMiddleware, loggerMiddleware\n\n\n\n有的同学会问，`enforceImmutableMiddleware`是什么？干嘛用的？这个使用禁止你改变state的。什么？不改变state，我们如何更新状态，Redux不允许你改变state，在reducer中我们必须要返回一个新的state，而不是修改原来的state！\n\n那个`thunk`是什么？`thunk`我们已经在[React 与 Redux 教程（一）connect、applyMiddleware、thunk、webpackHotMiddleware](https://lewis617.github.io/2016/01/19/r2-counter/)里面讲过了。\n\n那么什么是`promiseMiddleware`？这也是个中间件，和`thunk`一样，使得你的action可以具备异步的功能。不过，我们可以发现，本例中我们并没有用到`thunk`和`promiseMiddleware`这两个中间件，本例子是个种子文件，可以在这个基础上拓展，所以作者提前写好了两个常用中间件，便于我们日后使用！\n\n那么`loggerMiddleware`是用来干嘛的？顾名思义，就是用来记录日志的，当你添加这个中间件，你可以在命令行中看到相关的打印日志！当然你可以在运行程序的时候，去掉这个中间件，来对比观察它的作用！\n\n\n\n## instrument()与compose()写法\n\n`instrument()`不同于`applymiddleware`，它只能用于开发环境，只能enable你的devtools组件！那么我们把`applymiddleware`和`instrument`用逗号隔开，为什么？这是compose写法，用来代替以前的函数嵌套！\n\n## Router\n\n简单来说，Router也是个组件，一个多重视图的组件，这个组件可以通过切换URL来切换视图，总之它还是个组件。既然是组件，我们只要把它渲染出来就可以了！\n\n最顶层我们要渲染一个`Router`, 代码在containers/Root.js中，我们就不重复列出代码清单了。\n\n然后我们开始渲染各个视图，这里我们只有一个视图，也就是目录是\"/\"的视图，我们把它渲染出来！\n\nroutes.js\n\n```js\n/*eslint-disable*/\nimport React from 'react'\nimport { Route } from 'react-router'\nimport App from './containers/App'\nimport * as containers from './containers'\n/*eslint-enable*/\n\nconst {\n  CounterPage\n} = containers\n\nexport default (\n  <Route component={App}>\n    <Route path=\"/\" component={CounterPage} />\n  </Route>\n)\n```\n\n我们导出了一个视图，这个视图的组件是`CounterPage`。就是这么简单！\n\n然后，我们在containers/Root.js，将它渲染到`Router`组件里面就可以了！\n\n```js\n<Router key=\"router\" history={history} children={routes} />\n```\n\n我们可以发现，我们并没有把devtools这个组件放在路由组件里面。这意味着，无论你如何切换视图，devtools都一直会渲染出来！\n\n当然react-router的api还有很多，我们只是用了很少一部分，我不建议专门阅读api文档，应该在项目中，遇到不会的查询api文档，这样对api的用法的理解会更加的深刻！\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n\n","source":"_posts/r2-undo.md","raw":"---\ntitle: React 与 Redux 教程（四）undo、devtools、router\ndate: 2016-01-27 03:39:00\ntags: [React, Redux]\n---\n\n上节课，我们介绍了一些es6的新语法：[React 与 Redux 教程（三）reduce()、filter()、map()、some()、every()、...展开属性](https://lewis617.github.io/2016/01/21/r2-array/)\n\n今天我们通过解读redux-undo的官方示例代码来学习，在Redux中使用撤销功能、devtools功能、以及router。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/164.gif)\n\n这个例子是个计数器程序，包含计数器、右边的Redux开发工具、还有一个路由（不过只有\"/\"这一个地址）。\n\n源代码：\n\nhttps://github.com/lewis617/react-redux-tutorial/tree/master/redux-undo-boilerplate\n\n##  撤销\n\n实现撤销功能非常简单，你只需要使你的reducers可以撤销就可以了。这是什么意思呢？看代码\n\nreducers/index.js\n\n```js\nimport { combineReducers } from 'redux'\nimport counter from './counter'\nimport {\n  INCREMENT_COUNTER, DECREMENT_COUNTER,\n  UNDO_COUNTER, REDO_COUNTER\n} from '../actions/counter'\nimport undoable, { includeAction } from 'redux-undo'\n\nconst rootReducer = combineReducers({\n  counter: undoable(counter, {\n    filter: includeAction([INCREMENT_COUNTER, DECREMENT_COUNTER]),\n    limit: 10,\n    debug: true,\n    undoType: UNDO_COUNTER,\n    redoType: REDO_COUNTER\n  })\n})\n\nexport default rootReducer\n```\n\n我们使用`redux-undo`这个包给我们提供的`undoable`和`includeAction`，就可以可以给指定reducer（counter）添加撤销功能。`filter`是选择过滤的action有哪些，这里我们只撤销重做加减action，也就是`INCREMENT_COUNTER`, `DECREMENT_COUNTER`，  `limit`是次数限制，`debug`是是否调试码，`undotype`和`redotype`是撤销重做的action。\n\n如此以来，我只需要触发撤销重做的action便可以实现撤销重做功能，就是这么简单！\n\n## devtools\n\n接下来，我们开始学习使用devtools这个功能，devtools是什么？devtools的实质其实也是组件。devtools能干什么？devtools可以帮助我们看到整个程序的状态和整个程序的触发的action的日志记录。我们如何安装devtools呢？首先，我们知道devtools是个组件，那么我们直接把devtools放在容器中渲染出来不就可以了吗？\n\ncontainers/DevTools.js\n\n```js\n/*eslint-disable*/\nimport React from 'react'\nimport { createDevTools } from 'redux-devtools'\nimport LogMonitor from 'redux-devtools-log-monitor'\nimport DockMonitor from 'redux-devtools-dock-monitor'\n/*eslint-enable*/\n\nexport default createDevTools(\n  <DockMonitor toggleVisibilityKey=\"H\"\n               changePositionKey=\"Q\">\n    <LogMonitor />\n  </DockMonitor>\n)\n```\n\n这是一个可以复用的容器代码，也就意味着，你可以直接把这个js文件，复制粘贴到你的项目中。这段代码我们输出了一个devtools组件。\n\ncontainers/Root.js\n\n```js\n/* global __DEVTOOLS__ */\n/*eslint-disable*/\nimport React, { Component, PropTypes } from 'react'\nimport { Provider } from 'react-redux'\nimport { Router } from 'react-router'\nimport configureStore from '../store/configureStore'\nimport routes from '../routes'\n/*eslint-enable*/\n\nconst store = configureStore()\n\nfunction createElements (history) {\n  const elements = [\n    <Router key=\"router\" history={history} children={routes} />\n  ]\n\n  if (typeof __DEVTOOLS__ !== 'undefined' && __DEVTOOLS__) {\n    /*eslint-disable*/\n    const DevTools = require('./DevTools')\n    /*eslint-enable*/\n    elements.push(<DevTools key=\"devtools\" />)\n  }\n\n  return elements\n}\n\nexport default class Root extends Component {\n\n  static propTypes = {\n    history: PropTypes.object.isRequired\n  }\n\n  render () {\n    return (\n      <Provider store={store} key=\"provider\">\n        <div>\n          {createElements(this.props.history)}\n        </div>\n      </Provider>\n    )\n  }\n}\n```\n\n这段代码，我们将我们导出的devtools组件放在了`router`这个组件的下面，不过我们加了一个`typeof DEVTOOLS !=='undefined' && DEVTOOLS`的判断，如果条件成立，我们将渲染devtools，否则不渲染。这样做，意味着我们可以通过参数控制devtools在开发环境中显示，在生产环境中不显示。\n\n是不是渲染出来，就可以了？当然不是！我们还需要在`store`里面注册！\n\nstore/configureStore.js\n\n```js\n/* global __DEVTOOLS__ */\nimport { createStore, applyMiddleware, compose } from 'redux'\n// reducer\nimport rootReducer from '../reducers'\n// middleware\nimport thunkMiddleware from 'redux-thunk'\nimport promiseMiddleware from 'redux-promise'\nimport createLogger from 'redux-logger'\n\nconst loggerMiddleware = createLogger({\n  level: 'info',\n  collapsed: true\n})\n\nconst enforceImmutableMiddleware = require('redux-immutable-state-invariant')()\n\nlet createStoreWithMiddleware\n\nif (typeof __DEVTOOLS__ !== 'undefined' && __DEVTOOLS__) {\n  const { persistState } = require('redux-devtools')\n  const DevTools = require('../containers/DevTools')\n  createStoreWithMiddleware = compose(\n    applyMiddleware(\n      enforceImmutableMiddleware,\n      thunkMiddleware,\n      promiseMiddleware,\n      loggerMiddleware\n    ),\n    DevTools.instrument(),\n    persistState(window.location.href.match(/[?&]debug_session=([^&]+)\\b/))\n  )(createStore)\n} else {\n  createStoreWithMiddleware = compose(\n    applyMiddleware(thunkMiddleware, promiseMiddleware)\n  )(createStore)\n}\n\n/**\n * Creates a preconfigured store.\n */\nexport default function configureStore (initialState) {\n  const store = createStoreWithMiddleware(rootReducer, initialState)\n\n  if (module.hot) {\n    // Enable Webpack hot module replacement for reducers\n    module.hot.accept('../reducers', () => {\n      const nextRootReducer = require('../reducers/index')\n      store.replaceReducer(nextRootReducer)\n    })\n  }\n\n  return store\n}\n\n```\n\n到此为止，devtools我们就安装好了，就是这么简单！把它渲染出来就可以了，可以放在整个程序的下面就可以了！\n\n## store enhancer\n\n`DevTools.instrument()` 这行代码使得devtools可以使用了！有的同学会问，这个`instrument()`是什么鬼？官方称之为store enhancer，翻译过来就是store加强器，跟`applymiddleware`是一类，都是store加强器。那么store加强器，能干什么？store加强器可以重新构建一个更牛逼的store，来替换之前的基础版的store，让你的程序可以增加很多别的功能，比如`appllymiddleware`可以给你的Redux增加中间件，使之可以拥有异步功能，日志功能等！\n\n\n## enforceImmutableMiddleware,thunkMiddleware, promiseMiddleware, loggerMiddleware\n\n\n\n有的同学会问，`enforceImmutableMiddleware`是什么？干嘛用的？这个使用禁止你改变state的。什么？不改变state，我们如何更新状态，Redux不允许你改变state，在reducer中我们必须要返回一个新的state，而不是修改原来的state！\n\n那个`thunk`是什么？`thunk`我们已经在[React 与 Redux 教程（一）connect、applyMiddleware、thunk、webpackHotMiddleware](https://lewis617.github.io/2016/01/19/r2-counter/)里面讲过了。\n\n那么什么是`promiseMiddleware`？这也是个中间件，和`thunk`一样，使得你的action可以具备异步的功能。不过，我们可以发现，本例中我们并没有用到`thunk`和`promiseMiddleware`这两个中间件，本例子是个种子文件，可以在这个基础上拓展，所以作者提前写好了两个常用中间件，便于我们日后使用！\n\n那么`loggerMiddleware`是用来干嘛的？顾名思义，就是用来记录日志的，当你添加这个中间件，你可以在命令行中看到相关的打印日志！当然你可以在运行程序的时候，去掉这个中间件，来对比观察它的作用！\n\n\n\n## instrument()与compose()写法\n\n`instrument()`不同于`applymiddleware`，它只能用于开发环境，只能enable你的devtools组件！那么我们把`applymiddleware`和`instrument`用逗号隔开，为什么？这是compose写法，用来代替以前的函数嵌套！\n\n## Router\n\n简单来说，Router也是个组件，一个多重视图的组件，这个组件可以通过切换URL来切换视图，总之它还是个组件。既然是组件，我们只要把它渲染出来就可以了！\n\n最顶层我们要渲染一个`Router`, 代码在containers/Root.js中，我们就不重复列出代码清单了。\n\n然后我们开始渲染各个视图，这里我们只有一个视图，也就是目录是\"/\"的视图，我们把它渲染出来！\n\nroutes.js\n\n```js\n/*eslint-disable*/\nimport React from 'react'\nimport { Route } from 'react-router'\nimport App from './containers/App'\nimport * as containers from './containers'\n/*eslint-enable*/\n\nconst {\n  CounterPage\n} = containers\n\nexport default (\n  <Route component={App}>\n    <Route path=\"/\" component={CounterPage} />\n  </Route>\n)\n```\n\n我们导出了一个视图，这个视图的组件是`CounterPage`。就是这么简单！\n\n然后，我们在containers/Root.js，将它渲染到`Router`组件里面就可以了！\n\n```js\n<Router key=\"router\" history={history} children={routes} />\n```\n\n我们可以发现，我们并没有把devtools这个组件放在路由组件里面。这意味着，无论你如何切换视图，devtools都一直会渲染出来！\n\n当然react-router的api还有很多，我们只是用了很少一部分，我不建议专门阅读api文档，应该在项目中，遇到不会的查询api文档，这样对api的用法的理解会更加的深刻！\n\n* * *\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n\n","slug":"r2-undo","published":1,"updated":"2019-05-01T08:10:30.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmh002ttgytg79fa7es","content":"<p>上节课，我们介绍了一些es6的新语法：<a href=\"https://lewis617.github.io/2016/01/21/r2-array/\" target=\"_blank\" rel=\"noopener\">React 与 Redux 教程（三）reduce()、filter()、map()、some()、every()、…展开属性</a></p>\n<p>今天我们通过解读redux-undo的官方示例代码来学习，在Redux中使用撤销功能、devtools功能、以及router。</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/164.gif\" alt=\"\"></p>\n<p>这个例子是个计数器程序，包含计数器、右边的Redux开发工具、还有一个路由（不过只有”/“这一个地址）。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/redux-undo-boilerplate\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/redux-undo-boilerplate</a></p>\n<h2 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h2><p>实现撤销功能非常简单，你只需要使你的reducers可以撤销就可以了。这是什么意思呢？看代码</p>\n<p>reducers/index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./counter'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  INCREMENT_COUNTER, DECREMENT_COUNTER,</span><br><span class=\"line\">  UNDO_COUNTER, REDO_COUNTER</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions/counter'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> undoable, &#123; includeAction &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux-undo'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rootReducer = combineReducers(&#123;</span><br><span class=\"line\">  counter: undoable(counter, &#123;</span><br><span class=\"line\">    filter: includeAction([INCREMENT_COUNTER, DECREMENT_COUNTER]),</span><br><span class=\"line\">    limit: <span class=\"number\">10</span>,</span><br><span class=\"line\">    debug: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    undoType: UNDO_COUNTER,</span><br><span class=\"line\">    redoType: REDO_COUNTER</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> rootReducer</span><br></pre></td></tr></table></figure>\n<p>我们使用<code>redux-undo</code>这个包给我们提供的<code>undoable</code>和<code>includeAction</code>，就可以可以给指定reducer（counter）添加撤销功能。<code>filter</code>是选择过滤的action有哪些，这里我们只撤销重做加减action，也就是<code>INCREMENT_COUNTER</code>, <code>DECREMENT_COUNTER</code>，  <code>limit</code>是次数限制，<code>debug</code>是是否调试码，<code>undotype</code>和<code>redotype</code>是撤销重做的action。</p>\n<p>如此以来，我只需要触发撤销重做的action便可以实现撤销重做功能，就是这么简单！</p>\n<h2 id=\"devtools\"><a href=\"#devtools\" class=\"headerlink\" title=\"devtools\"></a>devtools</h2><p>接下来，我们开始学习使用devtools这个功能，devtools是什么？devtools的实质其实也是组件。devtools能干什么？devtools可以帮助我们看到整个程序的状态和整个程序的触发的action的日志记录。我们如何安装devtools呢？首先，我们知道devtools是个组件，那么我们直接把devtools放在容器中渲染出来不就可以了吗？</p>\n<p>containers/DevTools.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*eslint-disable*/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createDevTools &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux-devtools'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> LogMonitor <span class=\"keyword\">from</span> <span class=\"string\">'redux-devtools-log-monitor'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> DockMonitor <span class=\"keyword\">from</span> <span class=\"string\">'redux-devtools-dock-monitor'</span></span><br><span class=\"line\"><span class=\"comment\">/*eslint-enable*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> createDevTools(</span><br><span class=\"line\">  &lt;DockMonitor toggleVisibilityKey=<span class=\"string\">\"H\"</span></span><br><span class=\"line\">               changePositionKey=<span class=\"string\">\"Q\"</span>&gt;</span><br><span class=\"line\">    &lt;LogMonitor /&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/DockMonitor&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n<p>这是一个可以复用的容器代码，也就意味着，你可以直接把这个js文件，复制粘贴到你的项目中。这段代码我们输出了一个devtools组件。</p>\n<p>containers/Root.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* global __DEVTOOLS__ */</span></span><br><span class=\"line\"><span class=\"comment\">/*eslint-disable*/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component, PropTypes &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Router &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> configureStore <span class=\"keyword\">from</span> <span class=\"string\">'../store/configureStore'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> routes <span class=\"keyword\">from</span> <span class=\"string\">'../routes'</span></span><br><span class=\"line\"><span class=\"comment\">/*eslint-enable*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = configureStore()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElements</span> (<span class=\"params\">history</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = [</span><br><span class=\"line\">    &lt;Router key=<span class=\"string\">\"router\"</span> history=&#123;history&#125; children=&#123;routes&#125; /&gt;</span><br><span class=\"line\">  ]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> __DEVTOOLS__ !== <span class=\"string\">'undefined'</span> &amp;&amp; __DEVTOOLS__) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*eslint-disable*/</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> DevTools = <span class=\"built_in\">require</span>(<span class=\"string\">'./DevTools'</span>)</span><br><span class=\"line\">    <span class=\"comment\">/*eslint-enable*/</span></span><br><span class=\"line\">    elements.push(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">DevTools</span> <span class=\"attr\">key</span>=<span class=\"string\">\"devtools\"</span> /&gt;</span>)</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  return elements</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">export default class Root extends Component &#123;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  static propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    history: PropTypes.object.isRequired</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  render () &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    return (</span></span><br><span class=\"line\">      &lt;Provider store=&#123;store&#125; key=\"provider\"&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &#123;createElements(this.props.history)&#125;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">Provider</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    )</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这段代码，我们将我们导出的devtools组件放在了<code>router</code>这个组件的下面，不过我们加了一个<code>typeof DEVTOOLS !==&#39;undefined&#39; &amp;&amp; DEVTOOLS</code>的判断，如果条件成立，我们将渲染devtools，否则不渲染。这样做，意味着我们可以通过参数控制devtools在开发环境中显示，在生产环境中不显示。</p>\n<p>是不是渲染出来，就可以了？当然不是！我们还需要在<code>store</code>里面注册！</p>\n<p>store/configureStore.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* global __DEVTOOLS__ */</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"comment\">// reducer</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> rootReducer <span class=\"keyword\">from</span> <span class=\"string\">'../reducers'</span></span><br><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> thunkMiddleware <span class=\"keyword\">from</span> <span class=\"string\">'redux-thunk'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> promiseMiddleware <span class=\"keyword\">from</span> <span class=\"string\">'redux-promise'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> createLogger <span class=\"keyword\">from</span> <span class=\"string\">'redux-logger'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> loggerMiddleware = createLogger(&#123;</span><br><span class=\"line\">  level: <span class=\"string\">'info'</span>,</span><br><span class=\"line\">  collapsed: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> enforceImmutableMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'redux-immutable-state-invariant'</span>)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> createStoreWithMiddleware</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> __DEVTOOLS__ !== <span class=\"string\">'undefined'</span> &amp;&amp; __DEVTOOLS__) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; persistState &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'redux-devtools'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> DevTools = <span class=\"built_in\">require</span>(<span class=\"string\">'../containers/DevTools'</span>)</span><br><span class=\"line\">  createStoreWithMiddleware = compose(</span><br><span class=\"line\">    applyMiddleware(</span><br><span class=\"line\">      enforceImmutableMiddleware,</span><br><span class=\"line\">      thunkMiddleware,</span><br><span class=\"line\">      promiseMiddleware,</span><br><span class=\"line\">      loggerMiddleware</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    DevTools.instrument(),</span><br><span class=\"line\">    persistState(<span class=\"built_in\">window</span>.location.href.match(<span class=\"regexp\">/[?&amp;]debug_session=([^&amp;]+)\\b/</span>))</span><br><span class=\"line\">  )(createStore)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  createStoreWithMiddleware = compose(</span><br><span class=\"line\">    applyMiddleware(thunkMiddleware, promiseMiddleware)</span><br><span class=\"line\">  )(createStore)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates a preconfigured store.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">configureStore</span> (<span class=\"params\">initialState</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> store = createStoreWithMiddleware(rootReducer, initialState)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Enable Webpack hot module replacement for reducers</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'../reducers'</span>, () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextRootReducer = <span class=\"built_in\">require</span>(<span class=\"string\">'../reducers/index'</span>)</span><br><span class=\"line\">      store.replaceReducer(nextRootReducer)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> store</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此为止，devtools我们就安装好了，就是这么简单！把它渲染出来就可以了，可以放在整个程序的下面就可以了！</p>\n<h2 id=\"store-enhancer\"><a href=\"#store-enhancer\" class=\"headerlink\" title=\"store enhancer\"></a>store enhancer</h2><p><code>DevTools.instrument()</code> 这行代码使得devtools可以使用了！有的同学会问，这个<code>instrument()</code>是什么鬼？官方称之为store enhancer，翻译过来就是store加强器，跟<code>applymiddleware</code>是一类，都是store加强器。那么store加强器，能干什么？store加强器可以重新构建一个更牛逼的store，来替换之前的基础版的store，让你的程序可以增加很多别的功能，比如<code>appllymiddleware</code>可以给你的Redux增加中间件，使之可以拥有异步功能，日志功能等！</p>\n<h2 id=\"enforceImmutableMiddleware-thunkMiddleware-promiseMiddleware-loggerMiddleware\"><a href=\"#enforceImmutableMiddleware-thunkMiddleware-promiseMiddleware-loggerMiddleware\" class=\"headerlink\" title=\"enforceImmutableMiddleware,thunkMiddleware, promiseMiddleware, loggerMiddleware\"></a>enforceImmutableMiddleware,thunkMiddleware, promiseMiddleware, loggerMiddleware</h2><p>有的同学会问，<code>enforceImmutableMiddleware</code>是什么？干嘛用的？这个使用禁止你改变state的。什么？不改变state，我们如何更新状态，Redux不允许你改变state，在reducer中我们必须要返回一个新的state，而不是修改原来的state！</p>\n<p>那个<code>thunk</code>是什么？<code>thunk</code>我们已经在<a href=\"https://lewis617.github.io/2016/01/19/r2-counter/\" target=\"_blank\" rel=\"noopener\">React 与 Redux 教程（一）connect、applyMiddleware、thunk、webpackHotMiddleware</a>里面讲过了。</p>\n<p>那么什么是<code>promiseMiddleware</code>？这也是个中间件，和<code>thunk</code>一样，使得你的action可以具备异步的功能。不过，我们可以发现，本例中我们并没有用到<code>thunk</code>和<code>promiseMiddleware</code>这两个中间件，本例子是个种子文件，可以在这个基础上拓展，所以作者提前写好了两个常用中间件，便于我们日后使用！</p>\n<p>那么<code>loggerMiddleware</code>是用来干嘛的？顾名思义，就是用来记录日志的，当你添加这个中间件，你可以在命令行中看到相关的打印日志！当然你可以在运行程序的时候，去掉这个中间件，来对比观察它的作用！</p>\n<h2 id=\"instrument-与compose-写法\"><a href=\"#instrument-与compose-写法\" class=\"headerlink\" title=\"instrument()与compose()写法\"></a>instrument()与compose()写法</h2><p><code>instrument()</code>不同于<code>applymiddleware</code>，它只能用于开发环境，只能enable你的devtools组件！那么我们把<code>applymiddleware</code>和<code>instrument</code>用逗号隔开，为什么？这是compose写法，用来代替以前的函数嵌套！</p>\n<h2 id=\"Router\"><a href=\"#Router\" class=\"headerlink\" title=\"Router\"></a>Router</h2><p>简单来说，Router也是个组件，一个多重视图的组件，这个组件可以通过切换URL来切换视图，总之它还是个组件。既然是组件，我们只要把它渲染出来就可以了！</p>\n<p>最顶层我们要渲染一个<code>Router</code>, 代码在containers/Root.js中，我们就不重复列出代码清单了。</p>\n<p>然后我们开始渲染各个视图，这里我们只有一个视图，也就是目录是”/“的视图，我们把它渲染出来！</p>\n<p>routes.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*eslint-disable*/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Route &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./containers/App'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> containers <span class=\"keyword\">from</span> <span class=\"string\">'./containers'</span></span><br><span class=\"line\"><span class=\"comment\">/*eslint-enable*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  CounterPage</span><br><span class=\"line\">&#125; = containers</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (</span><br><span class=\"line\">  &lt;Route component=&#123;App&#125;&gt;</span><br><span class=\"line\">    &lt;Route path=<span class=\"string\">\"/\"</span> component=&#123;CounterPage&#125; /&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Route&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n<p>我们导出了一个视图，这个视图的组件是<code>CounterPage</code>。就是这么简单！</p>\n<p>然后，我们在containers/Root.js，将它渲染到<code>Router</code>组件里面就可以了！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Router key=<span class=\"string\">\"router\"</span> history=&#123;history&#125; children=&#123;routes&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>我们可以发现，我们并没有把devtools这个组件放在路由组件里面。这意味着，无论你如何切换视图，devtools都一直会渲染出来！</p>\n<p>当然react-router的api还有很多，我们只是用了很少一部分，我不建议专门阅读api文档，应该在项目中，遇到不会的查询api文档，这样对api的用法的理解会更加的深刻！</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>\n","site":{"data":{}},"excerpt":"<p>上节课，我们介绍了一些es6的新语法：<a href=\"https://lewis617.github.io/2016/01/21/r2-array/\" target=\"_blank\" rel=\"noopener\">React 与 Redux 教程（三）reduce()、filter()、map()、some()、every()、…展开属性</a></p>\n<p>今天我们通过解读redux-undo的官方示例代码来学习，在Redux中使用撤销功能、devtools功能、以及router。</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/164.gif\" alt=\"\"></p>\n<p>这个例子是个计数器程序，包含计数器、右边的Redux开发工具、还有一个路由（不过只有”/“这一个地址）。</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/redux-undo-boilerplate\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/redux-undo-boilerplate</a></p>\n<h2 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h2><p>实现撤销功能非常简单，你只需要使你的reducers可以撤销就可以了。这是什么意思呢？看代码</p>\n<p>reducers/index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./counter'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  INCREMENT_COUNTER, DECREMENT_COUNTER,</span><br><span class=\"line\">  UNDO_COUNTER, REDO_COUNTER</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions/counter'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> undoable, &#123; includeAction &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux-undo'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rootReducer = combineReducers(&#123;</span><br><span class=\"line\">  counter: undoable(counter, &#123;</span><br><span class=\"line\">    filter: includeAction([INCREMENT_COUNTER, DECREMENT_COUNTER]),</span><br><span class=\"line\">    limit: <span class=\"number\">10</span>,</span><br><span class=\"line\">    debug: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    undoType: UNDO_COUNTER,</span><br><span class=\"line\">    redoType: REDO_COUNTER</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> rootReducer</span><br></pre></td></tr></table></figure>\n<p>我们使用<code>redux-undo</code>这个包给我们提供的<code>undoable</code>和<code>includeAction</code>，就可以可以给指定reducer（counter）添加撤销功能。<code>filter</code>是选择过滤的action有哪些，这里我们只撤销重做加减action，也就是<code>INCREMENT_COUNTER</code>, <code>DECREMENT_COUNTER</code>，  <code>limit</code>是次数限制，<code>debug</code>是是否调试码，<code>undotype</code>和<code>redotype</code>是撤销重做的action。</p>\n<p>如此以来，我只需要触发撤销重做的action便可以实现撤销重做功能，就是这么简单！</p>\n<h2 id=\"devtools\"><a href=\"#devtools\" class=\"headerlink\" title=\"devtools\"></a>devtools</h2><p>接下来，我们开始学习使用devtools这个功能，devtools是什么？devtools的实质其实也是组件。devtools能干什么？devtools可以帮助我们看到整个程序的状态和整个程序的触发的action的日志记录。我们如何安装devtools呢？首先，我们知道devtools是个组件，那么我们直接把devtools放在容器中渲染出来不就可以了吗？</p>\n<p>containers/DevTools.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*eslint-disable*/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createDevTools &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux-devtools'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> LogMonitor <span class=\"keyword\">from</span> <span class=\"string\">'redux-devtools-log-monitor'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> DockMonitor <span class=\"keyword\">from</span> <span class=\"string\">'redux-devtools-dock-monitor'</span></span><br><span class=\"line\"><span class=\"comment\">/*eslint-enable*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> createDevTools(</span><br><span class=\"line\">  &lt;DockMonitor toggleVisibilityKey=<span class=\"string\">\"H\"</span></span><br><span class=\"line\">               changePositionKey=<span class=\"string\">\"Q\"</span>&gt;</span><br><span class=\"line\">    &lt;LogMonitor /&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/DockMonitor&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n<p>这是一个可以复用的容器代码，也就意味着，你可以直接把这个js文件，复制粘贴到你的项目中。这段代码我们输出了一个devtools组件。</p>\n<p>containers/Root.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* global __DEVTOOLS__ */</span></span><br><span class=\"line\"><span class=\"comment\">/*eslint-disable*/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component, PropTypes &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Router &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> configureStore <span class=\"keyword\">from</span> <span class=\"string\">'../store/configureStore'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> routes <span class=\"keyword\">from</span> <span class=\"string\">'../routes'</span></span><br><span class=\"line\"><span class=\"comment\">/*eslint-enable*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = configureStore()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElements</span> (<span class=\"params\">history</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = [</span><br><span class=\"line\">    &lt;Router key=<span class=\"string\">\"router\"</span> history=&#123;history&#125; children=&#123;routes&#125; /&gt;</span><br><span class=\"line\">  ]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> __DEVTOOLS__ !== <span class=\"string\">'undefined'</span> &amp;&amp; __DEVTOOLS__) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*eslint-disable*/</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> DevTools = <span class=\"built_in\">require</span>(<span class=\"string\">'./DevTools'</span>)</span><br><span class=\"line\">    <span class=\"comment\">/*eslint-enable*/</span></span><br><span class=\"line\">    elements.push(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">DevTools</span> <span class=\"attr\">key</span>=<span class=\"string\">\"devtools\"</span> /&gt;</span>)</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  return elements</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">export default class Root extends Component &#123;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  static propTypes = &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    history: PropTypes.object.isRequired</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  render () &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    return (</span></span><br><span class=\"line\">      &lt;Provider store=&#123;store&#125; key=\"provider\"&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &#123;createElements(this.props.history)&#125;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">Provider</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    )</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这段代码，我们将我们导出的devtools组件放在了<code>router</code>这个组件的下面，不过我们加了一个<code>typeof DEVTOOLS !==&#39;undefined&#39; &amp;&amp; DEVTOOLS</code>的判断，如果条件成立，我们将渲染devtools，否则不渲染。这样做，意味着我们可以通过参数控制devtools在开发环境中显示，在生产环境中不显示。</p>\n<p>是不是渲染出来，就可以了？当然不是！我们还需要在<code>store</code>里面注册！</p>\n<p>store/configureStore.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* global __DEVTOOLS__ */</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"comment\">// reducer</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> rootReducer <span class=\"keyword\">from</span> <span class=\"string\">'../reducers'</span></span><br><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> thunkMiddleware <span class=\"keyword\">from</span> <span class=\"string\">'redux-thunk'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> promiseMiddleware <span class=\"keyword\">from</span> <span class=\"string\">'redux-promise'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> createLogger <span class=\"keyword\">from</span> <span class=\"string\">'redux-logger'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> loggerMiddleware = createLogger(&#123;</span><br><span class=\"line\">  level: <span class=\"string\">'info'</span>,</span><br><span class=\"line\">  collapsed: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> enforceImmutableMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'redux-immutable-state-invariant'</span>)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> createStoreWithMiddleware</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> __DEVTOOLS__ !== <span class=\"string\">'undefined'</span> &amp;&amp; __DEVTOOLS__) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; persistState &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'redux-devtools'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> DevTools = <span class=\"built_in\">require</span>(<span class=\"string\">'../containers/DevTools'</span>)</span><br><span class=\"line\">  createStoreWithMiddleware = compose(</span><br><span class=\"line\">    applyMiddleware(</span><br><span class=\"line\">      enforceImmutableMiddleware,</span><br><span class=\"line\">      thunkMiddleware,</span><br><span class=\"line\">      promiseMiddleware,</span><br><span class=\"line\">      loggerMiddleware</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    DevTools.instrument(),</span><br><span class=\"line\">    persistState(<span class=\"built_in\">window</span>.location.href.match(<span class=\"regexp\">/[?&amp;]debug_session=([^&amp;]+)\\b/</span>))</span><br><span class=\"line\">  )(createStore)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  createStoreWithMiddleware = compose(</span><br><span class=\"line\">    applyMiddleware(thunkMiddleware, promiseMiddleware)</span><br><span class=\"line\">  )(createStore)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates a preconfigured store.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">configureStore</span> (<span class=\"params\">initialState</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> store = createStoreWithMiddleware(rootReducer, initialState)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Enable Webpack hot module replacement for reducers</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'../reducers'</span>, () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextRootReducer = <span class=\"built_in\">require</span>(<span class=\"string\">'../reducers/index'</span>)</span><br><span class=\"line\">      store.replaceReducer(nextRootReducer)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> store</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此为止，devtools我们就安装好了，就是这么简单！把它渲染出来就可以了，可以放在整个程序的下面就可以了！</p>\n<h2 id=\"store-enhancer\"><a href=\"#store-enhancer\" class=\"headerlink\" title=\"store enhancer\"></a>store enhancer</h2><p><code>DevTools.instrument()</code> 这行代码使得devtools可以使用了！有的同学会问，这个<code>instrument()</code>是什么鬼？官方称之为store enhancer，翻译过来就是store加强器，跟<code>applymiddleware</code>是一类，都是store加强器。那么store加强器，能干什么？store加强器可以重新构建一个更牛逼的store，来替换之前的基础版的store，让你的程序可以增加很多别的功能，比如<code>appllymiddleware</code>可以给你的Redux增加中间件，使之可以拥有异步功能，日志功能等！</p>\n<h2 id=\"enforceImmutableMiddleware-thunkMiddleware-promiseMiddleware-loggerMiddleware\"><a href=\"#enforceImmutableMiddleware-thunkMiddleware-promiseMiddleware-loggerMiddleware\" class=\"headerlink\" title=\"enforceImmutableMiddleware,thunkMiddleware, promiseMiddleware, loggerMiddleware\"></a>enforceImmutableMiddleware,thunkMiddleware, promiseMiddleware, loggerMiddleware</h2><p>有的同学会问，<code>enforceImmutableMiddleware</code>是什么？干嘛用的？这个使用禁止你改变state的。什么？不改变state，我们如何更新状态，Redux不允许你改变state，在reducer中我们必须要返回一个新的state，而不是修改原来的state！</p>\n<p>那个<code>thunk</code>是什么？<code>thunk</code>我们已经在<a href=\"https://lewis617.github.io/2016/01/19/r2-counter/\" target=\"_blank\" rel=\"noopener\">React 与 Redux 教程（一）connect、applyMiddleware、thunk、webpackHotMiddleware</a>里面讲过了。</p>\n<p>那么什么是<code>promiseMiddleware</code>？这也是个中间件，和<code>thunk</code>一样，使得你的action可以具备异步的功能。不过，我们可以发现，本例中我们并没有用到<code>thunk</code>和<code>promiseMiddleware</code>这两个中间件，本例子是个种子文件，可以在这个基础上拓展，所以作者提前写好了两个常用中间件，便于我们日后使用！</p>\n<p>那么<code>loggerMiddleware</code>是用来干嘛的？顾名思义，就是用来记录日志的，当你添加这个中间件，你可以在命令行中看到相关的打印日志！当然你可以在运行程序的时候，去掉这个中间件，来对比观察它的作用！</p>\n<h2 id=\"instrument-与compose-写法\"><a href=\"#instrument-与compose-写法\" class=\"headerlink\" title=\"instrument()与compose()写法\"></a>instrument()与compose()写法</h2><p><code>instrument()</code>不同于<code>applymiddleware</code>，它只能用于开发环境，只能enable你的devtools组件！那么我们把<code>applymiddleware</code>和<code>instrument</code>用逗号隔开，为什么？这是compose写法，用来代替以前的函数嵌套！</p>\n<h2 id=\"Router\"><a href=\"#Router\" class=\"headerlink\" title=\"Router\"></a>Router</h2><p>简单来说，Router也是个组件，一个多重视图的组件，这个组件可以通过切换URL来切换视图，总之它还是个组件。既然是组件，我们只要把它渲染出来就可以了！</p>\n<p>最顶层我们要渲染一个<code>Router</code>, 代码在containers/Root.js中，我们就不重复列出代码清单了。</p>\n<p>然后我们开始渲染各个视图，这里我们只有一个视图，也就是目录是”/“的视图，我们把它渲染出来！</p>\n<p>routes.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*eslint-disable*/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Route &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./containers/App'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> containers <span class=\"keyword\">from</span> <span class=\"string\">'./containers'</span></span><br><span class=\"line\"><span class=\"comment\">/*eslint-enable*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  CounterPage</span><br><span class=\"line\">&#125; = containers</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (</span><br><span class=\"line\">  &lt;Route component=&#123;App&#125;&gt;</span><br><span class=\"line\">    &lt;Route path=<span class=\"string\">\"/\"</span> component=&#123;CounterPage&#125; /&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Route&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n<p>我们导出了一个视图，这个视图的组件是<code>CounterPage</code>。就是这么简单！</p>\n<p>然后，我们在containers/Root.js，将它渲染到<code>Router</code>组件里面就可以了！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Router key=<span class=\"string\">\"router\"</span> history=&#123;history&#125; children=&#123;routes&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>我们可以发现，我们并没有把devtools这个组件放在路由组件里面。这意味着，无论你如何切换视图，devtools都一直会渲染出来！</p>\n<p>当然react-router的api还有很多，我们只是用了很少一部分，我不建议专门阅读api文档，应该在项目中，遇到不会的查询api文档，这样对api的用法的理解会更加的深刻！</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>"},{"title":"React+Reflux入门教程","date":"2016-01-13T19:26:00.000Z","_content":"\n为了简化React的Flux带来的冗余操作，社区的同仁们给我们带来了很多优秀的轮子，诸如Redux，Reflux等。今天我们就通过逐行讲解代码实例的方法，感受一番Reflux的设计之美。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/165.gif)\n\n这个例子是非常简单的todo例子，学习语言从helloworld开始，学习框架从todo开始，这是我们码农界的文化传统！\n\n## 组件\n\ncomponents/todo.js\n\n```js\nimport React from 'react' import Reflux from 'reflux' import ReactMixin from 'react-mixin' import store from '../stores/store' import actions from '../actions/actions' export default class Todo extends React.Component{ //组件渲染完成后，通过action获取所有的数组，刷新绑定到this.state上\n componentDidMount() {\n    actions.getAll();\n  }\n\n  add(){ var item =this.refs.item.value; this.refs.item.value='';\n    actions.add(item);\n\n  }\n\n  remove(i){\n    actions.remove(i);\n  }\n\n  render() { //items用于乘放li的集合\n let items; if(this.state.list){\n      items=this.state.list.map( (item,i)=> { //设置key是因为react的diff算法，是通过key来计算最小变化的\n              return <li key={i}> {item.name} <button onClick={this.remove.bind(this,i)}>remove</button>\n              </li>\n })\n    } return ( <div>\n          <input type=\"text\" ref=\"item\"/>\n          <button onClick={this.add.bind(this)}>add</button>\n          <ul> {items} </ul>\n        </div>\n )\n  }\n} // ES6 mixin写法，通过mixin将store的与组件连接，功能是监听store带来的state变化并刷新到this.state\nReactMixin.onClass(Todo, Reflux.connect(store));\n```\n\n上述代码，我们干了3件事：\n\n1.  渲染了一个组件，这个组件包括一个`input`，一个add按钮，一个列表，列表每项包含名称和remove按钮\n2.  给这个组件添加了几个方法，其中`componentDidMount()`在组件渲染完成后触发，`componentDidMount()`、`add()`和`remove()`方法分别调用actions的方法去更新状态\n3.  最后一行代码，使用es6的mixin写法，使得组件监听store带来的state变化，并刷新界面。\n\n看到这里，很多没有接触过Reflux的同学可能已经晕了，我来图解下Reflux的功能流程吧！\n\n![](/css/images/166.jpg)\n\n组件就是用户界面，actions就是组件的动作，store用于执行actions的命令，并返回一个state对象给组件。组件通过state来更新界面。\n\n这里我想说说React和Angular的某个相同之处，就是将数据和界面绑定起来，通过操作数据来更新界面（不用苦逼的操作dom了）。我们把数据和界面的规则建好后，更新数据，界面自动就变化了。在这里，数据指的是`this.state`，界面指的是组件。\n\n那么为何要用actions和store这么多层去更新state呢？为了以后项目业务逻辑变复杂后便于管理。为什么便于管理，因为actions有很多钩子，钩子就是“触发之前，触发之后的回调什么的”，这些钩子我们以后会用得上。\n\n## actions和store两个好基友开始更新状态\n\nactions/actions.js\n\n```js\nimport Reflux from 'reflux' export default Reflux.createActions(['getAll','add','remove']);\n```\n\nstores/store.js\n\n```\nimport Reflux from 'reflux' import actions from '../actions/actions'\n\n//给数组添加remove方法，用于去除指定下标的元素\nArray.prototype.remove=function(dx)\n{ if(isNaN(dx)||dx>this.length){return false;} for(var i=0,n=0;i<this.length;i++)\n    { if(this[i]!=this[dx])\n        { this[n++]=this[i]\n        }\n    } this.length-=1 };\n\nexport default Reflux.createStore({\n    items:[], //监听所有的actions\n listenables: [actions], //on开头的都是action触发后的回调函数\n onGetAll () { //更新状态（就是个对象）\n        this.trigger({list:this.items});\n    },\n    onAdd(item){ this.items.push({name:item}); this.trigger({list:this.items});\n    },\n    onRemove(i){ this.items.remove(i); this.trigger({list:this.items});\n    }\n});\n```\n\n上述代码，我们干了3件事：\n\n1.  给数组对象的原型添加一个remove的方法，用于删除指定下标的元素\n2.  创建一个store，监听actions的方法\n3.  在store里，on开头的都是actions对应的回调函数，this.trigger()，负责更新state（这里指的是{list:this.items}这个对象）\n\n## 渲染组件\n\nindex.js\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport Todo from './components/todo';\n\nReactDOM.render( <Todo>\n  </Todo>,\n  document.querySelector('#app')\n);\n```\n\n## 最后，用webpack编译\n\nwebpack.config.js\n\n```js\nvar path = require('path'); var webpack = require('webpack');\n\nmodule.exports = {\n    entry: {\n        app:path.join(__dirname, 'src'),\n        vendors: ['react','reflux','react-mixin']\n    },\n    output: {\n        path: path.join(__dirname, 'dist'),\n        filename: '[name].js' },\n    module: {\n        loaders: [\n            {\n                test:/\\.js?$/,\n                exclude:/node_modules/,\n                loader:'babel',\n                query:{\n                    presets:['react','es2015']\n                }\n            }\n        ]\n    },\n    plugins: [ new webpack.optimize.CommonsChunkPlugin('vendors', 'vendors.js')\n    ]\n};\n```\n\n## 总结\n\n相比较Redux而言，\n\n1.  Reflux没有reducer的概念，取而代之，和action做基友的是store\n2.  Reflux没有把状态的一部分值绑定在组件的props上，而是将状态绑定在组件的state上，我们来看react dev tool的截图![](/css/images/167.jpg)\n3.  Reflux可以直接调用action的方法，而Redux必须将方法绑定在组件的props上，或者使用props的dispatch方法来执行actions的方法\n4.  ……\n\n由此看来，Reflux好理解的多，但是Redux的单一state是实际项目中是非常好用的，所以，Redux在Github上的星星比Reflux多得多！两个都是社区同仁智慧的结晶，都是优秀的值得学习的轮子！\n\n源代码：\n\n[https://github.com/lewis617/react-redux-tutorial/tree/master/todo-reflux](https://github.com/lewis617/react-redux-tutorial/tree/master/todo-reflux)\n\n运行方法：\n\n```sh\nnpm install\n\nnpm run build\n```\n手动打开index.html\n\n* * *\n\n# 教程示例代码及目录\n\n[https://github.com/lewis617/react-redux-tutorial](https://github.com/lewis617/react-redux-tutorial)","source":"_posts/react-reflux.md","raw":"---\ntitle: React+Reflux入门教程\ndate: 2016-01-14 03:26:00\ntags: [React, Reflux]\n---\n\n为了简化React的Flux带来的冗余操作，社区的同仁们给我们带来了很多优秀的轮子，诸如Redux，Reflux等。今天我们就通过逐行讲解代码实例的方法，感受一番Reflux的设计之美。\n\n<!--more-->\n\n## 例子\n\n![](/css/images/165.gif)\n\n这个例子是非常简单的todo例子，学习语言从helloworld开始，学习框架从todo开始，这是我们码农界的文化传统！\n\n## 组件\n\ncomponents/todo.js\n\n```js\nimport React from 'react' import Reflux from 'reflux' import ReactMixin from 'react-mixin' import store from '../stores/store' import actions from '../actions/actions' export default class Todo extends React.Component{ //组件渲染完成后，通过action获取所有的数组，刷新绑定到this.state上\n componentDidMount() {\n    actions.getAll();\n  }\n\n  add(){ var item =this.refs.item.value; this.refs.item.value='';\n    actions.add(item);\n\n  }\n\n  remove(i){\n    actions.remove(i);\n  }\n\n  render() { //items用于乘放li的集合\n let items; if(this.state.list){\n      items=this.state.list.map( (item,i)=> { //设置key是因为react的diff算法，是通过key来计算最小变化的\n              return <li key={i}> {item.name} <button onClick={this.remove.bind(this,i)}>remove</button>\n              </li>\n })\n    } return ( <div>\n          <input type=\"text\" ref=\"item\"/>\n          <button onClick={this.add.bind(this)}>add</button>\n          <ul> {items} </ul>\n        </div>\n )\n  }\n} // ES6 mixin写法，通过mixin将store的与组件连接，功能是监听store带来的state变化并刷新到this.state\nReactMixin.onClass(Todo, Reflux.connect(store));\n```\n\n上述代码，我们干了3件事：\n\n1.  渲染了一个组件，这个组件包括一个`input`，一个add按钮，一个列表，列表每项包含名称和remove按钮\n2.  给这个组件添加了几个方法，其中`componentDidMount()`在组件渲染完成后触发，`componentDidMount()`、`add()`和`remove()`方法分别调用actions的方法去更新状态\n3.  最后一行代码，使用es6的mixin写法，使得组件监听store带来的state变化，并刷新界面。\n\n看到这里，很多没有接触过Reflux的同学可能已经晕了，我来图解下Reflux的功能流程吧！\n\n![](/css/images/166.jpg)\n\n组件就是用户界面，actions就是组件的动作，store用于执行actions的命令，并返回一个state对象给组件。组件通过state来更新界面。\n\n这里我想说说React和Angular的某个相同之处，就是将数据和界面绑定起来，通过操作数据来更新界面（不用苦逼的操作dom了）。我们把数据和界面的规则建好后，更新数据，界面自动就变化了。在这里，数据指的是`this.state`，界面指的是组件。\n\n那么为何要用actions和store这么多层去更新state呢？为了以后项目业务逻辑变复杂后便于管理。为什么便于管理，因为actions有很多钩子，钩子就是“触发之前，触发之后的回调什么的”，这些钩子我们以后会用得上。\n\n## actions和store两个好基友开始更新状态\n\nactions/actions.js\n\n```js\nimport Reflux from 'reflux' export default Reflux.createActions(['getAll','add','remove']);\n```\n\nstores/store.js\n\n```\nimport Reflux from 'reflux' import actions from '../actions/actions'\n\n//给数组添加remove方法，用于去除指定下标的元素\nArray.prototype.remove=function(dx)\n{ if(isNaN(dx)||dx>this.length){return false;} for(var i=0,n=0;i<this.length;i++)\n    { if(this[i]!=this[dx])\n        { this[n++]=this[i]\n        }\n    } this.length-=1 };\n\nexport default Reflux.createStore({\n    items:[], //监听所有的actions\n listenables: [actions], //on开头的都是action触发后的回调函数\n onGetAll () { //更新状态（就是个对象）\n        this.trigger({list:this.items});\n    },\n    onAdd(item){ this.items.push({name:item}); this.trigger({list:this.items});\n    },\n    onRemove(i){ this.items.remove(i); this.trigger({list:this.items});\n    }\n});\n```\n\n上述代码，我们干了3件事：\n\n1.  给数组对象的原型添加一个remove的方法，用于删除指定下标的元素\n2.  创建一个store，监听actions的方法\n3.  在store里，on开头的都是actions对应的回调函数，this.trigger()，负责更新state（这里指的是{list:this.items}这个对象）\n\n## 渲染组件\n\nindex.js\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport Todo from './components/todo';\n\nReactDOM.render( <Todo>\n  </Todo>,\n  document.querySelector('#app')\n);\n```\n\n## 最后，用webpack编译\n\nwebpack.config.js\n\n```js\nvar path = require('path'); var webpack = require('webpack');\n\nmodule.exports = {\n    entry: {\n        app:path.join(__dirname, 'src'),\n        vendors: ['react','reflux','react-mixin']\n    },\n    output: {\n        path: path.join(__dirname, 'dist'),\n        filename: '[name].js' },\n    module: {\n        loaders: [\n            {\n                test:/\\.js?$/,\n                exclude:/node_modules/,\n                loader:'babel',\n                query:{\n                    presets:['react','es2015']\n                }\n            }\n        ]\n    },\n    plugins: [ new webpack.optimize.CommonsChunkPlugin('vendors', 'vendors.js')\n    ]\n};\n```\n\n## 总结\n\n相比较Redux而言，\n\n1.  Reflux没有reducer的概念，取而代之，和action做基友的是store\n2.  Reflux没有把状态的一部分值绑定在组件的props上，而是将状态绑定在组件的state上，我们来看react dev tool的截图![](/css/images/167.jpg)\n3.  Reflux可以直接调用action的方法，而Redux必须将方法绑定在组件的props上，或者使用props的dispatch方法来执行actions的方法\n4.  ……\n\n由此看来，Reflux好理解的多，但是Redux的单一state是实际项目中是非常好用的，所以，Redux在Github上的星星比Reflux多得多！两个都是社区同仁智慧的结晶，都是优秀的值得学习的轮子！\n\n源代码：\n\n[https://github.com/lewis617/react-redux-tutorial/tree/master/todo-reflux](https://github.com/lewis617/react-redux-tutorial/tree/master/todo-reflux)\n\n运行方法：\n\n```sh\nnpm install\n\nnpm run build\n```\n手动打开index.html\n\n* * *\n\n# 教程示例代码及目录\n\n[https://github.com/lewis617/react-redux-tutorial](https://github.com/lewis617/react-redux-tutorial)","slug":"react-reflux","published":1,"updated":"2019-05-01T08:10:30.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmi002utgyt72c70504","content":"<p>为了简化React的Flux带来的冗余操作，社区的同仁们给我们带来了很多优秀的轮子，诸如Redux，Reflux等。今天我们就通过逐行讲解代码实例的方法，感受一番Reflux的设计之美。</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/165.gif\" alt=\"\"></p>\n<p>这个例子是非常简单的todo例子，学习语言从helloworld开始，学习框架从todo开始，这是我们码农界的文化传统！</p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><p>components/todo.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span> <span class=\"keyword\">import</span> Reflux <span class=\"keyword\">from</span> <span class=\"string\">'reflux'</span> <span class=\"keyword\">import</span> ReactMixin <span class=\"keyword\">from</span> <span class=\"string\">'react-mixin'</span> <span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'../stores/store'</span> <span class=\"keyword\">import</span> actions <span class=\"keyword\">from</span> <span class=\"string\">'../actions/actions'</span> <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Todo</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123; <span class=\"comment\">//组件渲染完成后，通过action获取所有的数组，刷新绑定到this.state上</span></span><br><span class=\"line\"> componentDidMount() &#123;</span><br><span class=\"line\">    actions.getAll();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  add()&#123; <span class=\"keyword\">var</span> item =<span class=\"keyword\">this</span>.refs.item.value; <span class=\"keyword\">this</span>.refs.item.value=<span class=\"string\">''</span>;</span><br><span class=\"line\">    actions.add(item);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  remove(i)&#123;</span><br><span class=\"line\">    actions.remove(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123; <span class=\"comment\">//items用于乘放li的集合</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> items; <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state.list)&#123;</span><br><span class=\"line\">      items=<span class=\"keyword\">this</span>.state.list.map( <span class=\"function\">(<span class=\"params\">item,i</span>)=&gt;</span> &#123; <span class=\"comment\">//设置key是因为react的diff算法，是通过key来计算最小变化的</span></span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;i&#125;</span>&gt;</span> &#123;item.name&#125; <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.remove.bind(this,i)&#125;</span>&gt;</span>remove<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">              <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">return</span> ( <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">          &lt;input type=\"text\" ref=\"item\"/&gt;</span><br><span class=\"line\">          &lt;button onClick=&#123;this.add.bind(this)&#125;&gt;add&lt;/button&gt;</span><br><span class=\"line\">          &lt;ul&gt; &#123;items&#125; &lt;/ul&gt;</span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"> )</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125; // ES6 mixin写法，通过mixin将store的与组件连接，功能是监听store带来的state变化并刷新到this.state</span></span><br><span class=\"line\"><span class=\"xml\">ReactMixin.onClass(Todo, Reflux.connect(store));</span></span><br></pre></td></tr></table></figure>\n<p>上述代码，我们干了3件事：</p>\n<ol>\n<li>渲染了一个组件，这个组件包括一个<code>input</code>，一个add按钮，一个列表，列表每项包含名称和remove按钮</li>\n<li>给这个组件添加了几个方法，其中<code>componentDidMount()</code>在组件渲染完成后触发，<code>componentDidMount()</code>、<code>add()</code>和<code>remove()</code>方法分别调用actions的方法去更新状态</li>\n<li>最后一行代码，使用es6的mixin写法，使得组件监听store带来的state变化，并刷新界面。</li>\n</ol>\n<p>看到这里，很多没有接触过Reflux的同学可能已经晕了，我来图解下Reflux的功能流程吧！</p>\n<p><img src=\"/css/images/166.jpg\" alt=\"\"></p>\n<p>组件就是用户界面，actions就是组件的动作，store用于执行actions的命令，并返回一个state对象给组件。组件通过state来更新界面。</p>\n<p>这里我想说说React和Angular的某个相同之处，就是将数据和界面绑定起来，通过操作数据来更新界面（不用苦逼的操作dom了）。我们把数据和界面的规则建好后，更新数据，界面自动就变化了。在这里，数据指的是<code>this.state</code>，界面指的是组件。</p>\n<p>那么为何要用actions和store这么多层去更新state呢？为了以后项目业务逻辑变复杂后便于管理。为什么便于管理，因为actions有很多钩子，钩子就是“触发之前，触发之后的回调什么的”，这些钩子我们以后会用得上。</p>\n<h2 id=\"actions和store两个好基友开始更新状态\"><a href=\"#actions和store两个好基友开始更新状态\" class=\"headerlink\" title=\"actions和store两个好基友开始更新状态\"></a>actions和store两个好基友开始更新状态</h2><p>actions/actions.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Reflux <span class=\"keyword\">from</span> <span class=\"string\">'reflux'</span> <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Reflux.createActions([<span class=\"string\">'getAll'</span>,<span class=\"string\">'add'</span>,<span class=\"string\">'remove'</span>]);</span><br></pre></td></tr></table></figure>\n<p>stores/store.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Reflux from &apos;reflux&apos; import actions from &apos;../actions/actions&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">//给数组添加remove方法，用于去除指定下标的元素</span><br><span class=\"line\">Array.prototype.remove=function(dx)</span><br><span class=\"line\">&#123; if(isNaN(dx)||dx&gt;this.length)&#123;return false;&#125; for(var i=0,n=0;i&lt;this.length;i++)</span><br><span class=\"line\">    &#123; if(this[i]!=this[dx])</span><br><span class=\"line\">        &#123; this[n++]=this[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; this.length-=1 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Reflux.createStore(&#123;</span><br><span class=\"line\">    items:[], //监听所有的actions</span><br><span class=\"line\"> listenables: [actions], //on开头的都是action触发后的回调函数</span><br><span class=\"line\"> onGetAll () &#123; //更新状态（就是个对象）</span><br><span class=\"line\">        this.trigger(&#123;list:this.items&#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onAdd(item)&#123; this.items.push(&#123;name:item&#125;); this.trigger(&#123;list:this.items&#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onRemove(i)&#123; this.items.remove(i); this.trigger(&#123;list:this.items&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码，我们干了3件事：</p>\n<ol>\n<li>给数组对象的原型添加一个remove的方法，用于删除指定下标的元素</li>\n<li>创建一个store，监听actions的方法</li>\n<li>在store里，on开头的都是actions对应的回调函数，this.trigger()，负责更新state（这里指的是{list:this.items}这个对象）</li>\n</ol>\n<h2 id=\"渲染组件\"><a href=\"#渲染组件\" class=\"headerlink\" title=\"渲染组件\"></a>渲染组件</h2><p>index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Todo <span class=\"keyword\">from</span> <span class=\"string\">'./components/todo'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render( <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Todo</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;/<span class=\"name\">Todo</span>&gt;</span></span>,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#app'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"最后，用webpack编译\"><a href=\"#最后，用webpack编译\" class=\"headerlink\" title=\"最后，用webpack编译\"></a>最后，用webpack编译</h2><p>webpack.config.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>); <span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        app:path.join(__dirname, <span class=\"string\">'src'</span>),</span><br><span class=\"line\">        vendors: [<span class=\"string\">'react'</span>,<span class=\"string\">'reflux'</span>,<span class=\"string\">'react-mixin'</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: path.join(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">        filename: <span class=\"string\">'[name].js'</span> &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test:<span class=\"regexp\">/\\.js?$/</span>,</span><br><span class=\"line\">                exclude:<span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">                loader:<span class=\"string\">'babel'</span>,</span><br><span class=\"line\">                query:&#123;</span><br><span class=\"line\">                    presets:[<span class=\"string\">'react'</span>,<span class=\"string\">'es2015'</span>]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins: [ <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(<span class=\"string\">'vendors'</span>, <span class=\"string\">'vendors.js'</span>)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>相比较Redux而言，</p>\n<ol>\n<li>Reflux没有reducer的概念，取而代之，和action做基友的是store</li>\n<li>Reflux没有把状态的一部分值绑定在组件的props上，而是将状态绑定在组件的state上，我们来看react dev tool的截图<img src=\"/css/images/167.jpg\" alt=\"\"></li>\n<li>Reflux可以直接调用action的方法，而Redux必须将方法绑定在组件的props上，或者使用props的dispatch方法来执行actions的方法</li>\n<li>……</li>\n</ol>\n<p>由此看来，Reflux好理解的多，但是Redux的单一state是实际项目中是非常好用的，所以，Redux在Github上的星星比Reflux多得多！两个都是社区同仁智慧的结晶，都是优秀的值得学习的轮子！</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/todo-reflux\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/todo-reflux</a></p>\n<p>运行方法：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n<p>手动打开index.html</p>\n<hr>\n<h1 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h1><p><a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n","site":{"data":{}},"excerpt":"<p>为了简化React的Flux带来的冗余操作，社区的同仁们给我们带来了很多优秀的轮子，诸如Redux，Reflux等。今天我们就通过逐行讲解代码实例的方法，感受一番Reflux的设计之美。</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><img src=\"/css/images/165.gif\" alt=\"\"></p>\n<p>这个例子是非常简单的todo例子，学习语言从helloworld开始，学习框架从todo开始，这是我们码农界的文化传统！</p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><p>components/todo.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span> <span class=\"keyword\">import</span> Reflux <span class=\"keyword\">from</span> <span class=\"string\">'reflux'</span> <span class=\"keyword\">import</span> ReactMixin <span class=\"keyword\">from</span> <span class=\"string\">'react-mixin'</span> <span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'../stores/store'</span> <span class=\"keyword\">import</span> actions <span class=\"keyword\">from</span> <span class=\"string\">'../actions/actions'</span> <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Todo</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123; <span class=\"comment\">//组件渲染完成后，通过action获取所有的数组，刷新绑定到this.state上</span></span><br><span class=\"line\"> componentDidMount() &#123;</span><br><span class=\"line\">    actions.getAll();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  add()&#123; <span class=\"keyword\">var</span> item =<span class=\"keyword\">this</span>.refs.item.value; <span class=\"keyword\">this</span>.refs.item.value=<span class=\"string\">''</span>;</span><br><span class=\"line\">    actions.add(item);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  remove(i)&#123;</span><br><span class=\"line\">    actions.remove(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123; <span class=\"comment\">//items用于乘放li的集合</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> items; <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state.list)&#123;</span><br><span class=\"line\">      items=<span class=\"keyword\">this</span>.state.list.map( <span class=\"function\">(<span class=\"params\">item,i</span>)=&gt;</span> &#123; <span class=\"comment\">//设置key是因为react的diff算法，是通过key来计算最小变化的</span></span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;i&#125;</span>&gt;</span> &#123;item.name&#125; <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.remove.bind(this,i)&#125;</span>&gt;</span>remove<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">              <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">return</span> ( <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">          &lt;input type=\"text\" ref=\"item\"/&gt;</span><br><span class=\"line\">          &lt;button onClick=&#123;this.add.bind(this)&#125;&gt;add&lt;/button&gt;</span><br><span class=\"line\">          &lt;ul&gt; &#123;items&#125; &lt;/ul&gt;</span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"> )</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125; // ES6 mixin写法，通过mixin将store的与组件连接，功能是监听store带来的state变化并刷新到this.state</span></span><br><span class=\"line\"><span class=\"xml\">ReactMixin.onClass(Todo, Reflux.connect(store));</span></span><br></pre></td></tr></table></figure>\n<p>上述代码，我们干了3件事：</p>\n<ol>\n<li>渲染了一个组件，这个组件包括一个<code>input</code>，一个add按钮，一个列表，列表每项包含名称和remove按钮</li>\n<li>给这个组件添加了几个方法，其中<code>componentDidMount()</code>在组件渲染完成后触发，<code>componentDidMount()</code>、<code>add()</code>和<code>remove()</code>方法分别调用actions的方法去更新状态</li>\n<li>最后一行代码，使用es6的mixin写法，使得组件监听store带来的state变化，并刷新界面。</li>\n</ol>\n<p>看到这里，很多没有接触过Reflux的同学可能已经晕了，我来图解下Reflux的功能流程吧！</p>\n<p><img src=\"/css/images/166.jpg\" alt=\"\"></p>\n<p>组件就是用户界面，actions就是组件的动作，store用于执行actions的命令，并返回一个state对象给组件。组件通过state来更新界面。</p>\n<p>这里我想说说React和Angular的某个相同之处，就是将数据和界面绑定起来，通过操作数据来更新界面（不用苦逼的操作dom了）。我们把数据和界面的规则建好后，更新数据，界面自动就变化了。在这里，数据指的是<code>this.state</code>，界面指的是组件。</p>\n<p>那么为何要用actions和store这么多层去更新state呢？为了以后项目业务逻辑变复杂后便于管理。为什么便于管理，因为actions有很多钩子，钩子就是“触发之前，触发之后的回调什么的”，这些钩子我们以后会用得上。</p>\n<h2 id=\"actions和store两个好基友开始更新状态\"><a href=\"#actions和store两个好基友开始更新状态\" class=\"headerlink\" title=\"actions和store两个好基友开始更新状态\"></a>actions和store两个好基友开始更新状态</h2><p>actions/actions.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Reflux <span class=\"keyword\">from</span> <span class=\"string\">'reflux'</span> <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Reflux.createActions([<span class=\"string\">'getAll'</span>,<span class=\"string\">'add'</span>,<span class=\"string\">'remove'</span>]);</span><br></pre></td></tr></table></figure>\n<p>stores/store.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Reflux from &apos;reflux&apos; import actions from &apos;../actions/actions&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">//给数组添加remove方法，用于去除指定下标的元素</span><br><span class=\"line\">Array.prototype.remove=function(dx)</span><br><span class=\"line\">&#123; if(isNaN(dx)||dx&gt;this.length)&#123;return false;&#125; for(var i=0,n=0;i&lt;this.length;i++)</span><br><span class=\"line\">    &#123; if(this[i]!=this[dx])</span><br><span class=\"line\">        &#123; this[n++]=this[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; this.length-=1 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Reflux.createStore(&#123;</span><br><span class=\"line\">    items:[], //监听所有的actions</span><br><span class=\"line\"> listenables: [actions], //on开头的都是action触发后的回调函数</span><br><span class=\"line\"> onGetAll () &#123; //更新状态（就是个对象）</span><br><span class=\"line\">        this.trigger(&#123;list:this.items&#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onAdd(item)&#123; this.items.push(&#123;name:item&#125;); this.trigger(&#123;list:this.items&#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onRemove(i)&#123; this.items.remove(i); this.trigger(&#123;list:this.items&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码，我们干了3件事：</p>\n<ol>\n<li>给数组对象的原型添加一个remove的方法，用于删除指定下标的元素</li>\n<li>创建一个store，监听actions的方法</li>\n<li>在store里，on开头的都是actions对应的回调函数，this.trigger()，负责更新state（这里指的是{list:this.items}这个对象）</li>\n</ol>\n<h2 id=\"渲染组件\"><a href=\"#渲染组件\" class=\"headerlink\" title=\"渲染组件\"></a>渲染组件</h2><p>index.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Todo <span class=\"keyword\">from</span> <span class=\"string\">'./components/todo'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render( <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Todo</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;/<span class=\"name\">Todo</span>&gt;</span></span>,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#app'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"最后，用webpack编译\"><a href=\"#最后，用webpack编译\" class=\"headerlink\" title=\"最后，用webpack编译\"></a>最后，用webpack编译</h2><p>webpack.config.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>); <span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        app:path.join(__dirname, <span class=\"string\">'src'</span>),</span><br><span class=\"line\">        vendors: [<span class=\"string\">'react'</span>,<span class=\"string\">'reflux'</span>,<span class=\"string\">'react-mixin'</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: path.join(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">        filename: <span class=\"string\">'[name].js'</span> &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test:<span class=\"regexp\">/\\.js?$/</span>,</span><br><span class=\"line\">                exclude:<span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">                loader:<span class=\"string\">'babel'</span>,</span><br><span class=\"line\">                query:&#123;</span><br><span class=\"line\">                    presets:[<span class=\"string\">'react'</span>,<span class=\"string\">'es2015'</span>]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins: [ <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(<span class=\"string\">'vendors'</span>, <span class=\"string\">'vendors.js'</span>)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>相比较Redux而言，</p>\n<ol>\n<li>Reflux没有reducer的概念，取而代之，和action做基友的是store</li>\n<li>Reflux没有把状态的一部分值绑定在组件的props上，而是将状态绑定在组件的state上，我们来看react dev tool的截图<img src=\"/css/images/167.jpg\" alt=\"\"></li>\n<li>Reflux可以直接调用action的方法，而Redux必须将方法绑定在组件的props上，或者使用props的dispatch方法来执行actions的方法</li>\n<li>……</li>\n</ol>\n<p>由此看来，Reflux好理解的多，但是Redux的单一state是实际项目中是非常好用的，所以，Redux在Github上的星星比Reflux多得多！两个都是社区同仁智慧的结晶，都是优秀的值得学习的轮子！</p>\n<p>源代码：</p>\n<p><a href=\"https://github.com/lewis617/react-redux-tutorial/tree/master/todo-reflux\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial/tree/master/todo-reflux</a></p>\n<p>运行方法：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n<p>手动打开index.html</p>\n<hr>\n<h1 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h1><p><a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>"},{"title":"用更少的代码发起异步 action","date":"2016-11-30T20:18:00.000Z","_content":"\n很多人说 Redux 代码多，开发效率低。其实 Redux 是可以灵活使用以及拓展的，经过充分定制的 Redux 其实写不了几行代码。今天先介绍一个很好用的 Redux 拓展—— [redux-amrc](https://github.com/lewis617/redux-amrc)。它可以帮助我们使用更少的样板代码发起异步 action。\n\n<!--more-->\n\n## 低效的过去\n\n一般情况下，为了清楚地记录异步的过程，我们需要使用 三个 action 来记录状态变化。通常，我们的代码会是这样：\n\n```js\nconst LOAD = 'redux-example/auth/LOAD';\nconst LOAD_SUCCESS = 'redux-example/auth/LOAD_SUCCESS';\nconst LOAD_FAIL = 'redux-example/auth/LOAD_FAIL';\n```\n\n写完这么多 action，还要在异步的前后发起它们，当然这时你可能会用中间件，所以你的代码最少也会是这样：\n\n```js\nexport function load() {\n  return {\n    types: [LOAD, LOAD_SUCCESS, LOAD_FAIL],\n    promise: (client) => client.get('/loadAuth')\n  };\n}\n```\n\n发起 action 后，还要编写 reducer 来处理这些 action，以改变状态：\n\n```js\nexport default function reducer(state = initialState, action = {}) {\n  switch (action.type) {\n    case LOAD:\n      return {\n        ...state,\n        loading: true\n      };\n    case LOAD_SUCCESS:\n      return {\n        ...state,\n        loading: false,\n        loaded: true,\n        user: action.result\n      };\n    case LOAD_FAIL:\n      return {\n        ...state,\n        loading: false,\n        loaded: false,\n        error: action.error\n\tdefault:\n      return state;\n  }\n}  \n```\n\n这太痛苦了，不就是发起一个异步吗？非要让我写这么多代码？\n\n其实，上述过程是可以简化的。记得有篇文章叫《超过90秒的任务不自动化，你好意思说自己是黑客？》，前端工程师也应该具有黑客精神，接下来就让我们使用 redux-amrc 将上述过程简化。\n\n## 轻松的现在\n\n使用了 redux-amrc 后，再也不用写这么多 action了，甚至连处理这些 action 的 reducer 都不用写，你只需要把异步以 Promise 的形式传给 redux-amrc 就行了。没有 action，没有 reducer，只需要编写一个 action 创建函数并发起它就可以了！就是这么清爽！\n\n```js\nimport fetch from 'isomorphic-fetch';\nimport { ASYNC } from 'redux-amrc';\n\nexport function load() {\n  return {\n    [ASYNC]: {\n      key: 'counter',\n      promise: () => fetch('http://localhost:3000/api/counter')\n        .then(response => response.json())\n    }\n  };\n}\n```\n\n另外，附一张使用 redux-amrc 的程序截图，看到 async 那颗树了吗，就是这个插件自动帮你构建的，你可以获取 `value`、`error`、`loading`、`loaded`、`loadingNumber`，应有尽有，而且全自动生成！\n\n![](/css/images/168.jpg)\n\n快把这个插件用到你的 Redux 应用中吧！具体用法请参考 [redux-amrc 中文文档](https://lewis617.github.io/redux-amrc/)。\n","source":"_posts/redux-amrc.md","raw":"---\ntitle: 用更少的代码发起异步 action\ndate: 2016-12-1 04:18:00\ntags: [Redux, redux-amrc]\n---\n\n很多人说 Redux 代码多，开发效率低。其实 Redux 是可以灵活使用以及拓展的，经过充分定制的 Redux 其实写不了几行代码。今天先介绍一个很好用的 Redux 拓展—— [redux-amrc](https://github.com/lewis617/redux-amrc)。它可以帮助我们使用更少的样板代码发起异步 action。\n\n<!--more-->\n\n## 低效的过去\n\n一般情况下，为了清楚地记录异步的过程，我们需要使用 三个 action 来记录状态变化。通常，我们的代码会是这样：\n\n```js\nconst LOAD = 'redux-example/auth/LOAD';\nconst LOAD_SUCCESS = 'redux-example/auth/LOAD_SUCCESS';\nconst LOAD_FAIL = 'redux-example/auth/LOAD_FAIL';\n```\n\n写完这么多 action，还要在异步的前后发起它们，当然这时你可能会用中间件，所以你的代码最少也会是这样：\n\n```js\nexport function load() {\n  return {\n    types: [LOAD, LOAD_SUCCESS, LOAD_FAIL],\n    promise: (client) => client.get('/loadAuth')\n  };\n}\n```\n\n发起 action 后，还要编写 reducer 来处理这些 action，以改变状态：\n\n```js\nexport default function reducer(state = initialState, action = {}) {\n  switch (action.type) {\n    case LOAD:\n      return {\n        ...state,\n        loading: true\n      };\n    case LOAD_SUCCESS:\n      return {\n        ...state,\n        loading: false,\n        loaded: true,\n        user: action.result\n      };\n    case LOAD_FAIL:\n      return {\n        ...state,\n        loading: false,\n        loaded: false,\n        error: action.error\n\tdefault:\n      return state;\n  }\n}  \n```\n\n这太痛苦了，不就是发起一个异步吗？非要让我写这么多代码？\n\n其实，上述过程是可以简化的。记得有篇文章叫《超过90秒的任务不自动化，你好意思说自己是黑客？》，前端工程师也应该具有黑客精神，接下来就让我们使用 redux-amrc 将上述过程简化。\n\n## 轻松的现在\n\n使用了 redux-amrc 后，再也不用写这么多 action了，甚至连处理这些 action 的 reducer 都不用写，你只需要把异步以 Promise 的形式传给 redux-amrc 就行了。没有 action，没有 reducer，只需要编写一个 action 创建函数并发起它就可以了！就是这么清爽！\n\n```js\nimport fetch from 'isomorphic-fetch';\nimport { ASYNC } from 'redux-amrc';\n\nexport function load() {\n  return {\n    [ASYNC]: {\n      key: 'counter',\n      promise: () => fetch('http://localhost:3000/api/counter')\n        .then(response => response.json())\n    }\n  };\n}\n```\n\n另外，附一张使用 redux-amrc 的程序截图，看到 async 那颗树了吗，就是这个插件自动帮你构建的，你可以获取 `value`、`error`、`loading`、`loaded`、`loadingNumber`，应有尽有，而且全自动生成！\n\n![](/css/images/168.jpg)\n\n快把这个插件用到你的 Redux 应用中吧！具体用法请参考 [redux-amrc 中文文档](https://lewis617.github.io/redux-amrc/)。\n","slug":"redux-amrc","published":1,"updated":"2019-05-01T08:10:30.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmj002wtgyt6hxogny1","content":"<p>很多人说 Redux 代码多，开发效率低。其实 Redux 是可以灵活使用以及拓展的，经过充分定制的 Redux 其实写不了几行代码。今天先介绍一个很好用的 Redux 拓展—— <a href=\"https://github.com/lewis617/redux-amrc\" target=\"_blank\" rel=\"noopener\">redux-amrc</a>。它可以帮助我们使用更少的样板代码发起异步 action。</p>\n<a id=\"more\"></a>\n<h2 id=\"低效的过去\"><a href=\"#低效的过去\" class=\"headerlink\" title=\"低效的过去\"></a>低效的过去</h2><p>一般情况下，为了清楚地记录异步的过程，我们需要使用 三个 action 来记录状态变化。通常，我们的代码会是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> LOAD = <span class=\"string\">'redux-example/auth/LOAD'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> LOAD_SUCCESS = <span class=\"string\">'redux-example/auth/LOAD_SUCCESS'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> LOAD_FAIL = <span class=\"string\">'redux-example/auth/LOAD_FAIL'</span>;</span><br></pre></td></tr></table></figure>\n<p>写完这么多 action，还要在异步的前后发起它们，当然这时你可能会用中间件，所以你的代码最少也会是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">load</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    types: [LOAD, LOAD_SUCCESS, LOAD_FAIL],</span><br><span class=\"line\">    promise: <span class=\"function\">(<span class=\"params\">client</span>) =&gt;</span> client.get(<span class=\"string\">'/loadAuth'</span>)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发起 action 后，还要编写 reducer 来处理这些 action，以改变状态：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span>(<span class=\"params\">state = initialState, action = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LOAD:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        loading: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LOAD_SUCCESS:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        loading: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        loaded: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        user: action.result</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LOAD_FAIL:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        loading: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        loaded: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        error: action.error</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这太痛苦了，不就是发起一个异步吗？非要让我写这么多代码？</p>\n<p>其实，上述过程是可以简化的。记得有篇文章叫《超过90秒的任务不自动化，你好意思说自己是黑客？》，前端工程师也应该具有黑客精神，接下来就让我们使用 redux-amrc 将上述过程简化。</p>\n<h2 id=\"轻松的现在\"><a href=\"#轻松的现在\" class=\"headerlink\" title=\"轻松的现在\"></a>轻松的现在</h2><p>使用了 redux-amrc 后，再也不用写这么多 action了，甚至连处理这些 action 的 reducer 都不用写，你只需要把异步以 Promise 的形式传给 redux-amrc 就行了。没有 action，没有 reducer，只需要编写一个 action 创建函数并发起它就可以了！就是这么清爽！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> fetch <span class=\"keyword\">from</span> <span class=\"string\">'isomorphic-fetch'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ASYNC &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux-amrc'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">load</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    [ASYNC]: &#123;</span><br><span class=\"line\">      key: <span class=\"string\">'counter'</span>,</span><br><span class=\"line\">      promise: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> fetch(<span class=\"string\">'http://localhost:3000/api/counter'</span>)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.json())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外，附一张使用 redux-amrc 的程序截图，看到 async 那颗树了吗，就是这个插件自动帮你构建的，你可以获取 <code>value</code>、<code>error</code>、<code>loading</code>、<code>loaded</code>、<code>loadingNumber</code>，应有尽有，而且全自动生成！</p>\n<p><img src=\"/css/images/168.jpg\" alt=\"\"></p>\n<p>快把这个插件用到你的 Redux 应用中吧！具体用法请参考 <a href=\"https://lewis617.github.io/redux-amrc/\" target=\"_blank\" rel=\"noopener\">redux-amrc 中文文档</a>。</p>\n","site":{"data":{}},"excerpt":"<p>很多人说 Redux 代码多，开发效率低。其实 Redux 是可以灵活使用以及拓展的，经过充分定制的 Redux 其实写不了几行代码。今天先介绍一个很好用的 Redux 拓展—— <a href=\"https://github.com/lewis617/redux-amrc\" target=\"_blank\" rel=\"noopener\">redux-amrc</a>。它可以帮助我们使用更少的样板代码发起异步 action。</p>","more":"<h2 id=\"低效的过去\"><a href=\"#低效的过去\" class=\"headerlink\" title=\"低效的过去\"></a>低效的过去</h2><p>一般情况下，为了清楚地记录异步的过程，我们需要使用 三个 action 来记录状态变化。通常，我们的代码会是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> LOAD = <span class=\"string\">'redux-example/auth/LOAD'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> LOAD_SUCCESS = <span class=\"string\">'redux-example/auth/LOAD_SUCCESS'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> LOAD_FAIL = <span class=\"string\">'redux-example/auth/LOAD_FAIL'</span>;</span><br></pre></td></tr></table></figure>\n<p>写完这么多 action，还要在异步的前后发起它们，当然这时你可能会用中间件，所以你的代码最少也会是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">load</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    types: [LOAD, LOAD_SUCCESS, LOAD_FAIL],</span><br><span class=\"line\">    promise: <span class=\"function\">(<span class=\"params\">client</span>) =&gt;</span> client.get(<span class=\"string\">'/loadAuth'</span>)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发起 action 后，还要编写 reducer 来处理这些 action，以改变状态：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span>(<span class=\"params\">state = initialState, action = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LOAD:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        loading: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LOAD_SUCCESS:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        loading: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        loaded: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        user: action.result</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LOAD_FAIL:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        loading: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        loaded: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        error: action.error</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这太痛苦了，不就是发起一个异步吗？非要让我写这么多代码？</p>\n<p>其实，上述过程是可以简化的。记得有篇文章叫《超过90秒的任务不自动化，你好意思说自己是黑客？》，前端工程师也应该具有黑客精神，接下来就让我们使用 redux-amrc 将上述过程简化。</p>\n<h2 id=\"轻松的现在\"><a href=\"#轻松的现在\" class=\"headerlink\" title=\"轻松的现在\"></a>轻松的现在</h2><p>使用了 redux-amrc 后，再也不用写这么多 action了，甚至连处理这些 action 的 reducer 都不用写，你只需要把异步以 Promise 的形式传给 redux-amrc 就行了。没有 action，没有 reducer，只需要编写一个 action 创建函数并发起它就可以了！就是这么清爽！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> fetch <span class=\"keyword\">from</span> <span class=\"string\">'isomorphic-fetch'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ASYNC &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux-amrc'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">load</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    [ASYNC]: &#123;</span><br><span class=\"line\">      key: <span class=\"string\">'counter'</span>,</span><br><span class=\"line\">      promise: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> fetch(<span class=\"string\">'http://localhost:3000/api/counter'</span>)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.json())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外，附一张使用 redux-amrc 的程序截图，看到 async 那颗树了吗，就是这个插件自动帮你构建的，你可以获取 <code>value</code>、<code>error</code>、<code>loading</code>、<code>loaded</code>、<code>loadingNumber</code>，应有尽有，而且全自动生成！</p>\n<p><img src=\"/css/images/168.jpg\" alt=\"\"></p>\n<p>快把这个插件用到你的 Redux 应用中吧！具体用法请参考 <a href=\"https://lewis617.github.io/redux-amrc/\" target=\"_blank\" rel=\"noopener\">redux-amrc 中文文档</a>。</p>"},{"title":"使用 render-react-components 来单独渲染每个 React 组件","date":"2018-04-13T09:56:00.000Z","_content":"\n今天，我们要讲的是如何使用 render-react-components 来单独渲染每个 React 组件。\n\n<!--more-->\n\n## 为何要单独渲染每个 React 组件？\n\n我之前参与了一位阿里前端专家架构的项目，这个项目的技术栈是 Angular1 ，经过几天的开发，我发现这是我来阿里后参与的开发体验最好的几个前端项目之一了。为何这么说呢？主要原因是这个项目使用了 Angular1 的指令（Angular1 的指令就是 Angular2 的组件，也等同于 React 的组件）将页面组件化，并且为每个单独的指令创建了一个 demo 页面，可以单独渲染展示每个指令。相当于一个复杂的项目被分为很多小项目，每个小项目都可以独立调试，这样的开发体验太好了！不仅如此，这么做还有很多好处：\n\n- 每个组件的 demo 页面也可以成为该组件的文档，方便别的前端同学快速掌握每个组件是干嘛的，这比在混杂在项目中清晰多了。\n- 每个组件按道理都应该写单元测试的，如果我们能单独渲染每个 React 组件，相当于给每个组件进行了一次“看得见摸得着”的单元测试。\n- 如果你喜欢写端对端测试，那么你可以对每个组件的 demo 页面进行完全模拟用户的端对端测试。\n- \b假如你\b编写的组件的父组件还没写出来，放到过去，你完全没招，只能等待，但现在每个组件都是可以单独开发调试的，再也不用受制于人，受制于环境了。\n- \b假如的项目特别庞大，运行一次，需要编译很久，那么你还可以使用 demo 页面来提升你的开发效率。\n- 假如你的组件有很多种环境，但在项目中，只能模拟有限的环境，那么你可以在 demo 页面里自由的模拟各种环境，\b进行各种逻辑的开发。\n- ……\n\n既然有这么多好处，然后我就想，在 React 项目中能不能也将项目中的每个小组件，单独渲染出来呢？答案是可以的，不过稍微麻烦一点，因为 React 组件不像 Angular1 那样可以直接在浏览器里面运行，需要编译一下，所以我就开发了一个名为 render-react-components 的命令行工具，帮我做这件事。\n\n## render-react-components 是什么？\n\nrender-react-components（简称 rrc） 是一个命令行工具，可以递归找出当前项目中所有的 React 组件（仅限于 src 目录下的所有组件），并为它们创建相互隔离的 demo 页面。\n\n## 快速开始\n\n使用 rrc 非常简单，只需要：\n\n```bash\n## 本地或者全局安装\n$ npm i render-react-components -g\n\n## 为项目中所有的 React 组件，创建 demo 页面\n$ rrc init\n\n## 如果你只想给部分组件创建 demo 页面，可以使用 filter 参数，输入组件路径的关键词即可\n$ rrc init --filter=Component1\n## 或者简写\n$ rrc init -f=Component1\n\n## 本地开发，支持代码热加载\n$ rrc dev\n\n## 删除了 rrc init 创建的所有文件\n$ rrc clean\n```\n\n以下动图，演示了如何使用这个工具，先后做了这几件事：\n\n- 运行 \b`find . -name *.js` （`find` 命令和本工具无关，只是为了对比展示文件的变化）列出原始项目中的 js。\n- 运行 `rrc init`，为项目中所有的 React 组件创建 demo 页面。再次运行 \b`find . -name *.js` 发现多了一些文件，不过放心，这只是一些 js、html 文件，不会给你添加多余的依赖，非常干净、非常隔离。\n- 运行 `rrc dev` ，自动弹出一个页面，我们发现每个组件都可以展示了。并且，修改代码，页面会自动更新，非常方便。\n\n![](https://img.alicdn.com/tfs/TB1VPzQnHGYBuNjy0FoXXciBFXa-894-444.gif)\n\n## 修改组件的 demo 页面\n\n每个 React 组件的 props 都不同，需要我们单独编写。如果你想修改某个组件的 props ，只需要去项目根目录的 rrc 文件夹中找到组件对应的 demo 页面的入口文件即可。那么组件的对应的入口文件如何寻找呢？非常简单明了：\n\n- 假如一个组件的路径是 src/Component1.js，那么这个组件的入口文件的路径就是：rrc/Component1.js。\n- 假如一个组件的路径是 src/Component2/index.js，那么这个组件的入口文件的路径就是：rrc/Component2.js。\n- 假如一个组件的路径是 src/Component2/Component3/index.js，那么这个组件的入口文件的路径就是：rrc/Component2_Component3.js。\n\n## 修改渲染组件的 webpack 配置\n\n虽然在大多数情况下，你都不用操心 webpack 配置，但如果你实在想修改渲染组件的 webpack 配置，那么你可以直接在根目录下的 `.rrc.js` 中修改，具体配置可以在[这里](https://github.com/lewis617/render-react-components/blob/master/README_zh-cn.md#%E9%85%8D%E7%BD%AE)参考。\n\n## 真实小例子\n\n上面动图中真实小例子可以在[这里](https://github.com/lewis617/render-react-components/tree/master/examples/dead-simple)找到。\n\n本工具的 Github 地址： <https://github.com/lewis617/render-react-components>，欢迎 star、提 issue 和 pull request。","source":"_posts/render-react-components.md","raw":"---\ntitle: 使用 render-react-components 来单独渲染每个 React 组件\ndate: 2018-04-13 17:56:00\ntags: [React, render-react-components, 测试, 单元测试]\n---\n\n今天，我们要讲的是如何使用 render-react-components 来单独渲染每个 React 组件。\n\n<!--more-->\n\n## 为何要单独渲染每个 React 组件？\n\n我之前参与了一位阿里前端专家架构的项目，这个项目的技术栈是 Angular1 ，经过几天的开发，我发现这是我来阿里后参与的开发体验最好的几个前端项目之一了。为何这么说呢？主要原因是这个项目使用了 Angular1 的指令（Angular1 的指令就是 Angular2 的组件，也等同于 React 的组件）将页面组件化，并且为每个单独的指令创建了一个 demo 页面，可以单独渲染展示每个指令。相当于一个复杂的项目被分为很多小项目，每个小项目都可以独立调试，这样的开发体验太好了！不仅如此，这么做还有很多好处：\n\n- 每个组件的 demo 页面也可以成为该组件的文档，方便别的前端同学快速掌握每个组件是干嘛的，这比在混杂在项目中清晰多了。\n- 每个组件按道理都应该写单元测试的，如果我们能单独渲染每个 React 组件，相当于给每个组件进行了一次“看得见摸得着”的单元测试。\n- 如果你喜欢写端对端测试，那么你可以对每个组件的 demo 页面进行完全模拟用户的端对端测试。\n- \b假如你\b编写的组件的父组件还没写出来，放到过去，你完全没招，只能等待，但现在每个组件都是可以单独开发调试的，再也不用受制于人，受制于环境了。\n- \b假如的项目特别庞大，运行一次，需要编译很久，那么你还可以使用 demo 页面来提升你的开发效率。\n- 假如你的组件有很多种环境，但在项目中，只能模拟有限的环境，那么你可以在 demo 页面里自由的模拟各种环境，\b进行各种逻辑的开发。\n- ……\n\n既然有这么多好处，然后我就想，在 React 项目中能不能也将项目中的每个小组件，单独渲染出来呢？答案是可以的，不过稍微麻烦一点，因为 React 组件不像 Angular1 那样可以直接在浏览器里面运行，需要编译一下，所以我就开发了一个名为 render-react-components 的命令行工具，帮我做这件事。\n\n## render-react-components 是什么？\n\nrender-react-components（简称 rrc） 是一个命令行工具，可以递归找出当前项目中所有的 React 组件（仅限于 src 目录下的所有组件），并为它们创建相互隔离的 demo 页面。\n\n## 快速开始\n\n使用 rrc 非常简单，只需要：\n\n```bash\n## 本地或者全局安装\n$ npm i render-react-components -g\n\n## 为项目中所有的 React 组件，创建 demo 页面\n$ rrc init\n\n## 如果你只想给部分组件创建 demo 页面，可以使用 filter 参数，输入组件路径的关键词即可\n$ rrc init --filter=Component1\n## 或者简写\n$ rrc init -f=Component1\n\n## 本地开发，支持代码热加载\n$ rrc dev\n\n## 删除了 rrc init 创建的所有文件\n$ rrc clean\n```\n\n以下动图，演示了如何使用这个工具，先后做了这几件事：\n\n- 运行 \b`find . -name *.js` （`find` 命令和本工具无关，只是为了对比展示文件的变化）列出原始项目中的 js。\n- 运行 `rrc init`，为项目中所有的 React 组件创建 demo 页面。再次运行 \b`find . -name *.js` 发现多了一些文件，不过放心，这只是一些 js、html 文件，不会给你添加多余的依赖，非常干净、非常隔离。\n- 运行 `rrc dev` ，自动弹出一个页面，我们发现每个组件都可以展示了。并且，修改代码，页面会自动更新，非常方便。\n\n![](https://img.alicdn.com/tfs/TB1VPzQnHGYBuNjy0FoXXciBFXa-894-444.gif)\n\n## 修改组件的 demo 页面\n\n每个 React 组件的 props 都不同，需要我们单独编写。如果你想修改某个组件的 props ，只需要去项目根目录的 rrc 文件夹中找到组件对应的 demo 页面的入口文件即可。那么组件的对应的入口文件如何寻找呢？非常简单明了：\n\n- 假如一个组件的路径是 src/Component1.js，那么这个组件的入口文件的路径就是：rrc/Component1.js。\n- 假如一个组件的路径是 src/Component2/index.js，那么这个组件的入口文件的路径就是：rrc/Component2.js。\n- 假如一个组件的路径是 src/Component2/Component3/index.js，那么这个组件的入口文件的路径就是：rrc/Component2_Component3.js。\n\n## 修改渲染组件的 webpack 配置\n\n虽然在大多数情况下，你都不用操心 webpack 配置，但如果你实在想修改渲染组件的 webpack 配置，那么你可以直接在根目录下的 `.rrc.js` 中修改，具体配置可以在[这里](https://github.com/lewis617/render-react-components/blob/master/README_zh-cn.md#%E9%85%8D%E7%BD%AE)参考。\n\n## 真实小例子\n\n上面动图中真实小例子可以在[这里](https://github.com/lewis617/render-react-components/tree/master/examples/dead-simple)找到。\n\n本工具的 Github 地址： <https://github.com/lewis617/render-react-components>，欢迎 star、提 issue 和 pull request。","slug":"render-react-components","published":1,"updated":"2019-05-01T08:02:12.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmk002xtgyth2kw7i3d","content":"<p>今天，我们要讲的是如何使用 render-react-components 来单独渲染每个 React 组件。</p>\n<a id=\"more\"></a>\n<h2 id=\"为何要单独渲染每个-React-组件？\"><a href=\"#为何要单独渲染每个-React-组件？\" class=\"headerlink\" title=\"为何要单独渲染每个 React 组件？\"></a>为何要单独渲染每个 React 组件？</h2><p>我之前参与了一位阿里前端专家架构的项目，这个项目的技术栈是 Angular1 ，经过几天的开发，我发现这是我来阿里后参与的开发体验最好的几个前端项目之一了。为何这么说呢？主要原因是这个项目使用了 Angular1 的指令（Angular1 的指令就是 Angular2 的组件，也等同于 React 的组件）将页面组件化，并且为每个单独的指令创建了一个 demo 页面，可以单独渲染展示每个指令。相当于一个复杂的项目被分为很多小项目，每个小项目都可以独立调试，这样的开发体验太好了！不仅如此，这么做还有很多好处：</p>\n<ul>\n<li>每个组件的 demo 页面也可以成为该组件的文档，方便别的前端同学快速掌握每个组件是干嘛的，这比在混杂在项目中清晰多了。</li>\n<li>每个组件按道理都应该写单元测试的，如果我们能单独渲染每个 React 组件，相当于给每个组件进行了一次“看得见摸得着”的单元测试。</li>\n<li>如果你喜欢写端对端测试，那么你可以对每个组件的 demo 页面进行完全模拟用户的端对端测试。</li>\n<li>\b假如你\b编写的组件的父组件还没写出来，放到过去，你完全没招，只能等待，但现在每个组件都是可以单独开发调试的，再也不用受制于人，受制于环境了。</li>\n<li>\b假如的项目特别庞大，运行一次，需要编译很久，那么你还可以使用 demo 页面来提升你的开发效率。</li>\n<li>假如你的组件有很多种环境，但在项目中，只能模拟有限的环境，那么你可以在 demo 页面里自由的模拟各种环境，\b进行各种逻辑的开发。</li>\n<li>……</li>\n</ul>\n<p>既然有这么多好处，然后我就想，在 React 项目中能不能也将项目中的每个小组件，单独渲染出来呢？答案是可以的，不过稍微麻烦一点，因为 React 组件不像 Angular1 那样可以直接在浏览器里面运行，需要编译一下，所以我就开发了一个名为 render-react-components 的命令行工具，帮我做这件事。</p>\n<h2 id=\"render-react-components-是什么？\"><a href=\"#render-react-components-是什么？\" class=\"headerlink\" title=\"render-react-components 是什么？\"></a>render-react-components 是什么？</h2><p>render-react-components（简称 rrc） 是一个命令行工具，可以递归找出当前项目中所有的 React 组件（仅限于 src 目录下的所有组件），并为它们创建相互隔离的 demo 页面。</p>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><p>使用 rrc 非常简单，只需要：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 本地或者全局安装</span></span><br><span class=\"line\">$ npm i render-react-components -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 为项目中所有的 React 组件，创建 demo 页面</span></span><br><span class=\"line\">$ rrc init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 如果你只想给部分组件创建 demo 页面，可以使用 filter 参数，输入组件路径的关键词即可</span></span><br><span class=\"line\">$ rrc init --filter=Component1</span><br><span class=\"line\"><span class=\"comment\">## 或者简写</span></span><br><span class=\"line\">$ rrc init -f=Component1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 本地开发，支持代码热加载</span></span><br><span class=\"line\">$ rrc dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 删除了 rrc init 创建的所有文件</span></span><br><span class=\"line\">$ rrc clean</span><br></pre></td></tr></table></figure>\n<p>以下动图，演示了如何使用这个工具，先后做了这几件事：</p>\n<ul>\n<li>运行 \b<code>find . -name *.js</code> （<code>find</code> 命令和本工具无关，只是为了对比展示文件的变化）列出原始项目中的 js。</li>\n<li>运行 <code>rrc init</code>，为项目中所有的 React 组件创建 demo 页面。再次运行 \b<code>find . -name *.js</code> 发现多了一些文件，不过放心，这只是一些 js、html 文件，不会给你添加多余的依赖，非常干净、非常隔离。</li>\n<li>运行 <code>rrc dev</code> ，自动弹出一个页面，我们发现每个组件都可以展示了。并且，修改代码，页面会自动更新，非常方便。</li>\n</ul>\n<p><img src=\"https://img.alicdn.com/tfs/TB1VPzQnHGYBuNjy0FoXXciBFXa-894-444.gif\" alt=\"\"></p>\n<h2 id=\"修改组件的-demo-页面\"><a href=\"#修改组件的-demo-页面\" class=\"headerlink\" title=\"修改组件的 demo 页面\"></a>修改组件的 demo 页面</h2><p>每个 React 组件的 props 都不同，需要我们单独编写。如果你想修改某个组件的 props ，只需要去项目根目录的 rrc 文件夹中找到组件对应的 demo 页面的入口文件即可。那么组件的对应的入口文件如何寻找呢？非常简单明了：</p>\n<ul>\n<li>假如一个组件的路径是 src/Component1.js，那么这个组件的入口文件的路径就是：rrc/Component1.js。</li>\n<li>假如一个组件的路径是 src/Component2/index.js，那么这个组件的入口文件的路径就是：rrc/Component2.js。</li>\n<li>假如一个组件的路径是 src/Component2/Component3/index.js，那么这个组件的入口文件的路径就是：rrc/Component2_Component3.js。</li>\n</ul>\n<h2 id=\"修改渲染组件的-webpack-配置\"><a href=\"#修改渲染组件的-webpack-配置\" class=\"headerlink\" title=\"修改渲染组件的 webpack 配置\"></a>修改渲染组件的 webpack 配置</h2><p>虽然在大多数情况下，你都不用操心 webpack 配置，但如果你实在想修改渲染组件的 webpack 配置，那么你可以直接在根目录下的 <code>.rrc.js</code> 中修改，具体配置可以在<a href=\"https://github.com/lewis617/render-react-components/blob/master/README_zh-cn.md#%E9%85%8D%E7%BD%AE\" target=\"_blank\" rel=\"noopener\">这里</a>参考。</p>\n<h2 id=\"真实小例子\"><a href=\"#真实小例子\" class=\"headerlink\" title=\"真实小例子\"></a>真实小例子</h2><p>上面动图中真实小例子可以在<a href=\"https://github.com/lewis617/render-react-components/tree/master/examples/dead-simple\" target=\"_blank\" rel=\"noopener\">这里</a>找到。</p>\n<p>本工具的 Github 地址： <a href=\"https://github.com/lewis617/render-react-components\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/render-react-components</a>，欢迎 star、提 issue 和 pull request。</p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是如何使用 render-react-components 来单独渲染每个 React 组件。</p>","more":"<h2 id=\"为何要单独渲染每个-React-组件？\"><a href=\"#为何要单独渲染每个-React-组件？\" class=\"headerlink\" title=\"为何要单独渲染每个 React 组件？\"></a>为何要单独渲染每个 React 组件？</h2><p>我之前参与了一位阿里前端专家架构的项目，这个项目的技术栈是 Angular1 ，经过几天的开发，我发现这是我来阿里后参与的开发体验最好的几个前端项目之一了。为何这么说呢？主要原因是这个项目使用了 Angular1 的指令（Angular1 的指令就是 Angular2 的组件，也等同于 React 的组件）将页面组件化，并且为每个单独的指令创建了一个 demo 页面，可以单独渲染展示每个指令。相当于一个复杂的项目被分为很多小项目，每个小项目都可以独立调试，这样的开发体验太好了！不仅如此，这么做还有很多好处：</p>\n<ul>\n<li>每个组件的 demo 页面也可以成为该组件的文档，方便别的前端同学快速掌握每个组件是干嘛的，这比在混杂在项目中清晰多了。</li>\n<li>每个组件按道理都应该写单元测试的，如果我们能单独渲染每个 React 组件，相当于给每个组件进行了一次“看得见摸得着”的单元测试。</li>\n<li>如果你喜欢写端对端测试，那么你可以对每个组件的 demo 页面进行完全模拟用户的端对端测试。</li>\n<li>\b假如你\b编写的组件的父组件还没写出来，放到过去，你完全没招，只能等待，但现在每个组件都是可以单独开发调试的，再也不用受制于人，受制于环境了。</li>\n<li>\b假如的项目特别庞大，运行一次，需要编译很久，那么你还可以使用 demo 页面来提升你的开发效率。</li>\n<li>假如你的组件有很多种环境，但在项目中，只能模拟有限的环境，那么你可以在 demo 页面里自由的模拟各种环境，\b进行各种逻辑的开发。</li>\n<li>……</li>\n</ul>\n<p>既然有这么多好处，然后我就想，在 React 项目中能不能也将项目中的每个小组件，单独渲染出来呢？答案是可以的，不过稍微麻烦一点，因为 React 组件不像 Angular1 那样可以直接在浏览器里面运行，需要编译一下，所以我就开发了一个名为 render-react-components 的命令行工具，帮我做这件事。</p>\n<h2 id=\"render-react-components-是什么？\"><a href=\"#render-react-components-是什么？\" class=\"headerlink\" title=\"render-react-components 是什么？\"></a>render-react-components 是什么？</h2><p>render-react-components（简称 rrc） 是一个命令行工具，可以递归找出当前项目中所有的 React 组件（仅限于 src 目录下的所有组件），并为它们创建相互隔离的 demo 页面。</p>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><p>使用 rrc 非常简单，只需要：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 本地或者全局安装</span></span><br><span class=\"line\">$ npm i render-react-components -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 为项目中所有的 React 组件，创建 demo 页面</span></span><br><span class=\"line\">$ rrc init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 如果你只想给部分组件创建 demo 页面，可以使用 filter 参数，输入组件路径的关键词即可</span></span><br><span class=\"line\">$ rrc init --filter=Component1</span><br><span class=\"line\"><span class=\"comment\">## 或者简写</span></span><br><span class=\"line\">$ rrc init -f=Component1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 本地开发，支持代码热加载</span></span><br><span class=\"line\">$ rrc dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 删除了 rrc init 创建的所有文件</span></span><br><span class=\"line\">$ rrc clean</span><br></pre></td></tr></table></figure>\n<p>以下动图，演示了如何使用这个工具，先后做了这几件事：</p>\n<ul>\n<li>运行 \b<code>find . -name *.js</code> （<code>find</code> 命令和本工具无关，只是为了对比展示文件的变化）列出原始项目中的 js。</li>\n<li>运行 <code>rrc init</code>，为项目中所有的 React 组件创建 demo 页面。再次运行 \b<code>find . -name *.js</code> 发现多了一些文件，不过放心，这只是一些 js、html 文件，不会给你添加多余的依赖，非常干净、非常隔离。</li>\n<li>运行 <code>rrc dev</code> ，自动弹出一个页面，我们发现每个组件都可以展示了。并且，修改代码，页面会自动更新，非常方便。</li>\n</ul>\n<p><img src=\"https://img.alicdn.com/tfs/TB1VPzQnHGYBuNjy0FoXXciBFXa-894-444.gif\" alt=\"\"></p>\n<h2 id=\"修改组件的-demo-页面\"><a href=\"#修改组件的-demo-页面\" class=\"headerlink\" title=\"修改组件的 demo 页面\"></a>修改组件的 demo 页面</h2><p>每个 React 组件的 props 都不同，需要我们单独编写。如果你想修改某个组件的 props ，只需要去项目根目录的 rrc 文件夹中找到组件对应的 demo 页面的入口文件即可。那么组件的对应的入口文件如何寻找呢？非常简单明了：</p>\n<ul>\n<li>假如一个组件的路径是 src/Component1.js，那么这个组件的入口文件的路径就是：rrc/Component1.js。</li>\n<li>假如一个组件的路径是 src/Component2/index.js，那么这个组件的入口文件的路径就是：rrc/Component2.js。</li>\n<li>假如一个组件的路径是 src/Component2/Component3/index.js，那么这个组件的入口文件的路径就是：rrc/Component2_Component3.js。</li>\n</ul>\n<h2 id=\"修改渲染组件的-webpack-配置\"><a href=\"#修改渲染组件的-webpack-配置\" class=\"headerlink\" title=\"修改渲染组件的 webpack 配置\"></a>修改渲染组件的 webpack 配置</h2><p>虽然在大多数情况下，你都不用操心 webpack 配置，但如果你实在想修改渲染组件的 webpack 配置，那么你可以直接在根目录下的 <code>.rrc.js</code> 中修改，具体配置可以在<a href=\"https://github.com/lewis617/render-react-components/blob/master/README_zh-cn.md#%E9%85%8D%E7%BD%AE\" target=\"_blank\" rel=\"noopener\">这里</a>参考。</p>\n<h2 id=\"真实小例子\"><a href=\"#真实小例子\" class=\"headerlink\" title=\"真实小例子\"></a>真实小例子</h2><p>上面动图中真实小例子可以在<a href=\"https://github.com/lewis617/render-react-components/tree/master/examples/dead-simple\" target=\"_blank\" rel=\"noopener\">这里</a>找到。</p>\n<p>本工具的 Github 地址： <a href=\"https://github.com/lewis617/render-react-components\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/render-react-components</a>，欢迎 star、提 issue 和 pull request。</p>"},{"title":"使用RequireJs和Bootstrap模态框实现表单提交","date":"2015-09-26T01:59:00.000Z","_content":"\n下面我将使用Requirejs结合模态框实现**三五行代码**部署表单提交操作。\n\n<!--more-->\n\n### 传统开发思路如下：\n\n![](/css/images/169.jpg)\n\n缺点：所有代码写在一个html中，难以阅读，难以维护，难以复用！\n\n### 使用Requirejs开发思路如下（且看笔者如何解耦模块化代码）：\n\n![](/css/images/170.jpg)\n\n 缺点：编写过程较为复杂\n\n优点：代码解耦，便于复用。什么时候你想复用，只需require你编写好的js模块，即可！里面的bootstrap,jquery,模态框等等所有东西都会加载好（因为你在定义的时候，已经写好依赖关系了）\n\n举个例子：我们项目中关于项目授权的使用至少存在三个页面，编写好这样一个js模块，可以很轻易的在那三个页面上复用。如果使用传统办法，估计要复制粘贴大量的html和js。\n\n看一下代码运行效果吧：\n\n![](/css/images/171.jpg)","source":"_posts/requirejs-bootstraop-modal.md","raw":"---\ntitle: 使用RequireJs和Bootstrap模态框实现表单提交\ndate: 2015-09-26 09:59:00\ntags: [RequireJs, Bootstrap]\n---\n\n下面我将使用Requirejs结合模态框实现**三五行代码**部署表单提交操作。\n\n<!--more-->\n\n### 传统开发思路如下：\n\n![](/css/images/169.jpg)\n\n缺点：所有代码写在一个html中，难以阅读，难以维护，难以复用！\n\n### 使用Requirejs开发思路如下（且看笔者如何解耦模块化代码）：\n\n![](/css/images/170.jpg)\n\n 缺点：编写过程较为复杂\n\n优点：代码解耦，便于复用。什么时候你想复用，只需require你编写好的js模块，即可！里面的bootstrap,jquery,模态框等等所有东西都会加载好（因为你在定义的时候，已经写好依赖关系了）\n\n举个例子：我们项目中关于项目授权的使用至少存在三个页面，编写好这样一个js模块，可以很轻易的在那三个页面上复用。如果使用传统办法，估计要复制粘贴大量的html和js。\n\n看一下代码运行效果吧：\n\n![](/css/images/171.jpg)","slug":"requirejs-bootstraop-modal","published":1,"updated":"2019-05-01T08:10:30.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmm002ztgytdsfu4xgk","content":"<p>下面我将使用Requirejs结合模态框实现<strong>三五行代码</strong>部署表单提交操作。</p>\n<a id=\"more\"></a>\n<h3 id=\"传统开发思路如下：\"><a href=\"#传统开发思路如下：\" class=\"headerlink\" title=\"传统开发思路如下：\"></a>传统开发思路如下：</h3><p><img src=\"/css/images/169.jpg\" alt=\"\"></p>\n<p>缺点：所有代码写在一个html中，难以阅读，难以维护，难以复用！</p>\n<h3 id=\"使用Requirejs开发思路如下（且看笔者如何解耦模块化代码）：\"><a href=\"#使用Requirejs开发思路如下（且看笔者如何解耦模块化代码）：\" class=\"headerlink\" title=\"使用Requirejs开发思路如下（且看笔者如何解耦模块化代码）：\"></a>使用Requirejs开发思路如下（且看笔者如何解耦模块化代码）：</h3><p><img src=\"/css/images/170.jpg\" alt=\"\"></p>\n<p> 缺点：编写过程较为复杂</p>\n<p>优点：代码解耦，便于复用。什么时候你想复用，只需require你编写好的js模块，即可！里面的bootstrap,jquery,模态框等等所有东西都会加载好（因为你在定义的时候，已经写好依赖关系了）</p>\n<p>举个例子：我们项目中关于项目授权的使用至少存在三个页面，编写好这样一个js模块，可以很轻易的在那三个页面上复用。如果使用传统办法，估计要复制粘贴大量的html和js。</p>\n<p>看一下代码运行效果吧：</p>\n<p><img src=\"/css/images/171.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>下面我将使用Requirejs结合模态框实现<strong>三五行代码</strong>部署表单提交操作。</p>","more":"<h3 id=\"传统开发思路如下：\"><a href=\"#传统开发思路如下：\" class=\"headerlink\" title=\"传统开发思路如下：\"></a>传统开发思路如下：</h3><p><img src=\"/css/images/169.jpg\" alt=\"\"></p>\n<p>缺点：所有代码写在一个html中，难以阅读，难以维护，难以复用！</p>\n<h3 id=\"使用Requirejs开发思路如下（且看笔者如何解耦模块化代码）：\"><a href=\"#使用Requirejs开发思路如下（且看笔者如何解耦模块化代码）：\" class=\"headerlink\" title=\"使用Requirejs开发思路如下（且看笔者如何解耦模块化代码）：\"></a>使用Requirejs开发思路如下（且看笔者如何解耦模块化代码）：</h3><p><img src=\"/css/images/170.jpg\" alt=\"\"></p>\n<p> 缺点：编写过程较为复杂</p>\n<p>优点：代码解耦，便于复用。什么时候你想复用，只需require你编写好的js模块，即可！里面的bootstrap,jquery,模态框等等所有东西都会加载好（因为你在定义的时候，已经写好依赖关系了）</p>\n<p>举个例子：我们项目中关于项目授权的使用至少存在三个页面，编写好这样一个js模块，可以很轻易的在那三个页面上复用。如果使用传统办法，估计要复制粘贴大量的html和js。</p>\n<p>看一下代码运行效果吧：</p>\n<p><img src=\"/css/images/171.jpg\" alt=\"\"></p>"},{"title":"RequireJs调研","date":"2015-09-26T03:02:00.000Z","_content":"\n# 背景\n\n## Problem（问题）\n\n*   Web sites are turning into Web apps（网站正转变为网络应用程序）\n*   Code complexity grows as the site gets bigger（代码复杂度随着站点变大而变复杂）\n*   Assembly gets harder（组装变得更难【ps】这里我个人认为“组装”是拼接单个js文件中的昂多的代码段 ）\n*   Developer wants discrete JS files/modules（开发者想分离js文件/模块）\n*   Deployment wants optimized code in just one or a few HTTP calls（网站部署者想通过使用一个或者很少http请求来优化代码）\n\n## Solution（解决方案） \n\n*   Front-end developers need a solution with:（前端工程师需要一个解决方案，拥有这些功能：）\n*   Some sort of #include/import/require（一些引入文件的命令语句）\n*   ability to load nested dependencies（加载嵌套的依赖文件）\n*   ease of use for developer but then backed by an optimization tool that helps deployment（简单好用，但也有助于优化部署） \n\n<!--more-->\n\n# RequireJs简介\n\n## 作用 \n\nRequireJS的目标是鼓励代码的模块化，它使用了不同于传统script标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它鼓励在使用脚本时以module ID替代URL地址。\n\n## 优点 \n\n### 速度快\n\n![15085801_CrX1](http://images.cnitblog.com/blog/139239/201408/131435005307505.png \"15085801_CrX1\")\n\n[有位网友做了对比测试](http://www.cnblogs.com/powertoolsteam/p/RequireJS_wijmo.html)\n\n### 依赖关系清晰\n\n![JavaScript 文件之间的依赖项表示。](http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/html5/articles/javascript-architecture-requirejs-dependency-management/fig01.png \"JavaScript 文件之间的依赖项表示。\")\n\nrequirejs通过a.js调用b.js,b.js调用c.js,c.js调用d.js的原理，让我们可以只调用a.js，就可以加载所有的js,而且依赖关系非常清晰。  \n\njs文件不仅可以调用js，还能调用css和html页面，所以毫不夸张地说，引入一个入口js，无需向 HTML 文件添加任何其他元素即可构建大型单页面应用程序\n\n### 鼓励代码模块化（最大优点）\n\n![](/css/images/172.jpg)\n\n使用requirejs，我们就需要将原来在一个js文件里面写的代码，按照模块解耦分离成多个js文件，然后按照需求调用。这样做的好处很多：\n\n解耦了，就不会出现牵一发动全身的情况，便于日后维护；还能便于多人分工合作；还能复用...\n\n# 在项目中使用RequireJs\n\n## 调用第三方插件\n\n### 使用多选插件\n\n```js\n require(['jquery.shiftcheckbox'], function () {\n            $(function () {\n                $('#demo2 :checkbox').shiftcheckbox();\n            })\n        })\n```\n\n### 使用'bootstrap', 'jquery.form', 'jquery.validate'三个插件\n\n```js\nrequire(['bootstrap', 'jquery.form', 'jquery.validate'], function () {\n    $(function () {\n        jQuery.validator.addMethod(\"isZipCode\", function (value, element) { var tel = /^[0-9]{6}$/; return this.optional(element) || (tel.test(value));\n        }, \"请正确填写您的邮政编码\");\n        $(\"#signupForm\").validate({\n            rules: {\n                firstname: {\n                    required: true },\n                email: {\n                    required: true,\n                    email: true },\n                password: {\n                    required: true,\n                    minlength: 5 },\n                confirm_password: {\n                    required: true,\n                    minlength: 5,\n                    equalTo: \"#password\" },\n                isZipCode: {\n                    isZipCode: true }\n            },\n            messages: {\n                firstname: \"请输入姓名\",\n                email: {\n                    required: \"请输入Email地址\",\n                    email: \"请输入正确的email地址\" },\n                password: {\n                    required: \"请输入密码\",\n                    minlength: jQuery.format(\"密码不能小于{0}个字 符\")\n                },\n                confirm_password: {\n                    required: \"请输入确认密码\",\n                    minlength: \"确认密码不能小于5个字符\",\n                    equalTo: \"两次输入密码不一致不一致\" }\n            }\n        });\n        $(\"#signupForm\").ajaxSubmit();\n    });\n});\n```\n\n## 调用自己写的方法或者类\n\n### 调用日期方法类\n\n```js\n/**\n * Created by lewis on 15-9-15. */\n//自定义的命名空间，用来对日期进行操作\ndefine([],{ //输入json日期获取年\n    getYear: function (jsonDate) { var dateArry = jsonDate.split('-'); var jsonyear = parseInt(dateArry[0]); return jsonyear;\n    }, //输入json日期获取月\n    getMonth: function (jsonDate) { var dateArry = jsonDate.split('-'); var jsonmonth = parseInt(dateArry[1]); return jsonmonth;\n    }, //输入json日期获取日\n    getDay: function (jsonDate) { var dateArry = jsonDate.split('-'); var jsonday = parseInt(dateArry[2]); return jsonday;\n    }, //输入json日期和日历日期（后面的年）,判断json日期是否在两年内\n    isInYear: function (jsonDate, calenYear) { var jsonArry = jsonDate.split('-'); var jsonyear = parseInt(jsonArry[0]); if (jsonyear == calenYear || jsonyear == (calenYear - 1)) return true; else\n            return false;\n    }, //输入json日期和日历日期（年和月），判断json日期是否在日历日期内\n    isInMonth: function (jsonDate, calendarDate) { var jsonArry = jsonDate.split('-'); var jsonyear = parseInt(jsonArry[0]); var jsonmonth = parseInt(jsonArry[1]); var calenArry = calendarDate.split('-'); var calenyear = parseInt(calenArry[0]); var calenmonth = parseInt(calenArry[1]); if (jsonyear == calenyear && jsonmonth == calenmonth) return true; else\n            return false;\n    },\n    getNowFormatDate: function () { var date = new Date(); var seperator = \"-\"; var year = date.getFullYear(); var month = date.getMonth() + 1; var strDate = date.getDate(); var currentdate = year + seperator + month + seperator + strDate;\n        console.log(currentdate); return currentdate;\n    },\n    getDateFromYMD: function (a) { var arr = a.split(\"-\"); var date = new Date(arr[0], arr[1], arr[2]); return date;\n    }\n});\n```\n\n调用：\n\n```\n require(['common/myDateClass'], function (myDateClass) {\n。。。\n。。。\n}）\n```\n\n## 调用代码段（任性！！！）\n\na.js\n\n```js\nfunction myFunctionA(){\n    console.log('a');\n};\n```\n\nb.js\n\n```js\nfunction myFunctionB(){\n    console.log('b');\n};\n```\n\n调用：\n\n```js\nrequire(['js/ab/a','ab/b.js'],function(){\n    myFunctionA();\n    myFunctionB();\n});\n```","source":"_posts/requirejs-search.md","raw":"---\ntitle: RequireJs调研\ndate: 2015-09-26 11:02:00\ntags: [RequireJs]\n---\n\n# 背景\n\n## Problem（问题）\n\n*   Web sites are turning into Web apps（网站正转变为网络应用程序）\n*   Code complexity grows as the site gets bigger（代码复杂度随着站点变大而变复杂）\n*   Assembly gets harder（组装变得更难【ps】这里我个人认为“组装”是拼接单个js文件中的昂多的代码段 ）\n*   Developer wants discrete JS files/modules（开发者想分离js文件/模块）\n*   Deployment wants optimized code in just one or a few HTTP calls（网站部署者想通过使用一个或者很少http请求来优化代码）\n\n## Solution（解决方案） \n\n*   Front-end developers need a solution with:（前端工程师需要一个解决方案，拥有这些功能：）\n*   Some sort of #include/import/require（一些引入文件的命令语句）\n*   ability to load nested dependencies（加载嵌套的依赖文件）\n*   ease of use for developer but then backed by an optimization tool that helps deployment（简单好用，但也有助于优化部署） \n\n<!--more-->\n\n# RequireJs简介\n\n## 作用 \n\nRequireJS的目标是鼓励代码的模块化，它使用了不同于传统script标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它鼓励在使用脚本时以module ID替代URL地址。\n\n## 优点 \n\n### 速度快\n\n![15085801_CrX1](http://images.cnitblog.com/blog/139239/201408/131435005307505.png \"15085801_CrX1\")\n\n[有位网友做了对比测试](http://www.cnblogs.com/powertoolsteam/p/RequireJS_wijmo.html)\n\n### 依赖关系清晰\n\n![JavaScript 文件之间的依赖项表示。](http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/html5/articles/javascript-architecture-requirejs-dependency-management/fig01.png \"JavaScript 文件之间的依赖项表示。\")\n\nrequirejs通过a.js调用b.js,b.js调用c.js,c.js调用d.js的原理，让我们可以只调用a.js，就可以加载所有的js,而且依赖关系非常清晰。  \n\njs文件不仅可以调用js，还能调用css和html页面，所以毫不夸张地说，引入一个入口js，无需向 HTML 文件添加任何其他元素即可构建大型单页面应用程序\n\n### 鼓励代码模块化（最大优点）\n\n![](/css/images/172.jpg)\n\n使用requirejs，我们就需要将原来在一个js文件里面写的代码，按照模块解耦分离成多个js文件，然后按照需求调用。这样做的好处很多：\n\n解耦了，就不会出现牵一发动全身的情况，便于日后维护；还能便于多人分工合作；还能复用...\n\n# 在项目中使用RequireJs\n\n## 调用第三方插件\n\n### 使用多选插件\n\n```js\n require(['jquery.shiftcheckbox'], function () {\n            $(function () {\n                $('#demo2 :checkbox').shiftcheckbox();\n            })\n        })\n```\n\n### 使用'bootstrap', 'jquery.form', 'jquery.validate'三个插件\n\n```js\nrequire(['bootstrap', 'jquery.form', 'jquery.validate'], function () {\n    $(function () {\n        jQuery.validator.addMethod(\"isZipCode\", function (value, element) { var tel = /^[0-9]{6}$/; return this.optional(element) || (tel.test(value));\n        }, \"请正确填写您的邮政编码\");\n        $(\"#signupForm\").validate({\n            rules: {\n                firstname: {\n                    required: true },\n                email: {\n                    required: true,\n                    email: true },\n                password: {\n                    required: true,\n                    minlength: 5 },\n                confirm_password: {\n                    required: true,\n                    minlength: 5,\n                    equalTo: \"#password\" },\n                isZipCode: {\n                    isZipCode: true }\n            },\n            messages: {\n                firstname: \"请输入姓名\",\n                email: {\n                    required: \"请输入Email地址\",\n                    email: \"请输入正确的email地址\" },\n                password: {\n                    required: \"请输入密码\",\n                    minlength: jQuery.format(\"密码不能小于{0}个字 符\")\n                },\n                confirm_password: {\n                    required: \"请输入确认密码\",\n                    minlength: \"确认密码不能小于5个字符\",\n                    equalTo: \"两次输入密码不一致不一致\" }\n            }\n        });\n        $(\"#signupForm\").ajaxSubmit();\n    });\n});\n```\n\n## 调用自己写的方法或者类\n\n### 调用日期方法类\n\n```js\n/**\n * Created by lewis on 15-9-15. */\n//自定义的命名空间，用来对日期进行操作\ndefine([],{ //输入json日期获取年\n    getYear: function (jsonDate) { var dateArry = jsonDate.split('-'); var jsonyear = parseInt(dateArry[0]); return jsonyear;\n    }, //输入json日期获取月\n    getMonth: function (jsonDate) { var dateArry = jsonDate.split('-'); var jsonmonth = parseInt(dateArry[1]); return jsonmonth;\n    }, //输入json日期获取日\n    getDay: function (jsonDate) { var dateArry = jsonDate.split('-'); var jsonday = parseInt(dateArry[2]); return jsonday;\n    }, //输入json日期和日历日期（后面的年）,判断json日期是否在两年内\n    isInYear: function (jsonDate, calenYear) { var jsonArry = jsonDate.split('-'); var jsonyear = parseInt(jsonArry[0]); if (jsonyear == calenYear || jsonyear == (calenYear - 1)) return true; else\n            return false;\n    }, //输入json日期和日历日期（年和月），判断json日期是否在日历日期内\n    isInMonth: function (jsonDate, calendarDate) { var jsonArry = jsonDate.split('-'); var jsonyear = parseInt(jsonArry[0]); var jsonmonth = parseInt(jsonArry[1]); var calenArry = calendarDate.split('-'); var calenyear = parseInt(calenArry[0]); var calenmonth = parseInt(calenArry[1]); if (jsonyear == calenyear && jsonmonth == calenmonth) return true; else\n            return false;\n    },\n    getNowFormatDate: function () { var date = new Date(); var seperator = \"-\"; var year = date.getFullYear(); var month = date.getMonth() + 1; var strDate = date.getDate(); var currentdate = year + seperator + month + seperator + strDate;\n        console.log(currentdate); return currentdate;\n    },\n    getDateFromYMD: function (a) { var arr = a.split(\"-\"); var date = new Date(arr[0], arr[1], arr[2]); return date;\n    }\n});\n```\n\n调用：\n\n```\n require(['common/myDateClass'], function (myDateClass) {\n。。。\n。。。\n}）\n```\n\n## 调用代码段（任性！！！）\n\na.js\n\n```js\nfunction myFunctionA(){\n    console.log('a');\n};\n```\n\nb.js\n\n```js\nfunction myFunctionB(){\n    console.log('b');\n};\n```\n\n调用：\n\n```js\nrequire(['js/ab/a','ab/b.js'],function(){\n    myFunctionA();\n    myFunctionB();\n});\n```","slug":"requirejs-search","published":1,"updated":"2019-05-01T08:10:30.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmo0031tgyty25fy1us","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><h2 id=\"Problem（问题）\"><a href=\"#Problem（问题）\" class=\"headerlink\" title=\"Problem（问题）\"></a>Problem（问题）</h2><ul>\n<li>Web sites are turning into Web apps（网站正转变为网络应用程序）</li>\n<li>Code complexity grows as the site gets bigger（代码复杂度随着站点变大而变复杂）</li>\n<li>Assembly gets harder（组装变得更难【ps】这里我个人认为“组装”是拼接单个js文件中的昂多的代码段 ）</li>\n<li>Developer wants discrete JS files/modules（开发者想分离js文件/模块）</li>\n<li>Deployment wants optimized code in just one or a few HTTP calls（网站部署者想通过使用一个或者很少http请求来优化代码）</li>\n</ul>\n<h2 id=\"Solution（解决方案）\"><a href=\"#Solution（解决方案）\" class=\"headerlink\" title=\"Solution（解决方案）\"></a>Solution（解决方案）</h2><ul>\n<li>Front-end developers need a solution with:（前端工程师需要一个解决方案，拥有这些功能：）</li>\n<li>Some sort of #include/import/require（一些引入文件的命令语句）</li>\n<li>ability to load nested dependencies（加载嵌套的依赖文件）</li>\n<li>ease of use for developer but then backed by an optimization tool that helps deployment（简单好用，但也有助于优化部署） </li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"RequireJs简介\"><a href=\"#RequireJs简介\" class=\"headerlink\" title=\"RequireJs简介\"></a>RequireJs简介</h1><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>RequireJS的目标是鼓励代码的模块化，它使用了不同于传统script标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它鼓励在使用脚本时以module ID替代URL地址。</p>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><h3 id=\"速度快\"><a href=\"#速度快\" class=\"headerlink\" title=\"速度快\"></a>速度快</h3><p><img src=\"http://images.cnitblog.com/blog/139239/201408/131435005307505.png\" alt=\"15085801_CrX1\" title=\"15085801_CrX1\"></p>\n<p><a href=\"http://www.cnblogs.com/powertoolsteam/p/RequireJS_wijmo.html\" target=\"_blank\" rel=\"noopener\">有位网友做了对比测试</a></p>\n<h3 id=\"依赖关系清晰\"><a href=\"#依赖关系清晰\" class=\"headerlink\" title=\"依赖关系清晰\"></a>依赖关系清晰</h3><p><img src=\"http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/html5/articles/javascript-architecture-requirejs-dependency-management/fig01.png\" alt=\"JavaScript 文件之间的依赖项表示。\" title=\"JavaScript 文件之间的依赖项表示。\"></p>\n<p>requirejs通过a.js调用b.js,b.js调用c.js,c.js调用d.js的原理，让我们可以只调用a.js，就可以加载所有的js,而且依赖关系非常清晰。  </p>\n<p>js文件不仅可以调用js，还能调用css和html页面，所以毫不夸张地说，引入一个入口js，无需向 HTML 文件添加任何其他元素即可构建大型单页面应用程序</p>\n<h3 id=\"鼓励代码模块化（最大优点）\"><a href=\"#鼓励代码模块化（最大优点）\" class=\"headerlink\" title=\"鼓励代码模块化（最大优点）\"></a>鼓励代码模块化（最大优点）</h3><p><img src=\"/css/images/172.jpg\" alt=\"\"></p>\n<p>使用requirejs，我们就需要将原来在一个js文件里面写的代码，按照模块解耦分离成多个js文件，然后按照需求调用。这样做的好处很多：</p>\n<p>解耦了，就不会出现牵一发动全身的情况，便于日后维护；还能便于多人分工合作；还能复用…</p>\n<h1 id=\"在项目中使用RequireJs\"><a href=\"#在项目中使用RequireJs\" class=\"headerlink\" title=\"在项目中使用RequireJs\"></a>在项目中使用RequireJs</h1><h2 id=\"调用第三方插件\"><a href=\"#调用第三方插件\" class=\"headerlink\" title=\"调用第三方插件\"></a>调用第三方插件</h2><h3 id=\"使用多选插件\"><a href=\"#使用多选插件\" class=\"headerlink\" title=\"使用多选插件\"></a>使用多选插件</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'jquery.shiftcheckbox'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">           $(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">               $(<span class=\"string\">'#demo2 :checkbox'</span>).shiftcheckbox();</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">       &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用’bootstrap’-‘jquery-form’-‘jquery-validate’三个插件\"><a href=\"#使用’bootstrap’-‘jquery-form’-‘jquery-validate’三个插件\" class=\"headerlink\" title=\"使用’bootstrap’, ‘jquery.form’, ‘jquery.validate’三个插件\"></a>使用’bootstrap’, ‘jquery.form’, ‘jquery.validate’三个插件</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'bootstrap'</span>, <span class=\"string\">'jquery.form'</span>, <span class=\"string\">'jquery.validate'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    $(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        jQuery.validator.addMethod(<span class=\"string\">\"isZipCode\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, element</span>) </span>&#123; <span class=\"keyword\">var</span> tel = <span class=\"regexp\">/^[0-9]&#123;6&#125;$/</span>; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.optional(element) || (tel.test(value));</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"请正确填写您的邮政编码\"</span>);</span><br><span class=\"line\">        $(<span class=\"string\">\"#signupForm\"</span>).validate(&#123;</span><br><span class=\"line\">            rules: &#123;</span><br><span class=\"line\">                firstname: &#123;</span><br><span class=\"line\">                    required: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">                email: &#123;</span><br><span class=\"line\">                    required: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                    email: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">                password: &#123;</span><br><span class=\"line\">                    required: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                    minlength: <span class=\"number\">5</span> &#125;,</span><br><span class=\"line\">                confirm_password: &#123;</span><br><span class=\"line\">                    required: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                    minlength: <span class=\"number\">5</span>,</span><br><span class=\"line\">                    equalTo: <span class=\"string\">\"#password\"</span> &#125;,</span><br><span class=\"line\">                isZipCode: &#123;</span><br><span class=\"line\">                    isZipCode: <span class=\"literal\">true</span> &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            messages: &#123;</span><br><span class=\"line\">                firstname: <span class=\"string\">\"请输入姓名\"</span>,</span><br><span class=\"line\">                email: &#123;</span><br><span class=\"line\">                    required: <span class=\"string\">\"请输入Email地址\"</span>,</span><br><span class=\"line\">                    email: <span class=\"string\">\"请输入正确的email地址\"</span> &#125;,</span><br><span class=\"line\">                password: &#123;</span><br><span class=\"line\">                    required: <span class=\"string\">\"请输入密码\"</span>,</span><br><span class=\"line\">                    minlength: jQuery.format(<span class=\"string\">\"密码不能小于&#123;0&#125;个字 符\"</span>)</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                confirm_password: &#123;</span><br><span class=\"line\">                    required: <span class=\"string\">\"请输入确认密码\"</span>,</span><br><span class=\"line\">                    minlength: <span class=\"string\">\"确认密码不能小于5个字符\"</span>,</span><br><span class=\"line\">                    equalTo: <span class=\"string\">\"两次输入密码不一致不一致\"</span> &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        $(<span class=\"string\">\"#signupForm\"</span>).ajaxSubmit();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"调用自己写的方法或者类\"><a href=\"#调用自己写的方法或者类\" class=\"headerlink\" title=\"调用自己写的方法或者类\"></a>调用自己写的方法或者类</h2><h3 id=\"调用日期方法类\"><a href=\"#调用日期方法类\" class=\"headerlink\" title=\"调用日期方法类\"></a>调用日期方法类</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by lewis on 15-9-15. */</span></span><br><span class=\"line\"><span class=\"comment\">//自定义的命名空间，用来对日期进行操作</span></span><br><span class=\"line\">define([],&#123; <span class=\"comment\">//输入json日期获取年</span></span><br><span class=\"line\">    getYear: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">jsonDate</span>) </span>&#123; <span class=\"keyword\">var</span> dateArry = jsonDate.split(<span class=\"string\">'-'</span>); <span class=\"keyword\">var</span> jsonyear = <span class=\"built_in\">parseInt</span>(dateArry[<span class=\"number\">0</span>]); <span class=\"keyword\">return</span> jsonyear;</span><br><span class=\"line\">    &#125;, <span class=\"comment\">//输入json日期获取月</span></span><br><span class=\"line\">    getMonth: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">jsonDate</span>) </span>&#123; <span class=\"keyword\">var</span> dateArry = jsonDate.split(<span class=\"string\">'-'</span>); <span class=\"keyword\">var</span> jsonmonth = <span class=\"built_in\">parseInt</span>(dateArry[<span class=\"number\">1</span>]); <span class=\"keyword\">return</span> jsonmonth;</span><br><span class=\"line\">    &#125;, <span class=\"comment\">//输入json日期获取日</span></span><br><span class=\"line\">    getDay: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">jsonDate</span>) </span>&#123; <span class=\"keyword\">var</span> dateArry = jsonDate.split(<span class=\"string\">'-'</span>); <span class=\"keyword\">var</span> jsonday = <span class=\"built_in\">parseInt</span>(dateArry[<span class=\"number\">2</span>]); <span class=\"keyword\">return</span> jsonday;</span><br><span class=\"line\">    &#125;, <span class=\"comment\">//输入json日期和日历日期（后面的年）,判断json日期是否在两年内</span></span><br><span class=\"line\">    isInYear: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">jsonDate, calenYear</span>) </span>&#123; <span class=\"keyword\">var</span> jsonArry = jsonDate.split(<span class=\"string\">'-'</span>); <span class=\"keyword\">var</span> jsonyear = <span class=\"built_in\">parseInt</span>(jsonArry[<span class=\"number\">0</span>]); <span class=\"keyword\">if</span> (jsonyear == calenYear || jsonyear == (calenYear - <span class=\"number\">1</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;, <span class=\"comment\">//输入json日期和日历日期（年和月），判断json日期是否在日历日期内</span></span><br><span class=\"line\">    isInMonth: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">jsonDate, calendarDate</span>) </span>&#123; <span class=\"keyword\">var</span> jsonArry = jsonDate.split(<span class=\"string\">'-'</span>); <span class=\"keyword\">var</span> jsonyear = <span class=\"built_in\">parseInt</span>(jsonArry[<span class=\"number\">0</span>]); <span class=\"keyword\">var</span> jsonmonth = <span class=\"built_in\">parseInt</span>(jsonArry[<span class=\"number\">1</span>]); <span class=\"keyword\">var</span> calenArry = calendarDate.split(<span class=\"string\">'-'</span>); <span class=\"keyword\">var</span> calenyear = <span class=\"built_in\">parseInt</span>(calenArry[<span class=\"number\">0</span>]); <span class=\"keyword\">var</span> calenmonth = <span class=\"built_in\">parseInt</span>(calenArry[<span class=\"number\">1</span>]); <span class=\"keyword\">if</span> (jsonyear == calenyear &amp;&amp; jsonmonth == calenmonth) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getNowFormatDate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"keyword\">var</span> seperator = <span class=\"string\">\"-\"</span>; <span class=\"keyword\">var</span> year = date.getFullYear(); <span class=\"keyword\">var</span> month = date.getMonth() + <span class=\"number\">1</span>; <span class=\"keyword\">var</span> strDate = date.getDate(); <span class=\"keyword\">var</span> currentdate = year + seperator + month + seperator + strDate;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(currentdate); <span class=\"keyword\">return</span> currentdate;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getDateFromYMD: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>) </span>&#123; <span class=\"keyword\">var</span> arr = a.split(<span class=\"string\">\"-\"</span>); <span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(arr[<span class=\"number\">0</span>], arr[<span class=\"number\">1</span>], arr[<span class=\"number\">2</span>]); <span class=\"keyword\">return</span> date;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> require([&apos;common/myDateClass&apos;], function (myDateClass) &#123;</span><br><span class=\"line\">。。。</span><br><span class=\"line\">。。。</span><br><span class=\"line\">&#125;）</span><br></pre></td></tr></table></figure>\n<h2 id=\"调用代码段（任性！！！）\"><a href=\"#调用代码段（任性！！！）\" class=\"headerlink\" title=\"调用代码段（任性！！！）\"></a>调用代码段（任性！！！）</h2><p>a.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunctionA</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>b.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunctionB</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'js/ab/a'</span>,<span class=\"string\">'ab/b.js'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    myFunctionA();</span><br><span class=\"line\">    myFunctionB();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><h2 id=\"Problem（问题）\"><a href=\"#Problem（问题）\" class=\"headerlink\" title=\"Problem（问题）\"></a>Problem（问题）</h2><ul>\n<li>Web sites are turning into Web apps（网站正转变为网络应用程序）</li>\n<li>Code complexity grows as the site gets bigger（代码复杂度随着站点变大而变复杂）</li>\n<li>Assembly gets harder（组装变得更难【ps】这里我个人认为“组装”是拼接单个js文件中的昂多的代码段 ）</li>\n<li>Developer wants discrete JS files/modules（开发者想分离js文件/模块）</li>\n<li>Deployment wants optimized code in just one or a few HTTP calls（网站部署者想通过使用一个或者很少http请求来优化代码）</li>\n</ul>\n<h2 id=\"Solution（解决方案）\"><a href=\"#Solution（解决方案）\" class=\"headerlink\" title=\"Solution（解决方案）\"></a>Solution（解决方案）</h2><ul>\n<li>Front-end developers need a solution with:（前端工程师需要一个解决方案，拥有这些功能：）</li>\n<li>Some sort of #include/import/require（一些引入文件的命令语句）</li>\n<li>ability to load nested dependencies（加载嵌套的依赖文件）</li>\n<li>ease of use for developer but then backed by an optimization tool that helps deployment（简单好用，但也有助于优化部署） </li>\n</ul>","more":"<h1 id=\"RequireJs简介\"><a href=\"#RequireJs简介\" class=\"headerlink\" title=\"RequireJs简介\"></a>RequireJs简介</h1><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>RequireJS的目标是鼓励代码的模块化，它使用了不同于传统script标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它鼓励在使用脚本时以module ID替代URL地址。</p>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><h3 id=\"速度快\"><a href=\"#速度快\" class=\"headerlink\" title=\"速度快\"></a>速度快</h3><p><img src=\"http://images.cnitblog.com/blog/139239/201408/131435005307505.png\" alt=\"15085801_CrX1\" title=\"15085801_CrX1\"></p>\n<p><a href=\"http://www.cnblogs.com/powertoolsteam/p/RequireJS_wijmo.html\" target=\"_blank\" rel=\"noopener\">有位网友做了对比测试</a></p>\n<h3 id=\"依赖关系清晰\"><a href=\"#依赖关系清晰\" class=\"headerlink\" title=\"依赖关系清晰\"></a>依赖关系清晰</h3><p><img src=\"http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/html5/articles/javascript-architecture-requirejs-dependency-management/fig01.png\" alt=\"JavaScript 文件之间的依赖项表示。\" title=\"JavaScript 文件之间的依赖项表示。\"></p>\n<p>requirejs通过a.js调用b.js,b.js调用c.js,c.js调用d.js的原理，让我们可以只调用a.js，就可以加载所有的js,而且依赖关系非常清晰。  </p>\n<p>js文件不仅可以调用js，还能调用css和html页面，所以毫不夸张地说，引入一个入口js，无需向 HTML 文件添加任何其他元素即可构建大型单页面应用程序</p>\n<h3 id=\"鼓励代码模块化（最大优点）\"><a href=\"#鼓励代码模块化（最大优点）\" class=\"headerlink\" title=\"鼓励代码模块化（最大优点）\"></a>鼓励代码模块化（最大优点）</h3><p><img src=\"/css/images/172.jpg\" alt=\"\"></p>\n<p>使用requirejs，我们就需要将原来在一个js文件里面写的代码，按照模块解耦分离成多个js文件，然后按照需求调用。这样做的好处很多：</p>\n<p>解耦了，就不会出现牵一发动全身的情况，便于日后维护；还能便于多人分工合作；还能复用…</p>\n<h1 id=\"在项目中使用RequireJs\"><a href=\"#在项目中使用RequireJs\" class=\"headerlink\" title=\"在项目中使用RequireJs\"></a>在项目中使用RequireJs</h1><h2 id=\"调用第三方插件\"><a href=\"#调用第三方插件\" class=\"headerlink\" title=\"调用第三方插件\"></a>调用第三方插件</h2><h3 id=\"使用多选插件\"><a href=\"#使用多选插件\" class=\"headerlink\" title=\"使用多选插件\"></a>使用多选插件</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'jquery.shiftcheckbox'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">           $(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">               $(<span class=\"string\">'#demo2 :checkbox'</span>).shiftcheckbox();</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">       &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用’bootstrap’-‘jquery-form’-‘jquery-validate’三个插件\"><a href=\"#使用’bootstrap’-‘jquery-form’-‘jquery-validate’三个插件\" class=\"headerlink\" title=\"使用’bootstrap’, ‘jquery.form’, ‘jquery.validate’三个插件\"></a>使用’bootstrap’, ‘jquery.form’, ‘jquery.validate’三个插件</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'bootstrap'</span>, <span class=\"string\">'jquery.form'</span>, <span class=\"string\">'jquery.validate'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    $(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        jQuery.validator.addMethod(<span class=\"string\">\"isZipCode\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, element</span>) </span>&#123; <span class=\"keyword\">var</span> tel = <span class=\"regexp\">/^[0-9]&#123;6&#125;$/</span>; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.optional(element) || (tel.test(value));</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"请正确填写您的邮政编码\"</span>);</span><br><span class=\"line\">        $(<span class=\"string\">\"#signupForm\"</span>).validate(&#123;</span><br><span class=\"line\">            rules: &#123;</span><br><span class=\"line\">                firstname: &#123;</span><br><span class=\"line\">                    required: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">                email: &#123;</span><br><span class=\"line\">                    required: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                    email: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">                password: &#123;</span><br><span class=\"line\">                    required: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                    minlength: <span class=\"number\">5</span> &#125;,</span><br><span class=\"line\">                confirm_password: &#123;</span><br><span class=\"line\">                    required: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                    minlength: <span class=\"number\">5</span>,</span><br><span class=\"line\">                    equalTo: <span class=\"string\">\"#password\"</span> &#125;,</span><br><span class=\"line\">                isZipCode: &#123;</span><br><span class=\"line\">                    isZipCode: <span class=\"literal\">true</span> &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            messages: &#123;</span><br><span class=\"line\">                firstname: <span class=\"string\">\"请输入姓名\"</span>,</span><br><span class=\"line\">                email: &#123;</span><br><span class=\"line\">                    required: <span class=\"string\">\"请输入Email地址\"</span>,</span><br><span class=\"line\">                    email: <span class=\"string\">\"请输入正确的email地址\"</span> &#125;,</span><br><span class=\"line\">                password: &#123;</span><br><span class=\"line\">                    required: <span class=\"string\">\"请输入密码\"</span>,</span><br><span class=\"line\">                    minlength: jQuery.format(<span class=\"string\">\"密码不能小于&#123;0&#125;个字 符\"</span>)</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                confirm_password: &#123;</span><br><span class=\"line\">                    required: <span class=\"string\">\"请输入确认密码\"</span>,</span><br><span class=\"line\">                    minlength: <span class=\"string\">\"确认密码不能小于5个字符\"</span>,</span><br><span class=\"line\">                    equalTo: <span class=\"string\">\"两次输入密码不一致不一致\"</span> &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        $(<span class=\"string\">\"#signupForm\"</span>).ajaxSubmit();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"调用自己写的方法或者类\"><a href=\"#调用自己写的方法或者类\" class=\"headerlink\" title=\"调用自己写的方法或者类\"></a>调用自己写的方法或者类</h2><h3 id=\"调用日期方法类\"><a href=\"#调用日期方法类\" class=\"headerlink\" title=\"调用日期方法类\"></a>调用日期方法类</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by lewis on 15-9-15. */</span></span><br><span class=\"line\"><span class=\"comment\">//自定义的命名空间，用来对日期进行操作</span></span><br><span class=\"line\">define([],&#123; <span class=\"comment\">//输入json日期获取年</span></span><br><span class=\"line\">    getYear: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">jsonDate</span>) </span>&#123; <span class=\"keyword\">var</span> dateArry = jsonDate.split(<span class=\"string\">'-'</span>); <span class=\"keyword\">var</span> jsonyear = <span class=\"built_in\">parseInt</span>(dateArry[<span class=\"number\">0</span>]); <span class=\"keyword\">return</span> jsonyear;</span><br><span class=\"line\">    &#125;, <span class=\"comment\">//输入json日期获取月</span></span><br><span class=\"line\">    getMonth: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">jsonDate</span>) </span>&#123; <span class=\"keyword\">var</span> dateArry = jsonDate.split(<span class=\"string\">'-'</span>); <span class=\"keyword\">var</span> jsonmonth = <span class=\"built_in\">parseInt</span>(dateArry[<span class=\"number\">1</span>]); <span class=\"keyword\">return</span> jsonmonth;</span><br><span class=\"line\">    &#125;, <span class=\"comment\">//输入json日期获取日</span></span><br><span class=\"line\">    getDay: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">jsonDate</span>) </span>&#123; <span class=\"keyword\">var</span> dateArry = jsonDate.split(<span class=\"string\">'-'</span>); <span class=\"keyword\">var</span> jsonday = <span class=\"built_in\">parseInt</span>(dateArry[<span class=\"number\">2</span>]); <span class=\"keyword\">return</span> jsonday;</span><br><span class=\"line\">    &#125;, <span class=\"comment\">//输入json日期和日历日期（后面的年）,判断json日期是否在两年内</span></span><br><span class=\"line\">    isInYear: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">jsonDate, calenYear</span>) </span>&#123; <span class=\"keyword\">var</span> jsonArry = jsonDate.split(<span class=\"string\">'-'</span>); <span class=\"keyword\">var</span> jsonyear = <span class=\"built_in\">parseInt</span>(jsonArry[<span class=\"number\">0</span>]); <span class=\"keyword\">if</span> (jsonyear == calenYear || jsonyear == (calenYear - <span class=\"number\">1</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;, <span class=\"comment\">//输入json日期和日历日期（年和月），判断json日期是否在日历日期内</span></span><br><span class=\"line\">    isInMonth: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">jsonDate, calendarDate</span>) </span>&#123; <span class=\"keyword\">var</span> jsonArry = jsonDate.split(<span class=\"string\">'-'</span>); <span class=\"keyword\">var</span> jsonyear = <span class=\"built_in\">parseInt</span>(jsonArry[<span class=\"number\">0</span>]); <span class=\"keyword\">var</span> jsonmonth = <span class=\"built_in\">parseInt</span>(jsonArry[<span class=\"number\">1</span>]); <span class=\"keyword\">var</span> calenArry = calendarDate.split(<span class=\"string\">'-'</span>); <span class=\"keyword\">var</span> calenyear = <span class=\"built_in\">parseInt</span>(calenArry[<span class=\"number\">0</span>]); <span class=\"keyword\">var</span> calenmonth = <span class=\"built_in\">parseInt</span>(calenArry[<span class=\"number\">1</span>]); <span class=\"keyword\">if</span> (jsonyear == calenyear &amp;&amp; jsonmonth == calenmonth) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getNowFormatDate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"keyword\">var</span> seperator = <span class=\"string\">\"-\"</span>; <span class=\"keyword\">var</span> year = date.getFullYear(); <span class=\"keyword\">var</span> month = date.getMonth() + <span class=\"number\">1</span>; <span class=\"keyword\">var</span> strDate = date.getDate(); <span class=\"keyword\">var</span> currentdate = year + seperator + month + seperator + strDate;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(currentdate); <span class=\"keyword\">return</span> currentdate;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getDateFromYMD: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>) </span>&#123; <span class=\"keyword\">var</span> arr = a.split(<span class=\"string\">\"-\"</span>); <span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(arr[<span class=\"number\">0</span>], arr[<span class=\"number\">1</span>], arr[<span class=\"number\">2</span>]); <span class=\"keyword\">return</span> date;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> require([&apos;common/myDateClass&apos;], function (myDateClass) &#123;</span><br><span class=\"line\">。。。</span><br><span class=\"line\">。。。</span><br><span class=\"line\">&#125;）</span><br></pre></td></tr></table></figure>\n<h2 id=\"调用代码段（任性！！！）\"><a href=\"#调用代码段（任性！！！）\" class=\"headerlink\" title=\"调用代码段（任性！！！）\"></a>调用代码段（任性！！！）</h2><p>a.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunctionA</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>b.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunctionB</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'js/ab/a'</span>,<span class=\"string\">'ab/b.js'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    myFunctionA();</span><br><span class=\"line\">    myFunctionB();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"r.js结合gulp等于webpack（angular为例）","date":"2016-01-18T19:46:00.000Z","_content":"\n本人大学时玩Dojo，开始了AMD模块化的不归路，工作后一直使用Requirejs，感觉非常好。但是，近来随着React的火热，Webpack成为了天下无敌的模块化工具，能做模块化，合并压缩，监视等，当我看见Webpack甚至还能做反向代理的时候，我整个人都不好了。我已经打算从Requirejs转向Webpack了，在重构以前老代码的时候，我想记录下历史。使用r.js结合gulp同样可以实现Webpack的绝大部分功能。\n\n<!--more-->\n\n## 例子\n\n源代码地址：[https://github.com/lewis617/daily-task](https://github.com/lewis617/daily-task)\n\n例子比较弯弯绕，不适合Angular和Requirejs的新手看，但是可以只关注思路。\n\n写的是一个任务管理系统，包括用户系统，任务的crud等功能。\n\n## 组件（components）\n\nAngular的组件指的是指令、过滤器、服务等，在这个例子中，我自己编写了若干个组件，包括一个延迟加载工具、一个等待指令、一个确认框、一个wilddog工具模块（里面包含了若干个我能用到的服务），都是我平时经常复用的组件，直接复制文件夹过去就能用。\n\n还包括一些第三方的组件比如，angular-route，angular-ui等，都是直接用bower安装的。跟我自己写的组件原理是一样的哈哈，只不过最后用了一个module打包起来。\n\n## 模块（modules）\n\n就是按页面划分的功能模块，包括登录、主页、账户、任务四个模块。每个模块都包括config路由，controller，html页面等。\n\n## 开始打包\n\nnpm install requirejs后可以使用r.js了，我们直接使用r.js命令行工具也可以，但是无法实现监视代码变动的功能，所以我们引入gulp来实现监视功能，其他的合并压缩均使用requirejs来实现。\n\ngulpfile.js\n\n```js\nvar gulp = require('gulp'); var rjs = require('requirejs'); var paths = {\n  scripts: ['modules/**/*.js', 'modules/**/**/*.js','main.js']\n};\n\ngulp.task('build', function(cb){\n  rjs.optimize({\n    baseUrl: \"./\",\n    mainConfigFile:\"./main.js\",\n    name:'main',\n    out:'./dist/build-main.js' }, function(buildResponse){ // console.log('build response', buildResponse);\n cb();\n  }, cb);\n}); // Rerun the task when a file changes\ngulp.task('watch', function() { var watcher = gulp.watch(paths.scripts, ['build']);\n  watcher.on('change', function(event) {\n    console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');\n  });\n});\n\ngulp.task('default', ['build','watch']);\n```\n\n这个gulp配置文件就写了两个任务，一个是`build`一个是`watch`。`build`任务是直接把requirejs的入口文件（main.js）输入，指定输出目录，再指定配置文件（这里也是main.js），就可以合并压缩了。是不是非常简单。\n\n`watch`任务就是监视代码变动，如果代码改变就自动合并压缩一次。\n\n那么main.js里面究竟是什么呢？先贴出代码\n\nmain.js\n\n```js\n'use strict';\nrequire.config({\n    baseUrl:'',\n    paths: { 'ngRoute':'bower_components/angular-route/angular-route.min', 'domReady':'bower_components/domReady/domReady', 'text':'bower_components/text/text', 'ui-bootstrap' : 'bower_components/angular-bootstrap/ui-bootstrap-tpls.min', 'angular-animate':'bower_components/angular-animate/angular-animate.min', 'routeConfig':'components/routeConfig' }\n});\n\nrequire([ 'domReady!', 'modules/home/main', 'modules/login/main', 'modules/account/main', 'modules/task/main' ],function(){\n    angular.module(\"myApp\", [ \"myApp.home\", \"myApp.login\", \"myApp.account\", 'myApp.task' ]).run(['$rootScope', 'Auth', function($rootScope, Auth) { // track status of authentication\n            Auth.$onAuth(function(user) {\n                $rootScope.loggedIn = !!user;\n            }); //alert列表以及关闭方法\n            $rootScope.alerts = [];\n            $rootScope.closeAlert = function(index) {\n                $rootScope.alerts.splice(index, 1);\n            };\n\n        }]);\n\n    angular.bootstrap(document,['myApp']);\n});\n```\n\n这段代码包含两部分，第一部分是requirejs的配置部分，定义了几个假名而已；第二部分是requirejs的入口部分，主要是先加载一些模块，然后用在主module里面声明以来，最后用run方法，启动一些你需要启动的事件，最后的最后手动启动Angular。\n\n## 多米诺骨牌\n\n本文并不打算写Requirejs，但是可以简单说一下，Requirejs以及其他所有的模块化工具都是一个多米诺骨牌，触发入口文件，继而引入所有的文件。示例程序中的组件和模块就是这样被引入的。将他们封装起来用文件夹打包，在以后的复用过程中，会非常好用！\n\n## 比较Webpack\n\n这些功能Webpack都具备，但是Requirejs是可以不全部合并的，有些文件需要延迟加载，比如Angular程序绝大多数都是SPA ，如果我们一开始就把所有的文件全部合并，势必会造成首次加载速度非常慢，那么如果我们使用Requirejs就可以在改变路由时候延迟加载一些js文件，使得首次加载的js文件体积变小。使用Webpack的话，恐怕不能直接实现这个功能，但是一定有相关的插件或者模块可以实现类似的。期待Webpack，也感谢历史上那些曾经优秀的工具带给我们的便利，让我们程序员的工作更加轻松！","source":"_posts/rjs-gulp-webpack.md","raw":"---\ntitle: r.js结合gulp等于webpack（angular为例）\ndate: 2016-01-19 03:46:00\ntags: [RequireJs, r.js, Gulp, Webpack]\n---\n\n本人大学时玩Dojo，开始了AMD模块化的不归路，工作后一直使用Requirejs，感觉非常好。但是，近来随着React的火热，Webpack成为了天下无敌的模块化工具，能做模块化，合并压缩，监视等，当我看见Webpack甚至还能做反向代理的时候，我整个人都不好了。我已经打算从Requirejs转向Webpack了，在重构以前老代码的时候，我想记录下历史。使用r.js结合gulp同样可以实现Webpack的绝大部分功能。\n\n<!--more-->\n\n## 例子\n\n源代码地址：[https://github.com/lewis617/daily-task](https://github.com/lewis617/daily-task)\n\n例子比较弯弯绕，不适合Angular和Requirejs的新手看，但是可以只关注思路。\n\n写的是一个任务管理系统，包括用户系统，任务的crud等功能。\n\n## 组件（components）\n\nAngular的组件指的是指令、过滤器、服务等，在这个例子中，我自己编写了若干个组件，包括一个延迟加载工具、一个等待指令、一个确认框、一个wilddog工具模块（里面包含了若干个我能用到的服务），都是我平时经常复用的组件，直接复制文件夹过去就能用。\n\n还包括一些第三方的组件比如，angular-route，angular-ui等，都是直接用bower安装的。跟我自己写的组件原理是一样的哈哈，只不过最后用了一个module打包起来。\n\n## 模块（modules）\n\n就是按页面划分的功能模块，包括登录、主页、账户、任务四个模块。每个模块都包括config路由，controller，html页面等。\n\n## 开始打包\n\nnpm install requirejs后可以使用r.js了，我们直接使用r.js命令行工具也可以，但是无法实现监视代码变动的功能，所以我们引入gulp来实现监视功能，其他的合并压缩均使用requirejs来实现。\n\ngulpfile.js\n\n```js\nvar gulp = require('gulp'); var rjs = require('requirejs'); var paths = {\n  scripts: ['modules/**/*.js', 'modules/**/**/*.js','main.js']\n};\n\ngulp.task('build', function(cb){\n  rjs.optimize({\n    baseUrl: \"./\",\n    mainConfigFile:\"./main.js\",\n    name:'main',\n    out:'./dist/build-main.js' }, function(buildResponse){ // console.log('build response', buildResponse);\n cb();\n  }, cb);\n}); // Rerun the task when a file changes\ngulp.task('watch', function() { var watcher = gulp.watch(paths.scripts, ['build']);\n  watcher.on('change', function(event) {\n    console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');\n  });\n});\n\ngulp.task('default', ['build','watch']);\n```\n\n这个gulp配置文件就写了两个任务，一个是`build`一个是`watch`。`build`任务是直接把requirejs的入口文件（main.js）输入，指定输出目录，再指定配置文件（这里也是main.js），就可以合并压缩了。是不是非常简单。\n\n`watch`任务就是监视代码变动，如果代码改变就自动合并压缩一次。\n\n那么main.js里面究竟是什么呢？先贴出代码\n\nmain.js\n\n```js\n'use strict';\nrequire.config({\n    baseUrl:'',\n    paths: { 'ngRoute':'bower_components/angular-route/angular-route.min', 'domReady':'bower_components/domReady/domReady', 'text':'bower_components/text/text', 'ui-bootstrap' : 'bower_components/angular-bootstrap/ui-bootstrap-tpls.min', 'angular-animate':'bower_components/angular-animate/angular-animate.min', 'routeConfig':'components/routeConfig' }\n});\n\nrequire([ 'domReady!', 'modules/home/main', 'modules/login/main', 'modules/account/main', 'modules/task/main' ],function(){\n    angular.module(\"myApp\", [ \"myApp.home\", \"myApp.login\", \"myApp.account\", 'myApp.task' ]).run(['$rootScope', 'Auth', function($rootScope, Auth) { // track status of authentication\n            Auth.$onAuth(function(user) {\n                $rootScope.loggedIn = !!user;\n            }); //alert列表以及关闭方法\n            $rootScope.alerts = [];\n            $rootScope.closeAlert = function(index) {\n                $rootScope.alerts.splice(index, 1);\n            };\n\n        }]);\n\n    angular.bootstrap(document,['myApp']);\n});\n```\n\n这段代码包含两部分，第一部分是requirejs的配置部分，定义了几个假名而已；第二部分是requirejs的入口部分，主要是先加载一些模块，然后用在主module里面声明以来，最后用run方法，启动一些你需要启动的事件，最后的最后手动启动Angular。\n\n## 多米诺骨牌\n\n本文并不打算写Requirejs，但是可以简单说一下，Requirejs以及其他所有的模块化工具都是一个多米诺骨牌，触发入口文件，继而引入所有的文件。示例程序中的组件和模块就是这样被引入的。将他们封装起来用文件夹打包，在以后的复用过程中，会非常好用！\n\n## 比较Webpack\n\n这些功能Webpack都具备，但是Requirejs是可以不全部合并的，有些文件需要延迟加载，比如Angular程序绝大多数都是SPA ，如果我们一开始就把所有的文件全部合并，势必会造成首次加载速度非常慢，那么如果我们使用Requirejs就可以在改变路由时候延迟加载一些js文件，使得首次加载的js文件体积变小。使用Webpack的话，恐怕不能直接实现这个功能，但是一定有相关的插件或者模块可以实现类似的。期待Webpack，也感谢历史上那些曾经优秀的工具带给我们的便利，让我们程序员的工作更加轻松！","slug":"rjs-gulp-webpack","published":1,"updated":"2019-05-01T08:02:12.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmp0034tgytk5m037f1","content":"<p>本人大学时玩Dojo，开始了AMD模块化的不归路，工作后一直使用Requirejs，感觉非常好。但是，近来随着React的火热，Webpack成为了天下无敌的模块化工具，能做模块化，合并压缩，监视等，当我看见Webpack甚至还能做反向代理的时候，我整个人都不好了。我已经打算从Requirejs转向Webpack了，在重构以前老代码的时候，我想记录下历史。使用r.js结合gulp同样可以实现Webpack的绝大部分功能。</p>\n<a id=\"more\"></a>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>源代码地址：<a href=\"https://github.com/lewis617/daily-task\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/daily-task</a></p>\n<p>例子比较弯弯绕，不适合Angular和Requirejs的新手看，但是可以只关注思路。</p>\n<p>写的是一个任务管理系统，包括用户系统，任务的crud等功能。</p>\n<h2 id=\"组件（components）\"><a href=\"#组件（components）\" class=\"headerlink\" title=\"组件（components）\"></a>组件（components）</h2><p>Angular的组件指的是指令、过滤器、服务等，在这个例子中，我自己编写了若干个组件，包括一个延迟加载工具、一个等待指令、一个确认框、一个wilddog工具模块（里面包含了若干个我能用到的服务），都是我平时经常复用的组件，直接复制文件夹过去就能用。</p>\n<p>还包括一些第三方的组件比如，angular-route，angular-ui等，都是直接用bower安装的。跟我自己写的组件原理是一样的哈哈，只不过最后用了一个module打包起来。</p>\n<h2 id=\"模块（modules）\"><a href=\"#模块（modules）\" class=\"headerlink\" title=\"模块（modules）\"></a>模块（modules）</h2><p>就是按页面划分的功能模块，包括登录、主页、账户、任务四个模块。每个模块都包括config路由，controller，html页面等。</p>\n<h2 id=\"开始打包\"><a href=\"#开始打包\" class=\"headerlink\" title=\"开始打包\"></a>开始打包</h2><p>npm install requirejs后可以使用r.js了，我们直接使用r.js命令行工具也可以，但是无法实现监视代码变动的功能，所以我们引入gulp来实现监视功能，其他的合并压缩均使用requirejs来实现。</p>\n<p>gulpfile.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>); <span class=\"keyword\">var</span> rjs = <span class=\"built_in\">require</span>(<span class=\"string\">'requirejs'</span>); <span class=\"keyword\">var</span> paths = &#123;</span><br><span class=\"line\">  scripts: [<span class=\"string\">'modules/**/*.js'</span>, <span class=\"string\">'modules/**/**/*.js'</span>,<span class=\"string\">'main.js'</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'build'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cb</span>)</span>&#123;</span><br><span class=\"line\">  rjs.optimize(&#123;</span><br><span class=\"line\">    baseUrl: <span class=\"string\">\"./\"</span>,</span><br><span class=\"line\">    mainConfigFile:<span class=\"string\">\"./main.js\"</span>,</span><br><span class=\"line\">    name:<span class=\"string\">'main'</span>,</span><br><span class=\"line\">    out:<span class=\"string\">'./dist/build-main.js'</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">buildResponse</span>)</span>&#123; <span class=\"comment\">// console.log('build response', buildResponse);</span></span><br><span class=\"line\"> cb();</span><br><span class=\"line\">  &#125;, cb);</span><br><span class=\"line\">&#125;); <span class=\"comment\">// Rerun the task when a file changes</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'watch'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">var</span> watcher = gulp.watch(paths.scripts, [<span class=\"string\">'build'</span>]);</span><br><span class=\"line\">  watcher.on(<span class=\"string\">'change'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'File '</span> + event.path + <span class=\"string\">' was '</span> + event.type + <span class=\"string\">', running tasks...'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>, [<span class=\"string\">'build'</span>,<span class=\"string\">'watch'</span>]);</span><br></pre></td></tr></table></figure>\n<p>这个gulp配置文件就写了两个任务，一个是<code>build</code>一个是<code>watch</code>。<code>build</code>任务是直接把requirejs的入口文件（main.js）输入，指定输出目录，再指定配置文件（这里也是main.js），就可以合并压缩了。是不是非常简单。</p>\n<p><code>watch</code>任务就是监视代码变动，如果代码改变就自动合并压缩一次。</p>\n<p>那么main.js里面究竟是什么呢？先贴出代码</p>\n<p>main.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">    baseUrl:<span class=\"string\">''</span>,</span><br><span class=\"line\">    paths: &#123; <span class=\"string\">'ngRoute'</span>:<span class=\"string\">'bower_components/angular-route/angular-route.min'</span>, <span class=\"string\">'domReady'</span>:<span class=\"string\">'bower_components/domReady/domReady'</span>, <span class=\"string\">'text'</span>:<span class=\"string\">'bower_components/text/text'</span>, <span class=\"string\">'ui-bootstrap'</span> : <span class=\"string\">'bower_components/angular-bootstrap/ui-bootstrap-tpls.min'</span>, <span class=\"string\">'angular-animate'</span>:<span class=\"string\">'bower_components/angular-animate/angular-animate.min'</span>, <span class=\"string\">'routeConfig'</span>:<span class=\"string\">'components/routeConfig'</span> &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">require</span>([ <span class=\"string\">'domReady!'</span>, <span class=\"string\">'modules/home/main'</span>, <span class=\"string\">'modules/login/main'</span>, <span class=\"string\">'modules/account/main'</span>, <span class=\"string\">'modules/task/main'</span> ],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    angular.module(<span class=\"string\">\"myApp\"</span>, [ <span class=\"string\">\"myApp.home\"</span>, <span class=\"string\">\"myApp.login\"</span>, <span class=\"string\">\"myApp.account\"</span>, <span class=\"string\">'myApp.task'</span> ]).run([<span class=\"string\">'$rootScope'</span>, <span class=\"string\">'Auth'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$rootScope, Auth</span>) </span>&#123; <span class=\"comment\">// track status of authentication</span></span><br><span class=\"line\">            Auth.$onAuth(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">                $rootScope.loggedIn = !!user;</span><br><span class=\"line\">            &#125;); <span class=\"comment\">//alert列表以及关闭方法</span></span><br><span class=\"line\">            $rootScope.alerts = [];</span><br><span class=\"line\">            $rootScope.closeAlert = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">index</span>) </span>&#123;</span><br><span class=\"line\">                $rootScope.alerts.splice(index, <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;]);</span><br><span class=\"line\"></span><br><span class=\"line\">    angular.bootstrap(<span class=\"built_in\">document</span>,[<span class=\"string\">'myApp'</span>]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这段代码包含两部分，第一部分是requirejs的配置部分，定义了几个假名而已；第二部分是requirejs的入口部分，主要是先加载一些模块，然后用在主module里面声明以来，最后用run方法，启动一些你需要启动的事件，最后的最后手动启动Angular。</p>\n<h2 id=\"多米诺骨牌\"><a href=\"#多米诺骨牌\" class=\"headerlink\" title=\"多米诺骨牌\"></a>多米诺骨牌</h2><p>本文并不打算写Requirejs，但是可以简单说一下，Requirejs以及其他所有的模块化工具都是一个多米诺骨牌，触发入口文件，继而引入所有的文件。示例程序中的组件和模块就是这样被引入的。将他们封装起来用文件夹打包，在以后的复用过程中，会非常好用！</p>\n<h2 id=\"比较Webpack\"><a href=\"#比较Webpack\" class=\"headerlink\" title=\"比较Webpack\"></a>比较Webpack</h2><p>这些功能Webpack都具备，但是Requirejs是可以不全部合并的，有些文件需要延迟加载，比如Angular程序绝大多数都是SPA ，如果我们一开始就把所有的文件全部合并，势必会造成首次加载速度非常慢，那么如果我们使用Requirejs就可以在改变路由时候延迟加载一些js文件，使得首次加载的js文件体积变小。使用Webpack的话，恐怕不能直接实现这个功能，但是一定有相关的插件或者模块可以实现类似的。期待Webpack，也感谢历史上那些曾经优秀的工具带给我们的便利，让我们程序员的工作更加轻松！</p>\n","site":{"data":{}},"excerpt":"<p>本人大学时玩Dojo，开始了AMD模块化的不归路，工作后一直使用Requirejs，感觉非常好。但是，近来随着React的火热，Webpack成为了天下无敌的模块化工具，能做模块化，合并压缩，监视等，当我看见Webpack甚至还能做反向代理的时候，我整个人都不好了。我已经打算从Requirejs转向Webpack了，在重构以前老代码的时候，我想记录下历史。使用r.js结合gulp同样可以实现Webpack的绝大部分功能。</p>","more":"<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>源代码地址：<a href=\"https://github.com/lewis617/daily-task\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/daily-task</a></p>\n<p>例子比较弯弯绕，不适合Angular和Requirejs的新手看，但是可以只关注思路。</p>\n<p>写的是一个任务管理系统，包括用户系统，任务的crud等功能。</p>\n<h2 id=\"组件（components）\"><a href=\"#组件（components）\" class=\"headerlink\" title=\"组件（components）\"></a>组件（components）</h2><p>Angular的组件指的是指令、过滤器、服务等，在这个例子中，我自己编写了若干个组件，包括一个延迟加载工具、一个等待指令、一个确认框、一个wilddog工具模块（里面包含了若干个我能用到的服务），都是我平时经常复用的组件，直接复制文件夹过去就能用。</p>\n<p>还包括一些第三方的组件比如，angular-route，angular-ui等，都是直接用bower安装的。跟我自己写的组件原理是一样的哈哈，只不过最后用了一个module打包起来。</p>\n<h2 id=\"模块（modules）\"><a href=\"#模块（modules）\" class=\"headerlink\" title=\"模块（modules）\"></a>模块（modules）</h2><p>就是按页面划分的功能模块，包括登录、主页、账户、任务四个模块。每个模块都包括config路由，controller，html页面等。</p>\n<h2 id=\"开始打包\"><a href=\"#开始打包\" class=\"headerlink\" title=\"开始打包\"></a>开始打包</h2><p>npm install requirejs后可以使用r.js了，我们直接使用r.js命令行工具也可以，但是无法实现监视代码变动的功能，所以我们引入gulp来实现监视功能，其他的合并压缩均使用requirejs来实现。</p>\n<p>gulpfile.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>); <span class=\"keyword\">var</span> rjs = <span class=\"built_in\">require</span>(<span class=\"string\">'requirejs'</span>); <span class=\"keyword\">var</span> paths = &#123;</span><br><span class=\"line\">  scripts: [<span class=\"string\">'modules/**/*.js'</span>, <span class=\"string\">'modules/**/**/*.js'</span>,<span class=\"string\">'main.js'</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'build'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cb</span>)</span>&#123;</span><br><span class=\"line\">  rjs.optimize(&#123;</span><br><span class=\"line\">    baseUrl: <span class=\"string\">\"./\"</span>,</span><br><span class=\"line\">    mainConfigFile:<span class=\"string\">\"./main.js\"</span>,</span><br><span class=\"line\">    name:<span class=\"string\">'main'</span>,</span><br><span class=\"line\">    out:<span class=\"string\">'./dist/build-main.js'</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">buildResponse</span>)</span>&#123; <span class=\"comment\">// console.log('build response', buildResponse);</span></span><br><span class=\"line\"> cb();</span><br><span class=\"line\">  &#125;, cb);</span><br><span class=\"line\">&#125;); <span class=\"comment\">// Rerun the task when a file changes</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'watch'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">var</span> watcher = gulp.watch(paths.scripts, [<span class=\"string\">'build'</span>]);</span><br><span class=\"line\">  watcher.on(<span class=\"string\">'change'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'File '</span> + event.path + <span class=\"string\">' was '</span> + event.type + <span class=\"string\">', running tasks...'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>, [<span class=\"string\">'build'</span>,<span class=\"string\">'watch'</span>]);</span><br></pre></td></tr></table></figure>\n<p>这个gulp配置文件就写了两个任务，一个是<code>build</code>一个是<code>watch</code>。<code>build</code>任务是直接把requirejs的入口文件（main.js）输入，指定输出目录，再指定配置文件（这里也是main.js），就可以合并压缩了。是不是非常简单。</p>\n<p><code>watch</code>任务就是监视代码变动，如果代码改变就自动合并压缩一次。</p>\n<p>那么main.js里面究竟是什么呢？先贴出代码</p>\n<p>main.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">    baseUrl:<span class=\"string\">''</span>,</span><br><span class=\"line\">    paths: &#123; <span class=\"string\">'ngRoute'</span>:<span class=\"string\">'bower_components/angular-route/angular-route.min'</span>, <span class=\"string\">'domReady'</span>:<span class=\"string\">'bower_components/domReady/domReady'</span>, <span class=\"string\">'text'</span>:<span class=\"string\">'bower_components/text/text'</span>, <span class=\"string\">'ui-bootstrap'</span> : <span class=\"string\">'bower_components/angular-bootstrap/ui-bootstrap-tpls.min'</span>, <span class=\"string\">'angular-animate'</span>:<span class=\"string\">'bower_components/angular-animate/angular-animate.min'</span>, <span class=\"string\">'routeConfig'</span>:<span class=\"string\">'components/routeConfig'</span> &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">require</span>([ <span class=\"string\">'domReady!'</span>, <span class=\"string\">'modules/home/main'</span>, <span class=\"string\">'modules/login/main'</span>, <span class=\"string\">'modules/account/main'</span>, <span class=\"string\">'modules/task/main'</span> ],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    angular.module(<span class=\"string\">\"myApp\"</span>, [ <span class=\"string\">\"myApp.home\"</span>, <span class=\"string\">\"myApp.login\"</span>, <span class=\"string\">\"myApp.account\"</span>, <span class=\"string\">'myApp.task'</span> ]).run([<span class=\"string\">'$rootScope'</span>, <span class=\"string\">'Auth'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$rootScope, Auth</span>) </span>&#123; <span class=\"comment\">// track status of authentication</span></span><br><span class=\"line\">            Auth.$onAuth(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">                $rootScope.loggedIn = !!user;</span><br><span class=\"line\">            &#125;); <span class=\"comment\">//alert列表以及关闭方法</span></span><br><span class=\"line\">            $rootScope.alerts = [];</span><br><span class=\"line\">            $rootScope.closeAlert = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">index</span>) </span>&#123;</span><br><span class=\"line\">                $rootScope.alerts.splice(index, <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;]);</span><br><span class=\"line\"></span><br><span class=\"line\">    angular.bootstrap(<span class=\"built_in\">document</span>,[<span class=\"string\">'myApp'</span>]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这段代码包含两部分，第一部分是requirejs的配置部分，定义了几个假名而已；第二部分是requirejs的入口部分，主要是先加载一些模块，然后用在主module里面声明以来，最后用run方法，启动一些你需要启动的事件，最后的最后手动启动Angular。</p>\n<h2 id=\"多米诺骨牌\"><a href=\"#多米诺骨牌\" class=\"headerlink\" title=\"多米诺骨牌\"></a>多米诺骨牌</h2><p>本文并不打算写Requirejs，但是可以简单说一下，Requirejs以及其他所有的模块化工具都是一个多米诺骨牌，触发入口文件，继而引入所有的文件。示例程序中的组件和模块就是这样被引入的。将他们封装起来用文件夹打包，在以后的复用过程中，会非常好用！</p>\n<h2 id=\"比较Webpack\"><a href=\"#比较Webpack\" class=\"headerlink\" title=\"比较Webpack\"></a>比较Webpack</h2><p>这些功能Webpack都具备，但是Requirejs是可以不全部合并的，有些文件需要延迟加载，比如Angular程序绝大多数都是SPA ，如果我们一开始就把所有的文件全部合并，势必会造成首次加载速度非常慢，那么如果我们使用Requirejs就可以在改变路由时候延迟加载一些js文件，使得首次加载的js文件体积变小。使用Webpack的话，恐怕不能直接实现这个功能，但是一定有相关的插件或者模块可以实现类似的。期待Webpack，也感谢历史上那些曾经优秀的工具带给我们的便利，让我们程序员的工作更加轻松！</p>"},{"title":"RxJS + Redux + React = Amazing!（译一）","date":"2016-12-08T02:37:00.000Z","_content":"\n今天，我将Youtube上的《RxJS + Redux + React = Amazing!》翻译（+机译）了下来，以供国内的同学学习，英文听力好的同学可以直接看原版视频：\n\nhttps://www.youtube.com/watch?v=AslncyG8whg\n\n<!--more-->\n\n## 开场白\n\n管理状态很困难，对吧？如果你写过复杂应用，你一定对此深恶痛绝。React社区还有Angular2社区和Ember社区现在都开始使用一个库，叫Redux。为什么？因为它让管理状态变得简单多了。但Redux有个问题，就是它对你写异步代码没什么帮助，因为Redux认为异步是个比管理状态更难的问题。特别是当你试图去解决一些复杂问题，比如：并行或多重WebSockets。这些问题本身就很复杂，你也没辙。所以，这次演说将会介绍使用另一个库，叫RxJS。这个库至少可以让异步问题变得可控可管理，至少可以让你知道发生了什么。\n\n![](/css/images/173.jpg)\n\n## 自我介绍\n\n我是谁？我是Jay Phelps。很明显，照片中的衬衫不是我今天穿的，尽管它们很像，（歪果仁就是啰嗦，不过场下听众听到这都乐了）。其实我穿了另外一件蓝色衬衫，但这是我的推特头像，它可以帮助那些还没有认出我的人认出我来。很明显，我是Netflix的软件工程师。你可以关注我，通过下划线jayphelps（就是_jayphelps，然后他又扯了一些没用的，说有另外一个jayphelps，是一个16岁的家伙，经常转推一些足球图片。他说他经常说这个梗，因为很多本来要关注他的人，都去关注那个16岁足球小哥了）。\n\n![](/css/images/174.jpg)\n\n## 什么是Redux\n\n让我们开始讨论什么是Redux。这个演说不会详细介绍Redux和RxJS，因为它们本身就有非常多相关的演说，但我会给你们一个速成教程。这样，即便你不知道它们具体是什么，至少可以了解个大概。Redux提供了一个可预测的状态管理，它通过action和reducer来完成这个工作。那么什么是action？action被用来描述发生的事，但它不关心如何这件事如何发生。让我们来看个例子吧！\n\n```js\n{\n  type: \"CREATE_TODO\",\n  payload: \"Build my first redux app\"\n}\n```\n\n这是个简单的action，通过这个action，你知道了你要去创建一个todo，这个todo的内容是什么，但它没说如何去创建这个todo，它没说是是否要与服务器交互，也没说是否要存到数据库或localstorage中，它没有进行异步操作，它是个完全可以被序列化的对象。那么什么是reducer？reducer是一些纯函数，这意味着每次你给了一样的输入，那么就会有一样的输出，没有副作用。reducer的具体功能是输入上个的state和action，然后输出新的state，当然新的state可以和上个state完全一样（就是case为default的情况）。举个非真实场景的例子吧，这是个计数器的例子：\n\n```js\nexport default function counter(state = 0, action) {\n  switch (action.type) {\n    case INCREMENT_COUNTER:\n      return state + 1\n    case DECREMENT_COUNTER:\n      return state - 1\n    default:\n      return state\n  }\n}\n```\n我们仅仅就是选择action类型，当action是加一，state就加一，action是减一，state就减一，就是这么字面性质的工作。reducer负责state更新，但它必须是同步的。这意味着，如果reducer收到加一的action，那么就必须立马加一。reducer不能去除速率过快的事件（debounce），也不能和服务器交互，也不能问“我是否可以加一“。reducer只能受到action，然后立马同步执行。\n\n![](/css/images/175.jpg)\n\n## 异步\n\n我们平时都做些什么类型的异步操作呢？（竟然没有衔接，直接从Redux转折到异步）为何说异步是个难缠的问题呢？常见的异步事件操作包括：\n\n - 用户交互（键盘、鼠标）\n - Ajax（这就像面包和黄油一样熟悉，我们每个人都会做Ajax请求）\n - 计时器／动画\n - Web Sockets \n - Web Workers\n\n这不是个详细的列表。上述其中一些可以同步处理，尽管它们本身是异步的。React 与 Redux 已经封装好了，你可以直接同步处理它们！（然后，他举了一个例子，React组件的点击事件，可以触发加一的action，然后reducer处理这个action）从技术角度上来说，这些事件是异步的，但你可以用同步的方式来处理它。为什么？因为React已经帮你处理了异步。但是，问题来了，如果你还想要点击，如果你想去除速率过快的事件，比如，用户点了很多次，而你不想每次都进行事件处理。这时，你通常会计算点击间隔，然后只处理间隔较大的点击事件。有时候，你需要像这样的更多的控制。这些控制包括：\n\n - Ajax取消／组合（组合的意思是，比如你发起了一个Ajax，然后你又发起了另外一个Ajax，后一个的发起用到了前一个的响应数据）\n - Debounce／throttle／buffer等这些与时间相关的操作\n - Drag and Drop \n - Web Sockets, Web Workers, etc\n\n在Redux世界里，人们经常使用中间件来处理这些操作。所有action在你发起后，和到达reducer前，都必须穿过中间件。现在已经有很多中间件使用回调和Promise来做这些事了（指那些复杂的异步操作）。下面就让我们看看这两种最常用的异步处理方法吧！\n\n![](/css/images/176.jpg)\n\n## 回调和Promise\n\n回调对大家来说非常熟悉，因为它是JavaScript最原始的处理异步的方式（然后他举了个回调的例子，回调太简单，不再赘述）。但是回调有很多问题，其中最常见的就是“回调地狱“。大家几乎都见过这种代码（他指着屏幕上的代码示例）。如果你想改变代码，比如做点这样的事：\n\n - 条件判断，然后决定是否进行下一个异步\n - 你不想顺序执行这些异步\n - 更加复杂的回调操作，比如你想并发它们等\n\n那么事情就变得非常复杂了，对吧？我的同事称回调地狱是“V型电吉他“，因为它们的形状非常相似。不过，有了一种解决方案，叫Promise。使用Promise有个绝招，那就是如果你给Promise提供了一个回调，这个回调也返回了一个Promise，那么你可以将其写为平行的风格（这算什么绝招啊，大多数人都知道吧！）。如果你理解了这种模式，那么Promise的代码将会变得非常易读。这很棒，它是个非常好的候选方案。让我们更深入的了解一下Promise吧！Promise拥有这些特性：\n\n- 被保证的未来（意思是，一旦你创建了一个Promise，那么它肯定会执行它要做的事情，你不能停止它，开始黑Promise了。）\n- 不可变\n- 单一的值（意思是，如果你监听一个Promise很多次，你只会得到相同的值，而不是执行多次请求 ）\n- 缓存\n\n在真实项目中，你会发现“被保证的未来“和“单一的值“是个问题，先说“被保证的未来“吧，Promise是不能被取消的。或许你会问，我既然创建了一个Promise，为何要取消它？以下场景，你就要取消你的Promise，也就是异步请求：\n\n - 改变路由／视图（他举了Netflix的一个例子，大概就是点进一个页面，然后后悔了就返回了，这时需要取消请求）\n - 自动补全（这个例子比较常见，自动补全总不能每次键盘按下都发请求吧？）\n - 用户非要你取消\n\n可见，取消异步是一个非常常用，但是容易被忽略的需求。再说Promise的“单一的值“吧！（然后开始黑Promise的“单一的值“，不过他欲扬先抑了一下），其实绝大多数场景下，我们只需要单一的值，比如Ajax，请求-响应，就是单一的值。但人们不只想做这些事，像之前提到的：\n\n- 用户交互（键盘、鼠标）\n- Ajax（这就像面包和黄油一样熟悉，我们每个人都会做Ajax请求）\n- 计时器／动画\n- Web Sockets \n- Web Workers\n\n上述场景也就Ajax是单一的值，其他几个场景都不是。那我们该怎么办呢？那就是使用Observable！\n\n![](/css/images/177.jpg)\n\n## 未完待续\n\n这个视频太长了，今天就到此为止吧！在这篇文章中，我们主要听了Jay Phelps：\n\n - 讲了Redux和异步  \n - 黑了回调和Promise\n\n下篇文章我们将听他：\n\n - 吹Observable的牛\n - 讲述他和他搭档造redux-obserable这个轮子背后的故事！\n\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n","source":"_posts/rxjs-redux-react-amazing-1.md","raw":"---\ntitle: RxJS + Redux + React = Amazing!（译一）\ndate: 2016-12-8 10:37:00\ntags: [技术讲座, RxJS, Redux, React]\n---\n\n今天，我将Youtube上的《RxJS + Redux + React = Amazing!》翻译（+机译）了下来，以供国内的同学学习，英文听力好的同学可以直接看原版视频：\n\nhttps://www.youtube.com/watch?v=AslncyG8whg\n\n<!--more-->\n\n## 开场白\n\n管理状态很困难，对吧？如果你写过复杂应用，你一定对此深恶痛绝。React社区还有Angular2社区和Ember社区现在都开始使用一个库，叫Redux。为什么？因为它让管理状态变得简单多了。但Redux有个问题，就是它对你写异步代码没什么帮助，因为Redux认为异步是个比管理状态更难的问题。特别是当你试图去解决一些复杂问题，比如：并行或多重WebSockets。这些问题本身就很复杂，你也没辙。所以，这次演说将会介绍使用另一个库，叫RxJS。这个库至少可以让异步问题变得可控可管理，至少可以让你知道发生了什么。\n\n![](/css/images/173.jpg)\n\n## 自我介绍\n\n我是谁？我是Jay Phelps。很明显，照片中的衬衫不是我今天穿的，尽管它们很像，（歪果仁就是啰嗦，不过场下听众听到这都乐了）。其实我穿了另外一件蓝色衬衫，但这是我的推特头像，它可以帮助那些还没有认出我的人认出我来。很明显，我是Netflix的软件工程师。你可以关注我，通过下划线jayphelps（就是_jayphelps，然后他又扯了一些没用的，说有另外一个jayphelps，是一个16岁的家伙，经常转推一些足球图片。他说他经常说这个梗，因为很多本来要关注他的人，都去关注那个16岁足球小哥了）。\n\n![](/css/images/174.jpg)\n\n## 什么是Redux\n\n让我们开始讨论什么是Redux。这个演说不会详细介绍Redux和RxJS，因为它们本身就有非常多相关的演说，但我会给你们一个速成教程。这样，即便你不知道它们具体是什么，至少可以了解个大概。Redux提供了一个可预测的状态管理，它通过action和reducer来完成这个工作。那么什么是action？action被用来描述发生的事，但它不关心如何这件事如何发生。让我们来看个例子吧！\n\n```js\n{\n  type: \"CREATE_TODO\",\n  payload: \"Build my first redux app\"\n}\n```\n\n这是个简单的action，通过这个action，你知道了你要去创建一个todo，这个todo的内容是什么，但它没说如何去创建这个todo，它没说是是否要与服务器交互，也没说是否要存到数据库或localstorage中，它没有进行异步操作，它是个完全可以被序列化的对象。那么什么是reducer？reducer是一些纯函数，这意味着每次你给了一样的输入，那么就会有一样的输出，没有副作用。reducer的具体功能是输入上个的state和action，然后输出新的state，当然新的state可以和上个state完全一样（就是case为default的情况）。举个非真实场景的例子吧，这是个计数器的例子：\n\n```js\nexport default function counter(state = 0, action) {\n  switch (action.type) {\n    case INCREMENT_COUNTER:\n      return state + 1\n    case DECREMENT_COUNTER:\n      return state - 1\n    default:\n      return state\n  }\n}\n```\n我们仅仅就是选择action类型，当action是加一，state就加一，action是减一，state就减一，就是这么字面性质的工作。reducer负责state更新，但它必须是同步的。这意味着，如果reducer收到加一的action，那么就必须立马加一。reducer不能去除速率过快的事件（debounce），也不能和服务器交互，也不能问“我是否可以加一“。reducer只能受到action，然后立马同步执行。\n\n![](/css/images/175.jpg)\n\n## 异步\n\n我们平时都做些什么类型的异步操作呢？（竟然没有衔接，直接从Redux转折到异步）为何说异步是个难缠的问题呢？常见的异步事件操作包括：\n\n - 用户交互（键盘、鼠标）\n - Ajax（这就像面包和黄油一样熟悉，我们每个人都会做Ajax请求）\n - 计时器／动画\n - Web Sockets \n - Web Workers\n\n这不是个详细的列表。上述其中一些可以同步处理，尽管它们本身是异步的。React 与 Redux 已经封装好了，你可以直接同步处理它们！（然后，他举了一个例子，React组件的点击事件，可以触发加一的action，然后reducer处理这个action）从技术角度上来说，这些事件是异步的，但你可以用同步的方式来处理它。为什么？因为React已经帮你处理了异步。但是，问题来了，如果你还想要点击，如果你想去除速率过快的事件，比如，用户点了很多次，而你不想每次都进行事件处理。这时，你通常会计算点击间隔，然后只处理间隔较大的点击事件。有时候，你需要像这样的更多的控制。这些控制包括：\n\n - Ajax取消／组合（组合的意思是，比如你发起了一个Ajax，然后你又发起了另外一个Ajax，后一个的发起用到了前一个的响应数据）\n - Debounce／throttle／buffer等这些与时间相关的操作\n - Drag and Drop \n - Web Sockets, Web Workers, etc\n\n在Redux世界里，人们经常使用中间件来处理这些操作。所有action在你发起后，和到达reducer前，都必须穿过中间件。现在已经有很多中间件使用回调和Promise来做这些事了（指那些复杂的异步操作）。下面就让我们看看这两种最常用的异步处理方法吧！\n\n![](/css/images/176.jpg)\n\n## 回调和Promise\n\n回调对大家来说非常熟悉，因为它是JavaScript最原始的处理异步的方式（然后他举了个回调的例子，回调太简单，不再赘述）。但是回调有很多问题，其中最常见的就是“回调地狱“。大家几乎都见过这种代码（他指着屏幕上的代码示例）。如果你想改变代码，比如做点这样的事：\n\n - 条件判断，然后决定是否进行下一个异步\n - 你不想顺序执行这些异步\n - 更加复杂的回调操作，比如你想并发它们等\n\n那么事情就变得非常复杂了，对吧？我的同事称回调地狱是“V型电吉他“，因为它们的形状非常相似。不过，有了一种解决方案，叫Promise。使用Promise有个绝招，那就是如果你给Promise提供了一个回调，这个回调也返回了一个Promise，那么你可以将其写为平行的风格（这算什么绝招啊，大多数人都知道吧！）。如果你理解了这种模式，那么Promise的代码将会变得非常易读。这很棒，它是个非常好的候选方案。让我们更深入的了解一下Promise吧！Promise拥有这些特性：\n\n- 被保证的未来（意思是，一旦你创建了一个Promise，那么它肯定会执行它要做的事情，你不能停止它，开始黑Promise了。）\n- 不可变\n- 单一的值（意思是，如果你监听一个Promise很多次，你只会得到相同的值，而不是执行多次请求 ）\n- 缓存\n\n在真实项目中，你会发现“被保证的未来“和“单一的值“是个问题，先说“被保证的未来“吧，Promise是不能被取消的。或许你会问，我既然创建了一个Promise，为何要取消它？以下场景，你就要取消你的Promise，也就是异步请求：\n\n - 改变路由／视图（他举了Netflix的一个例子，大概就是点进一个页面，然后后悔了就返回了，这时需要取消请求）\n - 自动补全（这个例子比较常见，自动补全总不能每次键盘按下都发请求吧？）\n - 用户非要你取消\n\n可见，取消异步是一个非常常用，但是容易被忽略的需求。再说Promise的“单一的值“吧！（然后开始黑Promise的“单一的值“，不过他欲扬先抑了一下），其实绝大多数场景下，我们只需要单一的值，比如Ajax，请求-响应，就是单一的值。但人们不只想做这些事，像之前提到的：\n\n- 用户交互（键盘、鼠标）\n- Ajax（这就像面包和黄油一样熟悉，我们每个人都会做Ajax请求）\n- 计时器／动画\n- Web Sockets \n- Web Workers\n\n上述场景也就Ajax是单一的值，其他几个场景都不是。那我们该怎么办呢？那就是使用Observable！\n\n![](/css/images/177.jpg)\n\n## 未完待续\n\n这个视频太长了，今天就到此为止吧！在这篇文章中，我们主要听了Jay Phelps：\n\n - 讲了Redux和异步  \n - 黑了回调和Promise\n\n下篇文章我们将听他：\n\n - 吹Observable的牛\n - 讲述他和他搭档造redux-obserable这个轮子背后的故事！\n\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>\n","slug":"rxjs-redux-react-amazing-1","published":1,"updated":"2019-05-01T08:10:30.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmq0036tgytagepmnuf","content":"<p>今天，我将Youtube上的《RxJS + Redux + React = Amazing!》翻译（+机译）了下来，以供国内的同学学习，英文听力好的同学可以直接看原版视频：</p>\n<p><a href=\"https://www.youtube.com/watch?v=AslncyG8whg\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=AslncyG8whg</a></p>\n<a id=\"more\"></a>\n<h2 id=\"开场白\"><a href=\"#开场白\" class=\"headerlink\" title=\"开场白\"></a>开场白</h2><p>管理状态很困难，对吧？如果你写过复杂应用，你一定对此深恶痛绝。React社区还有Angular2社区和Ember社区现在都开始使用一个库，叫Redux。为什么？因为它让管理状态变得简单多了。但Redux有个问题，就是它对你写异步代码没什么帮助，因为Redux认为异步是个比管理状态更难的问题。特别是当你试图去解决一些复杂问题，比如：并行或多重WebSockets。这些问题本身就很复杂，你也没辙。所以，这次演说将会介绍使用另一个库，叫RxJS。这个库至少可以让异步问题变得可控可管理，至少可以让你知道发生了什么。</p>\n<p><img src=\"/css/images/173.jpg\" alt=\"\"></p>\n<h2 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h2><p>我是谁？我是Jay Phelps。很明显，照片中的衬衫不是我今天穿的，尽管它们很像，（歪果仁就是啰嗦，不过场下听众听到这都乐了）。其实我穿了另外一件蓝色衬衫，但这是我的推特头像，它可以帮助那些还没有认出我的人认出我来。很明显，我是Netflix的软件工程师。你可以关注我，通过下划线jayphelps（就是_jayphelps，然后他又扯了一些没用的，说有另外一个jayphelps，是一个16岁的家伙，经常转推一些足球图片。他说他经常说这个梗，因为很多本来要关注他的人，都去关注那个16岁足球小哥了）。</p>\n<p><img src=\"/css/images/174.jpg\" alt=\"\"></p>\n<h2 id=\"什么是Redux\"><a href=\"#什么是Redux\" class=\"headerlink\" title=\"什么是Redux\"></a>什么是Redux</h2><p>让我们开始讨论什么是Redux。这个演说不会详细介绍Redux和RxJS，因为它们本身就有非常多相关的演说，但我会给你们一个速成教程。这样，即便你不知道它们具体是什么，至少可以了解个大概。Redux提供了一个可预测的状态管理，它通过action和reducer来完成这个工作。那么什么是action？action被用来描述发生的事，但它不关心如何这件事如何发生。让我们来看个例子吧！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: <span class=\"string\">\"CREATE_TODO\"</span>,</span><br><span class=\"line\">  payload: <span class=\"string\">\"Build my first redux app\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是个简单的action，通过这个action，你知道了你要去创建一个todo，这个todo的内容是什么，但它没说如何去创建这个todo，它没说是是否要与服务器交互，也没说是否要存到数据库或localstorage中，它没有进行异步操作，它是个完全可以被序列化的对象。那么什么是reducer？reducer是一些纯函数，这意味着每次你给了一样的输入，那么就会有一样的输出，没有副作用。reducer的具体功能是输入上个的state和action，然后输出新的state，当然新的state可以和上个state完全一样（就是case为default的情况）。举个非真实场景的例子吧，这是个计数器的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\">state = <span class=\"number\">0</span>, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> INCREMENT_COUNTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> DECREMENT_COUNTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们仅仅就是选择action类型，当action是加一，state就加一，action是减一，state就减一，就是这么字面性质的工作。reducer负责state更新，但它必须是同步的。这意味着，如果reducer收到加一的action，那么就必须立马加一。reducer不能去除速率过快的事件（debounce），也不能和服务器交互，也不能问“我是否可以加一“。reducer只能受到action，然后立马同步执行。</p>\n<p><img src=\"/css/images/175.jpg\" alt=\"\"></p>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><p>我们平时都做些什么类型的异步操作呢？（竟然没有衔接，直接从Redux转折到异步）为何说异步是个难缠的问题呢？常见的异步事件操作包括：</p>\n<ul>\n<li>用户交互（键盘、鼠标）</li>\n<li>Ajax（这就像面包和黄油一样熟悉，我们每个人都会做Ajax请求）</li>\n<li>计时器／动画</li>\n<li>Web Sockets </li>\n<li>Web Workers</li>\n</ul>\n<p>这不是个详细的列表。上述其中一些可以同步处理，尽管它们本身是异步的。React 与 Redux 已经封装好了，你可以直接同步处理它们！（然后，他举了一个例子，React组件的点击事件，可以触发加一的action，然后reducer处理这个action）从技术角度上来说，这些事件是异步的，但你可以用同步的方式来处理它。为什么？因为React已经帮你处理了异步。但是，问题来了，如果你还想要点击，如果你想去除速率过快的事件，比如，用户点了很多次，而你不想每次都进行事件处理。这时，你通常会计算点击间隔，然后只处理间隔较大的点击事件。有时候，你需要像这样的更多的控制。这些控制包括：</p>\n<ul>\n<li>Ajax取消／组合（组合的意思是，比如你发起了一个Ajax，然后你又发起了另外一个Ajax，后一个的发起用到了前一个的响应数据）</li>\n<li>Debounce／throttle／buffer等这些与时间相关的操作</li>\n<li>Drag and Drop </li>\n<li>Web Sockets, Web Workers, etc</li>\n</ul>\n<p>在Redux世界里，人们经常使用中间件来处理这些操作。所有action在你发起后，和到达reducer前，都必须穿过中间件。现在已经有很多中间件使用回调和Promise来做这些事了（指那些复杂的异步操作）。下面就让我们看看这两种最常用的异步处理方法吧！</p>\n<p><img src=\"/css/images/176.jpg\" alt=\"\"></p>\n<h2 id=\"回调和Promise\"><a href=\"#回调和Promise\" class=\"headerlink\" title=\"回调和Promise\"></a>回调和Promise</h2><p>回调对大家来说非常熟悉，因为它是JavaScript最原始的处理异步的方式（然后他举了个回调的例子，回调太简单，不再赘述）。但是回调有很多问题，其中最常见的就是“回调地狱“。大家几乎都见过这种代码（他指着屏幕上的代码示例）。如果你想改变代码，比如做点这样的事：</p>\n<ul>\n<li>条件判断，然后决定是否进行下一个异步</li>\n<li>你不想顺序执行这些异步</li>\n<li>更加复杂的回调操作，比如你想并发它们等</li>\n</ul>\n<p>那么事情就变得非常复杂了，对吧？我的同事称回调地狱是“V型电吉他“，因为它们的形状非常相似。不过，有了一种解决方案，叫Promise。使用Promise有个绝招，那就是如果你给Promise提供了一个回调，这个回调也返回了一个Promise，那么你可以将其写为平行的风格（这算什么绝招啊，大多数人都知道吧！）。如果你理解了这种模式，那么Promise的代码将会变得非常易读。这很棒，它是个非常好的候选方案。让我们更深入的了解一下Promise吧！Promise拥有这些特性：</p>\n<ul>\n<li>被保证的未来（意思是，一旦你创建了一个Promise，那么它肯定会执行它要做的事情，你不能停止它，开始黑Promise了。）</li>\n<li>不可变</li>\n<li>单一的值（意思是，如果你监听一个Promise很多次，你只会得到相同的值，而不是执行多次请求 ）</li>\n<li>缓存</li>\n</ul>\n<p>在真实项目中，你会发现“被保证的未来“和“单一的值“是个问题，先说“被保证的未来“吧，Promise是不能被取消的。或许你会问，我既然创建了一个Promise，为何要取消它？以下场景，你就要取消你的Promise，也就是异步请求：</p>\n<ul>\n<li>改变路由／视图（他举了Netflix的一个例子，大概就是点进一个页面，然后后悔了就返回了，这时需要取消请求）</li>\n<li>自动补全（这个例子比较常见，自动补全总不能每次键盘按下都发请求吧？）</li>\n<li>用户非要你取消</li>\n</ul>\n<p>可见，取消异步是一个非常常用，但是容易被忽略的需求。再说Promise的“单一的值“吧！（然后开始黑Promise的“单一的值“，不过他欲扬先抑了一下），其实绝大多数场景下，我们只需要单一的值，比如Ajax，请求-响应，就是单一的值。但人们不只想做这些事，像之前提到的：</p>\n<ul>\n<li>用户交互（键盘、鼠标）</li>\n<li>Ajax（这就像面包和黄油一样熟悉，我们每个人都会做Ajax请求）</li>\n<li>计时器／动画</li>\n<li>Web Sockets </li>\n<li>Web Workers</li>\n</ul>\n<p>上述场景也就Ajax是单一的值，其他几个场景都不是。那我们该怎么办呢？那就是使用Observable！</p>\n<p><img src=\"/css/images/177.jpg\" alt=\"\"></p>\n<h2 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h2><p>这个视频太长了，今天就到此为止吧！在这篇文章中，我们主要听了Jay Phelps：</p>\n<ul>\n<li>讲了Redux和异步  </li>\n<li>黑了回调和Promise</li>\n</ul>\n<p>下篇文章我们将听他：</p>\n<ul>\n<li>吹Observable的牛</li>\n<li>讲述他和他搭档造redux-obserable这个轮子背后的故事！</li>\n</ul>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我将Youtube上的《RxJS + Redux + React = Amazing!》翻译（+机译）了下来，以供国内的同学学习，英文听力好的同学可以直接看原版视频：</p>\n<p><a href=\"https://www.youtube.com/watch?v=AslncyG8whg\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=AslncyG8whg</a></p>","more":"<h2 id=\"开场白\"><a href=\"#开场白\" class=\"headerlink\" title=\"开场白\"></a>开场白</h2><p>管理状态很困难，对吧？如果你写过复杂应用，你一定对此深恶痛绝。React社区还有Angular2社区和Ember社区现在都开始使用一个库，叫Redux。为什么？因为它让管理状态变得简单多了。但Redux有个问题，就是它对你写异步代码没什么帮助，因为Redux认为异步是个比管理状态更难的问题。特别是当你试图去解决一些复杂问题，比如：并行或多重WebSockets。这些问题本身就很复杂，你也没辙。所以，这次演说将会介绍使用另一个库，叫RxJS。这个库至少可以让异步问题变得可控可管理，至少可以让你知道发生了什么。</p>\n<p><img src=\"/css/images/173.jpg\" alt=\"\"></p>\n<h2 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h2><p>我是谁？我是Jay Phelps。很明显，照片中的衬衫不是我今天穿的，尽管它们很像，（歪果仁就是啰嗦，不过场下听众听到这都乐了）。其实我穿了另外一件蓝色衬衫，但这是我的推特头像，它可以帮助那些还没有认出我的人认出我来。很明显，我是Netflix的软件工程师。你可以关注我，通过下划线jayphelps（就是_jayphelps，然后他又扯了一些没用的，说有另外一个jayphelps，是一个16岁的家伙，经常转推一些足球图片。他说他经常说这个梗，因为很多本来要关注他的人，都去关注那个16岁足球小哥了）。</p>\n<p><img src=\"/css/images/174.jpg\" alt=\"\"></p>\n<h2 id=\"什么是Redux\"><a href=\"#什么是Redux\" class=\"headerlink\" title=\"什么是Redux\"></a>什么是Redux</h2><p>让我们开始讨论什么是Redux。这个演说不会详细介绍Redux和RxJS，因为它们本身就有非常多相关的演说，但我会给你们一个速成教程。这样，即便你不知道它们具体是什么，至少可以了解个大概。Redux提供了一个可预测的状态管理，它通过action和reducer来完成这个工作。那么什么是action？action被用来描述发生的事，但它不关心如何这件事如何发生。让我们来看个例子吧！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: <span class=\"string\">\"CREATE_TODO\"</span>,</span><br><span class=\"line\">  payload: <span class=\"string\">\"Build my first redux app\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是个简单的action，通过这个action，你知道了你要去创建一个todo，这个todo的内容是什么，但它没说如何去创建这个todo，它没说是是否要与服务器交互，也没说是否要存到数据库或localstorage中，它没有进行异步操作，它是个完全可以被序列化的对象。那么什么是reducer？reducer是一些纯函数，这意味着每次你给了一样的输入，那么就会有一样的输出，没有副作用。reducer的具体功能是输入上个的state和action，然后输出新的state，当然新的state可以和上个state完全一样（就是case为default的情况）。举个非真实场景的例子吧，这是个计数器的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\">state = <span class=\"number\">0</span>, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> INCREMENT_COUNTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> DECREMENT_COUNTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们仅仅就是选择action类型，当action是加一，state就加一，action是减一，state就减一，就是这么字面性质的工作。reducer负责state更新，但它必须是同步的。这意味着，如果reducer收到加一的action，那么就必须立马加一。reducer不能去除速率过快的事件（debounce），也不能和服务器交互，也不能问“我是否可以加一“。reducer只能受到action，然后立马同步执行。</p>\n<p><img src=\"/css/images/175.jpg\" alt=\"\"></p>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><p>我们平时都做些什么类型的异步操作呢？（竟然没有衔接，直接从Redux转折到异步）为何说异步是个难缠的问题呢？常见的异步事件操作包括：</p>\n<ul>\n<li>用户交互（键盘、鼠标）</li>\n<li>Ajax（这就像面包和黄油一样熟悉，我们每个人都会做Ajax请求）</li>\n<li>计时器／动画</li>\n<li>Web Sockets </li>\n<li>Web Workers</li>\n</ul>\n<p>这不是个详细的列表。上述其中一些可以同步处理，尽管它们本身是异步的。React 与 Redux 已经封装好了，你可以直接同步处理它们！（然后，他举了一个例子，React组件的点击事件，可以触发加一的action，然后reducer处理这个action）从技术角度上来说，这些事件是异步的，但你可以用同步的方式来处理它。为什么？因为React已经帮你处理了异步。但是，问题来了，如果你还想要点击，如果你想去除速率过快的事件，比如，用户点了很多次，而你不想每次都进行事件处理。这时，你通常会计算点击间隔，然后只处理间隔较大的点击事件。有时候，你需要像这样的更多的控制。这些控制包括：</p>\n<ul>\n<li>Ajax取消／组合（组合的意思是，比如你发起了一个Ajax，然后你又发起了另外一个Ajax，后一个的发起用到了前一个的响应数据）</li>\n<li>Debounce／throttle／buffer等这些与时间相关的操作</li>\n<li>Drag and Drop </li>\n<li>Web Sockets, Web Workers, etc</li>\n</ul>\n<p>在Redux世界里，人们经常使用中间件来处理这些操作。所有action在你发起后，和到达reducer前，都必须穿过中间件。现在已经有很多中间件使用回调和Promise来做这些事了（指那些复杂的异步操作）。下面就让我们看看这两种最常用的异步处理方法吧！</p>\n<p><img src=\"/css/images/176.jpg\" alt=\"\"></p>\n<h2 id=\"回调和Promise\"><a href=\"#回调和Promise\" class=\"headerlink\" title=\"回调和Promise\"></a>回调和Promise</h2><p>回调对大家来说非常熟悉，因为它是JavaScript最原始的处理异步的方式（然后他举了个回调的例子，回调太简单，不再赘述）。但是回调有很多问题，其中最常见的就是“回调地狱“。大家几乎都见过这种代码（他指着屏幕上的代码示例）。如果你想改变代码，比如做点这样的事：</p>\n<ul>\n<li>条件判断，然后决定是否进行下一个异步</li>\n<li>你不想顺序执行这些异步</li>\n<li>更加复杂的回调操作，比如你想并发它们等</li>\n</ul>\n<p>那么事情就变得非常复杂了，对吧？我的同事称回调地狱是“V型电吉他“，因为它们的形状非常相似。不过，有了一种解决方案，叫Promise。使用Promise有个绝招，那就是如果你给Promise提供了一个回调，这个回调也返回了一个Promise，那么你可以将其写为平行的风格（这算什么绝招啊，大多数人都知道吧！）。如果你理解了这种模式，那么Promise的代码将会变得非常易读。这很棒，它是个非常好的候选方案。让我们更深入的了解一下Promise吧！Promise拥有这些特性：</p>\n<ul>\n<li>被保证的未来（意思是，一旦你创建了一个Promise，那么它肯定会执行它要做的事情，你不能停止它，开始黑Promise了。）</li>\n<li>不可变</li>\n<li>单一的值（意思是，如果你监听一个Promise很多次，你只会得到相同的值，而不是执行多次请求 ）</li>\n<li>缓存</li>\n</ul>\n<p>在真实项目中，你会发现“被保证的未来“和“单一的值“是个问题，先说“被保证的未来“吧，Promise是不能被取消的。或许你会问，我既然创建了一个Promise，为何要取消它？以下场景，你就要取消你的Promise，也就是异步请求：</p>\n<ul>\n<li>改变路由／视图（他举了Netflix的一个例子，大概就是点进一个页面，然后后悔了就返回了，这时需要取消请求）</li>\n<li>自动补全（这个例子比较常见，自动补全总不能每次键盘按下都发请求吧？）</li>\n<li>用户非要你取消</li>\n</ul>\n<p>可见，取消异步是一个非常常用，但是容易被忽略的需求。再说Promise的“单一的值“吧！（然后开始黑Promise的“单一的值“，不过他欲扬先抑了一下），其实绝大多数场景下，我们只需要单一的值，比如Ajax，请求-响应，就是单一的值。但人们不只想做这些事，像之前提到的：</p>\n<ul>\n<li>用户交互（键盘、鼠标）</li>\n<li>Ajax（这就像面包和黄油一样熟悉，我们每个人都会做Ajax请求）</li>\n<li>计时器／动画</li>\n<li>Web Sockets </li>\n<li>Web Workers</li>\n</ul>\n<p>上述场景也就Ajax是单一的值，其他几个场景都不是。那我们该怎么办呢？那就是使用Observable！</p>\n<p><img src=\"/css/images/177.jpg\" alt=\"\"></p>\n<h2 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h2><p>这个视频太长了，今天就到此为止吧！在这篇文章中，我们主要听了Jay Phelps：</p>\n<ul>\n<li>讲了Redux和异步  </li>\n<li>黑了回调和Promise</li>\n</ul>\n<p>下篇文章我们将听他：</p>\n<ul>\n<li>吹Observable的牛</li>\n<li>讲述他和他搭档造redux-obserable这个轮子背后的故事！</li>\n</ul>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>"},{"title":"RxJS + Redux + React = Amazing!（译二）","date":"2016-12-09T03:32:00.000Z","_content":"\n今天，我将Youtube上的《RxJS + Redux + React = Amazing!》的后半部分翻译（+机译）了下来，以供国内的同学学习，英文听力好的同学可以直接看原版视频：\n\nhttps://www.youtube.com/watch?v=AslncyG8whg\n\n<!--more-->\n\n## Observable\n\n什么是Observable？让我们快速来了解一下它吧！\n\n- **Observable是一个由零个、一个或多个值组成的流。**注意，是零个、一个或多个值。零个意味着可以没有值，这完全没问题。一个值的情况就像是Promise一样。如果有多个值，那么这些值将位于不同的时间点上。\n- **Observable跨越了时间。**时间是一种新的维度，这个维度是Observable与Promise的重要不同点。所有“流式”的事物都会跨越时间。事实上，**流就是一个以时间为维度的集合**。\n- **Observable可以取消。**\n\n很酷的是，Observable正在变为ECMAScript的标准，就像Promise那样，但现在你还不能直接在浏览器里使用它（原话很啰嗦，直接提取有用信息）。所以你需要使用RxJS。\n\n![](/css/images/178.jpg)\n\nRxJS是Observable的一种引用实现，它提供了一些定制的功能，比如操作符（Operators）、创建不同类型Observable的工厂方法。我同事说，RxJS就像是\n\n> lodash for async\n\n因为它和lodash一样也是个工具库。lodash的用法基本上就是，你给它一个输入，它给你一个输出。RxJS的用法则是，你给它一个输入，它给你一个输出，但是**跨越了时间**。所以，你可以拥有多个值。让我们通过一个速成教程来更深入的了解它吧！\n\n1. 创建Observable有很多种方式（直接贴截图）：\n\n\t![](/css/images/179.jpg)\n\t\n\t你可以：\n\t\n\t - 创建一个单值的Observable\n\t - 从数组（或其他类型）创建一个Observable\n\t - 设置时间间隔\n\t - 发起Ajax或WebSockets\n\t - 还有很多方法可以创建定制的Observable\n\t \n2. Observable可以被订阅（Subscribing）：\n\n\t![](/css/images/180.jpg)\n\t\n\tObservable的订阅和Promise的then挺像的。你可以给它提供三个函数：\n\t\n\t- **第一个函数是next函数**，它有点像Promise的成功情况下的回调函数，但是，因为Observable是**跨时间的**，它可能有零或多个值，所以next函数可能会被调用N次，或许会被调用上千次，或许一次都没被调用，这取决于Observable有多少值。\n\t- **第二个是error函数**\n\t- **第三个是complete函数**，有时候或许我们想知道是否完成了，此时，该函数就派上用场了。\n\n3. 我们还可以对Observable进行转换（Transform）。就像之前讨论的，我们可以像使用lodash那样，对Observable进行map、filter、reduce。如果Observable只有单值，我们不会做这些操作。我们只会对**流或流式的处理**进行这些操作，比如，一些数据来了，我们把它们映射（map）成另外一些数据。这个方式非常高效（用了声明式的写法，不用像指令式那样写过程，当然高效了）！\n\n4. Observable还可以被合并（Combine）：concat、merge、zip。\n\n5. Observable还可以表达时间（Represent Time，意思是可以进行与时间相关的操作）。因为Observable是以时间作为维度的，所以你**绝对绝对**可以做debounce、throttle、buffer这些操作（他说到这，有点自嗨了，注：debounce、throttle都是去除速率过快的事件、buffer则是周期性的合并一些项，然后一起触发它们）。\n\n6. Observable还有个优点，就是懒（lazy）：你定义了一个Observable应该做什么，它不会做任何事情，直到你订阅它。因此，你可以轻易实现重试或重复（retry、repeat，有相关的操作符，可以自行查询），比如在错误时重试或重复发起一个Ajax请求五次。\n\n（讲完上述几条后，他总结了一句话：**Observables can represent just about anything**，但接下来又非常辩证地说了也不要什么都用RxJS，因为RxJS太新了什么的，不再赘述。）\n\n## RxJS和Redux的结合——redux-observable\n\n我们非常喜欢RxJS，也非常喜欢Redux，所以我们想，把这两个技术结合一下吧！我们实验了几种模式，经过了一些迭代，最后有了一个稳定的解决方案。如果你之前开源过什么东西，那么你一定知道，最重要的事情是——先做个好logo。不是写测试，不是保证它正常工作，也不是写文档，而是要先做个logo，这是最重要的事情，关乎你能拿多少star（场下有人笑了，然后他讲了他们logo的来历，大概就是，本来想结合RxJS的logo和Redux的logo，但是Redux当时还没有logo，他们就用Redux的谐音“three ducks”，三只鸭子做为logo，在经历了压扁、合并以及添加旋转动画后，终于得到了他们满意的logo，也就是现在redux-observable的logo）。\n\n![](/css/images/181.jpg)\n\nredux-observable是一个Redux中间件，用来管理副作用，包括异步。我们使用一个叫Epic的概念去完成这个工作。那么什么是Epic？\n\n> A function that takes a stream of **all actions** dispatched and returns a stream of **new actions** to dispatch \n> Epic是一个函数，该函数将**所有被发起的流式的action**作为参数，然后返回**新的流式的action**去发起。\n\n简单来说，Epic就是：\n\n> \"action in, action out\"\n\n（然后他用了一些伪代码去演示Epic的工作原理，注意，阅读下面的内容需要一点Redux和RxJS基础，如果感到吃力，应该先去看下Redux和RxJS。）\n\n1. 这是一个简单的函数，输入PING，立马得到PONG：\n\n\t```js\n\tfunction pingPong(action, store){\n\t  if(action.type === 'PING'){\n\t    return { type: 'PONG'};\n\t  }\n\t}\n\t```\n2. 如果使用RxJS的操作符来实现它，会更加声明式： \n\n\t```js\n\tfunction pingPongEpic(action$, store){\n\t  return action$.ofType('PING')\n\t     .map(action => ({ type: 'PONG'}));\n\t}\n\t```\n这就是世界上最简单的Epic，它的第一个参数是个流式的action。首先，这个Epic函数对流式的action进行了类型过滤，然后将其映射为新的流式的action。这就像个管道一样，所有action都会进来，然后进行匹配并输出。\n\n3. 如果想等待一秒后，就像打乒乓球那样，“乒-乓-乒-乓”，只需要加一行代码：\n\n\t```js\n\tfunction pingPongEpic(action$, store){\n\t  return action$.ofType('PING')\n\t     .delay(1000) // <- that's it\n\t     .map(action => ({ type: 'PONG'}));\n\t}\n\t```\n\n\t此时，如果你的reducer的逻辑是，PING是true，PONG是false，那么你的应用会是这样（他指着屏幕的动图，大概功能就是点击按钮，isPING的值等待了一秒后变为false）。\n\n4. 让我们来看另外一个debounce例子吧（代码和程序截图如下，这是个计数器的例子，大概就是添加了debounce后，连续点击加一或减一，速率过快的操作将会被取消）！\n\n\t![](/css/images/182.jpg)\n\n上述示例都太简单了，让我们看几个复杂的例子，这些例子不会讲解代码的细节，只是用来证明**RxJS和redux-observable在复杂场景中有多么地牛！**\n\n- 自动补全（他先是演示了使用普通JavaScript的写法，代码特别长，过程特别繁琐，然后演示了使用Epic的写法，只用了debounce、switchMap和map三个操作符，代码特别短，而且非常声明式和易读）\n- 双向多重的WebSockets（他还是先演示使用普通JavaScript代码的写法，代码特别多，而且容易引入bug。然后他演示了Epic的写法，功能一样不少，但是代码特别少而且非常声明式）\n\n![](/css/images/183.jpg)\n\n让我们来快速总结下redux-observable吧：\n\n- 让跨时间的复杂异步任务的组合和控制变得简单，当然如果只是做请求-响应这种简单的Ajax，那么学习RxJS是多余的。\n- 你不需要管理Rx的订阅，因为redux-observable帮你做了这些。\n- 你依然可以享受Redux的功能，比如时间旅行等。\n\n但是在你尝试使用redux-observable之前，**你应该提前学习Redux和RxJS**。当然，这应该是业余时间做的事，或是在你特别想挑战自己的情况下才要做的事。我不是打击大家的积极性，只是不想让在座的各位产生一个错误观念，就是即便我的应用很小很简单，我仍然应该使用redux-observable。 但是，如果你觉得我今天描述的问题，也正好是你的问题，那么你一定愿意学习RxJS、Redux和redux-observable。 \n\n![](/css/images/184.jpg)\n\n另外，RxJS拥有非常陡峭的学习曲线。 最近有个新流行词叫响应式编程（Reactive Programing ），RxJS做的就是这个。响应式编程是个令人发狂的编程范式，不过你可以这么理解它：就像是你先安装好管道，但还没有水流过管道，等到将来某个人发起了一个action，然后潺潺流水就来了，你的管道就开始运作了。（他之所以用流水这个比喻，主要是为了突出响应式编程，自动响应和变化传播的特性，如果你还不能理解，可以参考[维基百科](https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B)）。响应式编程是一种完全不同的编程风格。\n\n（然后他介绍了他的联合作者，展示了redux-observable的官网以及目前有哪些公司在用，最后致谢。）\n\n![](/css/images/185.jpg)\n\n## 总结\n\nJay Phelps的这个talk还是很不错的，而且比较客观。从这个talk中，我们可以学习到：\n\n- Redux是什么，以及它是如何工作的。\n- Observable是什么，以及它的基本用法。\n- redux-observable的工作原理以及适用场景。\n- 在复杂的异步场景下，回调和Promise捉襟见肘，而Observable则应对自如。\n- 在简单的异步场景下，没必要使用Observable。\n\n---\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>","source":"_posts/rxjs-redux-react-amazing-2.md","raw":"---\ntitle: RxJS + Redux + React = Amazing!（译二）\ndate: 2016-12-9 11:32:00\ntags: [技术讲座, RxJS, Redux, React]\n---\n\n今天，我将Youtube上的《RxJS + Redux + React = Amazing!》的后半部分翻译（+机译）了下来，以供国内的同学学习，英文听力好的同学可以直接看原版视频：\n\nhttps://www.youtube.com/watch?v=AslncyG8whg\n\n<!--more-->\n\n## Observable\n\n什么是Observable？让我们快速来了解一下它吧！\n\n- **Observable是一个由零个、一个或多个值组成的流。**注意，是零个、一个或多个值。零个意味着可以没有值，这完全没问题。一个值的情况就像是Promise一样。如果有多个值，那么这些值将位于不同的时间点上。\n- **Observable跨越了时间。**时间是一种新的维度，这个维度是Observable与Promise的重要不同点。所有“流式”的事物都会跨越时间。事实上，**流就是一个以时间为维度的集合**。\n- **Observable可以取消。**\n\n很酷的是，Observable正在变为ECMAScript的标准，就像Promise那样，但现在你还不能直接在浏览器里使用它（原话很啰嗦，直接提取有用信息）。所以你需要使用RxJS。\n\n![](/css/images/178.jpg)\n\nRxJS是Observable的一种引用实现，它提供了一些定制的功能，比如操作符（Operators）、创建不同类型Observable的工厂方法。我同事说，RxJS就像是\n\n> lodash for async\n\n因为它和lodash一样也是个工具库。lodash的用法基本上就是，你给它一个输入，它给你一个输出。RxJS的用法则是，你给它一个输入，它给你一个输出，但是**跨越了时间**。所以，你可以拥有多个值。让我们通过一个速成教程来更深入的了解它吧！\n\n1. 创建Observable有很多种方式（直接贴截图）：\n\n\t![](/css/images/179.jpg)\n\t\n\t你可以：\n\t\n\t - 创建一个单值的Observable\n\t - 从数组（或其他类型）创建一个Observable\n\t - 设置时间间隔\n\t - 发起Ajax或WebSockets\n\t - 还有很多方法可以创建定制的Observable\n\t \n2. Observable可以被订阅（Subscribing）：\n\n\t![](/css/images/180.jpg)\n\t\n\tObservable的订阅和Promise的then挺像的。你可以给它提供三个函数：\n\t\n\t- **第一个函数是next函数**，它有点像Promise的成功情况下的回调函数，但是，因为Observable是**跨时间的**，它可能有零或多个值，所以next函数可能会被调用N次，或许会被调用上千次，或许一次都没被调用，这取决于Observable有多少值。\n\t- **第二个是error函数**\n\t- **第三个是complete函数**，有时候或许我们想知道是否完成了，此时，该函数就派上用场了。\n\n3. 我们还可以对Observable进行转换（Transform）。就像之前讨论的，我们可以像使用lodash那样，对Observable进行map、filter、reduce。如果Observable只有单值，我们不会做这些操作。我们只会对**流或流式的处理**进行这些操作，比如，一些数据来了，我们把它们映射（map）成另外一些数据。这个方式非常高效（用了声明式的写法，不用像指令式那样写过程，当然高效了）！\n\n4. Observable还可以被合并（Combine）：concat、merge、zip。\n\n5. Observable还可以表达时间（Represent Time，意思是可以进行与时间相关的操作）。因为Observable是以时间作为维度的，所以你**绝对绝对**可以做debounce、throttle、buffer这些操作（他说到这，有点自嗨了，注：debounce、throttle都是去除速率过快的事件、buffer则是周期性的合并一些项，然后一起触发它们）。\n\n6. Observable还有个优点，就是懒（lazy）：你定义了一个Observable应该做什么，它不会做任何事情，直到你订阅它。因此，你可以轻易实现重试或重复（retry、repeat，有相关的操作符，可以自行查询），比如在错误时重试或重复发起一个Ajax请求五次。\n\n（讲完上述几条后，他总结了一句话：**Observables can represent just about anything**，但接下来又非常辩证地说了也不要什么都用RxJS，因为RxJS太新了什么的，不再赘述。）\n\n## RxJS和Redux的结合——redux-observable\n\n我们非常喜欢RxJS，也非常喜欢Redux，所以我们想，把这两个技术结合一下吧！我们实验了几种模式，经过了一些迭代，最后有了一个稳定的解决方案。如果你之前开源过什么东西，那么你一定知道，最重要的事情是——先做个好logo。不是写测试，不是保证它正常工作，也不是写文档，而是要先做个logo，这是最重要的事情，关乎你能拿多少star（场下有人笑了，然后他讲了他们logo的来历，大概就是，本来想结合RxJS的logo和Redux的logo，但是Redux当时还没有logo，他们就用Redux的谐音“three ducks”，三只鸭子做为logo，在经历了压扁、合并以及添加旋转动画后，终于得到了他们满意的logo，也就是现在redux-observable的logo）。\n\n![](/css/images/181.jpg)\n\nredux-observable是一个Redux中间件，用来管理副作用，包括异步。我们使用一个叫Epic的概念去完成这个工作。那么什么是Epic？\n\n> A function that takes a stream of **all actions** dispatched and returns a stream of **new actions** to dispatch \n> Epic是一个函数，该函数将**所有被发起的流式的action**作为参数，然后返回**新的流式的action**去发起。\n\n简单来说，Epic就是：\n\n> \"action in, action out\"\n\n（然后他用了一些伪代码去演示Epic的工作原理，注意，阅读下面的内容需要一点Redux和RxJS基础，如果感到吃力，应该先去看下Redux和RxJS。）\n\n1. 这是一个简单的函数，输入PING，立马得到PONG：\n\n\t```js\n\tfunction pingPong(action, store){\n\t  if(action.type === 'PING'){\n\t    return { type: 'PONG'};\n\t  }\n\t}\n\t```\n2. 如果使用RxJS的操作符来实现它，会更加声明式： \n\n\t```js\n\tfunction pingPongEpic(action$, store){\n\t  return action$.ofType('PING')\n\t     .map(action => ({ type: 'PONG'}));\n\t}\n\t```\n这就是世界上最简单的Epic，它的第一个参数是个流式的action。首先，这个Epic函数对流式的action进行了类型过滤，然后将其映射为新的流式的action。这就像个管道一样，所有action都会进来，然后进行匹配并输出。\n\n3. 如果想等待一秒后，就像打乒乓球那样，“乒-乓-乒-乓”，只需要加一行代码：\n\n\t```js\n\tfunction pingPongEpic(action$, store){\n\t  return action$.ofType('PING')\n\t     .delay(1000) // <- that's it\n\t     .map(action => ({ type: 'PONG'}));\n\t}\n\t```\n\n\t此时，如果你的reducer的逻辑是，PING是true，PONG是false，那么你的应用会是这样（他指着屏幕的动图，大概功能就是点击按钮，isPING的值等待了一秒后变为false）。\n\n4. 让我们来看另外一个debounce例子吧（代码和程序截图如下，这是个计数器的例子，大概就是添加了debounce后，连续点击加一或减一，速率过快的操作将会被取消）！\n\n\t![](/css/images/182.jpg)\n\n上述示例都太简单了，让我们看几个复杂的例子，这些例子不会讲解代码的细节，只是用来证明**RxJS和redux-observable在复杂场景中有多么地牛！**\n\n- 自动补全（他先是演示了使用普通JavaScript的写法，代码特别长，过程特别繁琐，然后演示了使用Epic的写法，只用了debounce、switchMap和map三个操作符，代码特别短，而且非常声明式和易读）\n- 双向多重的WebSockets（他还是先演示使用普通JavaScript代码的写法，代码特别多，而且容易引入bug。然后他演示了Epic的写法，功能一样不少，但是代码特别少而且非常声明式）\n\n![](/css/images/183.jpg)\n\n让我们来快速总结下redux-observable吧：\n\n- 让跨时间的复杂异步任务的组合和控制变得简单，当然如果只是做请求-响应这种简单的Ajax，那么学习RxJS是多余的。\n- 你不需要管理Rx的订阅，因为redux-observable帮你做了这些。\n- 你依然可以享受Redux的功能，比如时间旅行等。\n\n但是在你尝试使用redux-observable之前，**你应该提前学习Redux和RxJS**。当然，这应该是业余时间做的事，或是在你特别想挑战自己的情况下才要做的事。我不是打击大家的积极性，只是不想让在座的各位产生一个错误观念，就是即便我的应用很小很简单，我仍然应该使用redux-observable。 但是，如果你觉得我今天描述的问题，也正好是你的问题，那么你一定愿意学习RxJS、Redux和redux-observable。 \n\n![](/css/images/184.jpg)\n\n另外，RxJS拥有非常陡峭的学习曲线。 最近有个新流行词叫响应式编程（Reactive Programing ），RxJS做的就是这个。响应式编程是个令人发狂的编程范式，不过你可以这么理解它：就像是你先安装好管道，但还没有水流过管道，等到将来某个人发起了一个action，然后潺潺流水就来了，你的管道就开始运作了。（他之所以用流水这个比喻，主要是为了突出响应式编程，自动响应和变化传播的特性，如果你还不能理解，可以参考[维基百科](https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B)）。响应式编程是一种完全不同的编程风格。\n\n（然后他介绍了他的联合作者，展示了redux-observable的官网以及目前有哪些公司在用，最后致谢。）\n\n![](/css/images/185.jpg)\n\n## 总结\n\nJay Phelps的这个talk还是很不错的，而且比较客观。从这个talk中，我们可以学习到：\n\n- Redux是什么，以及它是如何工作的。\n- Observable是什么，以及它的基本用法。\n- redux-observable的工作原理以及适用场景。\n- 在复杂的异步场景下，回调和Promise捉襟见肘，而Observable则应对自如。\n- 在简单的异步场景下，没必要使用Observable。\n\n---\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/react-redux-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/React/>","slug":"rxjs-redux-react-amazing-2","published":1,"updated":"2019-05-01T08:10:30.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvms0039tgytubgcoh7w","content":"<p>今天，我将Youtube上的《RxJS + Redux + React = Amazing!》的后半部分翻译（+机译）了下来，以供国内的同学学习，英文听力好的同学可以直接看原版视频：</p>\n<p><a href=\"https://www.youtube.com/watch?v=AslncyG8whg\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=AslncyG8whg</a></p>\n<a id=\"more\"></a>\n<h2 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a>Observable</h2><p>什么是Observable？让我们快速来了解一下它吧！</p>\n<ul>\n<li><strong>Observable是一个由零个、一个或多个值组成的流。</strong>注意，是零个、一个或多个值。零个意味着可以没有值，这完全没问题。一个值的情况就像是Promise一样。如果有多个值，那么这些值将位于不同的时间点上。</li>\n<li><strong>Observable跨越了时间。</strong>时间是一种新的维度，这个维度是Observable与Promise的重要不同点。所有“流式”的事物都会跨越时间。事实上，<strong>流就是一个以时间为维度的集合</strong>。</li>\n<li><strong>Observable可以取消。</strong></li>\n</ul>\n<p>很酷的是，Observable正在变为ECMAScript的标准，就像Promise那样，但现在你还不能直接在浏览器里使用它（原话很啰嗦，直接提取有用信息）。所以你需要使用RxJS。</p>\n<p><img src=\"/css/images/178.jpg\" alt=\"\"></p>\n<p>RxJS是Observable的一种引用实现，它提供了一些定制的功能，比如操作符（Operators）、创建不同类型Observable的工厂方法。我同事说，RxJS就像是</p>\n<blockquote>\n<p>lodash for async</p>\n</blockquote>\n<p>因为它和lodash一样也是个工具库。lodash的用法基本上就是，你给它一个输入，它给你一个输出。RxJS的用法则是，你给它一个输入，它给你一个输出，但是<strong>跨越了时间</strong>。所以，你可以拥有多个值。让我们通过一个速成教程来更深入的了解它吧！</p>\n<ol>\n<li><p>创建Observable有很多种方式（直接贴截图）：</p>\n<p> <img src=\"/css/images/179.jpg\" alt=\"\"></p>\n<p> 你可以：</p>\n<ul>\n<li>创建一个单值的Observable</li>\n<li>从数组（或其他类型）创建一个Observable</li>\n<li>设置时间间隔</li>\n<li>发起Ajax或WebSockets</li>\n<li>还有很多方法可以创建定制的Observable</li>\n</ul>\n</li>\n<li><p>Observable可以被订阅（Subscribing）：</p>\n<p> <img src=\"/css/images/180.jpg\" alt=\"\"></p>\n<p> Observable的订阅和Promise的then挺像的。你可以给它提供三个函数：</p>\n<ul>\n<li><strong>第一个函数是next函数</strong>，它有点像Promise的成功情况下的回调函数，但是，因为Observable是<strong>跨时间的</strong>，它可能有零或多个值，所以next函数可能会被调用N次，或许会被调用上千次，或许一次都没被调用，这取决于Observable有多少值。</li>\n<li><strong>第二个是error函数</strong></li>\n<li><strong>第三个是complete函数</strong>，有时候或许我们想知道是否完成了，此时，该函数就派上用场了。</li>\n</ul>\n</li>\n<li><p>我们还可以对Observable进行转换（Transform）。就像之前讨论的，我们可以像使用lodash那样，对Observable进行map、filter、reduce。如果Observable只有单值，我们不会做这些操作。我们只会对<strong>流或流式的处理</strong>进行这些操作，比如，一些数据来了，我们把它们映射（map）成另外一些数据。这个方式非常高效（用了声明式的写法，不用像指令式那样写过程，当然高效了）！</p>\n</li>\n<li><p>Observable还可以被合并（Combine）：concat、merge、zip。</p>\n</li>\n<li><p>Observable还可以表达时间（Represent Time，意思是可以进行与时间相关的操作）。因为Observable是以时间作为维度的，所以你<strong>绝对绝对</strong>可以做debounce、throttle、buffer这些操作（他说到这，有点自嗨了，注：debounce、throttle都是去除速率过快的事件、buffer则是周期性的合并一些项，然后一起触发它们）。</p>\n</li>\n<li><p>Observable还有个优点，就是懒（lazy）：你定义了一个Observable应该做什么，它不会做任何事情，直到你订阅它。因此，你可以轻易实现重试或重复（retry、repeat，有相关的操作符，可以自行查询），比如在错误时重试或重复发起一个Ajax请求五次。</p>\n</li>\n</ol>\n<p>（讲完上述几条后，他总结了一句话：<strong>Observables can represent just about anything</strong>，但接下来又非常辩证地说了也不要什么都用RxJS，因为RxJS太新了什么的，不再赘述。）</p>\n<h2 id=\"RxJS和Redux的结合——redux-observable\"><a href=\"#RxJS和Redux的结合——redux-observable\" class=\"headerlink\" title=\"RxJS和Redux的结合——redux-observable\"></a>RxJS和Redux的结合——redux-observable</h2><p>我们非常喜欢RxJS，也非常喜欢Redux，所以我们想，把这两个技术结合一下吧！我们实验了几种模式，经过了一些迭代，最后有了一个稳定的解决方案。如果你之前开源过什么东西，那么你一定知道，最重要的事情是——先做个好logo。不是写测试，不是保证它正常工作，也不是写文档，而是要先做个logo，这是最重要的事情，关乎你能拿多少star（场下有人笑了，然后他讲了他们logo的来历，大概就是，本来想结合RxJS的logo和Redux的logo，但是Redux当时还没有logo，他们就用Redux的谐音“three ducks”，三只鸭子做为logo，在经历了压扁、合并以及添加旋转动画后，终于得到了他们满意的logo，也就是现在redux-observable的logo）。</p>\n<p><img src=\"/css/images/181.jpg\" alt=\"\"></p>\n<p>redux-observable是一个Redux中间件，用来管理副作用，包括异步。我们使用一个叫Epic的概念去完成这个工作。那么什么是Epic？</p>\n<blockquote>\n<p>A function that takes a stream of <strong>all actions</strong> dispatched and returns a stream of <strong>new actions</strong> to dispatch<br>Epic是一个函数，该函数将<strong>所有被发起的流式的action</strong>作为参数，然后返回<strong>新的流式的action</strong>去发起。</p>\n</blockquote>\n<p>简单来说，Epic就是：</p>\n<blockquote>\n<p>“action in, action out”</p>\n</blockquote>\n<p>（然后他用了一些伪代码去演示Epic的工作原理，注意，阅读下面的内容需要一点Redux和RxJS基础，如果感到吃力，应该先去看下Redux和RxJS。）</p>\n<ol>\n<li><p>这是一个简单的函数，输入PING，立马得到PONG：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pingPong</span>(<span class=\"params\">action, store</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(action.type === <span class=\"string\">'PING'</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: <span class=\"string\">'PONG'</span>&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果使用RxJS的操作符来实现它，会更加声明式： </p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pingPongEpic</span>(<span class=\"params\">action$, store</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> action$.ofType(<span class=\"string\">'PING'</span>)</span><br><span class=\"line\">     .map(<span class=\"function\"><span class=\"params\">action</span> =&gt;</span> (&#123; <span class=\"attr\">type</span>: <span class=\"string\">'PONG'</span>&#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这就是世界上最简单的Epic，它的第一个参数是个流式的action。首先，这个Epic函数对流式的action进行了类型过滤，然后将其映射为新的流式的action。这就像个管道一样，所有action都会进来，然后进行匹配并输出。</p>\n<ol start=\"3\">\n<li><p>如果想等待一秒后，就像打乒乓球那样，“乒-乓-乒-乓”，只需要加一行代码：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pingPongEpic</span>(<span class=\"params\">action$, store</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> action$.ofType(<span class=\"string\">'PING'</span>)</span><br><span class=\"line\">     .delay(<span class=\"number\">1000</span>) <span class=\"comment\">// &lt;- that's it</span></span><br><span class=\"line\">     .map(<span class=\"function\"><span class=\"params\">action</span> =&gt;</span> (&#123; <span class=\"attr\">type</span>: <span class=\"string\">'PONG'</span>&#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 此时，如果你的reducer的逻辑是，PING是true，PONG是false，那么你的应用会是这样（他指着屏幕的动图，大概功能就是点击按钮，isPING的值等待了一秒后变为false）。</p>\n</li>\n<li><p>让我们来看另外一个debounce例子吧（代码和程序截图如下，这是个计数器的例子，大概就是添加了debounce后，连续点击加一或减一，速率过快的操作将会被取消）！</p>\n<p> <img src=\"/css/images/182.jpg\" alt=\"\"></p>\n</li>\n</ol>\n<p>上述示例都太简单了，让我们看几个复杂的例子，这些例子不会讲解代码的细节，只是用来证明<strong>RxJS和redux-observable在复杂场景中有多么地牛！</strong></p>\n<ul>\n<li>自动补全（他先是演示了使用普通JavaScript的写法，代码特别长，过程特别繁琐，然后演示了使用Epic的写法，只用了debounce、switchMap和map三个操作符，代码特别短，而且非常声明式和易读）</li>\n<li>双向多重的WebSockets（他还是先演示使用普通JavaScript代码的写法，代码特别多，而且容易引入bug。然后他演示了Epic的写法，功能一样不少，但是代码特别少而且非常声明式）</li>\n</ul>\n<p><img src=\"/css/images/183.jpg\" alt=\"\"></p>\n<p>让我们来快速总结下redux-observable吧：</p>\n<ul>\n<li>让跨时间的复杂异步任务的组合和控制变得简单，当然如果只是做请求-响应这种简单的Ajax，那么学习RxJS是多余的。</li>\n<li>你不需要管理Rx的订阅，因为redux-observable帮你做了这些。</li>\n<li>你依然可以享受Redux的功能，比如时间旅行等。</li>\n</ul>\n<p>但是在你尝试使用redux-observable之前，<strong>你应该提前学习Redux和RxJS</strong>。当然，这应该是业余时间做的事，或是在你特别想挑战自己的情况下才要做的事。我不是打击大家的积极性，只是不想让在座的各位产生一个错误观念，就是即便我的应用很小很简单，我仍然应该使用redux-observable。 但是，如果你觉得我今天描述的问题，也正好是你的问题，那么你一定愿意学习RxJS、Redux和redux-observable。 </p>\n<p><img src=\"/css/images/184.jpg\" alt=\"\"></p>\n<p>另外，RxJS拥有非常陡峭的学习曲线。 最近有个新流行词叫响应式编程（Reactive Programing ），RxJS做的就是这个。响应式编程是个令人发狂的编程范式，不过你可以这么理解它：就像是你先安装好管道，但还没有水流过管道，等到将来某个人发起了一个action，然后潺潺流水就来了，你的管道就开始运作了。（他之所以用流水这个比喻，主要是为了突出响应式编程，自动响应和变化传播的特性，如果你还不能理解，可以参考<a href=\"https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">维基百科</a>）。响应式编程是一种完全不同的编程风格。</p>\n<p>（然后他介绍了他的联合作者，展示了redux-observable的官网以及目前有哪些公司在用，最后致谢。）</p>\n<p><img src=\"/css/images/185.jpg\" alt=\"\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Jay Phelps的这个talk还是很不错的，而且比较客观。从这个talk中，我们可以学习到：</p>\n<ul>\n<li>Redux是什么，以及它是如何工作的。</li>\n<li>Observable是什么，以及它的基本用法。</li>\n<li>redux-observable的工作原理以及适用场景。</li>\n<li>在复杂的异步场景下，回调和Promise捉襟见肘，而Observable则应对自如。</li>\n<li>在简单的异步场景下，没必要使用Observable。</li>\n</ul>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我将Youtube上的《RxJS + Redux + React = Amazing!》的后半部分翻译（+机译）了下来，以供国内的同学学习，英文听力好的同学可以直接看原版视频：</p>\n<p><a href=\"https://www.youtube.com/watch?v=AslncyG8whg\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=AslncyG8whg</a></p>","more":"<h2 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a>Observable</h2><p>什么是Observable？让我们快速来了解一下它吧！</p>\n<ul>\n<li><strong>Observable是一个由零个、一个或多个值组成的流。</strong>注意，是零个、一个或多个值。零个意味着可以没有值，这完全没问题。一个值的情况就像是Promise一样。如果有多个值，那么这些值将位于不同的时间点上。</li>\n<li><strong>Observable跨越了时间。</strong>时间是一种新的维度，这个维度是Observable与Promise的重要不同点。所有“流式”的事物都会跨越时间。事实上，<strong>流就是一个以时间为维度的集合</strong>。</li>\n<li><strong>Observable可以取消。</strong></li>\n</ul>\n<p>很酷的是，Observable正在变为ECMAScript的标准，就像Promise那样，但现在你还不能直接在浏览器里使用它（原话很啰嗦，直接提取有用信息）。所以你需要使用RxJS。</p>\n<p><img src=\"/css/images/178.jpg\" alt=\"\"></p>\n<p>RxJS是Observable的一种引用实现，它提供了一些定制的功能，比如操作符（Operators）、创建不同类型Observable的工厂方法。我同事说，RxJS就像是</p>\n<blockquote>\n<p>lodash for async</p>\n</blockquote>\n<p>因为它和lodash一样也是个工具库。lodash的用法基本上就是，你给它一个输入，它给你一个输出。RxJS的用法则是，你给它一个输入，它给你一个输出，但是<strong>跨越了时间</strong>。所以，你可以拥有多个值。让我们通过一个速成教程来更深入的了解它吧！</p>\n<ol>\n<li><p>创建Observable有很多种方式（直接贴截图）：</p>\n<p> <img src=\"/css/images/179.jpg\" alt=\"\"></p>\n<p> 你可以：</p>\n<ul>\n<li>创建一个单值的Observable</li>\n<li>从数组（或其他类型）创建一个Observable</li>\n<li>设置时间间隔</li>\n<li>发起Ajax或WebSockets</li>\n<li>还有很多方法可以创建定制的Observable</li>\n</ul>\n</li>\n<li><p>Observable可以被订阅（Subscribing）：</p>\n<p> <img src=\"/css/images/180.jpg\" alt=\"\"></p>\n<p> Observable的订阅和Promise的then挺像的。你可以给它提供三个函数：</p>\n<ul>\n<li><strong>第一个函数是next函数</strong>，它有点像Promise的成功情况下的回调函数，但是，因为Observable是<strong>跨时间的</strong>，它可能有零或多个值，所以next函数可能会被调用N次，或许会被调用上千次，或许一次都没被调用，这取决于Observable有多少值。</li>\n<li><strong>第二个是error函数</strong></li>\n<li><strong>第三个是complete函数</strong>，有时候或许我们想知道是否完成了，此时，该函数就派上用场了。</li>\n</ul>\n</li>\n<li><p>我们还可以对Observable进行转换（Transform）。就像之前讨论的，我们可以像使用lodash那样，对Observable进行map、filter、reduce。如果Observable只有单值，我们不会做这些操作。我们只会对<strong>流或流式的处理</strong>进行这些操作，比如，一些数据来了，我们把它们映射（map）成另外一些数据。这个方式非常高效（用了声明式的写法，不用像指令式那样写过程，当然高效了）！</p>\n</li>\n<li><p>Observable还可以被合并（Combine）：concat、merge、zip。</p>\n</li>\n<li><p>Observable还可以表达时间（Represent Time，意思是可以进行与时间相关的操作）。因为Observable是以时间作为维度的，所以你<strong>绝对绝对</strong>可以做debounce、throttle、buffer这些操作（他说到这，有点自嗨了，注：debounce、throttle都是去除速率过快的事件、buffer则是周期性的合并一些项，然后一起触发它们）。</p>\n</li>\n<li><p>Observable还有个优点，就是懒（lazy）：你定义了一个Observable应该做什么，它不会做任何事情，直到你订阅它。因此，你可以轻易实现重试或重复（retry、repeat，有相关的操作符，可以自行查询），比如在错误时重试或重复发起一个Ajax请求五次。</p>\n</li>\n</ol>\n<p>（讲完上述几条后，他总结了一句话：<strong>Observables can represent just about anything</strong>，但接下来又非常辩证地说了也不要什么都用RxJS，因为RxJS太新了什么的，不再赘述。）</p>\n<h2 id=\"RxJS和Redux的结合——redux-observable\"><a href=\"#RxJS和Redux的结合——redux-observable\" class=\"headerlink\" title=\"RxJS和Redux的结合——redux-observable\"></a>RxJS和Redux的结合——redux-observable</h2><p>我们非常喜欢RxJS，也非常喜欢Redux，所以我们想，把这两个技术结合一下吧！我们实验了几种模式，经过了一些迭代，最后有了一个稳定的解决方案。如果你之前开源过什么东西，那么你一定知道，最重要的事情是——先做个好logo。不是写测试，不是保证它正常工作，也不是写文档，而是要先做个logo，这是最重要的事情，关乎你能拿多少star（场下有人笑了，然后他讲了他们logo的来历，大概就是，本来想结合RxJS的logo和Redux的logo，但是Redux当时还没有logo，他们就用Redux的谐音“three ducks”，三只鸭子做为logo，在经历了压扁、合并以及添加旋转动画后，终于得到了他们满意的logo，也就是现在redux-observable的logo）。</p>\n<p><img src=\"/css/images/181.jpg\" alt=\"\"></p>\n<p>redux-observable是一个Redux中间件，用来管理副作用，包括异步。我们使用一个叫Epic的概念去完成这个工作。那么什么是Epic？</p>\n<blockquote>\n<p>A function that takes a stream of <strong>all actions</strong> dispatched and returns a stream of <strong>new actions</strong> to dispatch<br>Epic是一个函数，该函数将<strong>所有被发起的流式的action</strong>作为参数，然后返回<strong>新的流式的action</strong>去发起。</p>\n</blockquote>\n<p>简单来说，Epic就是：</p>\n<blockquote>\n<p>“action in, action out”</p>\n</blockquote>\n<p>（然后他用了一些伪代码去演示Epic的工作原理，注意，阅读下面的内容需要一点Redux和RxJS基础，如果感到吃力，应该先去看下Redux和RxJS。）</p>\n<ol>\n<li><p>这是一个简单的函数，输入PING，立马得到PONG：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pingPong</span>(<span class=\"params\">action, store</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(action.type === <span class=\"string\">'PING'</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: <span class=\"string\">'PONG'</span>&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果使用RxJS的操作符来实现它，会更加声明式： </p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pingPongEpic</span>(<span class=\"params\">action$, store</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> action$.ofType(<span class=\"string\">'PING'</span>)</span><br><span class=\"line\">     .map(<span class=\"function\"><span class=\"params\">action</span> =&gt;</span> (&#123; <span class=\"attr\">type</span>: <span class=\"string\">'PONG'</span>&#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这就是世界上最简单的Epic，它的第一个参数是个流式的action。首先，这个Epic函数对流式的action进行了类型过滤，然后将其映射为新的流式的action。这就像个管道一样，所有action都会进来，然后进行匹配并输出。</p>\n<ol start=\"3\">\n<li><p>如果想等待一秒后，就像打乒乓球那样，“乒-乓-乒-乓”，只需要加一行代码：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pingPongEpic</span>(<span class=\"params\">action$, store</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> action$.ofType(<span class=\"string\">'PING'</span>)</span><br><span class=\"line\">     .delay(<span class=\"number\">1000</span>) <span class=\"comment\">// &lt;- that's it</span></span><br><span class=\"line\">     .map(<span class=\"function\"><span class=\"params\">action</span> =&gt;</span> (&#123; <span class=\"attr\">type</span>: <span class=\"string\">'PONG'</span>&#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 此时，如果你的reducer的逻辑是，PING是true，PONG是false，那么你的应用会是这样（他指着屏幕的动图，大概功能就是点击按钮，isPING的值等待了一秒后变为false）。</p>\n</li>\n<li><p>让我们来看另外一个debounce例子吧（代码和程序截图如下，这是个计数器的例子，大概就是添加了debounce后，连续点击加一或减一，速率过快的操作将会被取消）！</p>\n<p> <img src=\"/css/images/182.jpg\" alt=\"\"></p>\n</li>\n</ol>\n<p>上述示例都太简单了，让我们看几个复杂的例子，这些例子不会讲解代码的细节，只是用来证明<strong>RxJS和redux-observable在复杂场景中有多么地牛！</strong></p>\n<ul>\n<li>自动补全（他先是演示了使用普通JavaScript的写法，代码特别长，过程特别繁琐，然后演示了使用Epic的写法，只用了debounce、switchMap和map三个操作符，代码特别短，而且非常声明式和易读）</li>\n<li>双向多重的WebSockets（他还是先演示使用普通JavaScript代码的写法，代码特别多，而且容易引入bug。然后他演示了Epic的写法，功能一样不少，但是代码特别少而且非常声明式）</li>\n</ul>\n<p><img src=\"/css/images/183.jpg\" alt=\"\"></p>\n<p>让我们来快速总结下redux-observable吧：</p>\n<ul>\n<li>让跨时间的复杂异步任务的组合和控制变得简单，当然如果只是做请求-响应这种简单的Ajax，那么学习RxJS是多余的。</li>\n<li>你不需要管理Rx的订阅，因为redux-observable帮你做了这些。</li>\n<li>你依然可以享受Redux的功能，比如时间旅行等。</li>\n</ul>\n<p>但是在你尝试使用redux-observable之前，<strong>你应该提前学习Redux和RxJS</strong>。当然，这应该是业余时间做的事，或是在你特别想挑战自己的情况下才要做的事。我不是打击大家的积极性，只是不想让在座的各位产生一个错误观念，就是即便我的应用很小很简单，我仍然应该使用redux-observable。 但是，如果你觉得我今天描述的问题，也正好是你的问题，那么你一定愿意学习RxJS、Redux和redux-observable。 </p>\n<p><img src=\"/css/images/184.jpg\" alt=\"\"></p>\n<p>另外，RxJS拥有非常陡峭的学习曲线。 最近有个新流行词叫响应式编程（Reactive Programing ），RxJS做的就是这个。响应式编程是个令人发狂的编程范式，不过你可以这么理解它：就像是你先安装好管道，但还没有水流过管道，等到将来某个人发起了一个action，然后潺潺流水就来了，你的管道就开始运作了。（他之所以用流水这个比喻，主要是为了突出响应式编程，自动响应和变化传播的特性，如果你还不能理解，可以参考<a href=\"https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">维基百科</a>）。响应式编程是一种完全不同的编程风格。</p>\n<p>（然后他介绍了他的联合作者，展示了redux-observable的官网以及目前有哪些公司在用，最后致谢。）</p>\n<p><img src=\"/css/images/185.jpg\" alt=\"\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Jay Phelps的这个talk还是很不错的，而且比较客观。从这个talk中，我们可以学习到：</p>\n<ul>\n<li>Redux是什么，以及它是如何工作的。</li>\n<li>Observable是什么，以及它的基本用法。</li>\n<li>redux-observable的工作原理以及适用场景。</li>\n<li>在复杂的异步场景下，回调和Promise捉襟见肘，而Observable则应对自如。</li>\n<li>在简单的异步场景下，没必要使用Observable。</li>\n</ul>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/react-redux-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/react-redux-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/React/\">http://www.liuyiqi.cn/tags/React/</a></p>"},{"title":"JavaScript 版数据结构与算法（四）集合","date":"2017-02-16T02:11:00.000Z","_content":"\n今天，我们要讲的是数据结构与算法中的集合。\n\n<!--more-->\n\n## 集合简介\n\n什么是集合？与栈、队列、链表这些**顺序**数据结构不同，集合是一种**无序且唯一**的数据结构。集合有什么用？在 Python 中，我经常使用集合来给数组去重：\n\n```python\n>>> list(set([1,1,2]))\n[1, 2] \n```\n\n当然，ES6中也实现了集合——Set，那么 JavaScript 集合风格的数组去重应该是这样：\n\n```js\nfunction remove_duplicates_es6(arr) {\n    let s = new Set(arr);\n    let it = s.values();\n    return Array.from(it);\n}\n```\n貌似没有  Python 简约，不过简约谁比得过 Python 呢？哈哈！JavaScript 中有了 Set 总比没有强。想更多地了解 Set，可以看 MDN 文档—— [Set](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)。\n\n除此之外，我们还可以使用集合来执行并集、交集、差集、子集等操作。\n\n## 用 JavaScript 编写集合类\n\n尽管 ES6 已经实现了集合类——Set，不过我们还是自己写一个吧！\n\n### 私有变量\n\n为了存储无序且唯一的元素，我们使用一个对象 `items` 来作为私有变量：\n\n```js\nfunction Set(){\n  var items = {};\n}\n```\n\n然后，将每个元素作为该对象的键和值。比如，一个集合包含 `1,2` 两个元素，那么该集合的数据结构就应该是：\n\n```js\n{\n  '1': 1,\n  '2': 2\n}\n```\n\n这样就保证了集合元素的**无序且唯一**。\n\n### 实现 has 、add、remove 方法\n\n实现 `has` 方法（即判断集合中是否存在指定元素）、`add` 方法（向集合中添加不存在的元素）、`remove` 方法（删除集合中存在的元素），可以跑通如下测试：\n\n```js\nvar set = new Set();\n\nexpect(set.add(1)).toBeTruthy(); // 断言一\nexpect(set.add(1)).toBeFalsy(); // 断言二\nexpect(set.add(2)).toBeTruthy(); // 断言三\n\nexpect(set.has(1)).toBeTruthy(); // 断言四\nexpect(set.has(3)).toBeFalsy(); // 断言五\n\nexpect(set.remove(1)).toBeTruthy(); // 断言六\nexpect(set.remove(1)).toBeFalsy(); // 断言七\n```\n\n上述测试代码中的七个断言都需要判断元素是否存在于集合中。那么如何判断元素是否存在于集合中呢？答案是使用 `hasOwnProperty` 方法。\n> `hasOwnProperty` 这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。更多的用法可以参考 MDN 文档——[Object.prototype.hasOwnProperty()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)\n\n通过 `hasOwnProperty` 方法我们可以轻易实现 `has` 方法。有了 `has` 方法，`add` 和 `remove` 方法仅仅就是一个条件判断和给对象 `items` 赋值的简单问题了。实现代码如下：\n\n```js\nthis.has = function (value) {\n  return items.hasOwnProperty(value); // {1}\n};\n\nthis.add = function (value) {\n  if (!this.has(value)) {\n    items[value] = value;\n    return true;\n  }\n  return false;\n};\n\nthis.remove = function (value) {\n  if (this.has(value)) {\n    delete items[value];\n    return true;\n  }\n  return false;\n};\n```\n\n### 实现 size 和 values 方法\n\n实现 `size` 方法（返回集合元素个数）和 `values` 方法（返回集合所有值），跑通如下测试：\n\n```js\nvar set = new Set();\nset.add(2);\n\nexpect(set.size()).toBe(1); // 断言一\nexpect(set.values()).toEqual(['2']); // 断言二\n```\n断言一返回集合元素个数，断言二以数组形式返回所有值。为了实现这个需求，我们需要使用 `Object.keys()` 方法来获取对象的属性。\n\n> `Object.keys()` 方法会返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用 for-in 循环遍历该对象时返回的顺序一致 (顺序一致不包括数字属性)（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。更多的用法请参考 MDN 文档——[ Object.keys()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)。\n\n所以编写的代码如下：\n\n```js\nthis.size = function () {\n  return Object.keys(items).length;\n};\n\nthis.values = function () {\n  return Object.keys(items);\n};\n```\n\n### 实现 union 方法\n\n实现 `union` 方法（和另一个集合取并集），跑通如下测试：\n\n```js\nvar set = new Set();\nset.add(1);\nset.add(2);\n\nvar otherSet = new Set();\notherSet.add(3);\n\nvar unionSet = set.union(otherSet);\nexpect(unionSet.values()).toEqual(['1', '2', '3']);\n```\n\n通过上述测试，我们可以知道，`1,2`  和 `3`取并集是 `1,2,3`。那么如何用代码实现呢？其实很简单，只需要新建一个集合，然后遍历两个集合的元素，并添加到新集合即可，新集合会自动过滤已经存在的元素，自然而然就得到了并集。实现代码如下：\n\n```js\nthis.union = function (otherSet) {\n  var unionSet = new Set();\n\n  var values = this.values();\n  for (var i = 0; i < values.length; i++) {\n    unionSet.add(values[i]);\n  }\n\n  values = otherSet.values();\n  for (i = 0; i < values.length; i++) {\n    unionSet.add(values[i]);\n  }\n\n  return unionSet;\n};\n```\n\n### 实现 intersection 方法\n\n实现 `intersection` 方法（和另一个集合取交集），跑通如下测试：\n\n```js\nvar set = new Set();\nset.add(1);\nset.add(2);\n\nvar otherSet = new Set();\notherSet.add(2);\notherSet.add(3);\n\nvar intersectionSet = set.intersection(otherSet);\nexpect(intersectionSet.values()).toEqual(['2']);\n```\n\n上述测试代码，仅仅是将 `set` 和 `otherSet` 两个集合取交集，最终为 `2`。实现思路非常简单，只需要新建一个集合，然后遍历 `otherSet` 的元素，只要在 `set` 中存在就添加到新集合中，最后返回新集合。实现代码：\n\n```js\nthis.intersection = function (otherSet) {\n  var intersectionSet = new Set();\n\n  var values = otherSet.values();\n  for (var i = 0; i < values.length; i++) {\n    if (this.has(values[i])) {\n      intersectionSet.add(values[i]);\n    }\n  }\n  return intersectionSet;\n};\n```\n### 实现 difference 方法\n\n实现 `difference` 方法（和另一个集合取差集），跑通如下测试：\n\n```js\nvar set = new Set();\nset.add(1);\nset.add(2);\n\nvar otherSet = new Set();\notherSet.add(2);\notherSet.add(3);\n\nvar differenceSet = set.difference(otherSet);\nexpect(differenceSet.values()).toEqual(['1']);\n```\n\n上述测试代码仅仅是将 `set` 和 `otherSet` 两个集合取差集得到 `1`。实现思路非常简单，只需要新建一个集合，然后遍历 `set` 中的元素，如果元素不存在于 `otherSet` 中就添加到新集合中。实现代码如下：\n\n```js\nthis.difference = function (otherSet) {\n  var differenceSet = new Set();\n\n  var values = this.values();\n  for (var i = 0; i < values.length; i++) {\n    if (!otherSet.has(values[i])) {\n      differenceSet.add(values[i]);\n    }\n  }\n  return differenceSet;\n};\n```\n\n### 实现 subset 方法\n\n实现 `subset` 方法（判断是否是另一个集合的子集），跑通如下测试：\n\n```js\nvar set = new Set();\nset.add(1);\nset.add(2);\nset.add(3);\n\nvar otherSet = new Set();\notherSet.add(2);\notherSet.add(3);\n\nexpect(set.subset(otherSet)).toBeFalsy(); // 断言一\nset.remove(3);\nexpect(set.subset(otherSet)).toBeFalsy();  // 断言二\nset.add(1);\nexpect(set.subset(otherSet)).toBeTruthy();  // 断言三\n```\n\n断言一判断 `1,2,3` 是否是 `2，3` 的子集，因为元素个数都比人家多，显然不是。断言二判断 `1，2` 是否是 `2,3` 的子集，因为 `1` 不在 `2,3` 中，所以也不是。断言四判断 `2` 是否是 `2,3` 的子集，显然是。实现代码如下：\n\n```js\nthis.subset = function (otherSet) {\n  if (this.size() > otherSet.size()) {\n    return false;\n  } else {\n    var values = this.values();\n    for (var i = 0; i < values.length; i++) {\n      if (!otherSet.has(values[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n```\n\n至此，集合类就完成了！\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","source":"_posts/set.md","raw":"---\ntitle: JavaScript 版数据结构与算法（四）集合\ndate: 2017-02-16 10:11:00\ntags: [数据结构与算法]\n---\n\n今天，我们要讲的是数据结构与算法中的集合。\n\n<!--more-->\n\n## 集合简介\n\n什么是集合？与栈、队列、链表这些**顺序**数据结构不同，集合是一种**无序且唯一**的数据结构。集合有什么用？在 Python 中，我经常使用集合来给数组去重：\n\n```python\n>>> list(set([1,1,2]))\n[1, 2] \n```\n\n当然，ES6中也实现了集合——Set，那么 JavaScript 集合风格的数组去重应该是这样：\n\n```js\nfunction remove_duplicates_es6(arr) {\n    let s = new Set(arr);\n    let it = s.values();\n    return Array.from(it);\n}\n```\n貌似没有  Python 简约，不过简约谁比得过 Python 呢？哈哈！JavaScript 中有了 Set 总比没有强。想更多地了解 Set，可以看 MDN 文档—— [Set](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)。\n\n除此之外，我们还可以使用集合来执行并集、交集、差集、子集等操作。\n\n## 用 JavaScript 编写集合类\n\n尽管 ES6 已经实现了集合类——Set，不过我们还是自己写一个吧！\n\n### 私有变量\n\n为了存储无序且唯一的元素，我们使用一个对象 `items` 来作为私有变量：\n\n```js\nfunction Set(){\n  var items = {};\n}\n```\n\n然后，将每个元素作为该对象的键和值。比如，一个集合包含 `1,2` 两个元素，那么该集合的数据结构就应该是：\n\n```js\n{\n  '1': 1,\n  '2': 2\n}\n```\n\n这样就保证了集合元素的**无序且唯一**。\n\n### 实现 has 、add、remove 方法\n\n实现 `has` 方法（即判断集合中是否存在指定元素）、`add` 方法（向集合中添加不存在的元素）、`remove` 方法（删除集合中存在的元素），可以跑通如下测试：\n\n```js\nvar set = new Set();\n\nexpect(set.add(1)).toBeTruthy(); // 断言一\nexpect(set.add(1)).toBeFalsy(); // 断言二\nexpect(set.add(2)).toBeTruthy(); // 断言三\n\nexpect(set.has(1)).toBeTruthy(); // 断言四\nexpect(set.has(3)).toBeFalsy(); // 断言五\n\nexpect(set.remove(1)).toBeTruthy(); // 断言六\nexpect(set.remove(1)).toBeFalsy(); // 断言七\n```\n\n上述测试代码中的七个断言都需要判断元素是否存在于集合中。那么如何判断元素是否存在于集合中呢？答案是使用 `hasOwnProperty` 方法。\n> `hasOwnProperty` 这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。更多的用法可以参考 MDN 文档——[Object.prototype.hasOwnProperty()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)\n\n通过 `hasOwnProperty` 方法我们可以轻易实现 `has` 方法。有了 `has` 方法，`add` 和 `remove` 方法仅仅就是一个条件判断和给对象 `items` 赋值的简单问题了。实现代码如下：\n\n```js\nthis.has = function (value) {\n  return items.hasOwnProperty(value); // {1}\n};\n\nthis.add = function (value) {\n  if (!this.has(value)) {\n    items[value] = value;\n    return true;\n  }\n  return false;\n};\n\nthis.remove = function (value) {\n  if (this.has(value)) {\n    delete items[value];\n    return true;\n  }\n  return false;\n};\n```\n\n### 实现 size 和 values 方法\n\n实现 `size` 方法（返回集合元素个数）和 `values` 方法（返回集合所有值），跑通如下测试：\n\n```js\nvar set = new Set();\nset.add(2);\n\nexpect(set.size()).toBe(1); // 断言一\nexpect(set.values()).toEqual(['2']); // 断言二\n```\n断言一返回集合元素个数，断言二以数组形式返回所有值。为了实现这个需求，我们需要使用 `Object.keys()` 方法来获取对象的属性。\n\n> `Object.keys()` 方法会返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用 for-in 循环遍历该对象时返回的顺序一致 (顺序一致不包括数字属性)（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。更多的用法请参考 MDN 文档——[ Object.keys()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)。\n\n所以编写的代码如下：\n\n```js\nthis.size = function () {\n  return Object.keys(items).length;\n};\n\nthis.values = function () {\n  return Object.keys(items);\n};\n```\n\n### 实现 union 方法\n\n实现 `union` 方法（和另一个集合取并集），跑通如下测试：\n\n```js\nvar set = new Set();\nset.add(1);\nset.add(2);\n\nvar otherSet = new Set();\notherSet.add(3);\n\nvar unionSet = set.union(otherSet);\nexpect(unionSet.values()).toEqual(['1', '2', '3']);\n```\n\n通过上述测试，我们可以知道，`1,2`  和 `3`取并集是 `1,2,3`。那么如何用代码实现呢？其实很简单，只需要新建一个集合，然后遍历两个集合的元素，并添加到新集合即可，新集合会自动过滤已经存在的元素，自然而然就得到了并集。实现代码如下：\n\n```js\nthis.union = function (otherSet) {\n  var unionSet = new Set();\n\n  var values = this.values();\n  for (var i = 0; i < values.length; i++) {\n    unionSet.add(values[i]);\n  }\n\n  values = otherSet.values();\n  for (i = 0; i < values.length; i++) {\n    unionSet.add(values[i]);\n  }\n\n  return unionSet;\n};\n```\n\n### 实现 intersection 方法\n\n实现 `intersection` 方法（和另一个集合取交集），跑通如下测试：\n\n```js\nvar set = new Set();\nset.add(1);\nset.add(2);\n\nvar otherSet = new Set();\notherSet.add(2);\notherSet.add(3);\n\nvar intersectionSet = set.intersection(otherSet);\nexpect(intersectionSet.values()).toEqual(['2']);\n```\n\n上述测试代码，仅仅是将 `set` 和 `otherSet` 两个集合取交集，最终为 `2`。实现思路非常简单，只需要新建一个集合，然后遍历 `otherSet` 的元素，只要在 `set` 中存在就添加到新集合中，最后返回新集合。实现代码：\n\n```js\nthis.intersection = function (otherSet) {\n  var intersectionSet = new Set();\n\n  var values = otherSet.values();\n  for (var i = 0; i < values.length; i++) {\n    if (this.has(values[i])) {\n      intersectionSet.add(values[i]);\n    }\n  }\n  return intersectionSet;\n};\n```\n### 实现 difference 方法\n\n实现 `difference` 方法（和另一个集合取差集），跑通如下测试：\n\n```js\nvar set = new Set();\nset.add(1);\nset.add(2);\n\nvar otherSet = new Set();\notherSet.add(2);\notherSet.add(3);\n\nvar differenceSet = set.difference(otherSet);\nexpect(differenceSet.values()).toEqual(['1']);\n```\n\n上述测试代码仅仅是将 `set` 和 `otherSet` 两个集合取差集得到 `1`。实现思路非常简单，只需要新建一个集合，然后遍历 `set` 中的元素，如果元素不存在于 `otherSet` 中就添加到新集合中。实现代码如下：\n\n```js\nthis.difference = function (otherSet) {\n  var differenceSet = new Set();\n\n  var values = this.values();\n  for (var i = 0; i < values.length; i++) {\n    if (!otherSet.has(values[i])) {\n      differenceSet.add(values[i]);\n    }\n  }\n  return differenceSet;\n};\n```\n\n### 实现 subset 方法\n\n实现 `subset` 方法（判断是否是另一个集合的子集），跑通如下测试：\n\n```js\nvar set = new Set();\nset.add(1);\nset.add(2);\nset.add(3);\n\nvar otherSet = new Set();\notherSet.add(2);\notherSet.add(3);\n\nexpect(set.subset(otherSet)).toBeFalsy(); // 断言一\nset.remove(3);\nexpect(set.subset(otherSet)).toBeFalsy();  // 断言二\nset.add(1);\nexpect(set.subset(otherSet)).toBeTruthy();  // 断言三\n```\n\n断言一判断 `1,2,3` 是否是 `2，3` 的子集，因为元素个数都比人家多，显然不是。断言二判断 `1，2` 是否是 `2,3` 的子集，因为 `1` 不在 `2,3` 中，所以也不是。断言四判断 `2` 是否是 `2,3` 的子集，显然是。实现代码如下：\n\n```js\nthis.subset = function (otherSet) {\n  if (this.size() > otherSet.size()) {\n    return false;\n  } else {\n    var values = this.values();\n    for (var i = 0; i < values.length; i++) {\n      if (!otherSet.has(values[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n```\n\n至此，集合类就完成了！\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","slug":"set","published":1,"updated":"2019-05-01T08:02:12.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmt003btgyttbye6ch5","content":"<p>今天，我们要讲的是数据结构与算法中的集合。</p>\n<a id=\"more\"></a>\n<h2 id=\"集合简介\"><a href=\"#集合简介\" class=\"headerlink\" title=\"集合简介\"></a>集合简介</h2><p>什么是集合？与栈、队列、链表这些<strong>顺序</strong>数据结构不同，集合是一种<strong>无序且唯一</strong>的数据结构。集合有什么用？在 Python 中，我经常使用集合来给数组去重：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>list(set([<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>]))</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n<p>当然，ES6中也实现了集合——Set，那么 JavaScript 集合风格的数组去重应该是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">remove_duplicates_es6</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> it = s.values();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(it);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>貌似没有  Python 简约，不过简约谁比得过 Python 呢？哈哈！JavaScript 中有了 Set 总比没有强。想更多地了解 Set，可以看 MDN 文档—— <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set\" target=\"_blank\" rel=\"noopener\">Set</a>。</p>\n<p>除此之外，我们还可以使用集合来执行并集、交集、差集、子集等操作。</p>\n<h2 id=\"用-JavaScript-编写集合类\"><a href=\"#用-JavaScript-编写集合类\" class=\"headerlink\" title=\"用 JavaScript 编写集合类\"></a>用 JavaScript 编写集合类</h2><p>尽管 ES6 已经实现了集合类——Set，不过我们还是自己写一个吧！</p>\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>为了存储无序且唯一的元素，我们使用一个对象 <code>items</code> 来作为私有变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Set</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，将每个元素作为该对象的键和值。比如，一个集合包含 <code>1,2</code> 两个元素，那么该集合的数据结构就应该是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">'1'</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"string\">'2'</span>: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就保证了集合元素的<strong>无序且唯一</strong>。</p>\n<h3 id=\"实现-has-、add、remove-方法\"><a href=\"#实现-has-、add、remove-方法\" class=\"headerlink\" title=\"实现 has 、add、remove 方法\"></a>实现 has 、add、remove 方法</h3><p>实现 <code>has</code> 方法（即判断集合中是否存在指定元素）、<code>add</code> 方法（向集合中添加不存在的元素）、<code>remove</code> 方法（删除集合中存在的元素），可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">expect(set.add(<span class=\"number\">1</span>)).toBeTruthy(); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">expect(set.add(<span class=\"number\">1</span>)).toBeFalsy(); <span class=\"comment\">// 断言二</span></span><br><span class=\"line\">expect(set.add(<span class=\"number\">2</span>)).toBeTruthy(); <span class=\"comment\">// 断言三</span></span><br><span class=\"line\"></span><br><span class=\"line\">expect(set.has(<span class=\"number\">1</span>)).toBeTruthy(); <span class=\"comment\">// 断言四</span></span><br><span class=\"line\">expect(set.has(<span class=\"number\">3</span>)).toBeFalsy(); <span class=\"comment\">// 断言五</span></span><br><span class=\"line\"></span><br><span class=\"line\">expect(set.remove(<span class=\"number\">1</span>)).toBeTruthy(); <span class=\"comment\">// 断言六</span></span><br><span class=\"line\">expect(set.remove(<span class=\"number\">1</span>)).toBeFalsy(); <span class=\"comment\">// 断言七</span></span><br></pre></td></tr></table></figure>\n<p>上述测试代码中的七个断言都需要判断元素是否存在于集合中。那么如何判断元素是否存在于集合中呢？答案是使用 <code>hasOwnProperty</code> 方法。</p>\n<blockquote>\n<p><code>hasOwnProperty</code> 这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。更多的用法可以参考 MDN 文档——<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\" target=\"_blank\" rel=\"noopener\">Object.prototype.hasOwnProperty()</a></p>\n</blockquote>\n<p>通过 <code>hasOwnProperty</code> 方法我们可以轻易实现 <code>has</code> 方法。有了 <code>has</code> 方法，<code>add</code> 和 <code>remove</code> 方法仅仅就是一个条件判断和给对象 <code>items</code> 赋值的简单问题了。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.has = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> items.hasOwnProperty(value); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.has(value)) &#123;</span><br><span class=\"line\">    items[value] = value;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.remove = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.has(value)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> items[value];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-size-和-values-方法\"><a href=\"#实现-size-和-values-方法\" class=\"headerlink\" title=\"实现 size 和 values 方法\"></a>实现 size 和 values 方法</h3><p>实现 <code>size</code> 方法（返回集合元素个数）和 <code>values</code> 方法（返回集合所有值），跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">set.add(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(set.size()).toBe(<span class=\"number\">1</span>); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">expect(set.values()).toEqual([<span class=\"string\">'2'</span>]); <span class=\"comment\">// 断言二</span></span><br></pre></td></tr></table></figure>\n<p>断言一返回集合元素个数，断言二以数组形式返回所有值。为了实现这个需求，我们需要使用 <code>Object.keys()</code> 方法来获取对象的属性。</p>\n<blockquote>\n<p><code>Object.keys()</code> 方法会返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用 for-in 循环遍历该对象时返回的顺序一致 (顺序一致不包括数字属性)（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。更多的用法请参考 MDN 文档——<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" target=\"_blank\" rel=\"noopener\"> Object.keys()</a>。</p>\n</blockquote>\n<p>所以编写的代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.size = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(items).length;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.values = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(items);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-union-方法\"><a href=\"#实现-union-方法\" class=\"headerlink\" title=\"实现 union 方法\"></a>实现 union 方法</h3><p>实现 <code>union</code> 方法（和另一个集合取并集），跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">set.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">set.add(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">otherSet.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> unionSet = set.union(otherSet);</span><br><span class=\"line\">expect(unionSet.values()).toEqual([<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>]);</span><br></pre></td></tr></table></figure>\n<p>通过上述测试，我们可以知道，<code>1,2</code>  和 <code>3</code>取并集是 <code>1,2,3</code>。那么如何用代码实现呢？其实很简单，只需要新建一个集合，然后遍历两个集合的元素，并添加到新集合即可，新集合会自动过滤已经存在的元素，自然而然就得到了并集。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.union = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">otherSet</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> unionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> values = <span class=\"keyword\">this</span>.values();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; values.length; i++) &#123;</span><br><span class=\"line\">    unionSet.add(values[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  values = otherSet.values();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; values.length; i++) &#123;</span><br><span class=\"line\">    unionSet.add(values[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> unionSet;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-intersection-方法\"><a href=\"#实现-intersection-方法\" class=\"headerlink\" title=\"实现 intersection 方法\"></a>实现 intersection 方法</h3><p>实现 <code>intersection</code> 方法（和另一个集合取交集），跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">set.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">set.add(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">otherSet.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">otherSet.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> intersectionSet = set.intersection(otherSet);</span><br><span class=\"line\">expect(intersectionSet.values()).toEqual([<span class=\"string\">'2'</span>]);</span><br></pre></td></tr></table></figure>\n<p>上述测试代码，仅仅是将 <code>set</code> 和 <code>otherSet</code> 两个集合取交集，最终为 <code>2</code>。实现思路非常简单，只需要新建一个集合，然后遍历 <code>otherSet</code> 的元素，只要在 <code>set</code> 中存在就添加到新集合中，最后返回新集合。实现代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.intersection = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">otherSet</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> intersectionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> values = otherSet.values();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; values.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.has(values[i])) &#123;</span><br><span class=\"line\">      intersectionSet.add(values[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> intersectionSet;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-difference-方法\"><a href=\"#实现-difference-方法\" class=\"headerlink\" title=\"实现 difference 方法\"></a>实现 difference 方法</h3><p>实现 <code>difference</code> 方法（和另一个集合取差集），跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">set.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">set.add(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">otherSet.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">otherSet.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> differenceSet = set.difference(otherSet);</span><br><span class=\"line\">expect(differenceSet.values()).toEqual([<span class=\"string\">'1'</span>]);</span><br></pre></td></tr></table></figure>\n<p>上述测试代码仅仅是将 <code>set</code> 和 <code>otherSet</code> 两个集合取差集得到 <code>1</code>。实现思路非常简单，只需要新建一个集合，然后遍历 <code>set</code> 中的元素，如果元素不存在于 <code>otherSet</code> 中就添加到新集合中。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.difference = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">otherSet</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> differenceSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> values = <span class=\"keyword\">this</span>.values();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; values.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!otherSet.has(values[i])) &#123;</span><br><span class=\"line\">      differenceSet.add(values[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> differenceSet;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-subset-方法\"><a href=\"#实现-subset-方法\" class=\"headerlink\" title=\"实现 subset 方法\"></a>实现 subset 方法</h3><p>实现 <code>subset</code> 方法（判断是否是另一个集合的子集），跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">set.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">set.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">set.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">otherSet.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">otherSet.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(set.subset(otherSet)).toBeFalsy(); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">set.remove(<span class=\"number\">3</span>);</span><br><span class=\"line\">expect(set.subset(otherSet)).toBeFalsy();  <span class=\"comment\">// 断言二</span></span><br><span class=\"line\">set.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">expect(set.subset(otherSet)).toBeTruthy();  <span class=\"comment\">// 断言三</span></span><br></pre></td></tr></table></figure>\n<p>断言一判断 <code>1,2,3</code> 是否是 <code>2，3</code> 的子集，因为元素个数都比人家多，显然不是。断言二判断 <code>1，2</code> 是否是 <code>2,3</code> 的子集，因为 <code>1</code> 不在 <code>2,3</code> 中，所以也不是。断言四判断 <code>2</code> 是否是 <code>2,3</code> 的子集，显然是。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.subset = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">otherSet</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.size() &gt; otherSet.size()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> values = <span class=\"keyword\">this</span>.values();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; values.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!otherSet.has(values[i])) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>至此，集合类就完成了！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是数据结构与算法中的集合。</p>","more":"<h2 id=\"集合简介\"><a href=\"#集合简介\" class=\"headerlink\" title=\"集合简介\"></a>集合简介</h2><p>什么是集合？与栈、队列、链表这些<strong>顺序</strong>数据结构不同，集合是一种<strong>无序且唯一</strong>的数据结构。集合有什么用？在 Python 中，我经常使用集合来给数组去重：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>list(set([<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>]))</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n<p>当然，ES6中也实现了集合——Set，那么 JavaScript 集合风格的数组去重应该是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">remove_duplicates_es6</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> it = s.values();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(it);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>貌似没有  Python 简约，不过简约谁比得过 Python 呢？哈哈！JavaScript 中有了 Set 总比没有强。想更多地了解 Set，可以看 MDN 文档—— <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set\" target=\"_blank\" rel=\"noopener\">Set</a>。</p>\n<p>除此之外，我们还可以使用集合来执行并集、交集、差集、子集等操作。</p>\n<h2 id=\"用-JavaScript-编写集合类\"><a href=\"#用-JavaScript-编写集合类\" class=\"headerlink\" title=\"用 JavaScript 编写集合类\"></a>用 JavaScript 编写集合类</h2><p>尽管 ES6 已经实现了集合类——Set，不过我们还是自己写一个吧！</p>\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>为了存储无序且唯一的元素，我们使用一个对象 <code>items</code> 来作为私有变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Set</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，将每个元素作为该对象的键和值。比如，一个集合包含 <code>1,2</code> 两个元素，那么该集合的数据结构就应该是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">'1'</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"string\">'2'</span>: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就保证了集合元素的<strong>无序且唯一</strong>。</p>\n<h3 id=\"实现-has-、add、remove-方法\"><a href=\"#实现-has-、add、remove-方法\" class=\"headerlink\" title=\"实现 has 、add、remove 方法\"></a>实现 has 、add、remove 方法</h3><p>实现 <code>has</code> 方法（即判断集合中是否存在指定元素）、<code>add</code> 方法（向集合中添加不存在的元素）、<code>remove</code> 方法（删除集合中存在的元素），可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">expect(set.add(<span class=\"number\">1</span>)).toBeTruthy(); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">expect(set.add(<span class=\"number\">1</span>)).toBeFalsy(); <span class=\"comment\">// 断言二</span></span><br><span class=\"line\">expect(set.add(<span class=\"number\">2</span>)).toBeTruthy(); <span class=\"comment\">// 断言三</span></span><br><span class=\"line\"></span><br><span class=\"line\">expect(set.has(<span class=\"number\">1</span>)).toBeTruthy(); <span class=\"comment\">// 断言四</span></span><br><span class=\"line\">expect(set.has(<span class=\"number\">3</span>)).toBeFalsy(); <span class=\"comment\">// 断言五</span></span><br><span class=\"line\"></span><br><span class=\"line\">expect(set.remove(<span class=\"number\">1</span>)).toBeTruthy(); <span class=\"comment\">// 断言六</span></span><br><span class=\"line\">expect(set.remove(<span class=\"number\">1</span>)).toBeFalsy(); <span class=\"comment\">// 断言七</span></span><br></pre></td></tr></table></figure>\n<p>上述测试代码中的七个断言都需要判断元素是否存在于集合中。那么如何判断元素是否存在于集合中呢？答案是使用 <code>hasOwnProperty</code> 方法。</p>\n<blockquote>\n<p><code>hasOwnProperty</code> 这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。更多的用法可以参考 MDN 文档——<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\" target=\"_blank\" rel=\"noopener\">Object.prototype.hasOwnProperty()</a></p>\n</blockquote>\n<p>通过 <code>hasOwnProperty</code> 方法我们可以轻易实现 <code>has</code> 方法。有了 <code>has</code> 方法，<code>add</code> 和 <code>remove</code> 方法仅仅就是一个条件判断和给对象 <code>items</code> 赋值的简单问题了。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.has = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> items.hasOwnProperty(value); <span class=\"comment\">// &#123;1&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.has(value)) &#123;</span><br><span class=\"line\">    items[value] = value;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.remove = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.has(value)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> items[value];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-size-和-values-方法\"><a href=\"#实现-size-和-values-方法\" class=\"headerlink\" title=\"实现 size 和 values 方法\"></a>实现 size 和 values 方法</h3><p>实现 <code>size</code> 方法（返回集合元素个数）和 <code>values</code> 方法（返回集合所有值），跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">set.add(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(set.size()).toBe(<span class=\"number\">1</span>); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">expect(set.values()).toEqual([<span class=\"string\">'2'</span>]); <span class=\"comment\">// 断言二</span></span><br></pre></td></tr></table></figure>\n<p>断言一返回集合元素个数，断言二以数组形式返回所有值。为了实现这个需求，我们需要使用 <code>Object.keys()</code> 方法来获取对象的属性。</p>\n<blockquote>\n<p><code>Object.keys()</code> 方法会返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用 for-in 循环遍历该对象时返回的顺序一致 (顺序一致不包括数字属性)（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。更多的用法请参考 MDN 文档——<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" target=\"_blank\" rel=\"noopener\"> Object.keys()</a>。</p>\n</blockquote>\n<p>所以编写的代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.size = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(items).length;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.values = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(items);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-union-方法\"><a href=\"#实现-union-方法\" class=\"headerlink\" title=\"实现 union 方法\"></a>实现 union 方法</h3><p>实现 <code>union</code> 方法（和另一个集合取并集），跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">set.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">set.add(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">otherSet.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> unionSet = set.union(otherSet);</span><br><span class=\"line\">expect(unionSet.values()).toEqual([<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>]);</span><br></pre></td></tr></table></figure>\n<p>通过上述测试，我们可以知道，<code>1,2</code>  和 <code>3</code>取并集是 <code>1,2,3</code>。那么如何用代码实现呢？其实很简单，只需要新建一个集合，然后遍历两个集合的元素，并添加到新集合即可，新集合会自动过滤已经存在的元素，自然而然就得到了并集。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.union = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">otherSet</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> unionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> values = <span class=\"keyword\">this</span>.values();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; values.length; i++) &#123;</span><br><span class=\"line\">    unionSet.add(values[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  values = otherSet.values();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; values.length; i++) &#123;</span><br><span class=\"line\">    unionSet.add(values[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> unionSet;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-intersection-方法\"><a href=\"#实现-intersection-方法\" class=\"headerlink\" title=\"实现 intersection 方法\"></a>实现 intersection 方法</h3><p>实现 <code>intersection</code> 方法（和另一个集合取交集），跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">set.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">set.add(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">otherSet.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">otherSet.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> intersectionSet = set.intersection(otherSet);</span><br><span class=\"line\">expect(intersectionSet.values()).toEqual([<span class=\"string\">'2'</span>]);</span><br></pre></td></tr></table></figure>\n<p>上述测试代码，仅仅是将 <code>set</code> 和 <code>otherSet</code> 两个集合取交集，最终为 <code>2</code>。实现思路非常简单，只需要新建一个集合，然后遍历 <code>otherSet</code> 的元素，只要在 <code>set</code> 中存在就添加到新集合中，最后返回新集合。实现代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.intersection = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">otherSet</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> intersectionSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> values = otherSet.values();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; values.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.has(values[i])) &#123;</span><br><span class=\"line\">      intersectionSet.add(values[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> intersectionSet;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-difference-方法\"><a href=\"#实现-difference-方法\" class=\"headerlink\" title=\"实现 difference 方法\"></a>实现 difference 方法</h3><p>实现 <code>difference</code> 方法（和另一个集合取差集），跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">set.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">set.add(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">otherSet.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">otherSet.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> differenceSet = set.difference(otherSet);</span><br><span class=\"line\">expect(differenceSet.values()).toEqual([<span class=\"string\">'1'</span>]);</span><br></pre></td></tr></table></figure>\n<p>上述测试代码仅仅是将 <code>set</code> 和 <code>otherSet</code> 两个集合取差集得到 <code>1</code>。实现思路非常简单，只需要新建一个集合，然后遍历 <code>set</code> 中的元素，如果元素不存在于 <code>otherSet</code> 中就添加到新集合中。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.difference = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">otherSet</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> differenceSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> values = <span class=\"keyword\">this</span>.values();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; values.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!otherSet.has(values[i])) &#123;</span><br><span class=\"line\">      differenceSet.add(values[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> differenceSet;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-subset-方法\"><a href=\"#实现-subset-方法\" class=\"headerlink\" title=\"实现 subset 方法\"></a>实现 subset 方法</h3><p>实现 <code>subset</code> 方法（判断是否是另一个集合的子集），跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">set.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">set.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">set.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">otherSet.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">otherSet.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(set.subset(otherSet)).toBeFalsy(); <span class=\"comment\">// 断言一</span></span><br><span class=\"line\">set.remove(<span class=\"number\">3</span>);</span><br><span class=\"line\">expect(set.subset(otherSet)).toBeFalsy();  <span class=\"comment\">// 断言二</span></span><br><span class=\"line\">set.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">expect(set.subset(otherSet)).toBeTruthy();  <span class=\"comment\">// 断言三</span></span><br></pre></td></tr></table></figure>\n<p>断言一判断 <code>1,2,3</code> 是否是 <code>2，3</code> 的子集，因为元素个数都比人家多，显然不是。断言二判断 <code>1，2</code> 是否是 <code>2,3</code> 的子集，因为 <code>1</code> 不在 <code>2,3</code> 中，所以也不是。断言四判断 <code>2</code> 是否是 <code>2,3</code> 的子集，显然是。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.subset = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">otherSet</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.size() &gt; otherSet.size()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> values = <span class=\"keyword\">this</span>.values();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; values.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!otherSet.has(values[i])) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>至此，集合类就完成了！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>"},{"title":"JavaScript 版数据结构与算法（九）排序和搜索","date":"2017-02-20T02:39:00.000Z","_content":"\n今天，我们要讲的是一些基础的排序和搜索算法。\n\n<!--more-->\n\n## 编写 ArrayList 类\n\n在讲解排序和搜索算法前，我们先编写一个 `ArrayList` 类，使其包含私有变量 `array`，用于盛放数组，同时还包含 `insert` 和 `toString` 方法可以插入和转化为字符串。如此一来，当后面我们讲解各种排序和搜索算法时就可以很方便地设置输入输出来测试了。\n\n```js\nfunction ArrayList() {\n\n  var array = [];\n\n  this.insert = function (item) {\n    array.push(item);\n  };\n\n  this.toString = function () {\n    return array.toString();\n  };\n}\n```\n\n## 冒泡排序\n\n冒泡排序是排序中最简单的一种，不过它的性能并不好（时间复杂度为O(n^2)）。面试官有时候为了缓解面试的紧张气氛，会让应聘者手写冒泡排序算法。\n\n那么冒泡排序的思路是什么？其实就是每轮从头到尾比较相邻两个数并选择性交换（但是每次的最后一项在下一次就不用参与了，因为已经在正确的位置上了），然后执行 n-1 轮。比如对这个数组进行冒泡排序：\n\n```\n1 3 5 4 2\n```\n那么实现过程记录如下：\n\n第一轮\n```\n1 3 5 4 2  // 1<3 不交换\n1 3 5 4 2  // 3<5 不交换\n1 3 4 5 2  // 5>4 交换\n1 3 4 2 5  // 5>2 交换\n```\n\n第二轮\n```\n1 3 4 2 5  // 1<3 不交换\n1 3 4 2 5  // 3<4 不交换\n1 3 2 4 5  // 4>2 不交换\n```\n\n第三轮\n\n```\n1 3 2 4 5  // 1<3 不交换\n1 2 3 4 5  // 3>2 交换\n```\n\n第四轮\n\n```\n1 2 3 4 5  // 1<2 不交换\n```\n\n用代码实现就是：\n\n```js\nvar swap = function (index1, index2) {\n  var aux = array[index1];\n  array[index1] = array[index2];\n  array[index2] = aux;\n};\n\nthis.bubbleSort = function () {\n  var length = array.length;\n  for (var i = 0; i < length; i++) {  // 执行 n-1 轮\n    for (var j = 0; j < length - 1 - i; j++) {  // 每轮（i）比较 n - i 个数 \n      if (array[j] > array[j + 1]) {\n        swap(j, j + 1);\n      }\n    }\n  }\n};\n```\n\n冒泡排序非常简单，唯一需要注意的就是边界的设置，你可以先使用5或3个数来假设一下，这样可以轻松算出边界。\n\n测试代码：\n\n```js\nfunction createNonSortedArray() {\n  var array = new ArrayList();\n  array.insert(1);\n  array.insert(3);\n  array.insert(5);\n  array.insert(4);\n  array.insert(2);\n  return array;\n}\n\nvar array = createNonSortedArray();\nexpect(array.toString()).toBe('1,3,5,4,2');\narray.bubbleSort();\nexpect(array.toString()).toBe('1,2,3,4,5');\n```\n\n## 选择排序\n\n选择排序也是一种简单但性能（O(n^2)）一般的排序算法。在所有的**完全依靠交换去移动元素**的排序方法中，选择排序属于非常好的一种。选择排序的实现思路是：找到数据结构中的最小值，**选**中它并将其放置在第一位，接着找到第二小的值，**选**中它并将其放置在第二位，以此类推。\n\n比如对一个这样的数组进行排序：\n\n```\n1 3 5 4 2\n```\n\n那么第一轮：\n\n```\n1 3 5 4 2  // 找出最小值1和第一位的1交换，相同的话可以省去交换过程\n```\n\n第二轮：\n\n```\n1 2 5 4 3  // 找出第二小值2和第二位的3交换\n```\n\n第三轮：\n\n```\n1 2 3 4 5  // 找出第三小值3和第三位的5交换\n```\n\n第四轮\n\n```\n1 2 3 4 5  // 找出第四小值4和第四位的4交换，相同的话可以省去交换过程\n```\n\n那么代码的编写无法就是两个循环：\n\n- 循环得到最小值\n- 循环将最小值交换到指定位置\n\n实现代码如下：\n\n```js\nthis.selectionSort = function () {\n  var length = array.length,\n    indexMin;\n\n  for (var i = 0; i < length - 1; i++) {  // 循环将最小值交换到指定位置\n    indexMin = i;\n    for (var j = i; j < length; j++) {  // 循环得到最小值\n      if (array[indexMin] > array[j]) {\n        indexMin = j;\n      }\n    }\n    if (i !== indexMin) {\n      swap(i, indexMin);\n    }\n  }\n};\n```\n\n注意边界的设置！测试代码如下：\n\n```js\narray = createNonSortedArray();\nexpect(array.toString()).toBe('1,3,5,4,2');\narray.selectionSort();\nexpect(array.toString()).toBe('1,2,3,4,5');\n```\n\n## 插入排序\n\n虽然插入排序的复杂度也是O(n^2)，但排序**小型数组**时，此算法比选择排序和冒泡排序性能要好。插入排序的实现思路是：从第二个数开始往前比，比它大就往后排，依次进行到最后一个数。就好比是上学时排队，本来瞎胡排一队，然后老师说按个子高低排：\n\n- 第二个同学看看第一个同学，觉得比自己高，就说：“你个子高还站前面！后面去！”，然后**插**到他前面。\n- 第三个同学，先后看了第二个、第一个同学，觉得都比自己高，就**插**到第一个了。\n- 以此类推到最后一个同学。\n\n拿个数组做演示吧！比如对下面这个数组排序：\n\n```\n3 5 1 4 2\n```\n\n第一轮：\n\n```\n3 5 1 4 2  // 5>3，不插队\n```\n\n第二轮：\n\n```\n1 3 5 4 2  // 1<5，插队，1<3，再插队\n```\n\n第三轮：\n\n```\n1 3 4 5 2  // 4<5，插队，4>3，不插队\n```\n\n第四轮：\n\n```\n1 2 3 4 5  // 2<5，插队，2>4，插队，2<3，不插队\n```\n\n注意，只要第一次遇到较小的数，就不用再比较了，也就是说，如果第一次不插队，就不用再往前比了，因为前面都是更小的。所以代码实现是：\n\n```js\nthis.insertionSort = function () {\n  var length = array.length,\n    j, temp;\n  for (var i = 1; i < length; i++) {  // 从第二个开始比\n    temp = array[i];\n    j = i;\n    while (j > 0 && array[j - 1] > temp) { // 比完或遇到较小数就不用比了\n      array[j] = array[j - 1];\n      j--;\n    } \n    array[j] = temp;  // 插队！！！\n  }\n};\n```\n测试代码如下：\n\n```js\narray = createNonSortedArray(5);\nexpect(array.toString()).toBe('5,4,3,2,1');\narray.insertionSort();\nexpect(array.toString()).toBe('1,2,3,4,5');\n```\n\n## 归并排序\n\n归并排序的性能比前三个排序算法都要好，时间复杂度为O( nlogn )，而且 Mozilla Firefox 使用了归并排序作为 `Array.prototype.sort` 的实现（但 Chrome 使用的是快速排序）。那么归并排序的思路是什么呢？简单来说，就是先分再合。\n\n比如对这样的数组进行排序：\n\n```\n13542\n```\n\n分：\n\n```\n13 542\n```\n\n再分：\n\n```\n13 5 42\n```\n\n再分：\n\n```\n1 3 5 4 2\n```\n\n合：\n\n```\n13 5 24\n```\n\n再合：\n\n```\n13 245\n```\n\n再合：\n\n```\n12345\n```\n\n**分** 这个过程需要用到递归，对原数组分割，再对子数组做同样的事，终止条件是数组只有一项了，然后对这些数组进行合并，**合**这个过程主要是将两个数组合并的同时进行排序。所以，实现代码如下：\n\n```js\nvar mergeSortRec = function (array) {\n  var merge = function (left, right) {  // 合\n    var final = [];\n    while (left.length && right.length)\n      final.push(left[0] <= right[0] ? left.shift() : right.shift());\n    return final.concat(left.concat(right));\n  };\n  \n  var length = array.length;\n  if (length === 1) {\n    return array;\n  }\n  var mid = Math.floor(length / 2),  // 分\n    left = array.slice(0, mid),\n    right = array.slice(mid, length);\n  return merge(mergeSortRec(left), mergeSortRec(right));  // 递归\n};\n\nthis.mergeSort = function () {\n  array = mergeSortRec(array);\n};\n```\n测试代码如下：\n\n```js\narray = createNonSortedArray();\nexpect(array.toString()).toBe('1,3,5,4,2');\narray.insertionSort();\nexpect(array.toString()).toBe('1,2,3,4,5');\n```\n\n## 快速排序\n\n快速排序又称划分交换排序，是一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 Ο(n log n) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。\n\n快速排序的实现思路是：\n\n- 从数列中挑出一个元素，称为\"基准\"（pivot）。\n- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。\n- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n选择基准可以用第一项，也可以随机选择或选择中间一项。我们选择第一项！不过注意，研究表明选择第一项作为基准对几乎已经排序的数组并不适合，会导致性能最差。\n\n比如对这样的数组进行排序：\n\n```\n35142\n```\n\n那么第一轮：\n\n```\n// 对 35142 进行快排，left 为 21，基准是 3，right 为 45\n21 3 45\n```\n\n第二轮：\n\n```\n// 对 21 进行快排，left 为 1，基准是 2，right 为空\n1 2 3 45\n```\n\n第三轮：\n\n```\n// 对 45 进行快排，left 为空，基准是 4，right 为 5\n1 2 3 4 5\n```\n\n所以代码实现的核心就是：\n\n- 找基准\n- 找左右数组\n- 将左右数组和基准合并\n- 对左右子数组重复上述操作\n\n实现代码如下：\n\n```js  \nvar quick = function (array) {\n  var length = array.length;\n  if (length <= 1)\n    return array.slice(0);\n  var left = [];\n  var right = [];\n  var mid = [array[0]];\n  for (var i = 1; i < length; i++) {\n    if (array[i] < mid[0])\n      left.push(array[i]);\n    else\n      right.push(array[i]);\n  }\n  return quick(left).concat(mid.concat(quick(right)));\n};\n\nthis.quickSort = function () {\n  array = quick(array);\n};\n```\n\n## 顺序搜索\n\n排序算法讲完了，我们来看搜索算法，最基本的搜索算法是顺序搜索：将每一个数据结构中的元素和我们要找的元素做比较。这种算法非常低效（时间复杂度为O(n)），不过比较简单，可以用来缓解面试紧张气氛。实现代码如下：\n\n```js\nthis.sequentialSearch = function (item) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] === item) {\n      return i;\n    }\n  }\n  return -1;\n};\n```\n\n## 二分搜索\n\n在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是一种在**有序数组**中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。它的时间复杂度是 O(log(n))。\n\n代码编写的要诀是：不断改变最小值、最大值和中间值，直到中间值为被查找的值。\n\n```js\nthis.binarySearch = function (item) {\n  this.quickSort();\n\n  var low = 0,\n    high = array.length - 1,\n    mid, element;\n\n  while (low <= high) {\n    mid = Math.floor((low + high) / 2);\n    element = array[mid];\n    if (element < item) {\n      low = mid + 1;\n    } else if (element > item) {\n      high = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n};\n```\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","source":"_posts/sort-and-search.md","raw":"---\ntitle: JavaScript 版数据结构与算法（九）排序和搜索\ndate: 2017-02-20 10:39:00\ntags: [数据结构与算法]\n---\n\n今天，我们要讲的是一些基础的排序和搜索算法。\n\n<!--more-->\n\n## 编写 ArrayList 类\n\n在讲解排序和搜索算法前，我们先编写一个 `ArrayList` 类，使其包含私有变量 `array`，用于盛放数组，同时还包含 `insert` 和 `toString` 方法可以插入和转化为字符串。如此一来，当后面我们讲解各种排序和搜索算法时就可以很方便地设置输入输出来测试了。\n\n```js\nfunction ArrayList() {\n\n  var array = [];\n\n  this.insert = function (item) {\n    array.push(item);\n  };\n\n  this.toString = function () {\n    return array.toString();\n  };\n}\n```\n\n## 冒泡排序\n\n冒泡排序是排序中最简单的一种，不过它的性能并不好（时间复杂度为O(n^2)）。面试官有时候为了缓解面试的紧张气氛，会让应聘者手写冒泡排序算法。\n\n那么冒泡排序的思路是什么？其实就是每轮从头到尾比较相邻两个数并选择性交换（但是每次的最后一项在下一次就不用参与了，因为已经在正确的位置上了），然后执行 n-1 轮。比如对这个数组进行冒泡排序：\n\n```\n1 3 5 4 2\n```\n那么实现过程记录如下：\n\n第一轮\n```\n1 3 5 4 2  // 1<3 不交换\n1 3 5 4 2  // 3<5 不交换\n1 3 4 5 2  // 5>4 交换\n1 3 4 2 5  // 5>2 交换\n```\n\n第二轮\n```\n1 3 4 2 5  // 1<3 不交换\n1 3 4 2 5  // 3<4 不交换\n1 3 2 4 5  // 4>2 不交换\n```\n\n第三轮\n\n```\n1 3 2 4 5  // 1<3 不交换\n1 2 3 4 5  // 3>2 交换\n```\n\n第四轮\n\n```\n1 2 3 4 5  // 1<2 不交换\n```\n\n用代码实现就是：\n\n```js\nvar swap = function (index1, index2) {\n  var aux = array[index1];\n  array[index1] = array[index2];\n  array[index2] = aux;\n};\n\nthis.bubbleSort = function () {\n  var length = array.length;\n  for (var i = 0; i < length; i++) {  // 执行 n-1 轮\n    for (var j = 0; j < length - 1 - i; j++) {  // 每轮（i）比较 n - i 个数 \n      if (array[j] > array[j + 1]) {\n        swap(j, j + 1);\n      }\n    }\n  }\n};\n```\n\n冒泡排序非常简单，唯一需要注意的就是边界的设置，你可以先使用5或3个数来假设一下，这样可以轻松算出边界。\n\n测试代码：\n\n```js\nfunction createNonSortedArray() {\n  var array = new ArrayList();\n  array.insert(1);\n  array.insert(3);\n  array.insert(5);\n  array.insert(4);\n  array.insert(2);\n  return array;\n}\n\nvar array = createNonSortedArray();\nexpect(array.toString()).toBe('1,3,5,4,2');\narray.bubbleSort();\nexpect(array.toString()).toBe('1,2,3,4,5');\n```\n\n## 选择排序\n\n选择排序也是一种简单但性能（O(n^2)）一般的排序算法。在所有的**完全依靠交换去移动元素**的排序方法中，选择排序属于非常好的一种。选择排序的实现思路是：找到数据结构中的最小值，**选**中它并将其放置在第一位，接着找到第二小的值，**选**中它并将其放置在第二位，以此类推。\n\n比如对一个这样的数组进行排序：\n\n```\n1 3 5 4 2\n```\n\n那么第一轮：\n\n```\n1 3 5 4 2  // 找出最小值1和第一位的1交换，相同的话可以省去交换过程\n```\n\n第二轮：\n\n```\n1 2 5 4 3  // 找出第二小值2和第二位的3交换\n```\n\n第三轮：\n\n```\n1 2 3 4 5  // 找出第三小值3和第三位的5交换\n```\n\n第四轮\n\n```\n1 2 3 4 5  // 找出第四小值4和第四位的4交换，相同的话可以省去交换过程\n```\n\n那么代码的编写无法就是两个循环：\n\n- 循环得到最小值\n- 循环将最小值交换到指定位置\n\n实现代码如下：\n\n```js\nthis.selectionSort = function () {\n  var length = array.length,\n    indexMin;\n\n  for (var i = 0; i < length - 1; i++) {  // 循环将最小值交换到指定位置\n    indexMin = i;\n    for (var j = i; j < length; j++) {  // 循环得到最小值\n      if (array[indexMin] > array[j]) {\n        indexMin = j;\n      }\n    }\n    if (i !== indexMin) {\n      swap(i, indexMin);\n    }\n  }\n};\n```\n\n注意边界的设置！测试代码如下：\n\n```js\narray = createNonSortedArray();\nexpect(array.toString()).toBe('1,3,5,4,2');\narray.selectionSort();\nexpect(array.toString()).toBe('1,2,3,4,5');\n```\n\n## 插入排序\n\n虽然插入排序的复杂度也是O(n^2)，但排序**小型数组**时，此算法比选择排序和冒泡排序性能要好。插入排序的实现思路是：从第二个数开始往前比，比它大就往后排，依次进行到最后一个数。就好比是上学时排队，本来瞎胡排一队，然后老师说按个子高低排：\n\n- 第二个同学看看第一个同学，觉得比自己高，就说：“你个子高还站前面！后面去！”，然后**插**到他前面。\n- 第三个同学，先后看了第二个、第一个同学，觉得都比自己高，就**插**到第一个了。\n- 以此类推到最后一个同学。\n\n拿个数组做演示吧！比如对下面这个数组排序：\n\n```\n3 5 1 4 2\n```\n\n第一轮：\n\n```\n3 5 1 4 2  // 5>3，不插队\n```\n\n第二轮：\n\n```\n1 3 5 4 2  // 1<5，插队，1<3，再插队\n```\n\n第三轮：\n\n```\n1 3 4 5 2  // 4<5，插队，4>3，不插队\n```\n\n第四轮：\n\n```\n1 2 3 4 5  // 2<5，插队，2>4，插队，2<3，不插队\n```\n\n注意，只要第一次遇到较小的数，就不用再比较了，也就是说，如果第一次不插队，就不用再往前比了，因为前面都是更小的。所以代码实现是：\n\n```js\nthis.insertionSort = function () {\n  var length = array.length,\n    j, temp;\n  for (var i = 1; i < length; i++) {  // 从第二个开始比\n    temp = array[i];\n    j = i;\n    while (j > 0 && array[j - 1] > temp) { // 比完或遇到较小数就不用比了\n      array[j] = array[j - 1];\n      j--;\n    } \n    array[j] = temp;  // 插队！！！\n  }\n};\n```\n测试代码如下：\n\n```js\narray = createNonSortedArray(5);\nexpect(array.toString()).toBe('5,4,3,2,1');\narray.insertionSort();\nexpect(array.toString()).toBe('1,2,3,4,5');\n```\n\n## 归并排序\n\n归并排序的性能比前三个排序算法都要好，时间复杂度为O( nlogn )，而且 Mozilla Firefox 使用了归并排序作为 `Array.prototype.sort` 的实现（但 Chrome 使用的是快速排序）。那么归并排序的思路是什么呢？简单来说，就是先分再合。\n\n比如对这样的数组进行排序：\n\n```\n13542\n```\n\n分：\n\n```\n13 542\n```\n\n再分：\n\n```\n13 5 42\n```\n\n再分：\n\n```\n1 3 5 4 2\n```\n\n合：\n\n```\n13 5 24\n```\n\n再合：\n\n```\n13 245\n```\n\n再合：\n\n```\n12345\n```\n\n**分** 这个过程需要用到递归，对原数组分割，再对子数组做同样的事，终止条件是数组只有一项了，然后对这些数组进行合并，**合**这个过程主要是将两个数组合并的同时进行排序。所以，实现代码如下：\n\n```js\nvar mergeSortRec = function (array) {\n  var merge = function (left, right) {  // 合\n    var final = [];\n    while (left.length && right.length)\n      final.push(left[0] <= right[0] ? left.shift() : right.shift());\n    return final.concat(left.concat(right));\n  };\n  \n  var length = array.length;\n  if (length === 1) {\n    return array;\n  }\n  var mid = Math.floor(length / 2),  // 分\n    left = array.slice(0, mid),\n    right = array.slice(mid, length);\n  return merge(mergeSortRec(left), mergeSortRec(right));  // 递归\n};\n\nthis.mergeSort = function () {\n  array = mergeSortRec(array);\n};\n```\n测试代码如下：\n\n```js\narray = createNonSortedArray();\nexpect(array.toString()).toBe('1,3,5,4,2');\narray.insertionSort();\nexpect(array.toString()).toBe('1,2,3,4,5');\n```\n\n## 快速排序\n\n快速排序又称划分交换排序，是一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 Ο(n log n) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。\n\n快速排序的实现思路是：\n\n- 从数列中挑出一个元素，称为\"基准\"（pivot）。\n- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。\n- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n选择基准可以用第一项，也可以随机选择或选择中间一项。我们选择第一项！不过注意，研究表明选择第一项作为基准对几乎已经排序的数组并不适合，会导致性能最差。\n\n比如对这样的数组进行排序：\n\n```\n35142\n```\n\n那么第一轮：\n\n```\n// 对 35142 进行快排，left 为 21，基准是 3，right 为 45\n21 3 45\n```\n\n第二轮：\n\n```\n// 对 21 进行快排，left 为 1，基准是 2，right 为空\n1 2 3 45\n```\n\n第三轮：\n\n```\n// 对 45 进行快排，left 为空，基准是 4，right 为 5\n1 2 3 4 5\n```\n\n所以代码实现的核心就是：\n\n- 找基准\n- 找左右数组\n- 将左右数组和基准合并\n- 对左右子数组重复上述操作\n\n实现代码如下：\n\n```js  \nvar quick = function (array) {\n  var length = array.length;\n  if (length <= 1)\n    return array.slice(0);\n  var left = [];\n  var right = [];\n  var mid = [array[0]];\n  for (var i = 1; i < length; i++) {\n    if (array[i] < mid[0])\n      left.push(array[i]);\n    else\n      right.push(array[i]);\n  }\n  return quick(left).concat(mid.concat(quick(right)));\n};\n\nthis.quickSort = function () {\n  array = quick(array);\n};\n```\n\n## 顺序搜索\n\n排序算法讲完了，我们来看搜索算法，最基本的搜索算法是顺序搜索：将每一个数据结构中的元素和我们要找的元素做比较。这种算法非常低效（时间复杂度为O(n)），不过比较简单，可以用来缓解面试紧张气氛。实现代码如下：\n\n```js\nthis.sequentialSearch = function (item) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] === item) {\n      return i;\n    }\n  }\n  return -1;\n};\n```\n\n## 二分搜索\n\n在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是一种在**有序数组**中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。它的时间复杂度是 O(log(n))。\n\n代码编写的要诀是：不断改变最小值、最大值和中间值，直到中间值为被查找的值。\n\n```js\nthis.binarySearch = function (item) {\n  this.quickSort();\n\n  var low = 0,\n    high = array.length - 1,\n    mid, element;\n\n  while (low <= high) {\n    mid = Math.floor((low + high) / 2);\n    element = array[mid];\n    if (element < item) {\n      low = mid + 1;\n    } else if (element > item) {\n      high = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n};\n```\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","slug":"sort-and-search","published":1,"updated":"2019-05-01T08:02:12.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmu003etgytyvqop8o2","content":"<p>今天，我们要讲的是一些基础的排序和搜索算法。</p>\n<a id=\"more\"></a>\n<h2 id=\"编写-ArrayList-类\"><a href=\"#编写-ArrayList-类\" class=\"headerlink\" title=\"编写 ArrayList 类\"></a>编写 ArrayList 类</h2><p>在讲解排序和搜索算法前，我们先编写一个 <code>ArrayList</code> 类，使其包含私有变量 <code>array</code>，用于盛放数组，同时还包含 <code>insert</code> 和 <code>toString</code> 方法可以插入和转化为字符串。如此一来，当后面我们讲解各种排序和搜索算法时就可以很方便地设置输入输出来测试了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ArrayList</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> array = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.insert = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">    array.push(item);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array.toString();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡排序是排序中最简单的一种，不过它的性能并不好（时间复杂度为O(n^2)）。面试官有时候为了缓解面试的紧张气氛，会让应聘者手写冒泡排序算法。</p>\n<p>那么冒泡排序的思路是什么？其实就是每轮从头到尾比较相邻两个数并选择性交换（但是每次的最后一项在下一次就不用参与了，因为已经在正确的位置上了），然后执行 n-1 轮。比如对这个数组进行冒泡排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 5 4 2</span><br></pre></td></tr></table></figure>\n<p>那么实现过程记录如下：</p>\n<p>第一轮<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 5 4 2  // 1&lt;3 不交换</span><br><span class=\"line\">1 3 5 4 2  // 3&lt;5 不交换</span><br><span class=\"line\">1 3 4 5 2  // 5&gt;4 交换</span><br><span class=\"line\">1 3 4 2 5  // 5&gt;2 交换</span><br></pre></td></tr></table></figure></p>\n<p>第二轮<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 4 2 5  // 1&lt;3 不交换</span><br><span class=\"line\">1 3 4 2 5  // 3&lt;4 不交换</span><br><span class=\"line\">1 3 2 4 5  // 4&gt;2 不交换</span><br></pre></td></tr></table></figure></p>\n<p>第三轮</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 2 4 5  // 1&lt;3 不交换</span><br><span class=\"line\">1 2 3 4 5  // 3&gt;2 交换</span><br></pre></td></tr></table></figure>\n<p>第四轮</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 3 4 5  // 1&lt;2 不交换</span><br></pre></td></tr></table></figure>\n<p>用代码实现就是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> swap = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">index1, index2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> aux = array[index1];</span><br><span class=\"line\">  array[index1] = array[index2];</span><br><span class=\"line\">  array[index2] = aux;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.bubbleSort = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = array.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;  <span class=\"comment\">// 执行 n-1 轮</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span> - i; j++) &#123;  <span class=\"comment\">// 每轮（i）比较 n - i 个数 </span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (array[j] &gt; array[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>冒泡排序非常简单，唯一需要注意的就是边界的设置，你可以先使用5或3个数来假设一下，这样可以轻松算出边界。</p>\n<p>测试代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createNonSortedArray</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> array = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">  array.insert(<span class=\"number\">1</span>);</span><br><span class=\"line\">  array.insert(<span class=\"number\">3</span>);</span><br><span class=\"line\">  array.insert(<span class=\"number\">5</span>);</span><br><span class=\"line\">  array.insert(<span class=\"number\">4</span>);</span><br><span class=\"line\">  array.insert(<span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> array = createNonSortedArray();</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'1,3,5,4,2'</span>);</span><br><span class=\"line\">array.bubbleSort();</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'1,2,3,4,5'</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>选择排序也是一种简单但性能（O(n^2)）一般的排序算法。在所有的<strong>完全依靠交换去移动元素</strong>的排序方法中，选择排序属于非常好的一种。选择排序的实现思路是：找到数据结构中的最小值，<strong>选</strong>中它并将其放置在第一位，接着找到第二小的值，<strong>选</strong>中它并将其放置在第二位，以此类推。</p>\n<p>比如对一个这样的数组进行排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 5 4 2</span><br></pre></td></tr></table></figure>\n<p>那么第一轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 5 4 2  // 找出最小值1和第一位的1交换，相同的话可以省去交换过程</span><br></pre></td></tr></table></figure>\n<p>第二轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 5 4 3  // 找出第二小值2和第二位的3交换</span><br></pre></td></tr></table></figure>\n<p>第三轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 3 4 5  // 找出第三小值3和第三位的5交换</span><br></pre></td></tr></table></figure>\n<p>第四轮</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 3 4 5  // 找出第四小值4和第四位的4交换，相同的话可以省去交换过程</span><br></pre></td></tr></table></figure>\n<p>那么代码的编写无法就是两个循环：</p>\n<ul>\n<li>循环得到最小值</li>\n<li>循环将最小值交换到指定位置</li>\n</ul>\n<p>实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.selectionSort = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = array.length,</span><br><span class=\"line\">    indexMin;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;  <span class=\"comment\">// 循环将最小值交换到指定位置</span></span><br><span class=\"line\">    indexMin = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i; j &lt; length; j++) &#123;  <span class=\"comment\">// 循环得到最小值</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (array[indexMin] &gt; array[j]) &#123;</span><br><span class=\"line\">        indexMin = j;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i !== indexMin) &#123;</span><br><span class=\"line\">      swap(i, indexMin);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意边界的设置！测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array = createNonSortedArray();</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'1,3,5,4,2'</span>);</span><br><span class=\"line\">array.selectionSort();</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'1,2,3,4,5'</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>虽然插入排序的复杂度也是O(n^2)，但排序<strong>小型数组</strong>时，此算法比选择排序和冒泡排序性能要好。插入排序的实现思路是：从第二个数开始往前比，比它大就往后排，依次进行到最后一个数。就好比是上学时排队，本来瞎胡排一队，然后老师说按个子高低排：</p>\n<ul>\n<li>第二个同学看看第一个同学，觉得比自己高，就说：“你个子高还站前面！后面去！”，然后<strong>插</strong>到他前面。</li>\n<li>第三个同学，先后看了第二个、第一个同学，觉得都比自己高，就<strong>插</strong>到第一个了。</li>\n<li>以此类推到最后一个同学。</li>\n</ul>\n<p>拿个数组做演示吧！比如对下面这个数组排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 5 1 4 2</span><br></pre></td></tr></table></figure>\n<p>第一轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 5 1 4 2  // 5&gt;3，不插队</span><br></pre></td></tr></table></figure>\n<p>第二轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 5 4 2  // 1&lt;5，插队，1&lt;3，再插队</span><br></pre></td></tr></table></figure>\n<p>第三轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 4 5 2  // 4&lt;5，插队，4&gt;3，不插队</span><br></pre></td></tr></table></figure>\n<p>第四轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 3 4 5  // 2&lt;5，插队，2&gt;4，插队，2&lt;3，不插队</span><br></pre></td></tr></table></figure>\n<p>注意，只要第一次遇到较小的数，就不用再比较了，也就是说，如果第一次不插队，就不用再往前比了，因为前面都是更小的。所以代码实现是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.insertionSort = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = array.length,</span><br><span class=\"line\">    j, temp;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; length; i++) &#123;  <span class=\"comment\">// 从第二个开始比</span></span><br><span class=\"line\">    temp = array[i];</span><br><span class=\"line\">    j = i;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; array[j - <span class=\"number\">1</span>] &gt; temp) &#123; <span class=\"comment\">// 比完或遇到较小数就不用比了</span></span><br><span class=\"line\">      array[j] = array[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    array[j] = temp;  <span class=\"comment\">// 插队！！！</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array = createNonSortedArray(<span class=\"number\">5</span>);</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'5,4,3,2,1'</span>);</span><br><span class=\"line\">array.insertionSort();</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'1,2,3,4,5'</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p>归并排序的性能比前三个排序算法都要好，时间复杂度为O( nlogn )，而且 Mozilla Firefox 使用了归并排序作为 <code>Array.prototype.sort</code> 的实现（但 Chrome 使用的是快速排序）。那么归并排序的思路是什么呢？简单来说，就是先分再合。</p>\n<p>比如对这样的数组进行排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13542</span><br></pre></td></tr></table></figure>\n<p>分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13 542</span><br></pre></td></tr></table></figure>\n<p>再分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13 5 42</span><br></pre></td></tr></table></figure>\n<p>再分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 5 4 2</span><br></pre></td></tr></table></figure>\n<p>合：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13 5 24</span><br></pre></td></tr></table></figure>\n<p>再合：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13 245</span><br></pre></td></tr></table></figure>\n<p>再合：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12345</span><br></pre></td></tr></table></figure>\n<p><strong>分</strong> 这个过程需要用到递归，对原数组分割，再对子数组做同样的事，终止条件是数组只有一项了，然后对这些数组进行合并，<strong>合</strong>这个过程主要是将两个数组合并的同时进行排序。所以，实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mergeSortRec = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> merge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">left, right</span>) </span>&#123;  <span class=\"comment\">// 合</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> final = [];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length &amp;&amp; right.length)</span><br><span class=\"line\">      final.push(left[<span class=\"number\">0</span>] &lt;= right[<span class=\"number\">0</span>] ? left.shift() : right.shift());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> final.concat(left.concat(right));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = array.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> mid = <span class=\"built_in\">Math</span>.floor(length / <span class=\"number\">2</span>),  <span class=\"comment\">// 分</span></span><br><span class=\"line\">    left = array.slice(<span class=\"number\">0</span>, mid),</span><br><span class=\"line\">    right = array.slice(mid, length);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> merge(mergeSortRec(left), mergeSortRec(right));  <span class=\"comment\">// 递归</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.mergeSort = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  array = mergeSortRec(array);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array = createNonSortedArray();</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'1,3,5,4,2'</span>);</span><br><span class=\"line\">array.insertionSort();</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'1,2,3,4,5'</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快速排序又称划分交换排序，是一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 Ο(n log n) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>\n<p>快速排序的实现思路是：</p>\n<ul>\n<li>从数列中挑出一个元素，称为”基准”（pivot）。</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>\n</ul>\n<p>选择基准可以用第一项，也可以随机选择或选择中间一项。我们选择第一项！不过注意，研究表明选择第一项作为基准对几乎已经排序的数组并不适合，会导致性能最差。</p>\n<p>比如对这样的数组进行排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">35142</span><br></pre></td></tr></table></figure>\n<p>那么第一轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对 35142 进行快排，left 为 21，基准是 3，right 为 45</span><br><span class=\"line\">21 3 45</span><br></pre></td></tr></table></figure>\n<p>第二轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对 21 进行快排，left 为 1，基准是 2，right 为空</span><br><span class=\"line\">1 2 3 45</span><br></pre></td></tr></table></figure>\n<p>第三轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对 45 进行快排，left 为空，基准是 4，right 为 5</span><br><span class=\"line\">1 2 3 4 5</span><br></pre></td></tr></table></figure>\n<p>所以代码实现的核心就是：</p>\n<ul>\n<li>找基准</li>\n<li>找左右数组</li>\n<li>将左右数组和基准合并</li>\n<li>对左右子数组重复上述操作</li>\n</ul>\n<p>实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> quick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = array.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (length &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array.slice(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> left = [];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> right = [];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> mid = [array[<span class=\"number\">0</span>]];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[i] &lt; mid[<span class=\"number\">0</span>])</span><br><span class=\"line\">      left.push(array[i]);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      right.push(array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quick(left).concat(mid.concat(quick(right)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.quickSort = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  array = quick(array);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"顺序搜索\"><a href=\"#顺序搜索\" class=\"headerlink\" title=\"顺序搜索\"></a>顺序搜索</h2><p>排序算法讲完了，我们来看搜索算法，最基本的搜索算法是顺序搜索：将每一个数据结构中的元素和我们要找的元素做比较。这种算法非常低效（时间复杂度为O(n)），不过比较简单，可以用来缓解面试紧张气氛。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.sequentialSearch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[i] === item) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二分搜索\"><a href=\"#二分搜索\" class=\"headerlink\" title=\"二分搜索\"></a>二分搜索</h2><p>在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是一种在<strong>有序数组</strong>中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。它的时间复杂度是 O(log(n))。</p>\n<p>代码编写的要诀是：不断改变最小值、最大值和中间值，直到中间值为被查找的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.binarySearch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.quickSort();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> low = <span class=\"number\">0</span>,</span><br><span class=\"line\">    high = array.length - <span class=\"number\">1</span>,</span><br><span class=\"line\">    mid, element;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    element = array[mid];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element &lt; item) &#123;</span><br><span class=\"line\">      low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (element &gt; item) &#123;</span><br><span class=\"line\">      high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是一些基础的排序和搜索算法。</p>","more":"<h2 id=\"编写-ArrayList-类\"><a href=\"#编写-ArrayList-类\" class=\"headerlink\" title=\"编写 ArrayList 类\"></a>编写 ArrayList 类</h2><p>在讲解排序和搜索算法前，我们先编写一个 <code>ArrayList</code> 类，使其包含私有变量 <code>array</code>，用于盛放数组，同时还包含 <code>insert</code> 和 <code>toString</code> 方法可以插入和转化为字符串。如此一来，当后面我们讲解各种排序和搜索算法时就可以很方便地设置输入输出来测试了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ArrayList</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> array = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.insert = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">    array.push(item);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array.toString();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡排序是排序中最简单的一种，不过它的性能并不好（时间复杂度为O(n^2)）。面试官有时候为了缓解面试的紧张气氛，会让应聘者手写冒泡排序算法。</p>\n<p>那么冒泡排序的思路是什么？其实就是每轮从头到尾比较相邻两个数并选择性交换（但是每次的最后一项在下一次就不用参与了，因为已经在正确的位置上了），然后执行 n-1 轮。比如对这个数组进行冒泡排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 5 4 2</span><br></pre></td></tr></table></figure>\n<p>那么实现过程记录如下：</p>\n<p>第一轮<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 5 4 2  // 1&lt;3 不交换</span><br><span class=\"line\">1 3 5 4 2  // 3&lt;5 不交换</span><br><span class=\"line\">1 3 4 5 2  // 5&gt;4 交换</span><br><span class=\"line\">1 3 4 2 5  // 5&gt;2 交换</span><br></pre></td></tr></table></figure></p>\n<p>第二轮<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 4 2 5  // 1&lt;3 不交换</span><br><span class=\"line\">1 3 4 2 5  // 3&lt;4 不交换</span><br><span class=\"line\">1 3 2 4 5  // 4&gt;2 不交换</span><br></pre></td></tr></table></figure></p>\n<p>第三轮</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 2 4 5  // 1&lt;3 不交换</span><br><span class=\"line\">1 2 3 4 5  // 3&gt;2 交换</span><br></pre></td></tr></table></figure>\n<p>第四轮</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 3 4 5  // 1&lt;2 不交换</span><br></pre></td></tr></table></figure>\n<p>用代码实现就是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> swap = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">index1, index2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> aux = array[index1];</span><br><span class=\"line\">  array[index1] = array[index2];</span><br><span class=\"line\">  array[index2] = aux;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.bubbleSort = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = array.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;  <span class=\"comment\">// 执行 n-1 轮</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span> - i; j++) &#123;  <span class=\"comment\">// 每轮（i）比较 n - i 个数 </span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (array[j] &gt; array[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>冒泡排序非常简单，唯一需要注意的就是边界的设置，你可以先使用5或3个数来假设一下，这样可以轻松算出边界。</p>\n<p>测试代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createNonSortedArray</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> array = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">  array.insert(<span class=\"number\">1</span>);</span><br><span class=\"line\">  array.insert(<span class=\"number\">3</span>);</span><br><span class=\"line\">  array.insert(<span class=\"number\">5</span>);</span><br><span class=\"line\">  array.insert(<span class=\"number\">4</span>);</span><br><span class=\"line\">  array.insert(<span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> array = createNonSortedArray();</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'1,3,5,4,2'</span>);</span><br><span class=\"line\">array.bubbleSort();</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'1,2,3,4,5'</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>选择排序也是一种简单但性能（O(n^2)）一般的排序算法。在所有的<strong>完全依靠交换去移动元素</strong>的排序方法中，选择排序属于非常好的一种。选择排序的实现思路是：找到数据结构中的最小值，<strong>选</strong>中它并将其放置在第一位，接着找到第二小的值，<strong>选</strong>中它并将其放置在第二位，以此类推。</p>\n<p>比如对一个这样的数组进行排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 5 4 2</span><br></pre></td></tr></table></figure>\n<p>那么第一轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 5 4 2  // 找出最小值1和第一位的1交换，相同的话可以省去交换过程</span><br></pre></td></tr></table></figure>\n<p>第二轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 5 4 3  // 找出第二小值2和第二位的3交换</span><br></pre></td></tr></table></figure>\n<p>第三轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 3 4 5  // 找出第三小值3和第三位的5交换</span><br></pre></td></tr></table></figure>\n<p>第四轮</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 3 4 5  // 找出第四小值4和第四位的4交换，相同的话可以省去交换过程</span><br></pre></td></tr></table></figure>\n<p>那么代码的编写无法就是两个循环：</p>\n<ul>\n<li>循环得到最小值</li>\n<li>循环将最小值交换到指定位置</li>\n</ul>\n<p>实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.selectionSort = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = array.length,</span><br><span class=\"line\">    indexMin;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;  <span class=\"comment\">// 循环将最小值交换到指定位置</span></span><br><span class=\"line\">    indexMin = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i; j &lt; length; j++) &#123;  <span class=\"comment\">// 循环得到最小值</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (array[indexMin] &gt; array[j]) &#123;</span><br><span class=\"line\">        indexMin = j;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i !== indexMin) &#123;</span><br><span class=\"line\">      swap(i, indexMin);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意边界的设置！测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array = createNonSortedArray();</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'1,3,5,4,2'</span>);</span><br><span class=\"line\">array.selectionSort();</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'1,2,3,4,5'</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>虽然插入排序的复杂度也是O(n^2)，但排序<strong>小型数组</strong>时，此算法比选择排序和冒泡排序性能要好。插入排序的实现思路是：从第二个数开始往前比，比它大就往后排，依次进行到最后一个数。就好比是上学时排队，本来瞎胡排一队，然后老师说按个子高低排：</p>\n<ul>\n<li>第二个同学看看第一个同学，觉得比自己高，就说：“你个子高还站前面！后面去！”，然后<strong>插</strong>到他前面。</li>\n<li>第三个同学，先后看了第二个、第一个同学，觉得都比自己高，就<strong>插</strong>到第一个了。</li>\n<li>以此类推到最后一个同学。</li>\n</ul>\n<p>拿个数组做演示吧！比如对下面这个数组排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 5 1 4 2</span><br></pre></td></tr></table></figure>\n<p>第一轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 5 1 4 2  // 5&gt;3，不插队</span><br></pre></td></tr></table></figure>\n<p>第二轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 5 4 2  // 1&lt;5，插队，1&lt;3，再插队</span><br></pre></td></tr></table></figure>\n<p>第三轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 4 5 2  // 4&lt;5，插队，4&gt;3，不插队</span><br></pre></td></tr></table></figure>\n<p>第四轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 3 4 5  // 2&lt;5，插队，2&gt;4，插队，2&lt;3，不插队</span><br></pre></td></tr></table></figure>\n<p>注意，只要第一次遇到较小的数，就不用再比较了，也就是说，如果第一次不插队，就不用再往前比了，因为前面都是更小的。所以代码实现是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.insertionSort = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = array.length,</span><br><span class=\"line\">    j, temp;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; length; i++) &#123;  <span class=\"comment\">// 从第二个开始比</span></span><br><span class=\"line\">    temp = array[i];</span><br><span class=\"line\">    j = i;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; array[j - <span class=\"number\">1</span>] &gt; temp) &#123; <span class=\"comment\">// 比完或遇到较小数就不用比了</span></span><br><span class=\"line\">      array[j] = array[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    array[j] = temp;  <span class=\"comment\">// 插队！！！</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array = createNonSortedArray(<span class=\"number\">5</span>);</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'5,4,3,2,1'</span>);</span><br><span class=\"line\">array.insertionSort();</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'1,2,3,4,5'</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p>归并排序的性能比前三个排序算法都要好，时间复杂度为O( nlogn )，而且 Mozilla Firefox 使用了归并排序作为 <code>Array.prototype.sort</code> 的实现（但 Chrome 使用的是快速排序）。那么归并排序的思路是什么呢？简单来说，就是先分再合。</p>\n<p>比如对这样的数组进行排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13542</span><br></pre></td></tr></table></figure>\n<p>分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13 542</span><br></pre></td></tr></table></figure>\n<p>再分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13 5 42</span><br></pre></td></tr></table></figure>\n<p>再分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 5 4 2</span><br></pre></td></tr></table></figure>\n<p>合：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13 5 24</span><br></pre></td></tr></table></figure>\n<p>再合：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13 245</span><br></pre></td></tr></table></figure>\n<p>再合：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12345</span><br></pre></td></tr></table></figure>\n<p><strong>分</strong> 这个过程需要用到递归，对原数组分割，再对子数组做同样的事，终止条件是数组只有一项了，然后对这些数组进行合并，<strong>合</strong>这个过程主要是将两个数组合并的同时进行排序。所以，实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mergeSortRec = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> merge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">left, right</span>) </span>&#123;  <span class=\"comment\">// 合</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> final = [];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left.length &amp;&amp; right.length)</span><br><span class=\"line\">      final.push(left[<span class=\"number\">0</span>] &lt;= right[<span class=\"number\">0</span>] ? left.shift() : right.shift());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> final.concat(left.concat(right));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = array.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> mid = <span class=\"built_in\">Math</span>.floor(length / <span class=\"number\">2</span>),  <span class=\"comment\">// 分</span></span><br><span class=\"line\">    left = array.slice(<span class=\"number\">0</span>, mid),</span><br><span class=\"line\">    right = array.slice(mid, length);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> merge(mergeSortRec(left), mergeSortRec(right));  <span class=\"comment\">// 递归</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.mergeSort = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  array = mergeSortRec(array);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array = createNonSortedArray();</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'1,3,5,4,2'</span>);</span><br><span class=\"line\">array.insertionSort();</span><br><span class=\"line\">expect(array.toString()).toBe(<span class=\"string\">'1,2,3,4,5'</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快速排序又称划分交换排序，是一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 Ο(n log n) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>\n<p>快速排序的实现思路是：</p>\n<ul>\n<li>从数列中挑出一个元素，称为”基准”（pivot）。</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>\n</ul>\n<p>选择基准可以用第一项，也可以随机选择或选择中间一项。我们选择第一项！不过注意，研究表明选择第一项作为基准对几乎已经排序的数组并不适合，会导致性能最差。</p>\n<p>比如对这样的数组进行排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">35142</span><br></pre></td></tr></table></figure>\n<p>那么第一轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对 35142 进行快排，left 为 21，基准是 3，right 为 45</span><br><span class=\"line\">21 3 45</span><br></pre></td></tr></table></figure>\n<p>第二轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对 21 进行快排，left 为 1，基准是 2，right 为空</span><br><span class=\"line\">1 2 3 45</span><br></pre></td></tr></table></figure>\n<p>第三轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对 45 进行快排，left 为空，基准是 4，right 为 5</span><br><span class=\"line\">1 2 3 4 5</span><br></pre></td></tr></table></figure>\n<p>所以代码实现的核心就是：</p>\n<ul>\n<li>找基准</li>\n<li>找左右数组</li>\n<li>将左右数组和基准合并</li>\n<li>对左右子数组重复上述操作</li>\n</ul>\n<p>实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> quick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = array.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (length &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array.slice(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> left = [];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> right = [];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> mid = [array[<span class=\"number\">0</span>]];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[i] &lt; mid[<span class=\"number\">0</span>])</span><br><span class=\"line\">      left.push(array[i]);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      right.push(array[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quick(left).concat(mid.concat(quick(right)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.quickSort = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  array = quick(array);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"顺序搜索\"><a href=\"#顺序搜索\" class=\"headerlink\" title=\"顺序搜索\"></a>顺序搜索</h2><p>排序算法讲完了，我们来看搜索算法，最基本的搜索算法是顺序搜索：将每一个数据结构中的元素和我们要找的元素做比较。这种算法非常低效（时间复杂度为O(n)），不过比较简单，可以用来缓解面试紧张气氛。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.sequentialSearch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[i] === item) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二分搜索\"><a href=\"#二分搜索\" class=\"headerlink\" title=\"二分搜索\"></a>二分搜索</h2><p>在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是一种在<strong>有序数组</strong>中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。它的时间复杂度是 O(log(n))。</p>\n<p>代码编写的要诀是：不断改变最小值、最大值和中间值，直到中间值为被查找的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.binarySearch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.quickSort();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> low = <span class=\"number\">0</span>,</span><br><span class=\"line\">    high = array.length - <span class=\"number\">1</span>,</span><br><span class=\"line\">    mid, element;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    element = array[mid];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element &lt; item) &#123;</span><br><span class=\"line\">      low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (element &gt; item) &#123;</span><br><span class=\"line\">      high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>"},{"title":"JavaScript 版数据结构与算法（一）栈","date":"2017-02-15T02:46:00.000Z","_content":"\n今天，我们要讲的是数据结构与算法中的栈。\n\n<!--more-->\n\n## 栈的简介\n\n栈是什么？栈是一个后进先出（LIFO）的数据结构。栈有啥作用？栈可以模拟算法或生活中的一些后进先出的场景，比如：\n\n- 十进制转二进制，你需要将余数倒序输出。\n- 二叉树的先中后序非递归遍历都用到了栈。\n- 在生活中，栈可以模拟煤炉与蜂窝煤等场景。\n\n![](https://ws1.sinaimg.cn/mw690/83900b4ely1fcqywbcbrjj20hz08dq2s)\n\n\n## 用 JavaScript 写一个栈类\n\n对于 JavaScript 工程师来说，没必要在开发中实现一个栈。因为 JavaScript 的内置对象 Array 已经实现了栈的相关方法。不过，好的程序员不能光用别人设计好的方法，而不理解为啥这么设计，所以我们还是自己设计一个栈玩玩吧！\n\n我们使用构造器函数来模拟类，不了解构造器函数的同学可以看[《在 JavaScript 中使用构造器函数模拟类》](https://lewis617.github.io/2017/02/15/construcor-function-create-class/)这篇博客。\n\n```js\nfunction Stack(){\n  ...\n}\n\nmodule.exports = Stack;\n```\n\n### 私有变量\n\n栈类的私有变量是个数组 `items`，用于记录栈的元素。栈类实例化生成的对象不能直接操作 `items`，因为 `items` 在函数外面是不可见的，你只能通过一些类方法沿着作用域链来间接操作 `items`。\n\n```js\nfunction Stack() {\n  // 私有变量 items，用于记录数组，对象不能直接操作\n  var items = [];\n}\n```\n\n### 实现 push 、pop和 toString 方法\n\n实现 `push` 、`pop` 和 `toString` 方法，跑通如下测试：\n\n```js\n// 实例化一个 stack 对象\nvar stack = new Stack();\nstack.push(5);\nstack.push(8);\n\n// 期望 stack 转化成的字符串为'5,8'\nexpect(stack.toString()).toBe('5,8');\n\n// 期望 stack 删除并返回的是8\nexpect(stack.pop()).toBe(8);\n// 期望 stack 转化成的字符串为'5'\nexpect(stack.toString()).toBe('5');\n```\n\n> 单元测试有时候就是可以作为需求文档来用的，在测试驱动开发（TDD），往往都是先写测试，再写代码。本教程用了 Jest 来进行单元测试，如果你不了解 Jest 和单元测试，可以先看[《Jest 单元测试入门》](https://lewis617.github.io/2017/02/15/start-jest/)这篇博客。\n\n\n `push` 、`pop` 和 `toString` 方法 与 Array 自带的  `push` 、`pop` 和 `toString`  方法一样，所以实现代码如下：\n\n```js\nfunction Stack() {\n  // 私有变量 items，用于记录数组，对象不能直接操作\n  var items = [];\n  \n  // 类方法 push，在数组末尾添加项，对象可以直接调用\n  this.push = function (element) {\n    items.push(element);\n  };\n  \n  // 删除并返回数组末尾的项\n  this.pop = function () {\n    return items.pop();\n  };\n  \n  // 将数组转为字符串并返回\n  this.toString = function () {\n    return items.toString();\n  };\n}\n\n```\n\n### 实现 peek 、isEmpty、clear、size 方法\n\n实现 `peek` 、`isEmpty`、`clear`、`size` 方法，跑通如下测试：\n\n```js\n// 实例化一个 stack 对象\nvar stack = new Stack();\nstack.push(5);\nstack.push(8);\n\n// 期望 stack 最后一项是8\nexpect(stack.peek()).toBe(8);\n// 期望 stack 的长度为2\nexpect(stack.size()).toBe(2);\n// 期望 stack 不为空\nexpect(stack.isEmpty()).toBeFalsy();\n\nstack.clear();\n// 期望 stack 长度为0\nexpect(stack.size()).toBe(0);\n```\n\n上述方法比较简单，直接上代码：\n\n```js\nfunction Stack() {\n  // 私有变量 items，用于记录数组，对象不能直接操作\n  var items = [];\n  \n  // 查看数组最后一项\n  this.peek = function () {\n    return items[items.length - 1];\n  };\n  // 判断数组是否为空\n  this.isEmpty = function () {\n    return items.length == 0;\n  };\n  // 清空数组\n  this.clear = function () {\n    items = [];\n  };\n  // 返回数组长度\n  this.size = function () {\n    return items.length;\n  };\n}\n```\n\n至此，栈的编写就完成了。\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","source":"_posts/stack.md","raw":"---\ntitle:  JavaScript 版数据结构与算法（一）栈\ndate:  2017-02-15 10:46:00\ntags: [数据结构与算法]\n---\n\n今天，我们要讲的是数据结构与算法中的栈。\n\n<!--more-->\n\n## 栈的简介\n\n栈是什么？栈是一个后进先出（LIFO）的数据结构。栈有啥作用？栈可以模拟算法或生活中的一些后进先出的场景，比如：\n\n- 十进制转二进制，你需要将余数倒序输出。\n- 二叉树的先中后序非递归遍历都用到了栈。\n- 在生活中，栈可以模拟煤炉与蜂窝煤等场景。\n\n![](https://ws1.sinaimg.cn/mw690/83900b4ely1fcqywbcbrjj20hz08dq2s)\n\n\n## 用 JavaScript 写一个栈类\n\n对于 JavaScript 工程师来说，没必要在开发中实现一个栈。因为 JavaScript 的内置对象 Array 已经实现了栈的相关方法。不过，好的程序员不能光用别人设计好的方法，而不理解为啥这么设计，所以我们还是自己设计一个栈玩玩吧！\n\n我们使用构造器函数来模拟类，不了解构造器函数的同学可以看[《在 JavaScript 中使用构造器函数模拟类》](https://lewis617.github.io/2017/02/15/construcor-function-create-class/)这篇博客。\n\n```js\nfunction Stack(){\n  ...\n}\n\nmodule.exports = Stack;\n```\n\n### 私有变量\n\n栈类的私有变量是个数组 `items`，用于记录栈的元素。栈类实例化生成的对象不能直接操作 `items`，因为 `items` 在函数外面是不可见的，你只能通过一些类方法沿着作用域链来间接操作 `items`。\n\n```js\nfunction Stack() {\n  // 私有变量 items，用于记录数组，对象不能直接操作\n  var items = [];\n}\n```\n\n### 实现 push 、pop和 toString 方法\n\n实现 `push` 、`pop` 和 `toString` 方法，跑通如下测试：\n\n```js\n// 实例化一个 stack 对象\nvar stack = new Stack();\nstack.push(5);\nstack.push(8);\n\n// 期望 stack 转化成的字符串为'5,8'\nexpect(stack.toString()).toBe('5,8');\n\n// 期望 stack 删除并返回的是8\nexpect(stack.pop()).toBe(8);\n// 期望 stack 转化成的字符串为'5'\nexpect(stack.toString()).toBe('5');\n```\n\n> 单元测试有时候就是可以作为需求文档来用的，在测试驱动开发（TDD），往往都是先写测试，再写代码。本教程用了 Jest 来进行单元测试，如果你不了解 Jest 和单元测试，可以先看[《Jest 单元测试入门》](https://lewis617.github.io/2017/02/15/start-jest/)这篇博客。\n\n\n `push` 、`pop` 和 `toString` 方法 与 Array 自带的  `push` 、`pop` 和 `toString`  方法一样，所以实现代码如下：\n\n```js\nfunction Stack() {\n  // 私有变量 items，用于记录数组，对象不能直接操作\n  var items = [];\n  \n  // 类方法 push，在数组末尾添加项，对象可以直接调用\n  this.push = function (element) {\n    items.push(element);\n  };\n  \n  // 删除并返回数组末尾的项\n  this.pop = function () {\n    return items.pop();\n  };\n  \n  // 将数组转为字符串并返回\n  this.toString = function () {\n    return items.toString();\n  };\n}\n\n```\n\n### 实现 peek 、isEmpty、clear、size 方法\n\n实现 `peek` 、`isEmpty`、`clear`、`size` 方法，跑通如下测试：\n\n```js\n// 实例化一个 stack 对象\nvar stack = new Stack();\nstack.push(5);\nstack.push(8);\n\n// 期望 stack 最后一项是8\nexpect(stack.peek()).toBe(8);\n// 期望 stack 的长度为2\nexpect(stack.size()).toBe(2);\n// 期望 stack 不为空\nexpect(stack.isEmpty()).toBeFalsy();\n\nstack.clear();\n// 期望 stack 长度为0\nexpect(stack.size()).toBe(0);\n```\n\n上述方法比较简单，直接上代码：\n\n```js\nfunction Stack() {\n  // 私有变量 items，用于记录数组，对象不能直接操作\n  var items = [];\n  \n  // 查看数组最后一项\n  this.peek = function () {\n    return items[items.length - 1];\n  };\n  // 判断数组是否为空\n  this.isEmpty = function () {\n    return items.length == 0;\n  };\n  // 清空数组\n  this.clear = function () {\n    items = [];\n  };\n  // 返回数组长度\n  this.size = function () {\n    return items.length;\n  };\n}\n```\n\n至此，栈的编写就完成了。\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","slug":"stack","published":1,"updated":"2019-05-01T08:02:13.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmw003gtgytoyylr48f","content":"<p>今天，我们要讲的是数据结构与算法中的栈。</p>\n<a id=\"more\"></a>\n<h2 id=\"栈的简介\"><a href=\"#栈的简介\" class=\"headerlink\" title=\"栈的简介\"></a>栈的简介</h2><p>栈是什么？栈是一个后进先出（LIFO）的数据结构。栈有啥作用？栈可以模拟算法或生活中的一些后进先出的场景，比如：</p>\n<ul>\n<li>十进制转二进制，你需要将余数倒序输出。</li>\n<li>二叉树的先中后序非递归遍历都用到了栈。</li>\n<li>在生活中，栈可以模拟煤炉与蜂窝煤等场景。</li>\n</ul>\n<p><img src=\"https://ws1.sinaimg.cn/mw690/83900b4ely1fcqywbcbrjj20hz08dq2s\" alt=\"\"></p>\n<h2 id=\"用-JavaScript-写一个栈类\"><a href=\"#用-JavaScript-写一个栈类\" class=\"headerlink\" title=\"用 JavaScript 写一个栈类\"></a>用 JavaScript 写一个栈类</h2><p>对于 JavaScript 工程师来说，没必要在开发中实现一个栈。因为 JavaScript 的内置对象 Array 已经实现了栈的相关方法。不过，好的程序员不能光用别人设计好的方法，而不理解为啥这么设计，所以我们还是自己设计一个栈玩玩吧！</p>\n<p>我们使用构造器函数来模拟类，不了解构造器函数的同学可以看<a href=\"https://lewis617.github.io/2017/02/15/construcor-function-create-class/\" target=\"_blank\" rel=\"noopener\">《在 JavaScript 中使用构造器函数模拟类》</a>这篇博客。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Stack</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = Stack;</span><br></pre></td></tr></table></figure>\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>栈类的私有变量是个数组 <code>items</code>，用于记录栈的元素。栈类实例化生成的对象不能直接操作 <code>items</code>，因为 <code>items</code> 在函数外面是不可见的，你只能通过一些类方法沿着作用域链来间接操作 <code>items</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Stack</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量 items，用于记录数组，对象不能直接操作</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-push-、pop和-toString-方法\"><a href=\"#实现-push-、pop和-toString-方法\" class=\"headerlink\" title=\"实现 push 、pop和 toString 方法\"></a>实现 push 、pop和 toString 方法</h3><p>实现 <code>push</code> 、<code>pop</code> 和 <code>toString</code> 方法，跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实例化一个 stack 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">stack.push(<span class=\"number\">5</span>);</span><br><span class=\"line\">stack.push(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 期望 stack 转化成的字符串为'5,8'</span></span><br><span class=\"line\">expect(stack.toString()).toBe(<span class=\"string\">'5,8'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 期望 stack 删除并返回的是8</span></span><br><span class=\"line\">expect(stack.pop()).toBe(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"comment\">// 期望 stack 转化成的字符串为'5'</span></span><br><span class=\"line\">expect(stack.toString()).toBe(<span class=\"string\">'5'</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>单元测试有时候就是可以作为需求文档来用的，在测试驱动开发（TDD），往往都是先写测试，再写代码。本教程用了 Jest 来进行单元测试，如果你不了解 Jest 和单元测试，可以先看<a href=\"https://lewis617.github.io/2017/02/15/start-jest/\" target=\"_blank\" rel=\"noopener\">《Jest 单元测试入门》</a>这篇博客。</p>\n</blockquote>\n<p> <code>push</code> 、<code>pop</code> 和 <code>toString</code> 方法 与 Array 自带的  <code>push</code> 、<code>pop</code> 和 <code>toString</code>  方法一样，所以实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Stack</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量 items，用于记录数组，对象不能直接操作</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 类方法 push，在数组末尾添加项，对象可以直接调用</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.push = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">    items.push(element);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 删除并返回数组末尾的项</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pop = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.pop();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 将数组转为字符串并返回</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.toString();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-peek-、isEmpty、clear、size-方法\"><a href=\"#实现-peek-、isEmpty、clear、size-方法\" class=\"headerlink\" title=\"实现 peek 、isEmpty、clear、size 方法\"></a>实现 peek 、isEmpty、clear、size 方法</h3><p>实现 <code>peek</code> 、<code>isEmpty</code>、<code>clear</code>、<code>size</code> 方法，跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实例化一个 stack 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">stack.push(<span class=\"number\">5</span>);</span><br><span class=\"line\">stack.push(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 期望 stack 最后一项是8</span></span><br><span class=\"line\">expect(stack.peek()).toBe(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"comment\">// 期望 stack 的长度为2</span></span><br><span class=\"line\">expect(stack.size()).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 期望 stack 不为空</span></span><br><span class=\"line\">expect(stack.isEmpty()).toBeFalsy();</span><br><span class=\"line\"></span><br><span class=\"line\">stack.clear();</span><br><span class=\"line\"><span class=\"comment\">// 期望 stack 长度为0</span></span><br><span class=\"line\">expect(stack.size()).toBe(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>上述方法比较简单，直接上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Stack</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量 items，用于记录数组，对象不能直接操作</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 查看数组最后一项</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.peek = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items[items.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 判断数组是否为空</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.isEmpty = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.length == <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 清空数组</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.clear = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    items = [];</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 返回数组长度</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.size = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.length;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，栈的编写就完成了。</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是数据结构与算法中的栈。</p>","more":"<h2 id=\"栈的简介\"><a href=\"#栈的简介\" class=\"headerlink\" title=\"栈的简介\"></a>栈的简介</h2><p>栈是什么？栈是一个后进先出（LIFO）的数据结构。栈有啥作用？栈可以模拟算法或生活中的一些后进先出的场景，比如：</p>\n<ul>\n<li>十进制转二进制，你需要将余数倒序输出。</li>\n<li>二叉树的先中后序非递归遍历都用到了栈。</li>\n<li>在生活中，栈可以模拟煤炉与蜂窝煤等场景。</li>\n</ul>\n<p><img src=\"https://ws1.sinaimg.cn/mw690/83900b4ely1fcqywbcbrjj20hz08dq2s\" alt=\"\"></p>\n<h2 id=\"用-JavaScript-写一个栈类\"><a href=\"#用-JavaScript-写一个栈类\" class=\"headerlink\" title=\"用 JavaScript 写一个栈类\"></a>用 JavaScript 写一个栈类</h2><p>对于 JavaScript 工程师来说，没必要在开发中实现一个栈。因为 JavaScript 的内置对象 Array 已经实现了栈的相关方法。不过，好的程序员不能光用别人设计好的方法，而不理解为啥这么设计，所以我们还是自己设计一个栈玩玩吧！</p>\n<p>我们使用构造器函数来模拟类，不了解构造器函数的同学可以看<a href=\"https://lewis617.github.io/2017/02/15/construcor-function-create-class/\" target=\"_blank\" rel=\"noopener\">《在 JavaScript 中使用构造器函数模拟类》</a>这篇博客。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Stack</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = Stack;</span><br></pre></td></tr></table></figure>\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>栈类的私有变量是个数组 <code>items</code>，用于记录栈的元素。栈类实例化生成的对象不能直接操作 <code>items</code>，因为 <code>items</code> 在函数外面是不可见的，你只能通过一些类方法沿着作用域链来间接操作 <code>items</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Stack</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量 items，用于记录数组，对象不能直接操作</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-push-、pop和-toString-方法\"><a href=\"#实现-push-、pop和-toString-方法\" class=\"headerlink\" title=\"实现 push 、pop和 toString 方法\"></a>实现 push 、pop和 toString 方法</h3><p>实现 <code>push</code> 、<code>pop</code> 和 <code>toString</code> 方法，跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实例化一个 stack 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">stack.push(<span class=\"number\">5</span>);</span><br><span class=\"line\">stack.push(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 期望 stack 转化成的字符串为'5,8'</span></span><br><span class=\"line\">expect(stack.toString()).toBe(<span class=\"string\">'5,8'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 期望 stack 删除并返回的是8</span></span><br><span class=\"line\">expect(stack.pop()).toBe(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"comment\">// 期望 stack 转化成的字符串为'5'</span></span><br><span class=\"line\">expect(stack.toString()).toBe(<span class=\"string\">'5'</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>单元测试有时候就是可以作为需求文档来用的，在测试驱动开发（TDD），往往都是先写测试，再写代码。本教程用了 Jest 来进行单元测试，如果你不了解 Jest 和单元测试，可以先看<a href=\"https://lewis617.github.io/2017/02/15/start-jest/\" target=\"_blank\" rel=\"noopener\">《Jest 单元测试入门》</a>这篇博客。</p>\n</blockquote>\n<p> <code>push</code> 、<code>pop</code> 和 <code>toString</code> 方法 与 Array 自带的  <code>push</code> 、<code>pop</code> 和 <code>toString</code>  方法一样，所以实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Stack</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量 items，用于记录数组，对象不能直接操作</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 类方法 push，在数组末尾添加项，对象可以直接调用</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.push = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">    items.push(element);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 删除并返回数组末尾的项</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pop = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.pop();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 将数组转为字符串并返回</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.toString();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现-peek-、isEmpty、clear、size-方法\"><a href=\"#实现-peek-、isEmpty、clear、size-方法\" class=\"headerlink\" title=\"实现 peek 、isEmpty、clear、size 方法\"></a>实现 peek 、isEmpty、clear、size 方法</h3><p>实现 <code>peek</code> 、<code>isEmpty</code>、<code>clear</code>、<code>size</code> 方法，跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实例化一个 stack 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">stack.push(<span class=\"number\">5</span>);</span><br><span class=\"line\">stack.push(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 期望 stack 最后一项是8</span></span><br><span class=\"line\">expect(stack.peek()).toBe(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"comment\">// 期望 stack 的长度为2</span></span><br><span class=\"line\">expect(stack.size()).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 期望 stack 不为空</span></span><br><span class=\"line\">expect(stack.isEmpty()).toBeFalsy();</span><br><span class=\"line\"></span><br><span class=\"line\">stack.clear();</span><br><span class=\"line\"><span class=\"comment\">// 期望 stack 长度为0</span></span><br><span class=\"line\">expect(stack.size()).toBe(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>上述方法比较简单，直接上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Stack</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量 items，用于记录数组，对象不能直接操作</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 查看数组最后一项</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.peek = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items[items.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 判断数组是否为空</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.isEmpty = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.length == <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 清空数组</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.clear = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    items = [];</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 返回数组长度</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.size = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.length;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，栈的编写就完成了。</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>"},{"title":"Jest 单元测试入门","date":"2017-02-15T01:50:00.000Z","_content":"\n今天，我们要讲的是 Jest 单元测试的入门知识。\n\n<!--more-->\n\n## 为何要进行单元测试？\n\n在学习 Jest 之前，我们需要回答一个问题：为何要进行单元测试？编写单元测试可以给你带来很多好处：\n\n- 将测试自动化，无需每次都人工测试。\n- 变更检查，当代码发生重构，可以及时发现，并做出相应的调整。\n- 列举测试用例，可以帮你了解所有的边界情况。\n- 当作文档，如果你的测试描述足够详细，生成的测试报告甚至可以当作文档。\n- ……\n\n总之，单元测试会让你的生活更加美好。\n\n## 使用 Jest 进行单元测试\n\n编写测试通常都会基于某个测试框架，在众多测试框架中我选择了 Jest，不仅因为我是个 React 开发者（React 与 Jest 都是 Facebook 出的），而且因为它确实简单好用。让我们开始编写测试吧！\n\n首先，安装 Jest：\n\n```sh\nnpm install --save-dev jest\n```\n\n然后，编写一个待测试的文件，以Stack类为例：\n\nStack.js\n```js\nfunction Stack() {\n  // 私有变量 items，用于记录数组，对象不能直接操作\n  var items = [];\n  // 类方法 push，在数组末尾添加项，对象可以直接调用\n  this.push = function (element) {\n    items.push(element);\n  };\n  // 删除并返回数组末尾的项\n  this.pop = function () {\n    return items.pop();\n  };\n}\n```\n\n接下来，编写一个测试文件 Stack.test.js：\n\nStack.test.js\n\n```js\n// 导入 Stack\nvar Stack = require('./Stack');\n\ntest('Stack', function () {\n  // 实例化一个 stack 对象\n  var stack = new Stack();\n\n  stack.push(8);\n  // 期望 stack 最后一项是8\n  expect(stack.pop()).toBe(8);\n});\n```\n然后，在 package.json 中添加：\n\n```json\n\"scripts\": {\n  \"test\": \"jest\"\n}\n```\n\n最后，打开命令行运行：\n\n```sh\nnpm test\n```\n\n结果会在命令行中生成测试报告：\n\n```sh\nPASS  Stack.test.js\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        0.386s\nRan all test suites.\n\n```\n\n## 断言简介\n\n在上面的测试代码中有个 `expect().toBe()`  来判断结果是否是预期，这叫断言。什么是断言？在程序设计中，断言（assertion）是一种放在程序中的一阶逻辑（如一个结果为真或是假的逻辑判断式），目的是为了标示与验证程序开发者预期的结果。除了`expect().toBe()` 之外，其他常用的断言包括：\n\n- `expect().toEqual()`：判断结果是否和预期等价。\n- `expect().toBeFalsy()`：判断结果是否为假。\n- `expect().toBeTruthy()`：判断结果是否为真。\n\n\n至此，Jest 的入门用法已经演示完了，更多的用法可以参考它的官网文档：\n\nhttps://facebook.github.io/jest/\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>\n\n## 更多测试文章：\n\n<http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/>","source":"_posts/start-jest.md","raw":"---\ntitle: Jest 单元测试入门\ndate: 2017-02-15 09:50:00\ntags: [Jest, 单元测试, 测试]\n---\n\n今天，我们要讲的是 Jest 单元测试的入门知识。\n\n<!--more-->\n\n## 为何要进行单元测试？\n\n在学习 Jest 之前，我们需要回答一个问题：为何要进行单元测试？编写单元测试可以给你带来很多好处：\n\n- 将测试自动化，无需每次都人工测试。\n- 变更检查，当代码发生重构，可以及时发现，并做出相应的调整。\n- 列举测试用例，可以帮你了解所有的边界情况。\n- 当作文档，如果你的测试描述足够详细，生成的测试报告甚至可以当作文档。\n- ……\n\n总之，单元测试会让你的生活更加美好。\n\n## 使用 Jest 进行单元测试\n\n编写测试通常都会基于某个测试框架，在众多测试框架中我选择了 Jest，不仅因为我是个 React 开发者（React 与 Jest 都是 Facebook 出的），而且因为它确实简单好用。让我们开始编写测试吧！\n\n首先，安装 Jest：\n\n```sh\nnpm install --save-dev jest\n```\n\n然后，编写一个待测试的文件，以Stack类为例：\n\nStack.js\n```js\nfunction Stack() {\n  // 私有变量 items，用于记录数组，对象不能直接操作\n  var items = [];\n  // 类方法 push，在数组末尾添加项，对象可以直接调用\n  this.push = function (element) {\n    items.push(element);\n  };\n  // 删除并返回数组末尾的项\n  this.pop = function () {\n    return items.pop();\n  };\n}\n```\n\n接下来，编写一个测试文件 Stack.test.js：\n\nStack.test.js\n\n```js\n// 导入 Stack\nvar Stack = require('./Stack');\n\ntest('Stack', function () {\n  // 实例化一个 stack 对象\n  var stack = new Stack();\n\n  stack.push(8);\n  // 期望 stack 最后一项是8\n  expect(stack.pop()).toBe(8);\n});\n```\n然后，在 package.json 中添加：\n\n```json\n\"scripts\": {\n  \"test\": \"jest\"\n}\n```\n\n最后，打开命令行运行：\n\n```sh\nnpm test\n```\n\n结果会在命令行中生成测试报告：\n\n```sh\nPASS  Stack.test.js\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        0.386s\nRan all test suites.\n\n```\n\n## 断言简介\n\n在上面的测试代码中有个 `expect().toBe()`  来判断结果是否是预期，这叫断言。什么是断言？在程序设计中，断言（assertion）是一种放在程序中的一阶逻辑（如一个结果为真或是假的逻辑判断式），目的是为了标示与验证程序开发者预期的结果。除了`expect().toBe()` 之外，其他常用的断言包括：\n\n- `expect().toEqual()`：判断结果是否和预期等价。\n- `expect().toBeFalsy()`：判断结果是否为假。\n- `expect().toBeTruthy()`：判断结果是否为真。\n\n\n至此，Jest 的入门用法已经演示完了，更多的用法可以参考它的官网文档：\n\nhttps://facebook.github.io/jest/\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>\n\n## 更多测试文章：\n\n<http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/>","slug":"start-jest","published":1,"updated":"2019-05-01T08:02:13.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmx003jtgytvosf8uih","content":"<p>今天，我们要讲的是 Jest 单元测试的入门知识。</p>\n<a id=\"more\"></a>\n<h2 id=\"为何要进行单元测试？\"><a href=\"#为何要进行单元测试？\" class=\"headerlink\" title=\"为何要进行单元测试？\"></a>为何要进行单元测试？</h2><p>在学习 Jest 之前，我们需要回答一个问题：为何要进行单元测试？编写单元测试可以给你带来很多好处：</p>\n<ul>\n<li>将测试自动化，无需每次都人工测试。</li>\n<li>变更检查，当代码发生重构，可以及时发现，并做出相应的调整。</li>\n<li>列举测试用例，可以帮你了解所有的边界情况。</li>\n<li>当作文档，如果你的测试描述足够详细，生成的测试报告甚至可以当作文档。</li>\n<li>……</li>\n</ul>\n<p>总之，单元测试会让你的生活更加美好。</p>\n<h2 id=\"使用-Jest-进行单元测试\"><a href=\"#使用-Jest-进行单元测试\" class=\"headerlink\" title=\"使用 Jest 进行单元测试\"></a>使用 Jest 进行单元测试</h2><p>编写测试通常都会基于某个测试框架，在众多测试框架中我选择了 Jest，不仅因为我是个 React 开发者（React 与 Jest 都是 Facebook 出的），而且因为它确实简单好用。让我们开始编写测试吧！</p>\n<p>首先，安装 Jest：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev jest</span><br></pre></td></tr></table></figure>\n<p>然后，编写一个待测试的文件，以Stack类为例：</p>\n<p>Stack.js<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Stack</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量 items，用于记录数组，对象不能直接操作</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">  <span class=\"comment\">// 类方法 push，在数组末尾添加项，对象可以直接调用</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.push = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">    items.push(element);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 删除并返回数组末尾的项</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pop = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.pop();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来，编写一个测试文件 Stack.test.js：</p>\n<p>Stack.test.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 导入 Stack</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Stack = <span class=\"built_in\">require</span>(<span class=\"string\">'./Stack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'Stack'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 实例化一个 stack 对象</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\"></span><br><span class=\"line\">  stack.push(<span class=\"number\">8</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 期望 stack 最后一项是8</span></span><br><span class=\"line\">  expect(stack.pop()).toBe(<span class=\"number\">8</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>然后，在 package.json 中添加：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">  \"test\": \"jest\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，打开命令行运行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>结果会在命令行中生成测试报告：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PASS  Stack.test.js</span><br><span class=\"line\"></span><br><span class=\"line\">Test Suites: 1 passed, 1 total</span><br><span class=\"line\">Tests:       1 passed, 1 total</span><br><span class=\"line\">Snapshots:   0 total</span><br><span class=\"line\">Time:        0.386s</span><br><span class=\"line\">Ran all <span class=\"built_in\">test</span> suites.</span><br></pre></td></tr></table></figure>\n<h2 id=\"断言简介\"><a href=\"#断言简介\" class=\"headerlink\" title=\"断言简介\"></a>断言简介</h2><p>在上面的测试代码中有个 <code>expect().toBe()</code>  来判断结果是否是预期，这叫断言。什么是断言？在程序设计中，断言（assertion）是一种放在程序中的一阶逻辑（如一个结果为真或是假的逻辑判断式），目的是为了标示与验证程序开发者预期的结果。除了<code>expect().toBe()</code> 之外，其他常用的断言包括：</p>\n<ul>\n<li><code>expect().toEqual()</code>：判断结果是否和预期等价。</li>\n<li><code>expect().toBeFalsy()</code>：判断结果是否为假。</li>\n<li><code>expect().toBeTruthy()</code>：判断结果是否为真。</li>\n</ul>\n<p>至此，Jest 的入门用法已经演示完了，更多的用法可以参考它的官网文档：</p>\n<p><a href=\"https://facebook.github.io/jest/\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/jest/</a></p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n<h2 id=\"更多测试文章：\"><a href=\"#更多测试文章：\" class=\"headerlink\" title=\"更多测试文章：\"></a>更多测试文章：</h2><p><a href=\"http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/\">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是 Jest 单元测试的入门知识。</p>","more":"<h2 id=\"为何要进行单元测试？\"><a href=\"#为何要进行单元测试？\" class=\"headerlink\" title=\"为何要进行单元测试？\"></a>为何要进行单元测试？</h2><p>在学习 Jest 之前，我们需要回答一个问题：为何要进行单元测试？编写单元测试可以给你带来很多好处：</p>\n<ul>\n<li>将测试自动化，无需每次都人工测试。</li>\n<li>变更检查，当代码发生重构，可以及时发现，并做出相应的调整。</li>\n<li>列举测试用例，可以帮你了解所有的边界情况。</li>\n<li>当作文档，如果你的测试描述足够详细，生成的测试报告甚至可以当作文档。</li>\n<li>……</li>\n</ul>\n<p>总之，单元测试会让你的生活更加美好。</p>\n<h2 id=\"使用-Jest-进行单元测试\"><a href=\"#使用-Jest-进行单元测试\" class=\"headerlink\" title=\"使用 Jest 进行单元测试\"></a>使用 Jest 进行单元测试</h2><p>编写测试通常都会基于某个测试框架，在众多测试框架中我选择了 Jest，不仅因为我是个 React 开发者（React 与 Jest 都是 Facebook 出的），而且因为它确实简单好用。让我们开始编写测试吧！</p>\n<p>首先，安装 Jest：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev jest</span><br></pre></td></tr></table></figure>\n<p>然后，编写一个待测试的文件，以Stack类为例：</p>\n<p>Stack.js<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Stack</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量 items，用于记录数组，对象不能直接操作</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">  <span class=\"comment\">// 类方法 push，在数组末尾添加项，对象可以直接调用</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.push = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">    items.push(element);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 删除并返回数组末尾的项</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pop = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> items.pop();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来，编写一个测试文件 Stack.test.js：</p>\n<p>Stack.test.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 导入 Stack</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Stack = <span class=\"built_in\">require</span>(<span class=\"string\">'./Stack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'Stack'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 实例化一个 stack 对象</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\"></span><br><span class=\"line\">  stack.push(<span class=\"number\">8</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 期望 stack 最后一项是8</span></span><br><span class=\"line\">  expect(stack.pop()).toBe(<span class=\"number\">8</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>然后，在 package.json 中添加：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">  \"test\": \"jest\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，打开命令行运行：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>结果会在命令行中生成测试报告：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PASS  Stack.test.js</span><br><span class=\"line\"></span><br><span class=\"line\">Test Suites: 1 passed, 1 total</span><br><span class=\"line\">Tests:       1 passed, 1 total</span><br><span class=\"line\">Snapshots:   0 total</span><br><span class=\"line\">Time:        0.386s</span><br><span class=\"line\">Ran all <span class=\"built_in\">test</span> suites.</span><br></pre></td></tr></table></figure>\n<h2 id=\"断言简介\"><a href=\"#断言简介\" class=\"headerlink\" title=\"断言简介\"></a>断言简介</h2><p>在上面的测试代码中有个 <code>expect().toBe()</code>  来判断结果是否是预期，这叫断言。什么是断言？在程序设计中，断言（assertion）是一种放在程序中的一阶逻辑（如一个结果为真或是假的逻辑判断式），目的是为了标示与验证程序开发者预期的结果。除了<code>expect().toBe()</code> 之外，其他常用的断言包括：</p>\n<ul>\n<li><code>expect().toEqual()</code>：判断结果是否和预期等价。</li>\n<li><code>expect().toBeFalsy()</code>：判断结果是否为假。</li>\n<li><code>expect().toBeTruthy()</code>：判断结果是否为真。</li>\n</ul>\n<p>至此，Jest 的入门用法已经演示完了，更多的用法可以参考它的官网文档：</p>\n<p><a href=\"https://facebook.github.io/jest/\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/jest/</a></p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n<h2 id=\"更多测试文章：\"><a href=\"#更多测试文章：\" class=\"headerlink\" title=\"更多测试文章：\"></a>更多测试文章：</h2><p><a href=\"http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/\">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>"},{"title":"SVG轨迹回放实践","date":"2017-09-27T11:00:00.000Z","_content":"最近做了埋点方案XTracker的轨迹回放功能，大致效果就是，在指定几个顺序的点之间形成轨迹，来模拟用户在页面上的先后行为（比如一个用户先点了啥，后点了啥）。效果图如下：\n\n![](/css/images/198.gif)\n\n在这篇文章中，我们来聊聊轨迹回放的一些技术细节。\n\n> 注意，本文只关注轨迹的绘制，并不讨论轨迹的各种生成算法。\n\n\n<!--more-->\n\n## 绘制红点坐标\n\n在绘制轨迹前，需要先绘制轨迹经过的红点坐标。使用SVG绘制红点非常简单：\n\n```html\n<svg width=\"500\" height=\"500\">\n  <circle r=\"5\" cx=\"50\" cy=\"55\" fill=\"red\"></circle>\n</svg>\n```\n\n![](/css/images/187.jpg)\n\n\n然后根据需要多画几个红点就可以了，也可以通过js批量生成：\n\n```js\nfunction createCircles() {\n  var r = \"5\",\n    fill = \"red\",\n    // circleGroup是红点的容器\n    circleGroup = document.querySelector(\"#circle-group\");\n  // pointList是红点的坐标集合\n  pointList.forEach(function(point) {\n    var circle = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"circle\"\n    );\n    circle.setAttribute(\"r\", r);\n    circle.setAttribute(\"cx\", point[0]);\n    circle.setAttribute(\"cy\", point[1]);\n    circle.setAttribute(\"fill\", fill);\n    circleGroup.appendChild(circle);\n  });\n}\n```\n\n![](/css/images/188.jpg)\n\n\n## 两点之间的轨迹\n\n红点坐标画完了，我们来画轨迹。在画多点的轨迹之前，我们先来学习两点之间的轨迹，也就是两点之间曲线的画法。\n\n### 二次贝塞尔曲线、三次贝塞尔曲线还是圆弧？\n\nSVG通过path可以画多种曲线主要包括：\n\n- 二次贝塞尔曲线：需要一个控制点，用来确定起点和终点的曲线斜率。\n\t![](/css/images/189.jpg)\n- 三次贝塞尔曲线：需要两个控制点，用来确定起点和终点的曲线斜率。\n\t![](/css/images/190.jpg)\n- 圆弧：需要两个半径、旋转角度、逆时针还是顺时针、大圆弧还是小圆弧等多个属性。\n\t![](/css/images/191.jpg)\n\n显然，二次贝塞尔曲线最为简单，所以我们决定用二次贝塞尔曲线来画两点之间的弧线。在SVG的path中，二次贝塞曲线的参数是：\n\n```html\nM x1 y1 Q x2 y2 x3 y3\n```\n\n其中`x1 y1`是起点，`x2 y2`是控制点，`x3 y3`是终点。来个demo吧！\n\n```html\n<svg width=\"320px\" height=\"320px\">\n  <path id=\"line1\" stroke=\"black\" fill=\"none\" d=\"M 0 50 Q 25 10 50 50\"/>\n</svg>\n```\n\n效果：\n\n![](/css/images/192.jpg)\n\n### 确定控制点\n\n确定了使用二次贝塞尔曲线，那么问题又来了，如何确定控制点呢？控制点决定了曲线的斜率和方向，我们期望曲线：\n\n- 对称。\n- 接近直线，稍微弯曲即可，太弯可能会超出画布范围。\n- 曲线永远顺时针，这样可以保证，A点到B点的曲线和B点到A点的曲线不重合。\n\n要想做到这三点，我们只需要让控制点：\n\n- 在两点的中垂线上。\n- 距离两点的中点等于某个较小的固定值。\n- 在起点和终点的顺时针区域。\n\n画个图吧！\n\n![](/css/images/193.jpg)\n\n- 在顺时针区域画中垂线。中垂线和垂直线的角度为`angle`\n- 规定`offset`为某个定值（比如40，或者其他比较小的定值）。\n- 那么控制点相对于中点的偏移值就确定了：\n\t- `offsetX = Math.sin(angle) * offset;`\n\t- `offsetY = -Math.cos(angle) * offset;`\n\n完整算法：\n\n```js\nfunction getCtlPoint(startX, startY, endX, endY, offset) {\n  var offset = offset || 40;\n  var angle = Math.atan2(endY - startY, endX - startX);\n  var offsetX = Math.sin(angle) * offset;\n  var offsetY = -Math.cos(angle) * offset;\n  var ctlX = (startX + endX) / 2 + offsetX;\n  var ctlY = (startY + endY) / 2 + offsetY;\n  return [ctlX, ctlY];\n}\n```\n\n### 起点终点相同的情况\n\n如果起点终点相同，我们就不能使用二次贝塞尔曲线了，而是应该在该点右侧画一个小圆弧，就像这样：\n\n![](/css/images/195.jpg)\n\n\n在Path中圆弧的参数格式为：\n\n```\nA rx ry x-axis-rotation large-arc-flag sweep-flag x y\n```\n\n- 弧形命令A的前两个参数分别是x轴半径和y轴半径。\n- `x-axis-rotation`表示弧形的旋转情况。\n- `large-arc-flag`决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。\n- `sweep-flag`表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧。\n- 最后两个参数是指定弧形的终点。\n\n> 弧形命令A的具体用法不属于本文范畴，请参考：https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths 。\n\n因为我们要求：\n\n- 圆弧接近于圆，不是椭圆。\n- 圆弧在右侧。\n- 大于180度。\n\n所以，我们的圆弧参数为：\n\n- x轴和y轴半径同为某个很小的定值（我们就设为10吧）\n- `x-axis-rotation`为0，不需要旋转，既然是圆，转了也白转。\n- `large-arc-flag`为1，显然大于180度。\n- `sweep-flag`为1或0都行，不过要保证为1时，终点稍微比起点靠下一点，这样才能保证圆弧在右边。\n\n示例代码：\n\n```html\n<svg width=\"320px\" height=\"320px\">\n  <path id=\"line1\" stroke=\"black\" fill=\"none\" d=\"M 50 50 A 10 10 0 1 1 50 50.1\"/>\n</svg>\n```\n\n效果截图：\n\n![](https://wx3.sinaimg.cn/mw690/83900b4egy1fjy8a993prj203e032a9t.jpg)\n\n将两种情况封装成获取d属性的函数：\n\n```js\nfunction getD(startX, startY, endX, endY) {\n  var ctlPoint = getCtlPoint(startX, startY, endX, endY, 40);\n  var d = [\"M\", startX, startY].join(\" \");\n  if (startX !== endX || startY !== endY) {\n    d += [\" Q\", ctlPoint[0], ctlPoint[1], endX, endY].join(\" \");\n  } else {\n    d += [\" A\", 10, 10, 0, 1, 1, endX, endY + 0.1].join(\" \");\n  }\n  return d;\n}\n```\n\n完整demo：\n\nhttps://codepen.io/lewis617/pen/JrWMBy/\n\n\n## 多点之间的轨迹\n\n两点之间弧线确定了，那么如何确定多点之间的轨迹呢？其实很简单，只需要在命令后面加上新的控制点和终点即可：\n\n```html\nM x1 y1 Q x2 y2 x3 y3 Q x4 y4 x5 y5\n```\n\n所以只需要简单更新一下之前封装的函数即可：\n\n```js\nfunction getD(pointList){\n  var offset = offset || 40;\n  var d = (['M' ,pointList[0][0], pointList[0][1]]).join(' ');\n  pointList.forEach(function(point, i){\n    if(i>0){\n      var startX = pointList[i-1][0],\n          startY = pointList[i-1][1],\n          endX = point[0], \n          endY = point[1];\n      \n      var ctlPoint = getCtlPoint(startX, startY, endX, endY, offset);\n      \n      if(startX !== endX || startY !== endY){\n        d+=([' Q', ctlPoint[0], ctlPoint[1], endX, endY]).join(' ');\n      }else{\n        d+=([' A', 10, 10, 0, 1, 1, endX, endY + 0.1]).join(' ');\n      }\n    }\n  })\n  return d;\n}\n\n```\n\n如果`pointList`为：\n\n```js\nvar pointList = [\n  [0, 50],\n  [0, 50],\n  [50, 50],\n  [100, 50],\n  [0, 100],\n  [50, 100],\n  [100, 100],\n];\n```\n\n那么效果图：\n\n![](/css/images/196.jpg)\n\n\n完整demo：\n\nhttps://codepen.io/lewis617/pen/wrJpGY/\n\n## 让轨迹回放起来\n\n轨迹画完了，如何让它回放呢？这里需要用到这两个属性：\n\n[stroke-dasharray](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/stroke-dasharray)：控制用来描边的点划线的图案范式。\n\n[stroke-dashoffset](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/stroke-dashoffset)：指定了dash模式到路径开始的距离。\n\n- 先设置`stroke-dasharray`为 `\"length length\"`，来让曲线颜色和空白的长度均为曲线长度。\n- 然后设置`stroke-dashoffset`初始状态为曲线长度，来保证整个曲线\"看起来\"都是空白。\n- 最后渐变`stroke-dashoffset`属性为0，来模拟画线。\n\n如何渐变呢？使用[SVG SMIL animation](https://developer.mozilla.org/zh-CN/docs/Web/SVG/SVG_animation_with_SMIL)。\n\n关键代码：\n\n```js\nvar length = path.getTotalLength();\npath.setAttribute(\"stroke-dasharray\", length + \" \" + length);\npath.setAttribute(\"stroke-dashoffset\", length);\npath.innerHTML= '<animate attributeName=\"stroke-dashoffset\" to=\"0\"  dur=\"7s\" begin=\"0s\" fill=\"freeze\" repeatCount=\"indefinite\"/>';\n```\n\n完整demo：\n\n![](/css/images/197.gif)\n\nhttps://codepen.io/lewis617/pen/vexjyp/\n\n## 给轨迹加上“圆头”\n\n马上就可以看见胜利的曙光了，最后我们来做轨迹的“圆头”：\n\n- 圆头就是个圆点（circle）\n- 圆点需要跟着轨迹一起移动\n\n画一个圆点很简单，那么如何画一个按照轨迹移动的圆点呢？答案是：[animateMotion元素](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/animateMotion)。\n\n关键代码：\n\n```js\nfunction createPathHead(pathObj, d){\n  var r = 3;\n  var head = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n  head.setAttribute(\"id\", pathObj.id + \"-head\");\n  head.setAttribute(\"r\", r);\n  head.setAttribute(\"fill\", pathObj.stroke);\n  \n  var animateMotion = document.createElementNS(\"http://www.w3.org/2000/svg\", \"animateMotion\");\n  animateMotion.setAttribute(\"path\", d);\n  animateMotion.setAttribute(\"begin\", \"indefinite\");\n  animateMotion.setAttribute(\"dur\", \"7s\");\n  animateMotion.setAttribute(\"fill\", \"freeze\");\n  animateMotion.setAttribute(\"rotate\", \"auto\");\n  head.appendChild(animateMotion);\n  \n  return head;\n}\n```\n\n至此，轨迹回放的关键技术点就讲完了，再次欣赏下最终的效果：\n\n![](https://wx1.sinaimg.cn/mw690/83900b4egy1fk1jn3atyng204h04ead8.gif)\n\n完整的demo在这里：\n\nhttps://codepen.io/lewis617/pen/RLpxPj/","source":"_posts/svg-path-playback.md","raw":"---\ntitle: SVG轨迹回放实践\ndate: 2017-09-27 19:00:00\ntags: [SVG, 贝塞尔曲线,SVG SMIL animation]\n---\n最近做了埋点方案XTracker的轨迹回放功能，大致效果就是，在指定几个顺序的点之间形成轨迹，来模拟用户在页面上的先后行为（比如一个用户先点了啥，后点了啥）。效果图如下：\n\n![](/css/images/198.gif)\n\n在这篇文章中，我们来聊聊轨迹回放的一些技术细节。\n\n> 注意，本文只关注轨迹的绘制，并不讨论轨迹的各种生成算法。\n\n\n<!--more-->\n\n## 绘制红点坐标\n\n在绘制轨迹前，需要先绘制轨迹经过的红点坐标。使用SVG绘制红点非常简单：\n\n```html\n<svg width=\"500\" height=\"500\">\n  <circle r=\"5\" cx=\"50\" cy=\"55\" fill=\"red\"></circle>\n</svg>\n```\n\n![](/css/images/187.jpg)\n\n\n然后根据需要多画几个红点就可以了，也可以通过js批量生成：\n\n```js\nfunction createCircles() {\n  var r = \"5\",\n    fill = \"red\",\n    // circleGroup是红点的容器\n    circleGroup = document.querySelector(\"#circle-group\");\n  // pointList是红点的坐标集合\n  pointList.forEach(function(point) {\n    var circle = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"circle\"\n    );\n    circle.setAttribute(\"r\", r);\n    circle.setAttribute(\"cx\", point[0]);\n    circle.setAttribute(\"cy\", point[1]);\n    circle.setAttribute(\"fill\", fill);\n    circleGroup.appendChild(circle);\n  });\n}\n```\n\n![](/css/images/188.jpg)\n\n\n## 两点之间的轨迹\n\n红点坐标画完了，我们来画轨迹。在画多点的轨迹之前，我们先来学习两点之间的轨迹，也就是两点之间曲线的画法。\n\n### 二次贝塞尔曲线、三次贝塞尔曲线还是圆弧？\n\nSVG通过path可以画多种曲线主要包括：\n\n- 二次贝塞尔曲线：需要一个控制点，用来确定起点和终点的曲线斜率。\n\t![](/css/images/189.jpg)\n- 三次贝塞尔曲线：需要两个控制点，用来确定起点和终点的曲线斜率。\n\t![](/css/images/190.jpg)\n- 圆弧：需要两个半径、旋转角度、逆时针还是顺时针、大圆弧还是小圆弧等多个属性。\n\t![](/css/images/191.jpg)\n\n显然，二次贝塞尔曲线最为简单，所以我们决定用二次贝塞尔曲线来画两点之间的弧线。在SVG的path中，二次贝塞曲线的参数是：\n\n```html\nM x1 y1 Q x2 y2 x3 y3\n```\n\n其中`x1 y1`是起点，`x2 y2`是控制点，`x3 y3`是终点。来个demo吧！\n\n```html\n<svg width=\"320px\" height=\"320px\">\n  <path id=\"line1\" stroke=\"black\" fill=\"none\" d=\"M 0 50 Q 25 10 50 50\"/>\n</svg>\n```\n\n效果：\n\n![](/css/images/192.jpg)\n\n### 确定控制点\n\n确定了使用二次贝塞尔曲线，那么问题又来了，如何确定控制点呢？控制点决定了曲线的斜率和方向，我们期望曲线：\n\n- 对称。\n- 接近直线，稍微弯曲即可，太弯可能会超出画布范围。\n- 曲线永远顺时针，这样可以保证，A点到B点的曲线和B点到A点的曲线不重合。\n\n要想做到这三点，我们只需要让控制点：\n\n- 在两点的中垂线上。\n- 距离两点的中点等于某个较小的固定值。\n- 在起点和终点的顺时针区域。\n\n画个图吧！\n\n![](/css/images/193.jpg)\n\n- 在顺时针区域画中垂线。中垂线和垂直线的角度为`angle`\n- 规定`offset`为某个定值（比如40，或者其他比较小的定值）。\n- 那么控制点相对于中点的偏移值就确定了：\n\t- `offsetX = Math.sin(angle) * offset;`\n\t- `offsetY = -Math.cos(angle) * offset;`\n\n完整算法：\n\n```js\nfunction getCtlPoint(startX, startY, endX, endY, offset) {\n  var offset = offset || 40;\n  var angle = Math.atan2(endY - startY, endX - startX);\n  var offsetX = Math.sin(angle) * offset;\n  var offsetY = -Math.cos(angle) * offset;\n  var ctlX = (startX + endX) / 2 + offsetX;\n  var ctlY = (startY + endY) / 2 + offsetY;\n  return [ctlX, ctlY];\n}\n```\n\n### 起点终点相同的情况\n\n如果起点终点相同，我们就不能使用二次贝塞尔曲线了，而是应该在该点右侧画一个小圆弧，就像这样：\n\n![](/css/images/195.jpg)\n\n\n在Path中圆弧的参数格式为：\n\n```\nA rx ry x-axis-rotation large-arc-flag sweep-flag x y\n```\n\n- 弧形命令A的前两个参数分别是x轴半径和y轴半径。\n- `x-axis-rotation`表示弧形的旋转情况。\n- `large-arc-flag`决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。\n- `sweep-flag`表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧。\n- 最后两个参数是指定弧形的终点。\n\n> 弧形命令A的具体用法不属于本文范畴，请参考：https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths 。\n\n因为我们要求：\n\n- 圆弧接近于圆，不是椭圆。\n- 圆弧在右侧。\n- 大于180度。\n\n所以，我们的圆弧参数为：\n\n- x轴和y轴半径同为某个很小的定值（我们就设为10吧）\n- `x-axis-rotation`为0，不需要旋转，既然是圆，转了也白转。\n- `large-arc-flag`为1，显然大于180度。\n- `sweep-flag`为1或0都行，不过要保证为1时，终点稍微比起点靠下一点，这样才能保证圆弧在右边。\n\n示例代码：\n\n```html\n<svg width=\"320px\" height=\"320px\">\n  <path id=\"line1\" stroke=\"black\" fill=\"none\" d=\"M 50 50 A 10 10 0 1 1 50 50.1\"/>\n</svg>\n```\n\n效果截图：\n\n![](https://wx3.sinaimg.cn/mw690/83900b4egy1fjy8a993prj203e032a9t.jpg)\n\n将两种情况封装成获取d属性的函数：\n\n```js\nfunction getD(startX, startY, endX, endY) {\n  var ctlPoint = getCtlPoint(startX, startY, endX, endY, 40);\n  var d = [\"M\", startX, startY].join(\" \");\n  if (startX !== endX || startY !== endY) {\n    d += [\" Q\", ctlPoint[0], ctlPoint[1], endX, endY].join(\" \");\n  } else {\n    d += [\" A\", 10, 10, 0, 1, 1, endX, endY + 0.1].join(\" \");\n  }\n  return d;\n}\n```\n\n完整demo：\n\nhttps://codepen.io/lewis617/pen/JrWMBy/\n\n\n## 多点之间的轨迹\n\n两点之间弧线确定了，那么如何确定多点之间的轨迹呢？其实很简单，只需要在命令后面加上新的控制点和终点即可：\n\n```html\nM x1 y1 Q x2 y2 x3 y3 Q x4 y4 x5 y5\n```\n\n所以只需要简单更新一下之前封装的函数即可：\n\n```js\nfunction getD(pointList){\n  var offset = offset || 40;\n  var d = (['M' ,pointList[0][0], pointList[0][1]]).join(' ');\n  pointList.forEach(function(point, i){\n    if(i>0){\n      var startX = pointList[i-1][0],\n          startY = pointList[i-1][1],\n          endX = point[0], \n          endY = point[1];\n      \n      var ctlPoint = getCtlPoint(startX, startY, endX, endY, offset);\n      \n      if(startX !== endX || startY !== endY){\n        d+=([' Q', ctlPoint[0], ctlPoint[1], endX, endY]).join(' ');\n      }else{\n        d+=([' A', 10, 10, 0, 1, 1, endX, endY + 0.1]).join(' ');\n      }\n    }\n  })\n  return d;\n}\n\n```\n\n如果`pointList`为：\n\n```js\nvar pointList = [\n  [0, 50],\n  [0, 50],\n  [50, 50],\n  [100, 50],\n  [0, 100],\n  [50, 100],\n  [100, 100],\n];\n```\n\n那么效果图：\n\n![](/css/images/196.jpg)\n\n\n完整demo：\n\nhttps://codepen.io/lewis617/pen/wrJpGY/\n\n## 让轨迹回放起来\n\n轨迹画完了，如何让它回放呢？这里需要用到这两个属性：\n\n[stroke-dasharray](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/stroke-dasharray)：控制用来描边的点划线的图案范式。\n\n[stroke-dashoffset](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/stroke-dashoffset)：指定了dash模式到路径开始的距离。\n\n- 先设置`stroke-dasharray`为 `\"length length\"`，来让曲线颜色和空白的长度均为曲线长度。\n- 然后设置`stroke-dashoffset`初始状态为曲线长度，来保证整个曲线\"看起来\"都是空白。\n- 最后渐变`stroke-dashoffset`属性为0，来模拟画线。\n\n如何渐变呢？使用[SVG SMIL animation](https://developer.mozilla.org/zh-CN/docs/Web/SVG/SVG_animation_with_SMIL)。\n\n关键代码：\n\n```js\nvar length = path.getTotalLength();\npath.setAttribute(\"stroke-dasharray\", length + \" \" + length);\npath.setAttribute(\"stroke-dashoffset\", length);\npath.innerHTML= '<animate attributeName=\"stroke-dashoffset\" to=\"0\"  dur=\"7s\" begin=\"0s\" fill=\"freeze\" repeatCount=\"indefinite\"/>';\n```\n\n完整demo：\n\n![](/css/images/197.gif)\n\nhttps://codepen.io/lewis617/pen/vexjyp/\n\n## 给轨迹加上“圆头”\n\n马上就可以看见胜利的曙光了，最后我们来做轨迹的“圆头”：\n\n- 圆头就是个圆点（circle）\n- 圆点需要跟着轨迹一起移动\n\n画一个圆点很简单，那么如何画一个按照轨迹移动的圆点呢？答案是：[animateMotion元素](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/animateMotion)。\n\n关键代码：\n\n```js\nfunction createPathHead(pathObj, d){\n  var r = 3;\n  var head = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n  head.setAttribute(\"id\", pathObj.id + \"-head\");\n  head.setAttribute(\"r\", r);\n  head.setAttribute(\"fill\", pathObj.stroke);\n  \n  var animateMotion = document.createElementNS(\"http://www.w3.org/2000/svg\", \"animateMotion\");\n  animateMotion.setAttribute(\"path\", d);\n  animateMotion.setAttribute(\"begin\", \"indefinite\");\n  animateMotion.setAttribute(\"dur\", \"7s\");\n  animateMotion.setAttribute(\"fill\", \"freeze\");\n  animateMotion.setAttribute(\"rotate\", \"auto\");\n  head.appendChild(animateMotion);\n  \n  return head;\n}\n```\n\n至此，轨迹回放的关键技术点就讲完了，再次欣赏下最终的效果：\n\n![](https://wx1.sinaimg.cn/mw690/83900b4egy1fk1jn3atyng204h04ead8.gif)\n\n完整的demo在这里：\n\nhttps://codepen.io/lewis617/pen/RLpxPj/","slug":"svg-path-playback","published":1,"updated":"2019-05-01T08:10:30.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvmy003ltgyt0z5dqt8p","content":"<p>最近做了埋点方案XTracker的轨迹回放功能，大致效果就是，在指定几个顺序的点之间形成轨迹，来模拟用户在页面上的先后行为（比如一个用户先点了啥，后点了啥）。效果图如下：</p>\n<p><img src=\"/css/images/198.gif\" alt=\"\"></p>\n<p>在这篇文章中，我们来聊聊轨迹回放的一些技术细节。</p>\n<blockquote>\n<p>注意，本文只关注轨迹的绘制，并不讨论轨迹的各种生成算法。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"绘制红点坐标\"><a href=\"#绘制红点坐标\" class=\"headerlink\" title=\"绘制红点坐标\"></a>绘制红点坐标</h2><p>在绘制轨迹前，需要先绘制轨迹经过的红点坐标。使用SVG绘制红点非常简单：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"500\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"500\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">circle</span> <span class=\"attr\">r</span>=<span class=\"string\">\"5\"</span> <span class=\"attr\">cx</span>=<span class=\"string\">\"50\"</span> <span class=\"attr\">cy</span>=<span class=\"string\">\"55\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"red\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">circle</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/css/images/187.jpg\" alt=\"\"></p>\n<p>然后根据需要多画几个红点就可以了，也可以通过js批量生成：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCircles</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> r = <span class=\"string\">\"5\"</span>,</span><br><span class=\"line\">    fill = <span class=\"string\">\"red\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">// circleGroup是红点的容器</span></span><br><span class=\"line\">    circleGroup = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#circle-group\"</span>);</span><br><span class=\"line\">  <span class=\"comment\">// pointList是红点的坐标集合</span></span><br><span class=\"line\">  pointList.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">point</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> circle = <span class=\"built_in\">document</span>.createElementNS(</span><br><span class=\"line\">      <span class=\"string\">\"http://www.w3.org/2000/svg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"circle\"</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    circle.setAttribute(<span class=\"string\">\"r\"</span>, r);</span><br><span class=\"line\">    circle.setAttribute(<span class=\"string\">\"cx\"</span>, point[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    circle.setAttribute(<span class=\"string\">\"cy\"</span>, point[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    circle.setAttribute(<span class=\"string\">\"fill\"</span>, fill);</span><br><span class=\"line\">    circleGroup.appendChild(circle);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/css/images/188.jpg\" alt=\"\"></p>\n<h2 id=\"两点之间的轨迹\"><a href=\"#两点之间的轨迹\" class=\"headerlink\" title=\"两点之间的轨迹\"></a>两点之间的轨迹</h2><p>红点坐标画完了，我们来画轨迹。在画多点的轨迹之前，我们先来学习两点之间的轨迹，也就是两点之间曲线的画法。</p>\n<h3 id=\"二次贝塞尔曲线、三次贝塞尔曲线还是圆弧？\"><a href=\"#二次贝塞尔曲线、三次贝塞尔曲线还是圆弧？\" class=\"headerlink\" title=\"二次贝塞尔曲线、三次贝塞尔曲线还是圆弧？\"></a>二次贝塞尔曲线、三次贝塞尔曲线还是圆弧？</h3><p>SVG通过path可以画多种曲线主要包括：</p>\n<ul>\n<li>二次贝塞尔曲线：需要一个控制点，用来确定起点和终点的曲线斜率。<br>  <img src=\"/css/images/189.jpg\" alt=\"\"></li>\n<li>三次贝塞尔曲线：需要两个控制点，用来确定起点和终点的曲线斜率。<br>  <img src=\"/css/images/190.jpg\" alt=\"\"></li>\n<li>圆弧：需要两个半径、旋转角度、逆时针还是顺时针、大圆弧还是小圆弧等多个属性。<br>  <img src=\"/css/images/191.jpg\" alt=\"\"></li>\n</ul>\n<p>显然，二次贝塞尔曲线最为简单，所以我们决定用二次贝塞尔曲线来画两点之间的弧线。在SVG的path中，二次贝塞曲线的参数是：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">M x1 y1 Q x2 y2 x3 y3</span><br></pre></td></tr></table></figure>\n<p>其中<code>x1 y1</code>是起点，<code>x2 y2</code>是控制点，<code>x3 y3</code>是终点。来个demo吧！</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"320px\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"320px\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"line1\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"black\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"none\"</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M 0 50 Q 25 10 50 50\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><img src=\"/css/images/192.jpg\" alt=\"\"></p>\n<h3 id=\"确定控制点\"><a href=\"#确定控制点\" class=\"headerlink\" title=\"确定控制点\"></a>确定控制点</h3><p>确定了使用二次贝塞尔曲线，那么问题又来了，如何确定控制点呢？控制点决定了曲线的斜率和方向，我们期望曲线：</p>\n<ul>\n<li>对称。</li>\n<li>接近直线，稍微弯曲即可，太弯可能会超出画布范围。</li>\n<li>曲线永远顺时针，这样可以保证，A点到B点的曲线和B点到A点的曲线不重合。</li>\n</ul>\n<p>要想做到这三点，我们只需要让控制点：</p>\n<ul>\n<li>在两点的中垂线上。</li>\n<li>距离两点的中点等于某个较小的固定值。</li>\n<li>在起点和终点的顺时针区域。</li>\n</ul>\n<p>画个图吧！</p>\n<p><img src=\"/css/images/193.jpg\" alt=\"\"></p>\n<ul>\n<li>在顺时针区域画中垂线。中垂线和垂直线的角度为<code>angle</code></li>\n<li>规定<code>offset</code>为某个定值（比如40，或者其他比较小的定值）。</li>\n<li>那么控制点相对于中点的偏移值就确定了：<ul>\n<li><code>offsetX = Math.sin(angle) * offset;</code></li>\n<li><code>offsetY = -Math.cos(angle) * offset;</code></li>\n</ul>\n</li>\n</ul>\n<p>完整算法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCtlPoint</span>(<span class=\"params\">startX, startY, endX, endY, offset</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> offset = offset || <span class=\"number\">40</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> angle = <span class=\"built_in\">Math</span>.atan2(endY - startY, endX - startX);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> offsetX = <span class=\"built_in\">Math</span>.sin(angle) * offset;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> offsetY = -<span class=\"built_in\">Math</span>.cos(angle) * offset;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ctlX = (startX + endX) / <span class=\"number\">2</span> + offsetX;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ctlY = (startY + endY) / <span class=\"number\">2</span> + offsetY;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [ctlX, ctlY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"起点终点相同的情况\"><a href=\"#起点终点相同的情况\" class=\"headerlink\" title=\"起点终点相同的情况\"></a>起点终点相同的情况</h3><p>如果起点终点相同，我们就不能使用二次贝塞尔曲线了，而是应该在该点右侧画一个小圆弧，就像这样：</p>\n<p><img src=\"/css/images/195.jpg\" alt=\"\"></p>\n<p>在Path中圆弧的参数格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A rx ry x-axis-rotation large-arc-flag sweep-flag x y</span><br></pre></td></tr></table></figure>\n<ul>\n<li>弧形命令A的前两个参数分别是x轴半径和y轴半径。</li>\n<li><code>x-axis-rotation</code>表示弧形的旋转情况。</li>\n<li><code>large-arc-flag</code>决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。</li>\n<li><code>sweep-flag</code>表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧。</li>\n<li>最后两个参数是指定弧形的终点。</li>\n</ul>\n<blockquote>\n<p>弧形命令A的具体用法不属于本文范畴，请参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths</a> 。</p>\n</blockquote>\n<p>因为我们要求：</p>\n<ul>\n<li>圆弧接近于圆，不是椭圆。</li>\n<li>圆弧在右侧。</li>\n<li>大于180度。</li>\n</ul>\n<p>所以，我们的圆弧参数为：</p>\n<ul>\n<li>x轴和y轴半径同为某个很小的定值（我们就设为10吧）</li>\n<li><code>x-axis-rotation</code>为0，不需要旋转，既然是圆，转了也白转。</li>\n<li><code>large-arc-flag</code>为1，显然大于180度。</li>\n<li><code>sweep-flag</code>为1或0都行，不过要保证为1时，终点稍微比起点靠下一点，这样才能保证圆弧在右边。</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"320px\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"320px\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"line1\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"black\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"none\"</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M 50 50 A 10 10 0 1 1 50 50.1\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>效果截图：</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/83900b4egy1fjy8a993prj203e032a9t.jpg\" alt=\"\"></p>\n<p>将两种情况封装成获取d属性的函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getD</span>(<span class=\"params\">startX, startY, endX, endY</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ctlPoint = getCtlPoint(startX, startY, endX, endY, <span class=\"number\">40</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> d = [<span class=\"string\">\"M\"</span>, startX, startY].join(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (startX !== endX || startY !== endY) &#123;</span><br><span class=\"line\">    d += [<span class=\"string\">\" Q\"</span>, ctlPoint[<span class=\"number\">0</span>], ctlPoint[<span class=\"number\">1</span>], endX, endY].join(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    d += [<span class=\"string\">\" A\"</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, endX, endY + <span class=\"number\">0.1</span>].join(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完整demo：</p>\n<p><a href=\"https://codepen.io/lewis617/pen/JrWMBy/\" target=\"_blank\" rel=\"noopener\">https://codepen.io/lewis617/pen/JrWMBy/</a></p>\n<h2 id=\"多点之间的轨迹\"><a href=\"#多点之间的轨迹\" class=\"headerlink\" title=\"多点之间的轨迹\"></a>多点之间的轨迹</h2><p>两点之间弧线确定了，那么如何确定多点之间的轨迹呢？其实很简单，只需要在命令后面加上新的控制点和终点即可：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">M x1 y1 Q x2 y2 x3 y3 Q x4 y4 x5 y5</span><br></pre></td></tr></table></figure>\n<p>所以只需要简单更新一下之前封装的函数即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getD</span>(<span class=\"params\">pointList</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> offset = offset || <span class=\"number\">40</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> d = ([<span class=\"string\">'M'</span> ,pointList[<span class=\"number\">0</span>][<span class=\"number\">0</span>], pointList[<span class=\"number\">0</span>][<span class=\"number\">1</span>]]).join(<span class=\"string\">' '</span>);</span><br><span class=\"line\">  pointList.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">point, i</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> startX = pointList[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>],</span><br><span class=\"line\">          startY = pointList[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>],</span><br><span class=\"line\">          endX = point[<span class=\"number\">0</span>], </span><br><span class=\"line\">          endY = point[<span class=\"number\">1</span>];</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">var</span> ctlPoint = getCtlPoint(startX, startY, endX, endY, offset);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span>(startX !== endX || startY !== endY)&#123;</span><br><span class=\"line\">        d+=([<span class=\"string\">' Q'</span>, ctlPoint[<span class=\"number\">0</span>], ctlPoint[<span class=\"number\">1</span>], endX, endY]).join(<span class=\"string\">' '</span>);</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        d+=([<span class=\"string\">' A'</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, endX, endY + <span class=\"number\">0.1</span>]).join(<span class=\"string\">' '</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果<code>pointList</code>为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pointList = [</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">50</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">50</span>],</span><br><span class=\"line\">  [<span class=\"number\">50</span>, <span class=\"number\">50</span>],</span><br><span class=\"line\">  [<span class=\"number\">100</span>, <span class=\"number\">50</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">100</span>],</span><br><span class=\"line\">  [<span class=\"number\">50</span>, <span class=\"number\">100</span>],</span><br><span class=\"line\">  [<span class=\"number\">100</span>, <span class=\"number\">100</span>],</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>那么效果图：</p>\n<p><img src=\"/css/images/196.jpg\" alt=\"\"></p>\n<p>完整demo：</p>\n<p><a href=\"https://codepen.io/lewis617/pen/wrJpGY/\" target=\"_blank\" rel=\"noopener\">https://codepen.io/lewis617/pen/wrJpGY/</a></p>\n<h2 id=\"让轨迹回放起来\"><a href=\"#让轨迹回放起来\" class=\"headerlink\" title=\"让轨迹回放起来\"></a>让轨迹回放起来</h2><p>轨迹画完了，如何让它回放呢？这里需要用到这两个属性：</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/stroke-dasharray\" target=\"_blank\" rel=\"noopener\">stroke-dasharray</a>：控制用来描边的点划线的图案范式。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/stroke-dashoffset\" target=\"_blank\" rel=\"noopener\">stroke-dashoffset</a>：指定了dash模式到路径开始的距离。</p>\n<ul>\n<li>先设置<code>stroke-dasharray</code>为 <code>&quot;length length&quot;</code>，来让曲线颜色和空白的长度均为曲线长度。</li>\n<li>然后设置<code>stroke-dashoffset</code>初始状态为曲线长度，来保证整个曲线”看起来”都是空白。</li>\n<li>最后渐变<code>stroke-dashoffset</code>属性为0，来模拟画线。</li>\n</ul>\n<p>如何渐变呢？使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/SVG_animation_with_SMIL\" target=\"_blank\" rel=\"noopener\">SVG SMIL animation</a>。</p>\n<p>关键代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> length = path.getTotalLength();</span><br><span class=\"line\">path.setAttribute(<span class=\"string\">\"stroke-dasharray\"</span>, length + <span class=\"string\">\" \"</span> + length);</span><br><span class=\"line\">path.setAttribute(<span class=\"string\">\"stroke-dashoffset\"</span>, length);</span><br><span class=\"line\">path.innerHTML= <span class=\"string\">'&lt;animate attributeName=\"stroke-dashoffset\" to=\"0\"  dur=\"7s\" begin=\"0s\" fill=\"freeze\" repeatCount=\"indefinite\"/&gt;'</span>;</span><br></pre></td></tr></table></figure>\n<p>完整demo：</p>\n<p><img src=\"/css/images/197.gif\" alt=\"\"></p>\n<p><a href=\"https://codepen.io/lewis617/pen/vexjyp/\" target=\"_blank\" rel=\"noopener\">https://codepen.io/lewis617/pen/vexjyp/</a></p>\n<h2 id=\"给轨迹加上“圆头”\"><a href=\"#给轨迹加上“圆头”\" class=\"headerlink\" title=\"给轨迹加上“圆头”\"></a>给轨迹加上“圆头”</h2><p>马上就可以看见胜利的曙光了，最后我们来做轨迹的“圆头”：</p>\n<ul>\n<li>圆头就是个圆点（circle）</li>\n<li>圆点需要跟着轨迹一起移动</li>\n</ul>\n<p>画一个圆点很简单，那么如何画一个按照轨迹移动的圆点呢？答案是：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/animateMotion\" target=\"_blank\" rel=\"noopener\">animateMotion元素</a>。</p>\n<p>关键代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPathHead</span>(<span class=\"params\">pathObj, d</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> r = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> head = <span class=\"built_in\">document</span>.createElementNS(<span class=\"string\">\"http://www.w3.org/2000/svg\"</span>, <span class=\"string\">\"circle\"</span>);</span><br><span class=\"line\">  head.setAttribute(<span class=\"string\">\"id\"</span>, pathObj.id + <span class=\"string\">\"-head\"</span>);</span><br><span class=\"line\">  head.setAttribute(<span class=\"string\">\"r\"</span>, r);</span><br><span class=\"line\">  head.setAttribute(<span class=\"string\">\"fill\"</span>, pathObj.stroke);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> animateMotion = <span class=\"built_in\">document</span>.createElementNS(<span class=\"string\">\"http://www.w3.org/2000/svg\"</span>, <span class=\"string\">\"animateMotion\"</span>);</span><br><span class=\"line\">  animateMotion.setAttribute(<span class=\"string\">\"path\"</span>, d);</span><br><span class=\"line\">  animateMotion.setAttribute(<span class=\"string\">\"begin\"</span>, <span class=\"string\">\"indefinite\"</span>);</span><br><span class=\"line\">  animateMotion.setAttribute(<span class=\"string\">\"dur\"</span>, <span class=\"string\">\"7s\"</span>);</span><br><span class=\"line\">  animateMotion.setAttribute(<span class=\"string\">\"fill\"</span>, <span class=\"string\">\"freeze\"</span>);</span><br><span class=\"line\">  animateMotion.setAttribute(<span class=\"string\">\"rotate\"</span>, <span class=\"string\">\"auto\"</span>);</span><br><span class=\"line\">  head.appendChild(animateMotion);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，轨迹回放的关键技术点就讲完了，再次欣赏下最终的效果：</p>\n<p><img src=\"https://wx1.sinaimg.cn/mw690/83900b4egy1fk1jn3atyng204h04ead8.gif\" alt=\"\"></p>\n<p>完整的demo在这里：</p>\n<p><a href=\"https://codepen.io/lewis617/pen/RLpxPj/\" target=\"_blank\" rel=\"noopener\">https://codepen.io/lewis617/pen/RLpxPj/</a></p>\n","site":{"data":{}},"excerpt":"<p>最近做了埋点方案XTracker的轨迹回放功能，大致效果就是，在指定几个顺序的点之间形成轨迹，来模拟用户在页面上的先后行为（比如一个用户先点了啥，后点了啥）。效果图如下：</p>\n<p><img src=\"/css/images/198.gif\" alt=\"\"></p>\n<p>在这篇文章中，我们来聊聊轨迹回放的一些技术细节。</p>\n<blockquote>\n<p>注意，本文只关注轨迹的绘制，并不讨论轨迹的各种生成算法。</p>\n</blockquote>","more":"<h2 id=\"绘制红点坐标\"><a href=\"#绘制红点坐标\" class=\"headerlink\" title=\"绘制红点坐标\"></a>绘制红点坐标</h2><p>在绘制轨迹前，需要先绘制轨迹经过的红点坐标。使用SVG绘制红点非常简单：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"500\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"500\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">circle</span> <span class=\"attr\">r</span>=<span class=\"string\">\"5\"</span> <span class=\"attr\">cx</span>=<span class=\"string\">\"50\"</span> <span class=\"attr\">cy</span>=<span class=\"string\">\"55\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"red\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">circle</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/css/images/187.jpg\" alt=\"\"></p>\n<p>然后根据需要多画几个红点就可以了，也可以通过js批量生成：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCircles</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> r = <span class=\"string\">\"5\"</span>,</span><br><span class=\"line\">    fill = <span class=\"string\">\"red\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">// circleGroup是红点的容器</span></span><br><span class=\"line\">    circleGroup = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#circle-group\"</span>);</span><br><span class=\"line\">  <span class=\"comment\">// pointList是红点的坐标集合</span></span><br><span class=\"line\">  pointList.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">point</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> circle = <span class=\"built_in\">document</span>.createElementNS(</span><br><span class=\"line\">      <span class=\"string\">\"http://www.w3.org/2000/svg\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"circle\"</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    circle.setAttribute(<span class=\"string\">\"r\"</span>, r);</span><br><span class=\"line\">    circle.setAttribute(<span class=\"string\">\"cx\"</span>, point[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    circle.setAttribute(<span class=\"string\">\"cy\"</span>, point[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    circle.setAttribute(<span class=\"string\">\"fill\"</span>, fill);</span><br><span class=\"line\">    circleGroup.appendChild(circle);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/css/images/188.jpg\" alt=\"\"></p>\n<h2 id=\"两点之间的轨迹\"><a href=\"#两点之间的轨迹\" class=\"headerlink\" title=\"两点之间的轨迹\"></a>两点之间的轨迹</h2><p>红点坐标画完了，我们来画轨迹。在画多点的轨迹之前，我们先来学习两点之间的轨迹，也就是两点之间曲线的画法。</p>\n<h3 id=\"二次贝塞尔曲线、三次贝塞尔曲线还是圆弧？\"><a href=\"#二次贝塞尔曲线、三次贝塞尔曲线还是圆弧？\" class=\"headerlink\" title=\"二次贝塞尔曲线、三次贝塞尔曲线还是圆弧？\"></a>二次贝塞尔曲线、三次贝塞尔曲线还是圆弧？</h3><p>SVG通过path可以画多种曲线主要包括：</p>\n<ul>\n<li>二次贝塞尔曲线：需要一个控制点，用来确定起点和终点的曲线斜率。<br>  <img src=\"/css/images/189.jpg\" alt=\"\"></li>\n<li>三次贝塞尔曲线：需要两个控制点，用来确定起点和终点的曲线斜率。<br>  <img src=\"/css/images/190.jpg\" alt=\"\"></li>\n<li>圆弧：需要两个半径、旋转角度、逆时针还是顺时针、大圆弧还是小圆弧等多个属性。<br>  <img src=\"/css/images/191.jpg\" alt=\"\"></li>\n</ul>\n<p>显然，二次贝塞尔曲线最为简单，所以我们决定用二次贝塞尔曲线来画两点之间的弧线。在SVG的path中，二次贝塞曲线的参数是：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">M x1 y1 Q x2 y2 x3 y3</span><br></pre></td></tr></table></figure>\n<p>其中<code>x1 y1</code>是起点，<code>x2 y2</code>是控制点，<code>x3 y3</code>是终点。来个demo吧！</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"320px\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"320px\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"line1\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"black\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"none\"</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M 0 50 Q 25 10 50 50\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><img src=\"/css/images/192.jpg\" alt=\"\"></p>\n<h3 id=\"确定控制点\"><a href=\"#确定控制点\" class=\"headerlink\" title=\"确定控制点\"></a>确定控制点</h3><p>确定了使用二次贝塞尔曲线，那么问题又来了，如何确定控制点呢？控制点决定了曲线的斜率和方向，我们期望曲线：</p>\n<ul>\n<li>对称。</li>\n<li>接近直线，稍微弯曲即可，太弯可能会超出画布范围。</li>\n<li>曲线永远顺时针，这样可以保证，A点到B点的曲线和B点到A点的曲线不重合。</li>\n</ul>\n<p>要想做到这三点，我们只需要让控制点：</p>\n<ul>\n<li>在两点的中垂线上。</li>\n<li>距离两点的中点等于某个较小的固定值。</li>\n<li>在起点和终点的顺时针区域。</li>\n</ul>\n<p>画个图吧！</p>\n<p><img src=\"/css/images/193.jpg\" alt=\"\"></p>\n<ul>\n<li>在顺时针区域画中垂线。中垂线和垂直线的角度为<code>angle</code></li>\n<li>规定<code>offset</code>为某个定值（比如40，或者其他比较小的定值）。</li>\n<li>那么控制点相对于中点的偏移值就确定了：<ul>\n<li><code>offsetX = Math.sin(angle) * offset;</code></li>\n<li><code>offsetY = -Math.cos(angle) * offset;</code></li>\n</ul>\n</li>\n</ul>\n<p>完整算法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCtlPoint</span>(<span class=\"params\">startX, startY, endX, endY, offset</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> offset = offset || <span class=\"number\">40</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> angle = <span class=\"built_in\">Math</span>.atan2(endY - startY, endX - startX);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> offsetX = <span class=\"built_in\">Math</span>.sin(angle) * offset;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> offsetY = -<span class=\"built_in\">Math</span>.cos(angle) * offset;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ctlX = (startX + endX) / <span class=\"number\">2</span> + offsetX;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ctlY = (startY + endY) / <span class=\"number\">2</span> + offsetY;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [ctlX, ctlY];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"起点终点相同的情况\"><a href=\"#起点终点相同的情况\" class=\"headerlink\" title=\"起点终点相同的情况\"></a>起点终点相同的情况</h3><p>如果起点终点相同，我们就不能使用二次贝塞尔曲线了，而是应该在该点右侧画一个小圆弧，就像这样：</p>\n<p><img src=\"/css/images/195.jpg\" alt=\"\"></p>\n<p>在Path中圆弧的参数格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A rx ry x-axis-rotation large-arc-flag sweep-flag x y</span><br></pre></td></tr></table></figure>\n<ul>\n<li>弧形命令A的前两个参数分别是x轴半径和y轴半径。</li>\n<li><code>x-axis-rotation</code>表示弧形的旋转情况。</li>\n<li><code>large-arc-flag</code>决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。</li>\n<li><code>sweep-flag</code>表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧。</li>\n<li>最后两个参数是指定弧形的终点。</li>\n</ul>\n<blockquote>\n<p>弧形命令A的具体用法不属于本文范畴，请参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths</a> 。</p>\n</blockquote>\n<p>因为我们要求：</p>\n<ul>\n<li>圆弧接近于圆，不是椭圆。</li>\n<li>圆弧在右侧。</li>\n<li>大于180度。</li>\n</ul>\n<p>所以，我们的圆弧参数为：</p>\n<ul>\n<li>x轴和y轴半径同为某个很小的定值（我们就设为10吧）</li>\n<li><code>x-axis-rotation</code>为0，不需要旋转，既然是圆，转了也白转。</li>\n<li><code>large-arc-flag</code>为1，显然大于180度。</li>\n<li><code>sweep-flag</code>为1或0都行，不过要保证为1时，终点稍微比起点靠下一点，这样才能保证圆弧在右边。</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"320px\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"320px\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">id</span>=<span class=\"string\">\"line1\"</span> <span class=\"attr\">stroke</span>=<span class=\"string\">\"black\"</span> <span class=\"attr\">fill</span>=<span class=\"string\">\"none\"</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M 50 50 A 10 10 0 1 1 50 50.1\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>效果截图：</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/83900b4egy1fjy8a993prj203e032a9t.jpg\" alt=\"\"></p>\n<p>将两种情况封装成获取d属性的函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getD</span>(<span class=\"params\">startX, startY, endX, endY</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ctlPoint = getCtlPoint(startX, startY, endX, endY, <span class=\"number\">40</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> d = [<span class=\"string\">\"M\"</span>, startX, startY].join(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (startX !== endX || startY !== endY) &#123;</span><br><span class=\"line\">    d += [<span class=\"string\">\" Q\"</span>, ctlPoint[<span class=\"number\">0</span>], ctlPoint[<span class=\"number\">1</span>], endX, endY].join(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    d += [<span class=\"string\">\" A\"</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, endX, endY + <span class=\"number\">0.1</span>].join(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完整demo：</p>\n<p><a href=\"https://codepen.io/lewis617/pen/JrWMBy/\" target=\"_blank\" rel=\"noopener\">https://codepen.io/lewis617/pen/JrWMBy/</a></p>\n<h2 id=\"多点之间的轨迹\"><a href=\"#多点之间的轨迹\" class=\"headerlink\" title=\"多点之间的轨迹\"></a>多点之间的轨迹</h2><p>两点之间弧线确定了，那么如何确定多点之间的轨迹呢？其实很简单，只需要在命令后面加上新的控制点和终点即可：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">M x1 y1 Q x2 y2 x3 y3 Q x4 y4 x5 y5</span><br></pre></td></tr></table></figure>\n<p>所以只需要简单更新一下之前封装的函数即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getD</span>(<span class=\"params\">pointList</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> offset = offset || <span class=\"number\">40</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> d = ([<span class=\"string\">'M'</span> ,pointList[<span class=\"number\">0</span>][<span class=\"number\">0</span>], pointList[<span class=\"number\">0</span>][<span class=\"number\">1</span>]]).join(<span class=\"string\">' '</span>);</span><br><span class=\"line\">  pointList.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">point, i</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> startX = pointList[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>],</span><br><span class=\"line\">          startY = pointList[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>],</span><br><span class=\"line\">          endX = point[<span class=\"number\">0</span>], </span><br><span class=\"line\">          endY = point[<span class=\"number\">1</span>];</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">var</span> ctlPoint = getCtlPoint(startX, startY, endX, endY, offset);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span>(startX !== endX || startY !== endY)&#123;</span><br><span class=\"line\">        d+=([<span class=\"string\">' Q'</span>, ctlPoint[<span class=\"number\">0</span>], ctlPoint[<span class=\"number\">1</span>], endX, endY]).join(<span class=\"string\">' '</span>);</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        d+=([<span class=\"string\">' A'</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, endX, endY + <span class=\"number\">0.1</span>]).join(<span class=\"string\">' '</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果<code>pointList</code>为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pointList = [</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">50</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">50</span>],</span><br><span class=\"line\">  [<span class=\"number\">50</span>, <span class=\"number\">50</span>],</span><br><span class=\"line\">  [<span class=\"number\">100</span>, <span class=\"number\">50</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">100</span>],</span><br><span class=\"line\">  [<span class=\"number\">50</span>, <span class=\"number\">100</span>],</span><br><span class=\"line\">  [<span class=\"number\">100</span>, <span class=\"number\">100</span>],</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>那么效果图：</p>\n<p><img src=\"/css/images/196.jpg\" alt=\"\"></p>\n<p>完整demo：</p>\n<p><a href=\"https://codepen.io/lewis617/pen/wrJpGY/\" target=\"_blank\" rel=\"noopener\">https://codepen.io/lewis617/pen/wrJpGY/</a></p>\n<h2 id=\"让轨迹回放起来\"><a href=\"#让轨迹回放起来\" class=\"headerlink\" title=\"让轨迹回放起来\"></a>让轨迹回放起来</h2><p>轨迹画完了，如何让它回放呢？这里需要用到这两个属性：</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/stroke-dasharray\" target=\"_blank\" rel=\"noopener\">stroke-dasharray</a>：控制用来描边的点划线的图案范式。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/stroke-dashoffset\" target=\"_blank\" rel=\"noopener\">stroke-dashoffset</a>：指定了dash模式到路径开始的距离。</p>\n<ul>\n<li>先设置<code>stroke-dasharray</code>为 <code>&quot;length length&quot;</code>，来让曲线颜色和空白的长度均为曲线长度。</li>\n<li>然后设置<code>stroke-dashoffset</code>初始状态为曲线长度，来保证整个曲线”看起来”都是空白。</li>\n<li>最后渐变<code>stroke-dashoffset</code>属性为0，来模拟画线。</li>\n</ul>\n<p>如何渐变呢？使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/SVG_animation_with_SMIL\" target=\"_blank\" rel=\"noopener\">SVG SMIL animation</a>。</p>\n<p>关键代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> length = path.getTotalLength();</span><br><span class=\"line\">path.setAttribute(<span class=\"string\">\"stroke-dasharray\"</span>, length + <span class=\"string\">\" \"</span> + length);</span><br><span class=\"line\">path.setAttribute(<span class=\"string\">\"stroke-dashoffset\"</span>, length);</span><br><span class=\"line\">path.innerHTML= <span class=\"string\">'&lt;animate attributeName=\"stroke-dashoffset\" to=\"0\"  dur=\"7s\" begin=\"0s\" fill=\"freeze\" repeatCount=\"indefinite\"/&gt;'</span>;</span><br></pre></td></tr></table></figure>\n<p>完整demo：</p>\n<p><img src=\"/css/images/197.gif\" alt=\"\"></p>\n<p><a href=\"https://codepen.io/lewis617/pen/vexjyp/\" target=\"_blank\" rel=\"noopener\">https://codepen.io/lewis617/pen/vexjyp/</a></p>\n<h2 id=\"给轨迹加上“圆头”\"><a href=\"#给轨迹加上“圆头”\" class=\"headerlink\" title=\"给轨迹加上“圆头”\"></a>给轨迹加上“圆头”</h2><p>马上就可以看见胜利的曙光了，最后我们来做轨迹的“圆头”：</p>\n<ul>\n<li>圆头就是个圆点（circle）</li>\n<li>圆点需要跟着轨迹一起移动</li>\n</ul>\n<p>画一个圆点很简单，那么如何画一个按照轨迹移动的圆点呢？答案是：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/animateMotion\" target=\"_blank\" rel=\"noopener\">animateMotion元素</a>。</p>\n<p>关键代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPathHead</span>(<span class=\"params\">pathObj, d</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> r = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> head = <span class=\"built_in\">document</span>.createElementNS(<span class=\"string\">\"http://www.w3.org/2000/svg\"</span>, <span class=\"string\">\"circle\"</span>);</span><br><span class=\"line\">  head.setAttribute(<span class=\"string\">\"id\"</span>, pathObj.id + <span class=\"string\">\"-head\"</span>);</span><br><span class=\"line\">  head.setAttribute(<span class=\"string\">\"r\"</span>, r);</span><br><span class=\"line\">  head.setAttribute(<span class=\"string\">\"fill\"</span>, pathObj.stroke);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> animateMotion = <span class=\"built_in\">document</span>.createElementNS(<span class=\"string\">\"http://www.w3.org/2000/svg\"</span>, <span class=\"string\">\"animateMotion\"</span>);</span><br><span class=\"line\">  animateMotion.setAttribute(<span class=\"string\">\"path\"</span>, d);</span><br><span class=\"line\">  animateMotion.setAttribute(<span class=\"string\">\"begin\"</span>, <span class=\"string\">\"indefinite\"</span>);</span><br><span class=\"line\">  animateMotion.setAttribute(<span class=\"string\">\"dur\"</span>, <span class=\"string\">\"7s\"</span>);</span><br><span class=\"line\">  animateMotion.setAttribute(<span class=\"string\">\"fill\"</span>, <span class=\"string\">\"freeze\"</span>);</span><br><span class=\"line\">  animateMotion.setAttribute(<span class=\"string\">\"rotate\"</span>, <span class=\"string\">\"auto\"</span>);</span><br><span class=\"line\">  head.appendChild(animateMotion);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，轨迹回放的关键技术点就讲完了，再次欣赏下最终的效果：</p>\n<p><img src=\"https://wx1.sinaimg.cn/mw690/83900b4egy1fk1jn3atyng204h04ead8.gif\" alt=\"\"></p>\n<p>完整的demo在这里：</p>\n<p><a href=\"https://codepen.io/lewis617/pen/RLpxPj/\" target=\"_blank\" rel=\"noopener\">https://codepen.io/lewis617/pen/RLpxPj/</a></p>"},{"title":"Emily Gorcenski：物联网的伦理问题（译）","date":"2017-11-02T10:12:00.000Z","_content":"\n本文翻译整理自 YouTube 视频：\n\nhttps://www.youtube.com/watch?v=xLL7Fo_em2E\n\n![](/css/images/199.jpg)\n\n<!--more-->\n\n非常感谢大家！接下来我要讲的是物联网的伦理问题，保证不会有太多说教哦。我是 Emily Gorcenski，我并不经常在推特上讲物联网这些事，但我却对物联网以及它所构建的蓝图非常感兴趣。那么，我为何要在 JavaScript 大会上讲物联网的伦理问题呢？事情是这样的，我之前已经讲过几次这个主题，而且我开玩笑说，每次我都能给出一个全新的演讲，因为在物联网中，有太多的失败案例、漏洞和安全问题频繁出现。如果我只是专注案例研究，那么每次讲的东西都完全不同。而这次，我决定不这么做了，而是简单聊一下为何伦理很重要，为何伦理对作为 JavaScript 开发者的你很重要，以及我们如何将 JavaScript ，将科技注入一系列原本没有这些技术的设备和服务。聊伦理问题而不提及一些沉重话题是不可能的。所以这里给出了一些警告性的内容（看PPT）：\n\n- 人类伤亡的频繁讨论\n- 性侵犯的探讨\n- 一张生肉图片（留点悬念）\n\n![](/css/images/200.jpg)\n\n如果这些话题吓到你了，那么我会尽量在十分钟内结束这些话题。\n\n我是谁？这里我需要先承认，我在这个大会上有点像江湖骗子，因为我不是个 JavaScript 开发者。我是个数据科学家，以数学家的方式被培养，但也是个工程师，我在学校学习了航空工程和机械工程。\n\n![](/css/images/201.jpg)\n\n我曾经在航空、生物科技领域工作，现在在金融业。这些领域或行业有个共同点就是，它们都被严格调控。在这些领域工作的人们都会遵循一些专业的伦理法规，通过一个独立社会或其他协助指导什么是道德产品的组织。\n\n当讨论物联网时，总觉得这是个有点空洞无聊的概念。我们会想到智能冰箱、智能汽车这一类东东。我个人更喜欢把物联网想象为：把互联网放进原本不属于它的地方。\n\n![](/css/images/202.jpg)\n\n所以物联网可以指智能设备，但我也可以把 Uber 想象为出租车物联网。当我们看待这是否存在伦理问题时，我们必须要看看：我们使用科技做了什么，连接了什么。前后的差异并不在于这些设备、产品或服务有没有被计算机化，而是我们让用户拥有了连接什么的能力。如果你是个 JavaScript 开发者，或许你想要个物联网面包机，这样的话，你就可以在烤面包时插入一些代码进去。这很重要，因为物联网是下一代的便利优化。我们花了30年时间来优化产品使其更加方便易用。所以，现在你有个像冰箱这样的非物联网设备根本没有什么竞争优势。你必须要让它们连接起来！\n\n![](/css/images/203.jpg)\n\n你或许会关心物联网设备的监控能力，比如监控 Uber 引起的一些惨案。但是如果你没有能力到处逛逛，或没有住在方便打车的地方，或有其他需要，比如 有时候 Uber 可能会成为救生员，这些都改变了你的生活。我们不能简单说物联网是荒谬的、轻浮的，就像个玩具，就像是一个垃圾推特账号，非常滑稽，整天发一下低质量内容。事实上，物联网还是带来了很多好的事情。\n\n当我们说伦理这个词时，我们在说什么？你知道因为自动驾驶汽车，现在[电车问题](https://zh.wikipedia.org/wiki/%E6%9C%89%E8%BD%A8%E7%94%B5%E8%BD%A6%E9%9A%BE%E9%A2%98)很流行。\n\n![](/css/images/204.jpg)\n\n你或许已经看过这个图了（看PPT）：一个诺贝尔奖获得者被绑在一个轨道上，另外五个普通人被绑在另一个轨道上。不知怎的，你被安排在控制杠杆的位置上。这是个在互联网上非常流行的问题，因为：一，如果将该问题抽象出来，我们可以用类别理论来解决它。二，这确实是个[网络模因](https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E7%88%86%E7%B4%85%E4%BA%8B%E7%89%A9)。既然电车问题的关键不在电车，那么为何自动驾驶汽车会成为问题呢？\n\n![](/css/images/205.jpg)\n\n我们喜欢把事情当作难题来解决 - 这就是我们作为开发人员和工程师的本性。在技​​术上，我们实际上并没有经常面临伦理困境。\n\n![](/css/images/206.jpg)\n\n当有两个竞争的伦理框架同时存在，且你的行为不能违反至少其中一个。那么此时，伦理困境就出现了。我认为 JavaScript 非常引人入胜，因为 JavaScript 社区对在未来十年的技术发展中出现的最有意思伦理困境负有责任。这个话题我等会儿会细说，有些人或许已经知道我待会要说什么了。技术的问题是，我们往往不遵守道德准则。我不是说要写一个起诉书，说你是坏的，不道德的人。说到这，有些公司可能要对我斜眼了。但我的意思是，在我们行业，我们没有一个专业的法规。有一些社团，你可以加入。如果你是像 ACM 或 I888 这样的组织的成员，举起你的手。哦，有一些但不是大多数。\n\n在实践中，伦理学是关于损害的分析和风险的缓解。\n\n![](/css/images/207.jpg)\n\n所以，当我们讨论伦理行为时，特别是伦理研究时，我们要做的不是消除人员受伤的可能性，而是去理解人员可能被科技所伤害的各种方式，寻找能减少风险发生的方法，并在必要时提供整治。当我们为物联网开发各种技术时，上述做法就是我们需要提出的道德框架。事故可能会以三种方式发生： **不法行为**、 **故障**、**边界情况**。\n\n![](/css/images/208.jpg)\n\n不法行为在物联网中是最常见的话题，这是个安全问题，是人们常说的黑客行为。去年秋天，Miri 僵尸网络发生 DDoS 攻击，这是目前的最大的 DDoS 攻击，这次攻击发生在不安全的物联网设备上。你或许知道，物联网安全性现在处于非常糟糕的状态。当这次事故发生时，它的时间安排和方式让很多人担心这是对美国总统大选的攻击的前兆，这将试图影响这次选举的结果。事实证明，这个恐惧是没有根据的。我不想在这次演讲中讨论这个事故。因为，首先我没法覆盖所有事。另外，其他方式的事故依然可能会发生，比如故障和边界情况。当设备在出乎开发人员预料的情况下被运行时，边界情况就会发生。另外值得一提的是，很多时候我们把软件漏洞和边界情况混为一谈，事实上这两者除了表达方式外确实没有太多不同。\n\n这是 Twitter上一个很好的例子。\n\n![](/css/images/209.jpg)\n\n这个可怜的绅士安德鲁，有一个物联网的水冷却器，他的 TLS 证书过期了，导致一些阻塞代码，硬件互锁失败，导致他家里都是水。这是一个真实的问题，对吧？是的，这是个真实的问题。如果 TLS 证书在 Web 服务中过期，我们忘记了 TLS 证书，我们有一段阻止代码，这是个操作问题，我们需要有相关人员来处理。但我们无法把物联网设备当成人来看待，我们需要将其当作宠物。这些宠物生活在人类的家里，而且因为没有喂食而非常暴躁易怒。有一天，如果我们不小心把 JavaScript 放入一个物联网水壶，结果因为`\"undefined\" is not a function`，房子被这个水壶烧了。\n\n另外一个例子，这是我做的，我很自豪。\n\n![](/css/images/210.jpg)\n\n几年前我做了这个，如果可以的话，我想全屏显示。这是一个 [Microsoft Band](https://zh.wikipedia.org/wiki/Microsoft_Band)，我没有故意选择微软的产品。这是一块生鸡肉，我没有对活鸡做一些可怕的事，比如做僵尸鸡。这只是一块我从杂货店买的肉。从视频上看，它正在读取每分钟120次的心率！在现实世界中，传感器是凌乱的、嘈杂的、不完美的。所以当我们设计物联网设备时，我们必须考虑到这一点。可以读一个鸡胸肉的心率是荒谬的，但这可以对很多事产生深刻的影响。举个例子，有一些学校强制学生戴 [Fitbit](https://en.wikipedia.org/wiki/Fitbit)。也有雇主有健康保险激励计划来做这样的事。这样的话，我们就有监控设备，来监测我们的健康状况，并可以及时生成健康报告。这并不是假设的，而是真的发生了。\n\n2015年，一名女子正在兰开斯特 (宾夕法尼亚州)看望一个同事。 她向警方报告性侵犯。警方发现了她的 Fitbit，并在她允许的情况下分析了数据，结果警方不仅停止了调查，还指控该女子假报警。去年，她对承认了这些指控，被定罪并实行缓刑。检方律师说 FitBit 数据也证明了这个。\n\n![](/css/images/211.jpg)\n\n我可以从一块生鸡肉中测出每分钟120次的心率，一个女人的生活也可能会被毁掉，因为没有 Fi​​tBit 的人站起来说不：“我们的设备不是这样准确。” 你不能这样做。我们的设备会出错。问题是我们如何建立它们是没有规定，质量保证或标准的。\n\n![](/css/images/212.jpg)\n\n我们只是编写代码，制造硬件。 我们创新，快，快，快。我们不问自己，当出现错误时会发生什么样的伤害？而这种情况越来越频繁。这些装置正在用于刑事和民事调查。就在上周，CNN 报道说一个男人被指控谋杀了他的妻子，根据他妻子的 Fitbit 数据记录。任何人带着 Fitbit 走，Fitbit 都会记录，即便当时你正坐在沙发上。我们怎么能让这种事情发生呢？我们怎么能让这种信息影响人们的生活？另一个事件：去年，一个智能水表被用于谋杀调查。\n\n![](/css/images/213.jpg)\n\n问题是：谁去监狱？ 当一个设备向警方作出虚假陈述时，谁将要接受缓刑？此外，说一些事情真实发生，说一些事情是假的，说有人受伤或被杀了，如果该设备有故障，谁将承担责任？是设备主人吗？ 是开发者吗？ 是制造设备的公司吗？这似乎应该是一个解决的问题，但事实却没有。这已经发生了。\n\n![](/css/images/214.jpg)\n\n在这个框架下，你将看到几辆汽车，右边的白色汽车是 Google 自动驾驶汽车，这张图像是静止图像 - 这是从拍摄的视频中截取的屏幕截图，来自在加利福尼亚州山景城的一辆市政公共汽车的行车记录仪。\n\n![](/css/images/215.jpg)\n\n那辆 Google SUV 即将在公共汽车前面出来，发生意外。幸运的是，没有人受伤。这是自驾车首次被发现对一次意外承担责任。谷歌说：“我们的错，我们会进行相关损害赔偿。”他们调查了事情经过，得出结论，车子预测了因为我们领先于公共汽车，所以公共汽车应该让着我们。\n\n![](/css/images/216.jpg)\n\nGoogle 现在正想卖他们的自动驾驶汽车，所以他们当然会承担责任，而不是去法庭上测试他们的车。但是，随着我们进入物联网的未来，我们不能依靠这一点。 一旦这个规模出现，我们就不能依靠仁慈的公司承担责任。顺便说一下，即使 Google 是正确的，这仍然是一个历史时刻。因为如果公共汽车已经让了自动驾驶汽车，这将是市政府的公共汽车第一次屈服！\n\n几年前，旧金山有一名法官。他研究自主系统是否不受现有的责任理论限制。深入研究后，他发现那些自己做决定的，使用神经网络的，使用自适应自调节控制系统的，设计自己的手段来完成任务的机器在现有的侵权理论下，可能不受任何责任。\n\n![](/css/images/217.jpg)\n\n这有巨大的影响。因为如果你买普通的冰箱，它会损坏，你可以说，“嘿，制造商， 你负责这个损坏。”如果你买一个咖啡机，并且由于一个小故障，它会烧毁你的房子。但你可以安全地出门，然后从公司和您的保险公司收回损害赔偿。这是一个完整的道德框架，也有法律架构。显然，自驾车将会更安全，他们将会挽救生命。这是一件非常重要的事情。 我们要拯救生命。 我们希望道路更好。但是，救赎的人数并不是我们的道德演算中唯一的术语。我们必须看看当人受伤时发生了什么？ 他们如何被照顾？他们是否能够支付医疗费用或重新上班？还是虽然在他们恢复健康时失去工作，但仍然能够支付租金和买得起食物？\n\n那么关于这个的问题对作为开发人员的我们有什么意义？这是否给我们免费通行证？我们不对 IoT 设备负责。那意味着我们可以做任何事情。让我们创造一切，直到事故发生，直到先例发生。这真的是我们想留下的东西吗？我们是否愿意对我们所制造的东西不负责任，就因为我们可以这么做，就因为我们没有能力给予我们伤害的人任何补偿？ 一些公司实际上仍然只想要创新的环境下工作，他们只想建造东西，运送东西，在事后处理后果。但你必须问自己：我想对此负责吗？这就是伦理或道德关注的。\n\n我说过 JavaScript 社区中有最有意思技术伦理问题之一，比如 [left-pad 事件](http://taobaofed.org/blog/2016/03/31/what-can-we-learn-from-left-pad-event/)。\n\n![](/css/images/218.jpg)\n\n当 Ashley 昨天晚上谈到 left-pad，这真的很有意思，因为她看到了这个事件的很多反弹。她表示互联网在 left-pad 发生时被炸毁。人们对很多事情感到愤怒，JavaScript 社区开发了一个小模块系统，也许它是错误的，也许它是正确的，来回有很多争论，甚至在这个事件中失去了友谊。人们没有意识到的是所有愤怒和侮辱，是因为 left-pad 事件实际上暴露了什么是真正的伦理困境。现在我们还只见树木，未见树林。left-pad 事件拥有两个竞争性的伦理决定。一个是极客文化伦理，开源是最重要的事，开源是一种美德。控制你代码就是极客，就是开源开发者。当然，其他人可以 fork 这个模块，但你要选择把它放在哪里。 当 left-pad 作者删除了他的所有模块，并在互联网上打碎了一堆东西。NPM 也提出了自己的伦理框架，NPM 要求模块作者对使用他们模块的产品负有责任。他们有有作为工程师的责任。不过，NPM 依然认为开源有价值。NPM 本身就是个开源社区。所以这本身就是个很难的决定。你能想象如果这件事没有发生在2016年而是2018年，2020年，NPM 在运行在车子、冰箱上，这对整个网络会造成多大的影响？你正在高速公路上以一小时70英里的速度行驶，有人突然删除了一个模块，你的车子出现问题。你认为这不可能发生。 没有人会在运行IoT设备的汽车上进行实时部署。省省吧！就像我们现在在生产系统中做的那样，物联网安全简直就是一团糟。我们正在快速创新，这当然会有问题。你不想成为对冰箱负责的人，让用户失去了所有的食物，或失去了原本在冰箱中的他们需要的重要药物。你不想对此负责，但这是可能发生的。也许你认为开源更重要，那么这才是真正的伦理困境。所以作为工程师，我们要做些什么？当我们谈论伦理时，我们可以做些什么？这是为什么我不想做这个演讲，而是让大家能够做这个演讲，因为我们可以像工程师、开发人员那样做很多可操作的事情，使我们的工作场所更好，做更多有道德的事。\n\n![](/css/images/219.jpg)\n\n第一个就是与老板达成期望。如果你的老板有一些压力，要你做一些你觉得不舒服的事情。这时，你需要知道，你可以去找老板，告诉他你不愿意做这个。你需要知道如果你这样做会发生什么？ 这是重要的事情。你也必须准备说不。 如果有人来找你说，“嘿，我需要你编写一种发送方法，将某人的心率跟踪数据实时回到我们的服务器。”你会愿意这样做吗？也许你不愿意，但是你知道如何拒绝吗？你是否愿意拒绝？把你的职业生涯放置于危险的境地，就因为这么做违反了你相信的东西。您还需要能够与您的同事坦诚讨论这意味着什么。我在金融领域工作，我是数据科学家，所以我有大量的人力资料以及这些数据带来的强大能力。所以我们经常讨论，当我们记录客户数据时，当我们记录他们的财务信息时，我们当下的行为会产生什么影响。我们总是在讨论，比如你不愿意做什么？我们有法律义务做什么？在金融领域，我们在报告欺诈方面具有法律责任，例如洗钱。 所以我们必须相互讨论这些事情。作为工程师，你应该能够坦白地和你的同事坦言，“我不喜欢这样做。“ 我们如何确保不会那样？我们如何确保它保持在安全的一面而不是危险的一面？最重要的是知道你的底线，知道你何时愿意收手。因为科技真的有利可图，我们有很多的特权。我们在技术上有很多特权。即使只是看看我们所在的屋子，这也是一个非凡的会议室，这里有各种各样的设施。不是每个行业都这样的。什么是你的底线？超过了这个底线，你应该说：“我不能继续做这个”。如果你不知道这个底线是什么，你不会发现你已经越界了，直到一切已经来不及挽回。这就是我要讲的，非常谢谢大家。\n\n![](/css/images/220.jpg)","source":"_posts/the-ethics-of-the-internet-of-things.md","raw":"---\ntitle: Emily Gorcenski：物联网的伦理问题（译）\ndate: 2017-11-02 18:12:00\ntags: [技术讲座, 物联网, 伦理学, 电车问题, left-pad, Miri 僵尸网络, Fitbit, 自动驾驶汽车]\n---\n\n本文翻译整理自 YouTube 视频：\n\nhttps://www.youtube.com/watch?v=xLL7Fo_em2E\n\n![](/css/images/199.jpg)\n\n<!--more-->\n\n非常感谢大家！接下来我要讲的是物联网的伦理问题，保证不会有太多说教哦。我是 Emily Gorcenski，我并不经常在推特上讲物联网这些事，但我却对物联网以及它所构建的蓝图非常感兴趣。那么，我为何要在 JavaScript 大会上讲物联网的伦理问题呢？事情是这样的，我之前已经讲过几次这个主题，而且我开玩笑说，每次我都能给出一个全新的演讲，因为在物联网中，有太多的失败案例、漏洞和安全问题频繁出现。如果我只是专注案例研究，那么每次讲的东西都完全不同。而这次，我决定不这么做了，而是简单聊一下为何伦理很重要，为何伦理对作为 JavaScript 开发者的你很重要，以及我们如何将 JavaScript ，将科技注入一系列原本没有这些技术的设备和服务。聊伦理问题而不提及一些沉重话题是不可能的。所以这里给出了一些警告性的内容（看PPT）：\n\n- 人类伤亡的频繁讨论\n- 性侵犯的探讨\n- 一张生肉图片（留点悬念）\n\n![](/css/images/200.jpg)\n\n如果这些话题吓到你了，那么我会尽量在十分钟内结束这些话题。\n\n我是谁？这里我需要先承认，我在这个大会上有点像江湖骗子，因为我不是个 JavaScript 开发者。我是个数据科学家，以数学家的方式被培养，但也是个工程师，我在学校学习了航空工程和机械工程。\n\n![](/css/images/201.jpg)\n\n我曾经在航空、生物科技领域工作，现在在金融业。这些领域或行业有个共同点就是，它们都被严格调控。在这些领域工作的人们都会遵循一些专业的伦理法规，通过一个独立社会或其他协助指导什么是道德产品的组织。\n\n当讨论物联网时，总觉得这是个有点空洞无聊的概念。我们会想到智能冰箱、智能汽车这一类东东。我个人更喜欢把物联网想象为：把互联网放进原本不属于它的地方。\n\n![](/css/images/202.jpg)\n\n所以物联网可以指智能设备，但我也可以把 Uber 想象为出租车物联网。当我们看待这是否存在伦理问题时，我们必须要看看：我们使用科技做了什么，连接了什么。前后的差异并不在于这些设备、产品或服务有没有被计算机化，而是我们让用户拥有了连接什么的能力。如果你是个 JavaScript 开发者，或许你想要个物联网面包机，这样的话，你就可以在烤面包时插入一些代码进去。这很重要，因为物联网是下一代的便利优化。我们花了30年时间来优化产品使其更加方便易用。所以，现在你有个像冰箱这样的非物联网设备根本没有什么竞争优势。你必须要让它们连接起来！\n\n![](/css/images/203.jpg)\n\n你或许会关心物联网设备的监控能力，比如监控 Uber 引起的一些惨案。但是如果你没有能力到处逛逛，或没有住在方便打车的地方，或有其他需要，比如 有时候 Uber 可能会成为救生员，这些都改变了你的生活。我们不能简单说物联网是荒谬的、轻浮的，就像个玩具，就像是一个垃圾推特账号，非常滑稽，整天发一下低质量内容。事实上，物联网还是带来了很多好的事情。\n\n当我们说伦理这个词时，我们在说什么？你知道因为自动驾驶汽车，现在[电车问题](https://zh.wikipedia.org/wiki/%E6%9C%89%E8%BD%A8%E7%94%B5%E8%BD%A6%E9%9A%BE%E9%A2%98)很流行。\n\n![](/css/images/204.jpg)\n\n你或许已经看过这个图了（看PPT）：一个诺贝尔奖获得者被绑在一个轨道上，另外五个普通人被绑在另一个轨道上。不知怎的，你被安排在控制杠杆的位置上。这是个在互联网上非常流行的问题，因为：一，如果将该问题抽象出来，我们可以用类别理论来解决它。二，这确实是个[网络模因](https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E7%88%86%E7%B4%85%E4%BA%8B%E7%89%A9)。既然电车问题的关键不在电车，那么为何自动驾驶汽车会成为问题呢？\n\n![](/css/images/205.jpg)\n\n我们喜欢把事情当作难题来解决 - 这就是我们作为开发人员和工程师的本性。在技​​术上，我们实际上并没有经常面临伦理困境。\n\n![](/css/images/206.jpg)\n\n当有两个竞争的伦理框架同时存在，且你的行为不能违反至少其中一个。那么此时，伦理困境就出现了。我认为 JavaScript 非常引人入胜，因为 JavaScript 社区对在未来十年的技术发展中出现的最有意思伦理困境负有责任。这个话题我等会儿会细说，有些人或许已经知道我待会要说什么了。技术的问题是，我们往往不遵守道德准则。我不是说要写一个起诉书，说你是坏的，不道德的人。说到这，有些公司可能要对我斜眼了。但我的意思是，在我们行业，我们没有一个专业的法规。有一些社团，你可以加入。如果你是像 ACM 或 I888 这样的组织的成员，举起你的手。哦，有一些但不是大多数。\n\n在实践中，伦理学是关于损害的分析和风险的缓解。\n\n![](/css/images/207.jpg)\n\n所以，当我们讨论伦理行为时，特别是伦理研究时，我们要做的不是消除人员受伤的可能性，而是去理解人员可能被科技所伤害的各种方式，寻找能减少风险发生的方法，并在必要时提供整治。当我们为物联网开发各种技术时，上述做法就是我们需要提出的道德框架。事故可能会以三种方式发生： **不法行为**、 **故障**、**边界情况**。\n\n![](/css/images/208.jpg)\n\n不法行为在物联网中是最常见的话题，这是个安全问题，是人们常说的黑客行为。去年秋天，Miri 僵尸网络发生 DDoS 攻击，这是目前的最大的 DDoS 攻击，这次攻击发生在不安全的物联网设备上。你或许知道，物联网安全性现在处于非常糟糕的状态。当这次事故发生时，它的时间安排和方式让很多人担心这是对美国总统大选的攻击的前兆，这将试图影响这次选举的结果。事实证明，这个恐惧是没有根据的。我不想在这次演讲中讨论这个事故。因为，首先我没法覆盖所有事。另外，其他方式的事故依然可能会发生，比如故障和边界情况。当设备在出乎开发人员预料的情况下被运行时，边界情况就会发生。另外值得一提的是，很多时候我们把软件漏洞和边界情况混为一谈，事实上这两者除了表达方式外确实没有太多不同。\n\n这是 Twitter上一个很好的例子。\n\n![](/css/images/209.jpg)\n\n这个可怜的绅士安德鲁，有一个物联网的水冷却器，他的 TLS 证书过期了，导致一些阻塞代码，硬件互锁失败，导致他家里都是水。这是一个真实的问题，对吧？是的，这是个真实的问题。如果 TLS 证书在 Web 服务中过期，我们忘记了 TLS 证书，我们有一段阻止代码，这是个操作问题，我们需要有相关人员来处理。但我们无法把物联网设备当成人来看待，我们需要将其当作宠物。这些宠物生活在人类的家里，而且因为没有喂食而非常暴躁易怒。有一天，如果我们不小心把 JavaScript 放入一个物联网水壶，结果因为`\"undefined\" is not a function`，房子被这个水壶烧了。\n\n另外一个例子，这是我做的，我很自豪。\n\n![](/css/images/210.jpg)\n\n几年前我做了这个，如果可以的话，我想全屏显示。这是一个 [Microsoft Band](https://zh.wikipedia.org/wiki/Microsoft_Band)，我没有故意选择微软的产品。这是一块生鸡肉，我没有对活鸡做一些可怕的事，比如做僵尸鸡。这只是一块我从杂货店买的肉。从视频上看，它正在读取每分钟120次的心率！在现实世界中，传感器是凌乱的、嘈杂的、不完美的。所以当我们设计物联网设备时，我们必须考虑到这一点。可以读一个鸡胸肉的心率是荒谬的，但这可以对很多事产生深刻的影响。举个例子，有一些学校强制学生戴 [Fitbit](https://en.wikipedia.org/wiki/Fitbit)。也有雇主有健康保险激励计划来做这样的事。这样的话，我们就有监控设备，来监测我们的健康状况，并可以及时生成健康报告。这并不是假设的，而是真的发生了。\n\n2015年，一名女子正在兰开斯特 (宾夕法尼亚州)看望一个同事。 她向警方报告性侵犯。警方发现了她的 Fitbit，并在她允许的情况下分析了数据，结果警方不仅停止了调查，还指控该女子假报警。去年，她对承认了这些指控，被定罪并实行缓刑。检方律师说 FitBit 数据也证明了这个。\n\n![](/css/images/211.jpg)\n\n我可以从一块生鸡肉中测出每分钟120次的心率，一个女人的生活也可能会被毁掉，因为没有 Fi​​tBit 的人站起来说不：“我们的设备不是这样准确。” 你不能这样做。我们的设备会出错。问题是我们如何建立它们是没有规定，质量保证或标准的。\n\n![](/css/images/212.jpg)\n\n我们只是编写代码，制造硬件。 我们创新，快，快，快。我们不问自己，当出现错误时会发生什么样的伤害？而这种情况越来越频繁。这些装置正在用于刑事和民事调查。就在上周，CNN 报道说一个男人被指控谋杀了他的妻子，根据他妻子的 Fitbit 数据记录。任何人带着 Fitbit 走，Fitbit 都会记录，即便当时你正坐在沙发上。我们怎么能让这种事情发生呢？我们怎么能让这种信息影响人们的生活？另一个事件：去年，一个智能水表被用于谋杀调查。\n\n![](/css/images/213.jpg)\n\n问题是：谁去监狱？ 当一个设备向警方作出虚假陈述时，谁将要接受缓刑？此外，说一些事情真实发生，说一些事情是假的，说有人受伤或被杀了，如果该设备有故障，谁将承担责任？是设备主人吗？ 是开发者吗？ 是制造设备的公司吗？这似乎应该是一个解决的问题，但事实却没有。这已经发生了。\n\n![](/css/images/214.jpg)\n\n在这个框架下，你将看到几辆汽车，右边的白色汽车是 Google 自动驾驶汽车，这张图像是静止图像 - 这是从拍摄的视频中截取的屏幕截图，来自在加利福尼亚州山景城的一辆市政公共汽车的行车记录仪。\n\n![](/css/images/215.jpg)\n\n那辆 Google SUV 即将在公共汽车前面出来，发生意外。幸运的是，没有人受伤。这是自驾车首次被发现对一次意外承担责任。谷歌说：“我们的错，我们会进行相关损害赔偿。”他们调查了事情经过，得出结论，车子预测了因为我们领先于公共汽车，所以公共汽车应该让着我们。\n\n![](/css/images/216.jpg)\n\nGoogle 现在正想卖他们的自动驾驶汽车，所以他们当然会承担责任，而不是去法庭上测试他们的车。但是，随着我们进入物联网的未来，我们不能依靠这一点。 一旦这个规模出现，我们就不能依靠仁慈的公司承担责任。顺便说一下，即使 Google 是正确的，这仍然是一个历史时刻。因为如果公共汽车已经让了自动驾驶汽车，这将是市政府的公共汽车第一次屈服！\n\n几年前，旧金山有一名法官。他研究自主系统是否不受现有的责任理论限制。深入研究后，他发现那些自己做决定的，使用神经网络的，使用自适应自调节控制系统的，设计自己的手段来完成任务的机器在现有的侵权理论下，可能不受任何责任。\n\n![](/css/images/217.jpg)\n\n这有巨大的影响。因为如果你买普通的冰箱，它会损坏，你可以说，“嘿，制造商， 你负责这个损坏。”如果你买一个咖啡机，并且由于一个小故障，它会烧毁你的房子。但你可以安全地出门，然后从公司和您的保险公司收回损害赔偿。这是一个完整的道德框架，也有法律架构。显然，自驾车将会更安全，他们将会挽救生命。这是一件非常重要的事情。 我们要拯救生命。 我们希望道路更好。但是，救赎的人数并不是我们的道德演算中唯一的术语。我们必须看看当人受伤时发生了什么？ 他们如何被照顾？他们是否能够支付医疗费用或重新上班？还是虽然在他们恢复健康时失去工作，但仍然能够支付租金和买得起食物？\n\n那么关于这个的问题对作为开发人员的我们有什么意义？这是否给我们免费通行证？我们不对 IoT 设备负责。那意味着我们可以做任何事情。让我们创造一切，直到事故发生，直到先例发生。这真的是我们想留下的东西吗？我们是否愿意对我们所制造的东西不负责任，就因为我们可以这么做，就因为我们没有能力给予我们伤害的人任何补偿？ 一些公司实际上仍然只想要创新的环境下工作，他们只想建造东西，运送东西，在事后处理后果。但你必须问自己：我想对此负责吗？这就是伦理或道德关注的。\n\n我说过 JavaScript 社区中有最有意思技术伦理问题之一，比如 [left-pad 事件](http://taobaofed.org/blog/2016/03/31/what-can-we-learn-from-left-pad-event/)。\n\n![](/css/images/218.jpg)\n\n当 Ashley 昨天晚上谈到 left-pad，这真的很有意思，因为她看到了这个事件的很多反弹。她表示互联网在 left-pad 发生时被炸毁。人们对很多事情感到愤怒，JavaScript 社区开发了一个小模块系统，也许它是错误的，也许它是正确的，来回有很多争论，甚至在这个事件中失去了友谊。人们没有意识到的是所有愤怒和侮辱，是因为 left-pad 事件实际上暴露了什么是真正的伦理困境。现在我们还只见树木，未见树林。left-pad 事件拥有两个竞争性的伦理决定。一个是极客文化伦理，开源是最重要的事，开源是一种美德。控制你代码就是极客，就是开源开发者。当然，其他人可以 fork 这个模块，但你要选择把它放在哪里。 当 left-pad 作者删除了他的所有模块，并在互联网上打碎了一堆东西。NPM 也提出了自己的伦理框架，NPM 要求模块作者对使用他们模块的产品负有责任。他们有有作为工程师的责任。不过，NPM 依然认为开源有价值。NPM 本身就是个开源社区。所以这本身就是个很难的决定。你能想象如果这件事没有发生在2016年而是2018年，2020年，NPM 在运行在车子、冰箱上，这对整个网络会造成多大的影响？你正在高速公路上以一小时70英里的速度行驶，有人突然删除了一个模块，你的车子出现问题。你认为这不可能发生。 没有人会在运行IoT设备的汽车上进行实时部署。省省吧！就像我们现在在生产系统中做的那样，物联网安全简直就是一团糟。我们正在快速创新，这当然会有问题。你不想成为对冰箱负责的人，让用户失去了所有的食物，或失去了原本在冰箱中的他们需要的重要药物。你不想对此负责，但这是可能发生的。也许你认为开源更重要，那么这才是真正的伦理困境。所以作为工程师，我们要做些什么？当我们谈论伦理时，我们可以做些什么？这是为什么我不想做这个演讲，而是让大家能够做这个演讲，因为我们可以像工程师、开发人员那样做很多可操作的事情，使我们的工作场所更好，做更多有道德的事。\n\n![](/css/images/219.jpg)\n\n第一个就是与老板达成期望。如果你的老板有一些压力，要你做一些你觉得不舒服的事情。这时，你需要知道，你可以去找老板，告诉他你不愿意做这个。你需要知道如果你这样做会发生什么？ 这是重要的事情。你也必须准备说不。 如果有人来找你说，“嘿，我需要你编写一种发送方法，将某人的心率跟踪数据实时回到我们的服务器。”你会愿意这样做吗？也许你不愿意，但是你知道如何拒绝吗？你是否愿意拒绝？把你的职业生涯放置于危险的境地，就因为这么做违反了你相信的东西。您还需要能够与您的同事坦诚讨论这意味着什么。我在金融领域工作，我是数据科学家，所以我有大量的人力资料以及这些数据带来的强大能力。所以我们经常讨论，当我们记录客户数据时，当我们记录他们的财务信息时，我们当下的行为会产生什么影响。我们总是在讨论，比如你不愿意做什么？我们有法律义务做什么？在金融领域，我们在报告欺诈方面具有法律责任，例如洗钱。 所以我们必须相互讨论这些事情。作为工程师，你应该能够坦白地和你的同事坦言，“我不喜欢这样做。“ 我们如何确保不会那样？我们如何确保它保持在安全的一面而不是危险的一面？最重要的是知道你的底线，知道你何时愿意收手。因为科技真的有利可图，我们有很多的特权。我们在技术上有很多特权。即使只是看看我们所在的屋子，这也是一个非凡的会议室，这里有各种各样的设施。不是每个行业都这样的。什么是你的底线？超过了这个底线，你应该说：“我不能继续做这个”。如果你不知道这个底线是什么，你不会发现你已经越界了，直到一切已经来不及挽回。这就是我要讲的，非常谢谢大家。\n\n![](/css/images/220.jpg)","slug":"the-ethics-of-the-internet-of-things","published":1,"updated":"2019-05-01T08:10:30.575Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvn0003ntgytugfy9wsi","content":"<p>本文翻译整理自 YouTube 视频：</p>\n<p><a href=\"https://www.youtube.com/watch?v=xLL7Fo_em2E\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=xLL7Fo_em2E</a></p>\n<p><img src=\"/css/images/199.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>非常感谢大家！接下来我要讲的是物联网的伦理问题，保证不会有太多说教哦。我是 Emily Gorcenski，我并不经常在推特上讲物联网这些事，但我却对物联网以及它所构建的蓝图非常感兴趣。那么，我为何要在 JavaScript 大会上讲物联网的伦理问题呢？事情是这样的，我之前已经讲过几次这个主题，而且我开玩笑说，每次我都能给出一个全新的演讲，因为在物联网中，有太多的失败案例、漏洞和安全问题频繁出现。如果我只是专注案例研究，那么每次讲的东西都完全不同。而这次，我决定不这么做了，而是简单聊一下为何伦理很重要，为何伦理对作为 JavaScript 开发者的你很重要，以及我们如何将 JavaScript ，将科技注入一系列原本没有这些技术的设备和服务。聊伦理问题而不提及一些沉重话题是不可能的。所以这里给出了一些警告性的内容（看PPT）：</p>\n<ul>\n<li>人类伤亡的频繁讨论</li>\n<li>性侵犯的探讨</li>\n<li>一张生肉图片（留点悬念）</li>\n</ul>\n<p><img src=\"/css/images/200.jpg\" alt=\"\"></p>\n<p>如果这些话题吓到你了，那么我会尽量在十分钟内结束这些话题。</p>\n<p>我是谁？这里我需要先承认，我在这个大会上有点像江湖骗子，因为我不是个 JavaScript 开发者。我是个数据科学家，以数学家的方式被培养，但也是个工程师，我在学校学习了航空工程和机械工程。</p>\n<p><img src=\"/css/images/201.jpg\" alt=\"\"></p>\n<p>我曾经在航空、生物科技领域工作，现在在金融业。这些领域或行业有个共同点就是，它们都被严格调控。在这些领域工作的人们都会遵循一些专业的伦理法规，通过一个独立社会或其他协助指导什么是道德产品的组织。</p>\n<p>当讨论物联网时，总觉得这是个有点空洞无聊的概念。我们会想到智能冰箱、智能汽车这一类东东。我个人更喜欢把物联网想象为：把互联网放进原本不属于它的地方。</p>\n<p><img src=\"/css/images/202.jpg\" alt=\"\"></p>\n<p>所以物联网可以指智能设备，但我也可以把 Uber 想象为出租车物联网。当我们看待这是否存在伦理问题时，我们必须要看看：我们使用科技做了什么，连接了什么。前后的差异并不在于这些设备、产品或服务有没有被计算机化，而是我们让用户拥有了连接什么的能力。如果你是个 JavaScript 开发者，或许你想要个物联网面包机，这样的话，你就可以在烤面包时插入一些代码进去。这很重要，因为物联网是下一代的便利优化。我们花了30年时间来优化产品使其更加方便易用。所以，现在你有个像冰箱这样的非物联网设备根本没有什么竞争优势。你必须要让它们连接起来！</p>\n<p><img src=\"/css/images/203.jpg\" alt=\"\"></p>\n<p>你或许会关心物联网设备的监控能力，比如监控 Uber 引起的一些惨案。但是如果你没有能力到处逛逛，或没有住在方便打车的地方，或有其他需要，比如 有时候 Uber 可能会成为救生员，这些都改变了你的生活。我们不能简单说物联网是荒谬的、轻浮的，就像个玩具，就像是一个垃圾推特账号，非常滑稽，整天发一下低质量内容。事实上，物联网还是带来了很多好的事情。</p>\n<p>当我们说伦理这个词时，我们在说什么？你知道因为自动驾驶汽车，现在<a href=\"https://zh.wikipedia.org/wiki/%E6%9C%89%E8%BD%A8%E7%94%B5%E8%BD%A6%E9%9A%BE%E9%A2%98\" target=\"_blank\" rel=\"noopener\">电车问题</a>很流行。</p>\n<p><img src=\"/css/images/204.jpg\" alt=\"\"></p>\n<p>你或许已经看过这个图了（看PPT）：一个诺贝尔奖获得者被绑在一个轨道上，另外五个普通人被绑在另一个轨道上。不知怎的，你被安排在控制杠杆的位置上。这是个在互联网上非常流行的问题，因为：一，如果将该问题抽象出来，我们可以用类别理论来解决它。二，这确实是个<a href=\"https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E7%88%86%E7%B4%85%E4%BA%8B%E7%89%A9\" target=\"_blank\" rel=\"noopener\">网络模因</a>。既然电车问题的关键不在电车，那么为何自动驾驶汽车会成为问题呢？</p>\n<p><img src=\"/css/images/205.jpg\" alt=\"\"></p>\n<p>我们喜欢把事情当作难题来解决 - 这就是我们作为开发人员和工程师的本性。在技​​术上，我们实际上并没有经常面临伦理困境。</p>\n<p><img src=\"/css/images/206.jpg\" alt=\"\"></p>\n<p>当有两个竞争的伦理框架同时存在，且你的行为不能违反至少其中一个。那么此时，伦理困境就出现了。我认为 JavaScript 非常引人入胜，因为 JavaScript 社区对在未来十年的技术发展中出现的最有意思伦理困境负有责任。这个话题我等会儿会细说，有些人或许已经知道我待会要说什么了。技术的问题是，我们往往不遵守道德准则。我不是说要写一个起诉书，说你是坏的，不道德的人。说到这，有些公司可能要对我斜眼了。但我的意思是，在我们行业，我们没有一个专业的法规。有一些社团，你可以加入。如果你是像 ACM 或 I888 这样的组织的成员，举起你的手。哦，有一些但不是大多数。</p>\n<p>在实践中，伦理学是关于损害的分析和风险的缓解。</p>\n<p><img src=\"/css/images/207.jpg\" alt=\"\"></p>\n<p>所以，当我们讨论伦理行为时，特别是伦理研究时，我们要做的不是消除人员受伤的可能性，而是去理解人员可能被科技所伤害的各种方式，寻找能减少风险发生的方法，并在必要时提供整治。当我们为物联网开发各种技术时，上述做法就是我们需要提出的道德框架。事故可能会以三种方式发生： <strong>不法行为</strong>、 <strong>故障</strong>、<strong>边界情况</strong>。</p>\n<p><img src=\"/css/images/208.jpg\" alt=\"\"></p>\n<p>不法行为在物联网中是最常见的话题，这是个安全问题，是人们常说的黑客行为。去年秋天，Miri 僵尸网络发生 DDoS 攻击，这是目前的最大的 DDoS 攻击，这次攻击发生在不安全的物联网设备上。你或许知道，物联网安全性现在处于非常糟糕的状态。当这次事故发生时，它的时间安排和方式让很多人担心这是对美国总统大选的攻击的前兆，这将试图影响这次选举的结果。事实证明，这个恐惧是没有根据的。我不想在这次演讲中讨论这个事故。因为，首先我没法覆盖所有事。另外，其他方式的事故依然可能会发生，比如故障和边界情况。当设备在出乎开发人员预料的情况下被运行时，边界情况就会发生。另外值得一提的是，很多时候我们把软件漏洞和边界情况混为一谈，事实上这两者除了表达方式外确实没有太多不同。</p>\n<p>这是 Twitter上一个很好的例子。</p>\n<p><img src=\"/css/images/209.jpg\" alt=\"\"></p>\n<p>这个可怜的绅士安德鲁，有一个物联网的水冷却器，他的 TLS 证书过期了，导致一些阻塞代码，硬件互锁失败，导致他家里都是水。这是一个真实的问题，对吧？是的，这是个真实的问题。如果 TLS 证书在 Web 服务中过期，我们忘记了 TLS 证书，我们有一段阻止代码，这是个操作问题，我们需要有相关人员来处理。但我们无法把物联网设备当成人来看待，我们需要将其当作宠物。这些宠物生活在人类的家里，而且因为没有喂食而非常暴躁易怒。有一天，如果我们不小心把 JavaScript 放入一个物联网水壶，结果因为<code>&quot;undefined&quot; is not a function</code>，房子被这个水壶烧了。</p>\n<p>另外一个例子，这是我做的，我很自豪。</p>\n<p><img src=\"/css/images/210.jpg\" alt=\"\"></p>\n<p>几年前我做了这个，如果可以的话，我想全屏显示。这是一个 <a href=\"https://zh.wikipedia.org/wiki/Microsoft_Band\" target=\"_blank\" rel=\"noopener\">Microsoft Band</a>，我没有故意选择微软的产品。这是一块生鸡肉，我没有对活鸡做一些可怕的事，比如做僵尸鸡。这只是一块我从杂货店买的肉。从视频上看，它正在读取每分钟120次的心率！在现实世界中，传感器是凌乱的、嘈杂的、不完美的。所以当我们设计物联网设备时，我们必须考虑到这一点。可以读一个鸡胸肉的心率是荒谬的，但这可以对很多事产生深刻的影响。举个例子，有一些学校强制学生戴 <a href=\"https://en.wikipedia.org/wiki/Fitbit\" target=\"_blank\" rel=\"noopener\">Fitbit</a>。也有雇主有健康保险激励计划来做这样的事。这样的话，我们就有监控设备，来监测我们的健康状况，并可以及时生成健康报告。这并不是假设的，而是真的发生了。</p>\n<p>2015年，一名女子正在兰开斯特 (宾夕法尼亚州)看望一个同事。 她向警方报告性侵犯。警方发现了她的 Fitbit，并在她允许的情况下分析了数据，结果警方不仅停止了调查，还指控该女子假报警。去年，她对承认了这些指控，被定罪并实行缓刑。检方律师说 FitBit 数据也证明了这个。</p>\n<p><img src=\"/css/images/211.jpg\" alt=\"\"></p>\n<p>我可以从一块生鸡肉中测出每分钟120次的心率，一个女人的生活也可能会被毁掉，因为没有 Fi​​tBit 的人站起来说不：“我们的设备不是这样准确。” 你不能这样做。我们的设备会出错。问题是我们如何建立它们是没有规定，质量保证或标准的。</p>\n<p><img src=\"/css/images/212.jpg\" alt=\"\"></p>\n<p>我们只是编写代码，制造硬件。 我们创新，快，快，快。我们不问自己，当出现错误时会发生什么样的伤害？而这种情况越来越频繁。这些装置正在用于刑事和民事调查。就在上周，CNN 报道说一个男人被指控谋杀了他的妻子，根据他妻子的 Fitbit 数据记录。任何人带着 Fitbit 走，Fitbit 都会记录，即便当时你正坐在沙发上。我们怎么能让这种事情发生呢？我们怎么能让这种信息影响人们的生活？另一个事件：去年，一个智能水表被用于谋杀调查。</p>\n<p><img src=\"/css/images/213.jpg\" alt=\"\"></p>\n<p>问题是：谁去监狱？ 当一个设备向警方作出虚假陈述时，谁将要接受缓刑？此外，说一些事情真实发生，说一些事情是假的，说有人受伤或被杀了，如果该设备有故障，谁将承担责任？是设备主人吗？ 是开发者吗？ 是制造设备的公司吗？这似乎应该是一个解决的问题，但事实却没有。这已经发生了。</p>\n<p><img src=\"/css/images/214.jpg\" alt=\"\"></p>\n<p>在这个框架下，你将看到几辆汽车，右边的白色汽车是 Google 自动驾驶汽车，这张图像是静止图像 - 这是从拍摄的视频中截取的屏幕截图，来自在加利福尼亚州山景城的一辆市政公共汽车的行车记录仪。</p>\n<p><img src=\"/css/images/215.jpg\" alt=\"\"></p>\n<p>那辆 Google SUV 即将在公共汽车前面出来，发生意外。幸运的是，没有人受伤。这是自驾车首次被发现对一次意外承担责任。谷歌说：“我们的错，我们会进行相关损害赔偿。”他们调查了事情经过，得出结论，车子预测了因为我们领先于公共汽车，所以公共汽车应该让着我们。</p>\n<p><img src=\"/css/images/216.jpg\" alt=\"\"></p>\n<p>Google 现在正想卖他们的自动驾驶汽车，所以他们当然会承担责任，而不是去法庭上测试他们的车。但是，随着我们进入物联网的未来，我们不能依靠这一点。 一旦这个规模出现，我们就不能依靠仁慈的公司承担责任。顺便说一下，即使 Google 是正确的，这仍然是一个历史时刻。因为如果公共汽车已经让了自动驾驶汽车，这将是市政府的公共汽车第一次屈服！</p>\n<p>几年前，旧金山有一名法官。他研究自主系统是否不受现有的责任理论限制。深入研究后，他发现那些自己做决定的，使用神经网络的，使用自适应自调节控制系统的，设计自己的手段来完成任务的机器在现有的侵权理论下，可能不受任何责任。</p>\n<p><img src=\"/css/images/217.jpg\" alt=\"\"></p>\n<p>这有巨大的影响。因为如果你买普通的冰箱，它会损坏，你可以说，“嘿，制造商， 你负责这个损坏。”如果你买一个咖啡机，并且由于一个小故障，它会烧毁你的房子。但你可以安全地出门，然后从公司和您的保险公司收回损害赔偿。这是一个完整的道德框架，也有法律架构。显然，自驾车将会更安全，他们将会挽救生命。这是一件非常重要的事情。 我们要拯救生命。 我们希望道路更好。但是，救赎的人数并不是我们的道德演算中唯一的术语。我们必须看看当人受伤时发生了什么？ 他们如何被照顾？他们是否能够支付医疗费用或重新上班？还是虽然在他们恢复健康时失去工作，但仍然能够支付租金和买得起食物？</p>\n<p>那么关于这个的问题对作为开发人员的我们有什么意义？这是否给我们免费通行证？我们不对 IoT 设备负责。那意味着我们可以做任何事情。让我们创造一切，直到事故发生，直到先例发生。这真的是我们想留下的东西吗？我们是否愿意对我们所制造的东西不负责任，就因为我们可以这么做，就因为我们没有能力给予我们伤害的人任何补偿？ 一些公司实际上仍然只想要创新的环境下工作，他们只想建造东西，运送东西，在事后处理后果。但你必须问自己：我想对此负责吗？这就是伦理或道德关注的。</p>\n<p>我说过 JavaScript 社区中有最有意思技术伦理问题之一，比如 <a href=\"http://taobaofed.org/blog/2016/03/31/what-can-we-learn-from-left-pad-event/\" target=\"_blank\" rel=\"noopener\">left-pad 事件</a>。</p>\n<p><img src=\"/css/images/218.jpg\" alt=\"\"></p>\n<p>当 Ashley 昨天晚上谈到 left-pad，这真的很有意思，因为她看到了这个事件的很多反弹。她表示互联网在 left-pad 发生时被炸毁。人们对很多事情感到愤怒，JavaScript 社区开发了一个小模块系统，也许它是错误的，也许它是正确的，来回有很多争论，甚至在这个事件中失去了友谊。人们没有意识到的是所有愤怒和侮辱，是因为 left-pad 事件实际上暴露了什么是真正的伦理困境。现在我们还只见树木，未见树林。left-pad 事件拥有两个竞争性的伦理决定。一个是极客文化伦理，开源是最重要的事，开源是一种美德。控制你代码就是极客，就是开源开发者。当然，其他人可以 fork 这个模块，但你要选择把它放在哪里。 当 left-pad 作者删除了他的所有模块，并在互联网上打碎了一堆东西。NPM 也提出了自己的伦理框架，NPM 要求模块作者对使用他们模块的产品负有责任。他们有有作为工程师的责任。不过，NPM 依然认为开源有价值。NPM 本身就是个开源社区。所以这本身就是个很难的决定。你能想象如果这件事没有发生在2016年而是2018年，2020年，NPM 在运行在车子、冰箱上，这对整个网络会造成多大的影响？你正在高速公路上以一小时70英里的速度行驶，有人突然删除了一个模块，你的车子出现问题。你认为这不可能发生。 没有人会在运行IoT设备的汽车上进行实时部署。省省吧！就像我们现在在生产系统中做的那样，物联网安全简直就是一团糟。我们正在快速创新，这当然会有问题。你不想成为对冰箱负责的人，让用户失去了所有的食物，或失去了原本在冰箱中的他们需要的重要药物。你不想对此负责，但这是可能发生的。也许你认为开源更重要，那么这才是真正的伦理困境。所以作为工程师，我们要做些什么？当我们谈论伦理时，我们可以做些什么？这是为什么我不想做这个演讲，而是让大家能够做这个演讲，因为我们可以像工程师、开发人员那样做很多可操作的事情，使我们的工作场所更好，做更多有道德的事。</p>\n<p><img src=\"/css/images/219.jpg\" alt=\"\"></p>\n<p>第一个就是与老板达成期望。如果你的老板有一些压力，要你做一些你觉得不舒服的事情。这时，你需要知道，你可以去找老板，告诉他你不愿意做这个。你需要知道如果你这样做会发生什么？ 这是重要的事情。你也必须准备说不。 如果有人来找你说，“嘿，我需要你编写一种发送方法，将某人的心率跟踪数据实时回到我们的服务器。”你会愿意这样做吗？也许你不愿意，但是你知道如何拒绝吗？你是否愿意拒绝？把你的职业生涯放置于危险的境地，就因为这么做违反了你相信的东西。您还需要能够与您的同事坦诚讨论这意味着什么。我在金融领域工作，我是数据科学家，所以我有大量的人力资料以及这些数据带来的强大能力。所以我们经常讨论，当我们记录客户数据时，当我们记录他们的财务信息时，我们当下的行为会产生什么影响。我们总是在讨论，比如你不愿意做什么？我们有法律义务做什么？在金融领域，我们在报告欺诈方面具有法律责任，例如洗钱。 所以我们必须相互讨论这些事情。作为工程师，你应该能够坦白地和你的同事坦言，“我不喜欢这样做。“ 我们如何确保不会那样？我们如何确保它保持在安全的一面而不是危险的一面？最重要的是知道你的底线，知道你何时愿意收手。因为科技真的有利可图，我们有很多的特权。我们在技术上有很多特权。即使只是看看我们所在的屋子，这也是一个非凡的会议室，这里有各种各样的设施。不是每个行业都这样的。什么是你的底线？超过了这个底线，你应该说：“我不能继续做这个”。如果你不知道这个底线是什么，你不会发现你已经越界了，直到一切已经来不及挽回。这就是我要讲的，非常谢谢大家。</p>\n<p><img src=\"/css/images/220.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>本文翻译整理自 YouTube 视频：</p>\n<p><a href=\"https://www.youtube.com/watch?v=xLL7Fo_em2E\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=xLL7Fo_em2E</a></p>\n<p><img src=\"/css/images/199.jpg\" alt=\"\"></p>","more":"<p>非常感谢大家！接下来我要讲的是物联网的伦理问题，保证不会有太多说教哦。我是 Emily Gorcenski，我并不经常在推特上讲物联网这些事，但我却对物联网以及它所构建的蓝图非常感兴趣。那么，我为何要在 JavaScript 大会上讲物联网的伦理问题呢？事情是这样的，我之前已经讲过几次这个主题，而且我开玩笑说，每次我都能给出一个全新的演讲，因为在物联网中，有太多的失败案例、漏洞和安全问题频繁出现。如果我只是专注案例研究，那么每次讲的东西都完全不同。而这次，我决定不这么做了，而是简单聊一下为何伦理很重要，为何伦理对作为 JavaScript 开发者的你很重要，以及我们如何将 JavaScript ，将科技注入一系列原本没有这些技术的设备和服务。聊伦理问题而不提及一些沉重话题是不可能的。所以这里给出了一些警告性的内容（看PPT）：</p>\n<ul>\n<li>人类伤亡的频繁讨论</li>\n<li>性侵犯的探讨</li>\n<li>一张生肉图片（留点悬念）</li>\n</ul>\n<p><img src=\"/css/images/200.jpg\" alt=\"\"></p>\n<p>如果这些话题吓到你了，那么我会尽量在十分钟内结束这些话题。</p>\n<p>我是谁？这里我需要先承认，我在这个大会上有点像江湖骗子，因为我不是个 JavaScript 开发者。我是个数据科学家，以数学家的方式被培养，但也是个工程师，我在学校学习了航空工程和机械工程。</p>\n<p><img src=\"/css/images/201.jpg\" alt=\"\"></p>\n<p>我曾经在航空、生物科技领域工作，现在在金融业。这些领域或行业有个共同点就是，它们都被严格调控。在这些领域工作的人们都会遵循一些专业的伦理法规，通过一个独立社会或其他协助指导什么是道德产品的组织。</p>\n<p>当讨论物联网时，总觉得这是个有点空洞无聊的概念。我们会想到智能冰箱、智能汽车这一类东东。我个人更喜欢把物联网想象为：把互联网放进原本不属于它的地方。</p>\n<p><img src=\"/css/images/202.jpg\" alt=\"\"></p>\n<p>所以物联网可以指智能设备，但我也可以把 Uber 想象为出租车物联网。当我们看待这是否存在伦理问题时，我们必须要看看：我们使用科技做了什么，连接了什么。前后的差异并不在于这些设备、产品或服务有没有被计算机化，而是我们让用户拥有了连接什么的能力。如果你是个 JavaScript 开发者，或许你想要个物联网面包机，这样的话，你就可以在烤面包时插入一些代码进去。这很重要，因为物联网是下一代的便利优化。我们花了30年时间来优化产品使其更加方便易用。所以，现在你有个像冰箱这样的非物联网设备根本没有什么竞争优势。你必须要让它们连接起来！</p>\n<p><img src=\"/css/images/203.jpg\" alt=\"\"></p>\n<p>你或许会关心物联网设备的监控能力，比如监控 Uber 引起的一些惨案。但是如果你没有能力到处逛逛，或没有住在方便打车的地方，或有其他需要，比如 有时候 Uber 可能会成为救生员，这些都改变了你的生活。我们不能简单说物联网是荒谬的、轻浮的，就像个玩具，就像是一个垃圾推特账号，非常滑稽，整天发一下低质量内容。事实上，物联网还是带来了很多好的事情。</p>\n<p>当我们说伦理这个词时，我们在说什么？你知道因为自动驾驶汽车，现在<a href=\"https://zh.wikipedia.org/wiki/%E6%9C%89%E8%BD%A8%E7%94%B5%E8%BD%A6%E9%9A%BE%E9%A2%98\" target=\"_blank\" rel=\"noopener\">电车问题</a>很流行。</p>\n<p><img src=\"/css/images/204.jpg\" alt=\"\"></p>\n<p>你或许已经看过这个图了（看PPT）：一个诺贝尔奖获得者被绑在一个轨道上，另外五个普通人被绑在另一个轨道上。不知怎的，你被安排在控制杠杆的位置上。这是个在互联网上非常流行的问题，因为：一，如果将该问题抽象出来，我们可以用类别理论来解决它。二，这确实是个<a href=\"https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E7%88%86%E7%B4%85%E4%BA%8B%E7%89%A9\" target=\"_blank\" rel=\"noopener\">网络模因</a>。既然电车问题的关键不在电车，那么为何自动驾驶汽车会成为问题呢？</p>\n<p><img src=\"/css/images/205.jpg\" alt=\"\"></p>\n<p>我们喜欢把事情当作难题来解决 - 这就是我们作为开发人员和工程师的本性。在技​​术上，我们实际上并没有经常面临伦理困境。</p>\n<p><img src=\"/css/images/206.jpg\" alt=\"\"></p>\n<p>当有两个竞争的伦理框架同时存在，且你的行为不能违反至少其中一个。那么此时，伦理困境就出现了。我认为 JavaScript 非常引人入胜，因为 JavaScript 社区对在未来十年的技术发展中出现的最有意思伦理困境负有责任。这个话题我等会儿会细说，有些人或许已经知道我待会要说什么了。技术的问题是，我们往往不遵守道德准则。我不是说要写一个起诉书，说你是坏的，不道德的人。说到这，有些公司可能要对我斜眼了。但我的意思是，在我们行业，我们没有一个专业的法规。有一些社团，你可以加入。如果你是像 ACM 或 I888 这样的组织的成员，举起你的手。哦，有一些但不是大多数。</p>\n<p>在实践中，伦理学是关于损害的分析和风险的缓解。</p>\n<p><img src=\"/css/images/207.jpg\" alt=\"\"></p>\n<p>所以，当我们讨论伦理行为时，特别是伦理研究时，我们要做的不是消除人员受伤的可能性，而是去理解人员可能被科技所伤害的各种方式，寻找能减少风险发生的方法，并在必要时提供整治。当我们为物联网开发各种技术时，上述做法就是我们需要提出的道德框架。事故可能会以三种方式发生： <strong>不法行为</strong>、 <strong>故障</strong>、<strong>边界情况</strong>。</p>\n<p><img src=\"/css/images/208.jpg\" alt=\"\"></p>\n<p>不法行为在物联网中是最常见的话题，这是个安全问题，是人们常说的黑客行为。去年秋天，Miri 僵尸网络发生 DDoS 攻击，这是目前的最大的 DDoS 攻击，这次攻击发生在不安全的物联网设备上。你或许知道，物联网安全性现在处于非常糟糕的状态。当这次事故发生时，它的时间安排和方式让很多人担心这是对美国总统大选的攻击的前兆，这将试图影响这次选举的结果。事实证明，这个恐惧是没有根据的。我不想在这次演讲中讨论这个事故。因为，首先我没法覆盖所有事。另外，其他方式的事故依然可能会发生，比如故障和边界情况。当设备在出乎开发人员预料的情况下被运行时，边界情况就会发生。另外值得一提的是，很多时候我们把软件漏洞和边界情况混为一谈，事实上这两者除了表达方式外确实没有太多不同。</p>\n<p>这是 Twitter上一个很好的例子。</p>\n<p><img src=\"/css/images/209.jpg\" alt=\"\"></p>\n<p>这个可怜的绅士安德鲁，有一个物联网的水冷却器，他的 TLS 证书过期了，导致一些阻塞代码，硬件互锁失败，导致他家里都是水。这是一个真实的问题，对吧？是的，这是个真实的问题。如果 TLS 证书在 Web 服务中过期，我们忘记了 TLS 证书，我们有一段阻止代码，这是个操作问题，我们需要有相关人员来处理。但我们无法把物联网设备当成人来看待，我们需要将其当作宠物。这些宠物生活在人类的家里，而且因为没有喂食而非常暴躁易怒。有一天，如果我们不小心把 JavaScript 放入一个物联网水壶，结果因为<code>&quot;undefined&quot; is not a function</code>，房子被这个水壶烧了。</p>\n<p>另外一个例子，这是我做的，我很自豪。</p>\n<p><img src=\"/css/images/210.jpg\" alt=\"\"></p>\n<p>几年前我做了这个，如果可以的话，我想全屏显示。这是一个 <a href=\"https://zh.wikipedia.org/wiki/Microsoft_Band\" target=\"_blank\" rel=\"noopener\">Microsoft Band</a>，我没有故意选择微软的产品。这是一块生鸡肉，我没有对活鸡做一些可怕的事，比如做僵尸鸡。这只是一块我从杂货店买的肉。从视频上看，它正在读取每分钟120次的心率！在现实世界中，传感器是凌乱的、嘈杂的、不完美的。所以当我们设计物联网设备时，我们必须考虑到这一点。可以读一个鸡胸肉的心率是荒谬的，但这可以对很多事产生深刻的影响。举个例子，有一些学校强制学生戴 <a href=\"https://en.wikipedia.org/wiki/Fitbit\" target=\"_blank\" rel=\"noopener\">Fitbit</a>。也有雇主有健康保险激励计划来做这样的事。这样的话，我们就有监控设备，来监测我们的健康状况，并可以及时生成健康报告。这并不是假设的，而是真的发生了。</p>\n<p>2015年，一名女子正在兰开斯特 (宾夕法尼亚州)看望一个同事。 她向警方报告性侵犯。警方发现了她的 Fitbit，并在她允许的情况下分析了数据，结果警方不仅停止了调查，还指控该女子假报警。去年，她对承认了这些指控，被定罪并实行缓刑。检方律师说 FitBit 数据也证明了这个。</p>\n<p><img src=\"/css/images/211.jpg\" alt=\"\"></p>\n<p>我可以从一块生鸡肉中测出每分钟120次的心率，一个女人的生活也可能会被毁掉，因为没有 Fi​​tBit 的人站起来说不：“我们的设备不是这样准确。” 你不能这样做。我们的设备会出错。问题是我们如何建立它们是没有规定，质量保证或标准的。</p>\n<p><img src=\"/css/images/212.jpg\" alt=\"\"></p>\n<p>我们只是编写代码，制造硬件。 我们创新，快，快，快。我们不问自己，当出现错误时会发生什么样的伤害？而这种情况越来越频繁。这些装置正在用于刑事和民事调查。就在上周，CNN 报道说一个男人被指控谋杀了他的妻子，根据他妻子的 Fitbit 数据记录。任何人带着 Fitbit 走，Fitbit 都会记录，即便当时你正坐在沙发上。我们怎么能让这种事情发生呢？我们怎么能让这种信息影响人们的生活？另一个事件：去年，一个智能水表被用于谋杀调查。</p>\n<p><img src=\"/css/images/213.jpg\" alt=\"\"></p>\n<p>问题是：谁去监狱？ 当一个设备向警方作出虚假陈述时，谁将要接受缓刑？此外，说一些事情真实发生，说一些事情是假的，说有人受伤或被杀了，如果该设备有故障，谁将承担责任？是设备主人吗？ 是开发者吗？ 是制造设备的公司吗？这似乎应该是一个解决的问题，但事实却没有。这已经发生了。</p>\n<p><img src=\"/css/images/214.jpg\" alt=\"\"></p>\n<p>在这个框架下，你将看到几辆汽车，右边的白色汽车是 Google 自动驾驶汽车，这张图像是静止图像 - 这是从拍摄的视频中截取的屏幕截图，来自在加利福尼亚州山景城的一辆市政公共汽车的行车记录仪。</p>\n<p><img src=\"/css/images/215.jpg\" alt=\"\"></p>\n<p>那辆 Google SUV 即将在公共汽车前面出来，发生意外。幸运的是，没有人受伤。这是自驾车首次被发现对一次意外承担责任。谷歌说：“我们的错，我们会进行相关损害赔偿。”他们调查了事情经过，得出结论，车子预测了因为我们领先于公共汽车，所以公共汽车应该让着我们。</p>\n<p><img src=\"/css/images/216.jpg\" alt=\"\"></p>\n<p>Google 现在正想卖他们的自动驾驶汽车，所以他们当然会承担责任，而不是去法庭上测试他们的车。但是，随着我们进入物联网的未来，我们不能依靠这一点。 一旦这个规模出现，我们就不能依靠仁慈的公司承担责任。顺便说一下，即使 Google 是正确的，这仍然是一个历史时刻。因为如果公共汽车已经让了自动驾驶汽车，这将是市政府的公共汽车第一次屈服！</p>\n<p>几年前，旧金山有一名法官。他研究自主系统是否不受现有的责任理论限制。深入研究后，他发现那些自己做决定的，使用神经网络的，使用自适应自调节控制系统的，设计自己的手段来完成任务的机器在现有的侵权理论下，可能不受任何责任。</p>\n<p><img src=\"/css/images/217.jpg\" alt=\"\"></p>\n<p>这有巨大的影响。因为如果你买普通的冰箱，它会损坏，你可以说，“嘿，制造商， 你负责这个损坏。”如果你买一个咖啡机，并且由于一个小故障，它会烧毁你的房子。但你可以安全地出门，然后从公司和您的保险公司收回损害赔偿。这是一个完整的道德框架，也有法律架构。显然，自驾车将会更安全，他们将会挽救生命。这是一件非常重要的事情。 我们要拯救生命。 我们希望道路更好。但是，救赎的人数并不是我们的道德演算中唯一的术语。我们必须看看当人受伤时发生了什么？ 他们如何被照顾？他们是否能够支付医疗费用或重新上班？还是虽然在他们恢复健康时失去工作，但仍然能够支付租金和买得起食物？</p>\n<p>那么关于这个的问题对作为开发人员的我们有什么意义？这是否给我们免费通行证？我们不对 IoT 设备负责。那意味着我们可以做任何事情。让我们创造一切，直到事故发生，直到先例发生。这真的是我们想留下的东西吗？我们是否愿意对我们所制造的东西不负责任，就因为我们可以这么做，就因为我们没有能力给予我们伤害的人任何补偿？ 一些公司实际上仍然只想要创新的环境下工作，他们只想建造东西，运送东西，在事后处理后果。但你必须问自己：我想对此负责吗？这就是伦理或道德关注的。</p>\n<p>我说过 JavaScript 社区中有最有意思技术伦理问题之一，比如 <a href=\"http://taobaofed.org/blog/2016/03/31/what-can-we-learn-from-left-pad-event/\" target=\"_blank\" rel=\"noopener\">left-pad 事件</a>。</p>\n<p><img src=\"/css/images/218.jpg\" alt=\"\"></p>\n<p>当 Ashley 昨天晚上谈到 left-pad，这真的很有意思，因为她看到了这个事件的很多反弹。她表示互联网在 left-pad 发生时被炸毁。人们对很多事情感到愤怒，JavaScript 社区开发了一个小模块系统，也许它是错误的，也许它是正确的，来回有很多争论，甚至在这个事件中失去了友谊。人们没有意识到的是所有愤怒和侮辱，是因为 left-pad 事件实际上暴露了什么是真正的伦理困境。现在我们还只见树木，未见树林。left-pad 事件拥有两个竞争性的伦理决定。一个是极客文化伦理，开源是最重要的事，开源是一种美德。控制你代码就是极客，就是开源开发者。当然，其他人可以 fork 这个模块，但你要选择把它放在哪里。 当 left-pad 作者删除了他的所有模块，并在互联网上打碎了一堆东西。NPM 也提出了自己的伦理框架，NPM 要求模块作者对使用他们模块的产品负有责任。他们有有作为工程师的责任。不过，NPM 依然认为开源有价值。NPM 本身就是个开源社区。所以这本身就是个很难的决定。你能想象如果这件事没有发生在2016年而是2018年，2020年，NPM 在运行在车子、冰箱上，这对整个网络会造成多大的影响？你正在高速公路上以一小时70英里的速度行驶，有人突然删除了一个模块，你的车子出现问题。你认为这不可能发生。 没有人会在运行IoT设备的汽车上进行实时部署。省省吧！就像我们现在在生产系统中做的那样，物联网安全简直就是一团糟。我们正在快速创新，这当然会有问题。你不想成为对冰箱负责的人，让用户失去了所有的食物，或失去了原本在冰箱中的他们需要的重要药物。你不想对此负责，但这是可能发生的。也许你认为开源更重要，那么这才是真正的伦理困境。所以作为工程师，我们要做些什么？当我们谈论伦理时，我们可以做些什么？这是为什么我不想做这个演讲，而是让大家能够做这个演讲，因为我们可以像工程师、开发人员那样做很多可操作的事情，使我们的工作场所更好，做更多有道德的事。</p>\n<p><img src=\"/css/images/219.jpg\" alt=\"\"></p>\n<p>第一个就是与老板达成期望。如果你的老板有一些压力，要你做一些你觉得不舒服的事情。这时，你需要知道，你可以去找老板，告诉他你不愿意做这个。你需要知道如果你这样做会发生什么？ 这是重要的事情。你也必须准备说不。 如果有人来找你说，“嘿，我需要你编写一种发送方法，将某人的心率跟踪数据实时回到我们的服务器。”你会愿意这样做吗？也许你不愿意，但是你知道如何拒绝吗？你是否愿意拒绝？把你的职业生涯放置于危险的境地，就因为这么做违反了你相信的东西。您还需要能够与您的同事坦诚讨论这意味着什么。我在金融领域工作，我是数据科学家，所以我有大量的人力资料以及这些数据带来的强大能力。所以我们经常讨论，当我们记录客户数据时，当我们记录他们的财务信息时，我们当下的行为会产生什么影响。我们总是在讨论，比如你不愿意做什么？我们有法律义务做什么？在金融领域，我们在报告欺诈方面具有法律责任，例如洗钱。 所以我们必须相互讨论这些事情。作为工程师，你应该能够坦白地和你的同事坦言，“我不喜欢这样做。“ 我们如何确保不会那样？我们如何确保它保持在安全的一面而不是危险的一面？最重要的是知道你的底线，知道你何时愿意收手。因为科技真的有利可图，我们有很多的特权。我们在技术上有很多特权。即使只是看看我们所在的屋子，这也是一个非凡的会议室，这里有各种各样的设施。不是每个行业都这样的。什么是你的底线？超过了这个底线，你应该说：“我不能继续做这个”。如果你不知道这个底线是什么，你不会发现你已经越界了，直到一切已经来不及挽回。这就是我要讲的，非常谢谢大家。</p>\n<p><img src=\"/css/images/220.jpg\" alt=\"\"></p>"},{"title":"JavaScript 版数据结构与算法（七）树","date":"2017-02-18T05:15:00.000Z","_content":"\n今天，我们要讲的是数据结构与算法中的树。\n\n<!--more-->\n\n## 树简介\n\n树是什么？树是一种分层数据的抽象模型。都有哪几种树？常见的树包括：\n\n- 二叉树：树中每个节点最多只能有两个子节点。\n- 二叉搜索树（BST）：二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。\n- AVL树：一种自平衡二叉搜索树，树中任何一个节点左右两侧子树的高度之差最多为1。\n- 红黑树：http://goo.gl/OxED8K\n- 堆积树：http://goo.gl/SFlhW6\n\n树有啥用？树的作用有这些：\n\n- 树对存储需要快速查找的数据非常有用。\n- 二叉树的先序遍历可以用来打印一个结构化的文档。\n- 二叉树的中序遍历可以用来对树进行排序操作。\n- 二叉树的后序遍历可以用来计算一个目录和它的子目录中所有文件所占空间的大小。\n- 在前端 DOM 操作中，我们有时候会遍历元素，该操作的本质其实也是遍历树。而且值得了解的是：“DOM2 级遍历和范围”模块定义了两个用于辅助完成顺序遍历 DOM 结构的类型：NodeIterator 和 TreeWalker。这两个类型能够基于给定的起点对 DOM 结构执行深度优先（depth-first）的遍历操作。\n- 生活中，树可以模拟组织架构，比如总裁管着几个副总裁，副总裁管着几个经理等。\n\n\n\n树的应用非常广泛，远远不止上面这些，有兴趣的同学可以自行去了解更多的树的用途，这里不再详述。\n\n## 用 JavaScript 编写二叉搜索树类\n\n树的种类有很多，但本文仅介绍二叉搜索树的 JavaScript 实现，包括了插入、排序等操作。\n\n### 私有变量\n\n因为二叉搜索树的每个节点最多有两个子节点，所以我们首先要编写一个私有的构造器函数 `Node`，来构建树的节点：\n\n```js\nvar Node = function (key) {\n  this.key = key;\n  this.left = null;\n  this.right = null;\n};\n```\n\n又因为树的操作通常需要从根节点开始，所以我们还要编写一个私有变量 `root`，用于指向树的根节点：\n\n```js\nvar root = null;\n```\n\n如此一来，如果一颗树是这样：\n\n```js\n      11\n    7   13\n  5   9 \n3\n```\n那么在我们编写的类中就长这样：\n\n```js\n{\n  key: 11,  // root 指向 key 为 11 的对象。\n  left: {\n    key: 7,\n    left:  { \n      key: 5, \n      left: {\n        key: 3,\n        left: null,  \n        right: null  \n      },  \n      right: null  \n    },\n    right:  {  \n      key: 9,  \n      left: null,  \n      right: null  \n    } \n  },\n  right: {  \n    key: 13,  \n    left: null,  \n    right: null  \n  }  \n}\n```\n\n### 用递归实现 insert 方法\n\n实现 `insert` 方法，可以构造如上面那样的数据结构。在思考代码逻辑前，我们需要回忆一下，二叉搜索树的特点：它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。那么插入方法就必须要进行如下几个操作：\n\n- 判断：判断节点和被插入节点的大小，小了去判断左节点，否则判断右节点\n- 移动：移动被判断的节点\n- 插入：如果节点为空就插入\n\n使用递归来实现 `insert` 方法，非常简单，只需要将每个子树（特指节点不大于三的子树）的判断、移动、插入过程写进一个递归函数，然后自己调用自己就行了。实现代码如下：\n\n```js\n// 辅助函数，用于递归\nvar insertNode = function (node, newNode) {\n  if (newNode.key < node.key) {  \n    if (node.left === null) {\n      node.left = newNode; // 遇到空值就插入\n    } else {\n      insertNode(node.left, newNode); // 小了左边走\n    }\n  } else {\n    if (node.right === null) {\n      node.right = newNode; // 遇到空值就插入\n    } else {\n      insertNode(node.right, newNode);  // 大了或相等就右边走\n    }\n  }\n};\n\nthis.insert = function (key) {\n\n  var newNode = new Node(key);\n\n  if (root === null) {\n    root = newNode; // 遇到空值就插入\n  } else {\n    insertNode(root, newNode);  // 从根节点开始\n  }\n};\n```\n\n### 使用递归实现中序先序后序遍历\n\n使用递归实现中序先序后序遍历，并实现 `values` 方法（输入遍历方法，遍历节点并 push 到数组中，最后返回数组），可以跑通如下测试：\n\n```js\nvar binarySearchTree = new BinarySearchTree();\n\nbinarySearchTree.insert(11);\nbinarySearchTree.insert(7);\nbinarySearchTree.insert(13);\nbinarySearchTree.insert(5);\nbinarySearchTree.insert(3);\nbinarySearchTree.insert(9);\n\nexpect(binarySearchTree.values('inOrderTraverse')).toEqual([3, 5, 7, 9, 11, 13]);\nexpect(binarySearchTree.values('preOrderTraverse')).toEqual([11, 7, 5, 3, 9, 13]);\nexpect(binarySearchTree.values('postOrderTraverse')).toEqual([3, 5, 9, 7, 13, 11]);\n```\n\n中序遍历指先访问左子树，然后访问根，最后访问右子树的遍历方式。那么使用递归实现的话，非常简单，只需要**把每个子树的遍历写进递归函数**中，自己调用自己就行了。\n\n```js\nvar inOrderTraverseNode = function (node, callback) {\n  if (node !== null) {  // 注意一定要写上终止条件\n    inOrderTraverseNode(node.left, callback);\n    callback(node.key);\n    inOrderTraverseNode(node.right, callback);\n  }\n};\n\nthis.inOrderTraverse = function (callback) {\n  inOrderTraverseNode(root, callback);\n};\n```\n\n先序遍历指先访问根，然后访问子树的遍历方式。那么使用递归实现的话也非常简单，还是把每个子树的遍历写进递归函数中，自己调用自己就行了。\n\n```js\nvar preOrderTraverseNode = function (node, callback) {\n  if (node !== null) {  // 注意一定要写上终止条件\n    callback(node.key);\n    preOrderTraverseNode(node.left, callback);\n    preOrderTraverseNode(node.right, callback);\n  }\n};\n\nthis.preOrderTraverse = function (callback) {\n  preOrderTraverseNode(root, callback);\n};\n```\n\n后序遍历指指先访问子树，然后访问根的遍历方式。那么使用递归实现的话也非常简单，还是把每个子树的遍历写进递归函数中，自己调用自己就行了。\n\n```js\nvar postOrderTraverseNode = function (node, callback) {\n  if (node !== null) {  // 注意一定要写上终止条件\n    postOrderTraverseNode(node.left, callback);\n    postOrderTraverseNode(node.right, callback);\n    callback(node.key);\n  }\n};\n\nthis.postOrderTraverse = function (callback) {\n  postOrderTraverseNode(root, callback);\n};\n```\n\n最后，实现 `values` 方法：\n\n```js\nthis.values = function (traverseFuc) {\n  var keyList = [];\n  this[traverseFuc](function (key) {\n    keyList.push(key);\n  });\n  return keyList;\n};\n```\n\n`values` 方法比较简单，不再详述。\n\n###  使用非递归实现中序先序后序遍历\n\n使用递归实现中序先序后序遍历太过简单，面试官通常不屑于考这样的题目，但非递归遍历二叉树借助栈来实现，还是有点小复杂的，面试官考试最爱考了，所以我们接下来学习使用非递归实现中序先序后序遍历。\n\n中序遍历的非递归实现思路是：\n\n- 从根节点开始，左移到树的尽头，向栈中 push 移动过程中的每个节点。\n- 从栈中 pop 出一个节点，并访问它。\n- 如果该节点有右节点就从右节点开始，重复第一步。\n- 如果该节点没有右节点就重复第二步。\n\n上述思路可以简记为：\n\n- 左尽入栈\n- 出栈访问\n- 有右复一\n- 无右复二\n\n我自己编的，很有才吧！实现代码如下：\n\n```js\nthis.inOrderTraverseUnRec = function (callback) {\n  if (root !== null) {\n    var stack = new Stack(),\n      node = root;\n    while (!stack.isEmpty() || node) {\n      if (node) {   // 有右复一\n        stack.push(node); // 左尽入栈\n        node = node.left;\n      } else {   // 无右复二\n        node = stack.pop(); // 出栈访问\n        callback(node.key);\n        node = node.right;\n      }\n    }\n  }\n};\n```\n\n先序遍历的非递归实现思路是：\n\n- 从根节点开始，先访问当前节点，然后将当前节点的右、左节点依次 push 到栈中。\n- 从栈中 pop 出一个节点，重复第一步。\n\n上述思路可以简记为：\n\n- 访问当前\n- 入栈右左\n- 出栈复一\n\n实现代码为：\n\n```js\nthis.preOrderTraverseUnRec = function (callback) {\n  if (root !== null) {\n    var stack = new Stack();\n    stack.push(root);\n    while (!stack.isEmpty()) {\n      var node = stack.pop(); // 出栈复一\n      if (callback) {  // 访问当前\n        callback(node.key);\n      }\n      if (node.right) {  // 入栈右左\n        stack.push(node.right);\n      }\n      if (node.left) {\n        stack.push(node.left);\n      }\n    }\n  }\n};\n```\n\n后序遍历需要两个栈，它的非递归实现思路是通过先序遍历改编的，即将先序遍历中的**访问操作**改为**入栈操作**，等全部入栈后出栈访问：\n\n实现代码为：\n\n```js\n this.postOrderTraverseUnRec = function (callback) {\n   if (root !== null) {\n     var stack = new Stack(),\n       outputStack = new Stack(),\n       node;\n     stack.push(root);\n     while (!stack.isEmpty()) {\n       node = stack.pop();\n       outputStack.push(node);  // 将先序遍历中的访问操作改为入栈操作\n       if (node.left) {\n         stack.push(node.left);\n       }\n       if (node.right) {\n         stack.push(node.right);\n       }\n     }\n     while (!outputStack.isEmpty()) {\n       node = outputStack.pop();  // 全部入栈后出栈访问\n       if (callback) {\n         callback(node.key);\n       }\n     }\n   }\n };\n```\n\n还有搜索和移除的方法，本文不再讲解，有兴趣的同学可以自己研究示例代码。今天到此为止！\n\n \n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","source":"_posts/tree.md","raw":"---\ntitle: JavaScript 版数据结构与算法（七）树\ndate: 2017-02-18 13:15:00\ntags: [数据结构与算法]\n---\n\n今天，我们要讲的是数据结构与算法中的树。\n\n<!--more-->\n\n## 树简介\n\n树是什么？树是一种分层数据的抽象模型。都有哪几种树？常见的树包括：\n\n- 二叉树：树中每个节点最多只能有两个子节点。\n- 二叉搜索树（BST）：二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。\n- AVL树：一种自平衡二叉搜索树，树中任何一个节点左右两侧子树的高度之差最多为1。\n- 红黑树：http://goo.gl/OxED8K\n- 堆积树：http://goo.gl/SFlhW6\n\n树有啥用？树的作用有这些：\n\n- 树对存储需要快速查找的数据非常有用。\n- 二叉树的先序遍历可以用来打印一个结构化的文档。\n- 二叉树的中序遍历可以用来对树进行排序操作。\n- 二叉树的后序遍历可以用来计算一个目录和它的子目录中所有文件所占空间的大小。\n- 在前端 DOM 操作中，我们有时候会遍历元素，该操作的本质其实也是遍历树。而且值得了解的是：“DOM2 级遍历和范围”模块定义了两个用于辅助完成顺序遍历 DOM 结构的类型：NodeIterator 和 TreeWalker。这两个类型能够基于给定的起点对 DOM 结构执行深度优先（depth-first）的遍历操作。\n- 生活中，树可以模拟组织架构，比如总裁管着几个副总裁，副总裁管着几个经理等。\n\n\n\n树的应用非常广泛，远远不止上面这些，有兴趣的同学可以自行去了解更多的树的用途，这里不再详述。\n\n## 用 JavaScript 编写二叉搜索树类\n\n树的种类有很多，但本文仅介绍二叉搜索树的 JavaScript 实现，包括了插入、排序等操作。\n\n### 私有变量\n\n因为二叉搜索树的每个节点最多有两个子节点，所以我们首先要编写一个私有的构造器函数 `Node`，来构建树的节点：\n\n```js\nvar Node = function (key) {\n  this.key = key;\n  this.left = null;\n  this.right = null;\n};\n```\n\n又因为树的操作通常需要从根节点开始，所以我们还要编写一个私有变量 `root`，用于指向树的根节点：\n\n```js\nvar root = null;\n```\n\n如此一来，如果一颗树是这样：\n\n```js\n      11\n    7   13\n  5   9 \n3\n```\n那么在我们编写的类中就长这样：\n\n```js\n{\n  key: 11,  // root 指向 key 为 11 的对象。\n  left: {\n    key: 7,\n    left:  { \n      key: 5, \n      left: {\n        key: 3,\n        left: null,  \n        right: null  \n      },  \n      right: null  \n    },\n    right:  {  \n      key: 9,  \n      left: null,  \n      right: null  \n    } \n  },\n  right: {  \n    key: 13,  \n    left: null,  \n    right: null  \n  }  \n}\n```\n\n### 用递归实现 insert 方法\n\n实现 `insert` 方法，可以构造如上面那样的数据结构。在思考代码逻辑前，我们需要回忆一下，二叉搜索树的特点：它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。那么插入方法就必须要进行如下几个操作：\n\n- 判断：判断节点和被插入节点的大小，小了去判断左节点，否则判断右节点\n- 移动：移动被判断的节点\n- 插入：如果节点为空就插入\n\n使用递归来实现 `insert` 方法，非常简单，只需要将每个子树（特指节点不大于三的子树）的判断、移动、插入过程写进一个递归函数，然后自己调用自己就行了。实现代码如下：\n\n```js\n// 辅助函数，用于递归\nvar insertNode = function (node, newNode) {\n  if (newNode.key < node.key) {  \n    if (node.left === null) {\n      node.left = newNode; // 遇到空值就插入\n    } else {\n      insertNode(node.left, newNode); // 小了左边走\n    }\n  } else {\n    if (node.right === null) {\n      node.right = newNode; // 遇到空值就插入\n    } else {\n      insertNode(node.right, newNode);  // 大了或相等就右边走\n    }\n  }\n};\n\nthis.insert = function (key) {\n\n  var newNode = new Node(key);\n\n  if (root === null) {\n    root = newNode; // 遇到空值就插入\n  } else {\n    insertNode(root, newNode);  // 从根节点开始\n  }\n};\n```\n\n### 使用递归实现中序先序后序遍历\n\n使用递归实现中序先序后序遍历，并实现 `values` 方法（输入遍历方法，遍历节点并 push 到数组中，最后返回数组），可以跑通如下测试：\n\n```js\nvar binarySearchTree = new BinarySearchTree();\n\nbinarySearchTree.insert(11);\nbinarySearchTree.insert(7);\nbinarySearchTree.insert(13);\nbinarySearchTree.insert(5);\nbinarySearchTree.insert(3);\nbinarySearchTree.insert(9);\n\nexpect(binarySearchTree.values('inOrderTraverse')).toEqual([3, 5, 7, 9, 11, 13]);\nexpect(binarySearchTree.values('preOrderTraverse')).toEqual([11, 7, 5, 3, 9, 13]);\nexpect(binarySearchTree.values('postOrderTraverse')).toEqual([3, 5, 9, 7, 13, 11]);\n```\n\n中序遍历指先访问左子树，然后访问根，最后访问右子树的遍历方式。那么使用递归实现的话，非常简单，只需要**把每个子树的遍历写进递归函数**中，自己调用自己就行了。\n\n```js\nvar inOrderTraverseNode = function (node, callback) {\n  if (node !== null) {  // 注意一定要写上终止条件\n    inOrderTraverseNode(node.left, callback);\n    callback(node.key);\n    inOrderTraverseNode(node.right, callback);\n  }\n};\n\nthis.inOrderTraverse = function (callback) {\n  inOrderTraverseNode(root, callback);\n};\n```\n\n先序遍历指先访问根，然后访问子树的遍历方式。那么使用递归实现的话也非常简单，还是把每个子树的遍历写进递归函数中，自己调用自己就行了。\n\n```js\nvar preOrderTraverseNode = function (node, callback) {\n  if (node !== null) {  // 注意一定要写上终止条件\n    callback(node.key);\n    preOrderTraverseNode(node.left, callback);\n    preOrderTraverseNode(node.right, callback);\n  }\n};\n\nthis.preOrderTraverse = function (callback) {\n  preOrderTraverseNode(root, callback);\n};\n```\n\n后序遍历指指先访问子树，然后访问根的遍历方式。那么使用递归实现的话也非常简单，还是把每个子树的遍历写进递归函数中，自己调用自己就行了。\n\n```js\nvar postOrderTraverseNode = function (node, callback) {\n  if (node !== null) {  // 注意一定要写上终止条件\n    postOrderTraverseNode(node.left, callback);\n    postOrderTraverseNode(node.right, callback);\n    callback(node.key);\n  }\n};\n\nthis.postOrderTraverse = function (callback) {\n  postOrderTraverseNode(root, callback);\n};\n```\n\n最后，实现 `values` 方法：\n\n```js\nthis.values = function (traverseFuc) {\n  var keyList = [];\n  this[traverseFuc](function (key) {\n    keyList.push(key);\n  });\n  return keyList;\n};\n```\n\n`values` 方法比较简单，不再详述。\n\n###  使用非递归实现中序先序后序遍历\n\n使用递归实现中序先序后序遍历太过简单，面试官通常不屑于考这样的题目，但非递归遍历二叉树借助栈来实现，还是有点小复杂的，面试官考试最爱考了，所以我们接下来学习使用非递归实现中序先序后序遍历。\n\n中序遍历的非递归实现思路是：\n\n- 从根节点开始，左移到树的尽头，向栈中 push 移动过程中的每个节点。\n- 从栈中 pop 出一个节点，并访问它。\n- 如果该节点有右节点就从右节点开始，重复第一步。\n- 如果该节点没有右节点就重复第二步。\n\n上述思路可以简记为：\n\n- 左尽入栈\n- 出栈访问\n- 有右复一\n- 无右复二\n\n我自己编的，很有才吧！实现代码如下：\n\n```js\nthis.inOrderTraverseUnRec = function (callback) {\n  if (root !== null) {\n    var stack = new Stack(),\n      node = root;\n    while (!stack.isEmpty() || node) {\n      if (node) {   // 有右复一\n        stack.push(node); // 左尽入栈\n        node = node.left;\n      } else {   // 无右复二\n        node = stack.pop(); // 出栈访问\n        callback(node.key);\n        node = node.right;\n      }\n    }\n  }\n};\n```\n\n先序遍历的非递归实现思路是：\n\n- 从根节点开始，先访问当前节点，然后将当前节点的右、左节点依次 push 到栈中。\n- 从栈中 pop 出一个节点，重复第一步。\n\n上述思路可以简记为：\n\n- 访问当前\n- 入栈右左\n- 出栈复一\n\n实现代码为：\n\n```js\nthis.preOrderTraverseUnRec = function (callback) {\n  if (root !== null) {\n    var stack = new Stack();\n    stack.push(root);\n    while (!stack.isEmpty()) {\n      var node = stack.pop(); // 出栈复一\n      if (callback) {  // 访问当前\n        callback(node.key);\n      }\n      if (node.right) {  // 入栈右左\n        stack.push(node.right);\n      }\n      if (node.left) {\n        stack.push(node.left);\n      }\n    }\n  }\n};\n```\n\n后序遍历需要两个栈，它的非递归实现思路是通过先序遍历改编的，即将先序遍历中的**访问操作**改为**入栈操作**，等全部入栈后出栈访问：\n\n实现代码为：\n\n```js\n this.postOrderTraverseUnRec = function (callback) {\n   if (root !== null) {\n     var stack = new Stack(),\n       outputStack = new Stack(),\n       node;\n     stack.push(root);\n     while (!stack.isEmpty()) {\n       node = stack.pop();\n       outputStack.push(node);  // 将先序遍历中的访问操作改为入栈操作\n       if (node.left) {\n         stack.push(node.left);\n       }\n       if (node.right) {\n         stack.push(node.right);\n       }\n     }\n     while (!outputStack.isEmpty()) {\n       node = outputStack.pop();  // 全部入栈后出栈访问\n       if (callback) {\n         callback(node.key);\n       }\n     }\n   }\n };\n```\n\n还有搜索和移除的方法，本文不再讲解，有兴趣的同学可以自己研究示例代码。今天到此为止！\n\n \n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/javascript-datastructures-algorithms>\n\n目录：<http://www.liuyiqi.cn/tags/数据结构与算法/>","slug":"tree","published":1,"updated":"2019-05-01T08:02:13.414Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvn2003qtgytbavpvy6b","content":"<p>今天，我们要讲的是数据结构与算法中的树。</p>\n<a id=\"more\"></a>\n<h2 id=\"树简介\"><a href=\"#树简介\" class=\"headerlink\" title=\"树简介\"></a>树简介</h2><p>树是什么？树是一种分层数据的抽象模型。都有哪几种树？常见的树包括：</p>\n<ul>\n<li>二叉树：树中每个节点最多只能有两个子节点。</li>\n<li>二叉搜索树（BST）：二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。</li>\n<li>AVL树：一种自平衡二叉搜索树，树中任何一个节点左右两侧子树的高度之差最多为1。</li>\n<li>红黑树：<a href=\"http://goo.gl/OxED8K\" target=\"_blank\" rel=\"noopener\">http://goo.gl/OxED8K</a></li>\n<li>堆积树：<a href=\"http://goo.gl/SFlhW6\" target=\"_blank\" rel=\"noopener\">http://goo.gl/SFlhW6</a></li>\n</ul>\n<p>树有啥用？树的作用有这些：</p>\n<ul>\n<li>树对存储需要快速查找的数据非常有用。</li>\n<li>二叉树的先序遍历可以用来打印一个结构化的文档。</li>\n<li>二叉树的中序遍历可以用来对树进行排序操作。</li>\n<li>二叉树的后序遍历可以用来计算一个目录和它的子目录中所有文件所占空间的大小。</li>\n<li>在前端 DOM 操作中，我们有时候会遍历元素，该操作的本质其实也是遍历树。而且值得了解的是：“DOM2 级遍历和范围”模块定义了两个用于辅助完成顺序遍历 DOM 结构的类型：NodeIterator 和 TreeWalker。这两个类型能够基于给定的起点对 DOM 结构执行深度优先（depth-first）的遍历操作。</li>\n<li>生活中，树可以模拟组织架构，比如总裁管着几个副总裁，副总裁管着几个经理等。</li>\n</ul>\n<p>树的应用非常广泛，远远不止上面这些，有兴趣的同学可以自行去了解更多的树的用途，这里不再详述。</p>\n<h2 id=\"用-JavaScript-编写二叉搜索树类\"><a href=\"#用-JavaScript-编写二叉搜索树类\" class=\"headerlink\" title=\"用 JavaScript 编写二叉搜索树类\"></a>用 JavaScript 编写二叉搜索树类</h2><p>树的种类有很多，但本文仅介绍二叉搜索树的 JavaScript 实现，包括了插入、排序等操作。</p>\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>因为二叉搜索树的每个节点最多有两个子节点，所以我们首先要编写一个私有的构造器函数 <code>Node</code>，来构建树的节点：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Node = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.left = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.right = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>又因为树的操作通常需要从根节点开始，所以我们还要编写一个私有变量 <code>root</code>，用于指向树的根节点：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> root = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>如此一来，如果一颗树是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"number\">11</span></span><br><span class=\"line\">    <span class=\"number\">7</span>   <span class=\"number\">13</span></span><br><span class=\"line\">  <span class=\"number\">5</span>   <span class=\"number\">9</span> </span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>那么在我们编写的类中就长这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  key: <span class=\"number\">11</span>,  <span class=\"comment\">// root 指向 key 为 11 的对象。</span></span><br><span class=\"line\">  left: &#123;</span><br><span class=\"line\">    key: <span class=\"number\">7</span>,</span><br><span class=\"line\">    left:  &#123; </span><br><span class=\"line\">      key: <span class=\"number\">5</span>, </span><br><span class=\"line\">      left: &#123;</span><br><span class=\"line\">        key: <span class=\"number\">3</span>,</span><br><span class=\"line\">        left: <span class=\"literal\">null</span>,  </span><br><span class=\"line\">        right: <span class=\"literal\">null</span>  </span><br><span class=\"line\">      &#125;,  </span><br><span class=\"line\">      right: <span class=\"literal\">null</span>  </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    right:  &#123;  </span><br><span class=\"line\">      key: <span class=\"number\">9</span>,  </span><br><span class=\"line\">      left: <span class=\"literal\">null</span>,  </span><br><span class=\"line\">      right: <span class=\"literal\">null</span>  </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  right: &#123;  </span><br><span class=\"line\">    key: <span class=\"number\">13</span>,  </span><br><span class=\"line\">    left: <span class=\"literal\">null</span>,  </span><br><span class=\"line\">    right: <span class=\"literal\">null</span>  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"用递归实现-insert-方法\"><a href=\"#用递归实现-insert-方法\" class=\"headerlink\" title=\"用递归实现 insert 方法\"></a>用递归实现 insert 方法</h3><p>实现 <code>insert</code> 方法，可以构造如上面那样的数据结构。在思考代码逻辑前，我们需要回忆一下，二叉搜索树的特点：它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。那么插入方法就必须要进行如下几个操作：</p>\n<ul>\n<li>判断：判断节点和被插入节点的大小，小了去判断左节点，否则判断右节点</li>\n<li>移动：移动被判断的节点</li>\n<li>插入：如果节点为空就插入</li>\n</ul>\n<p>使用递归来实现 <code>insert</code> 方法，非常简单，只需要将每个子树（特指节点不大于三的子树）的判断、移动、插入过程写进一个递归函数，然后自己调用自己就行了。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 辅助函数，用于递归</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> insertNode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node, newNode</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newNode.key &lt; node.key) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.left === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      node.left = newNode; <span class=\"comment\">// 遇到空值就插入</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      insertNode(node.left, newNode); <span class=\"comment\">// 小了左边走</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.right === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      node.right = newNode; <span class=\"comment\">// 遇到空值就插入</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      insertNode(node.right, newNode);  <span class=\"comment\">// 大了或相等就右边走</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.insert = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> newNode = <span class=\"keyword\">new</span> Node(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    root = newNode; <span class=\"comment\">// 遇到空值就插入</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    insertNode(root, newNode);  <span class=\"comment\">// 从根节点开始</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用递归实现中序先序后序遍历\"><a href=\"#使用递归实现中序先序后序遍历\" class=\"headerlink\" title=\"使用递归实现中序先序后序遍历\"></a>使用递归实现中序先序后序遍历</h3><p>使用递归实现中序先序后序遍历，并实现 <code>values</code> 方法（输入遍历方法，遍历节点并 push 到数组中，最后返回数组），可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> binarySearchTree = <span class=\"keyword\">new</span> BinarySearchTree();</span><br><span class=\"line\"></span><br><span class=\"line\">binarySearchTree.insert(<span class=\"number\">11</span>);</span><br><span class=\"line\">binarySearchTree.insert(<span class=\"number\">7</span>);</span><br><span class=\"line\">binarySearchTree.insert(<span class=\"number\">13</span>);</span><br><span class=\"line\">binarySearchTree.insert(<span class=\"number\">5</span>);</span><br><span class=\"line\">binarySearchTree.insert(<span class=\"number\">3</span>);</span><br><span class=\"line\">binarySearchTree.insert(<span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(binarySearchTree.values(<span class=\"string\">'inOrderTraverse'</span>)).toEqual([<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>]);</span><br><span class=\"line\">expect(binarySearchTree.values(<span class=\"string\">'preOrderTraverse'</span>)).toEqual([<span class=\"number\">11</span>, <span class=\"number\">7</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>, <span class=\"number\">13</span>]);</span><br><span class=\"line\">expect(binarySearchTree.values(<span class=\"string\">'postOrderTraverse'</span>)).toEqual([<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">13</span>, <span class=\"number\">11</span>]);</span><br></pre></td></tr></table></figure>\n<p>中序遍历指先访问左子树，然后访问根，最后访问右子树的遍历方式。那么使用递归实现的话，非常简单，只需要<strong>把每个子树的遍历写进递归函数</strong>中，自己调用自己就行了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> inOrderTraverseNode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node !== <span class=\"literal\">null</span>) &#123;  <span class=\"comment\">// 注意一定要写上终止条件</span></span><br><span class=\"line\">    inOrderTraverseNode(node.left, callback);</span><br><span class=\"line\">    callback(node.key);</span><br><span class=\"line\">    inOrderTraverseNode(node.right, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.inOrderTraverse = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  inOrderTraverseNode(root, callback);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>先序遍历指先访问根，然后访问子树的遍历方式。那么使用递归实现的话也非常简单，还是把每个子树的遍历写进递归函数中，自己调用自己就行了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> preOrderTraverseNode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node !== <span class=\"literal\">null</span>) &#123;  <span class=\"comment\">// 注意一定要写上终止条件</span></span><br><span class=\"line\">    callback(node.key);</span><br><span class=\"line\">    preOrderTraverseNode(node.left, callback);</span><br><span class=\"line\">    preOrderTraverseNode(node.right, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.preOrderTraverse = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  preOrderTraverseNode(root, callback);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>后序遍历指指先访问子树，然后访问根的遍历方式。那么使用递归实现的话也非常简单，还是把每个子树的遍历写进递归函数中，自己调用自己就行了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> postOrderTraverseNode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node !== <span class=\"literal\">null</span>) &#123;  <span class=\"comment\">// 注意一定要写上终止条件</span></span><br><span class=\"line\">    postOrderTraverseNode(node.left, callback);</span><br><span class=\"line\">    postOrderTraverseNode(node.right, callback);</span><br><span class=\"line\">    callback(node.key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.postOrderTraverse = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  postOrderTraverseNode(root, callback);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>最后，实现 <code>values</code> 方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.values = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">traverseFuc</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> keyList = [];</span><br><span class=\"line\">  <span class=\"keyword\">this</span>[traverseFuc](<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    keyList.push(key);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> keyList;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>values</code> 方法比较简单，不再详述。</p>\n<h3 id=\"使用非递归实现中序先序后序遍历\"><a href=\"#使用非递归实现中序先序后序遍历\" class=\"headerlink\" title=\"使用非递归实现中序先序后序遍历\"></a>使用非递归实现中序先序后序遍历</h3><p>使用递归实现中序先序后序遍历太过简单，面试官通常不屑于考这样的题目，但非递归遍历二叉树借助栈来实现，还是有点小复杂的，面试官考试最爱考了，所以我们接下来学习使用非递归实现中序先序后序遍历。</p>\n<p>中序遍历的非递归实现思路是：</p>\n<ul>\n<li>从根节点开始，左移到树的尽头，向栈中 push 移动过程中的每个节点。</li>\n<li>从栈中 pop 出一个节点，并访问它。</li>\n<li>如果该节点有右节点就从右节点开始，重复第一步。</li>\n<li>如果该节点没有右节点就重复第二步。</li>\n</ul>\n<p>上述思路可以简记为：</p>\n<ul>\n<li>左尽入栈</li>\n<li>出栈访问</li>\n<li>有右复一</li>\n<li>无右复二</li>\n</ul>\n<p>我自己编的，很有才吧！实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.inOrderTraverseUnRec = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack = <span class=\"keyword\">new</span> Stack(),</span><br><span class=\"line\">      node = root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty() || node) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node) &#123;   <span class=\"comment\">// 有右复一</span></span><br><span class=\"line\">        stack.push(node); <span class=\"comment\">// 左尽入栈</span></span><br><span class=\"line\">        node = node.left;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;   <span class=\"comment\">// 无右复二</span></span><br><span class=\"line\">        node = stack.pop(); <span class=\"comment\">// 出栈访问</span></span><br><span class=\"line\">        callback(node.key);</span><br><span class=\"line\">        node = node.right;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>先序遍历的非递归实现思路是：</p>\n<ul>\n<li>从根节点开始，先访问当前节点，然后将当前节点的右、左节点依次 push 到栈中。</li>\n<li>从栈中 pop 出一个节点，重复第一步。</li>\n</ul>\n<p>上述思路可以简记为：</p>\n<ul>\n<li>访问当前</li>\n<li>入栈右左</li>\n<li>出栈复一</li>\n</ul>\n<p>实现代码为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.preOrderTraverseUnRec = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> node = stack.pop(); <span class=\"comment\">// 出栈复一</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callback) &#123;  <span class=\"comment\">// 访问当前</span></span><br><span class=\"line\">        callback(node.key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.right) &#123;  <span class=\"comment\">// 入栈右左</span></span><br><span class=\"line\">        stack.push(node.right);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left) &#123;</span><br><span class=\"line\">        stack.push(node.left);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>后序遍历需要两个栈，它的非递归实现思路是通过先序遍历改编的，即将先序遍历中的<strong>访问操作</strong>改为<strong>入栈操作</strong>，等全部入栈后出栈访问：</p>\n<p>实现代码为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.postOrderTraverseUnRec = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack = <span class=\"keyword\">new</span> Stack(),</span><br><span class=\"line\">      outputStack = <span class=\"keyword\">new</span> Stack(),</span><br><span class=\"line\">      node;</span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">      node = stack.pop();</span><br><span class=\"line\">      outputStack.push(node);  <span class=\"comment\">// 将先序遍历中的访问操作改为入栈操作</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left) &#123;</span><br><span class=\"line\">        stack.push(node.left);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.right) &#123;</span><br><span class=\"line\">        stack.push(node.right);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!outputStack.isEmpty()) &#123;</span><br><span class=\"line\">      node = outputStack.pop();  <span class=\"comment\">// 全部入栈后出栈访问</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callback) &#123;</span><br><span class=\"line\">        callback(node.key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>还有搜索和移除的方法，本文不再讲解，有兴趣的同学可以自己研究示例代码。今天到此为止！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是数据结构与算法中的树。</p>","more":"<h2 id=\"树简介\"><a href=\"#树简介\" class=\"headerlink\" title=\"树简介\"></a>树简介</h2><p>树是什么？树是一种分层数据的抽象模型。都有哪几种树？常见的树包括：</p>\n<ul>\n<li>二叉树：树中每个节点最多只能有两个子节点。</li>\n<li>二叉搜索树（BST）：二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。</li>\n<li>AVL树：一种自平衡二叉搜索树，树中任何一个节点左右两侧子树的高度之差最多为1。</li>\n<li>红黑树：<a href=\"http://goo.gl/OxED8K\" target=\"_blank\" rel=\"noopener\">http://goo.gl/OxED8K</a></li>\n<li>堆积树：<a href=\"http://goo.gl/SFlhW6\" target=\"_blank\" rel=\"noopener\">http://goo.gl/SFlhW6</a></li>\n</ul>\n<p>树有啥用？树的作用有这些：</p>\n<ul>\n<li>树对存储需要快速查找的数据非常有用。</li>\n<li>二叉树的先序遍历可以用来打印一个结构化的文档。</li>\n<li>二叉树的中序遍历可以用来对树进行排序操作。</li>\n<li>二叉树的后序遍历可以用来计算一个目录和它的子目录中所有文件所占空间的大小。</li>\n<li>在前端 DOM 操作中，我们有时候会遍历元素，该操作的本质其实也是遍历树。而且值得了解的是：“DOM2 级遍历和范围”模块定义了两个用于辅助完成顺序遍历 DOM 结构的类型：NodeIterator 和 TreeWalker。这两个类型能够基于给定的起点对 DOM 结构执行深度优先（depth-first）的遍历操作。</li>\n<li>生活中，树可以模拟组织架构，比如总裁管着几个副总裁，副总裁管着几个经理等。</li>\n</ul>\n<p>树的应用非常广泛，远远不止上面这些，有兴趣的同学可以自行去了解更多的树的用途，这里不再详述。</p>\n<h2 id=\"用-JavaScript-编写二叉搜索树类\"><a href=\"#用-JavaScript-编写二叉搜索树类\" class=\"headerlink\" title=\"用 JavaScript 编写二叉搜索树类\"></a>用 JavaScript 编写二叉搜索树类</h2><p>树的种类有很多，但本文仅介绍二叉搜索树的 JavaScript 实现，包括了插入、排序等操作。</p>\n<h3 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h3><p>因为二叉搜索树的每个节点最多有两个子节点，所以我们首先要编写一个私有的构造器函数 <code>Node</code>，来构建树的节点：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Node = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.left = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.right = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>又因为树的操作通常需要从根节点开始，所以我们还要编写一个私有变量 <code>root</code>，用于指向树的根节点：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> root = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>如此一来，如果一颗树是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"number\">11</span></span><br><span class=\"line\">    <span class=\"number\">7</span>   <span class=\"number\">13</span></span><br><span class=\"line\">  <span class=\"number\">5</span>   <span class=\"number\">9</span> </span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>那么在我们编写的类中就长这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  key: <span class=\"number\">11</span>,  <span class=\"comment\">// root 指向 key 为 11 的对象。</span></span><br><span class=\"line\">  left: &#123;</span><br><span class=\"line\">    key: <span class=\"number\">7</span>,</span><br><span class=\"line\">    left:  &#123; </span><br><span class=\"line\">      key: <span class=\"number\">5</span>, </span><br><span class=\"line\">      left: &#123;</span><br><span class=\"line\">        key: <span class=\"number\">3</span>,</span><br><span class=\"line\">        left: <span class=\"literal\">null</span>,  </span><br><span class=\"line\">        right: <span class=\"literal\">null</span>  </span><br><span class=\"line\">      &#125;,  </span><br><span class=\"line\">      right: <span class=\"literal\">null</span>  </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    right:  &#123;  </span><br><span class=\"line\">      key: <span class=\"number\">9</span>,  </span><br><span class=\"line\">      left: <span class=\"literal\">null</span>,  </span><br><span class=\"line\">      right: <span class=\"literal\">null</span>  </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  right: &#123;  </span><br><span class=\"line\">    key: <span class=\"number\">13</span>,  </span><br><span class=\"line\">    left: <span class=\"literal\">null</span>,  </span><br><span class=\"line\">    right: <span class=\"literal\">null</span>  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"用递归实现-insert-方法\"><a href=\"#用递归实现-insert-方法\" class=\"headerlink\" title=\"用递归实现 insert 方法\"></a>用递归实现 insert 方法</h3><p>实现 <code>insert</code> 方法，可以构造如上面那样的数据结构。在思考代码逻辑前，我们需要回忆一下，二叉搜索树的特点：它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。那么插入方法就必须要进行如下几个操作：</p>\n<ul>\n<li>判断：判断节点和被插入节点的大小，小了去判断左节点，否则判断右节点</li>\n<li>移动：移动被判断的节点</li>\n<li>插入：如果节点为空就插入</li>\n</ul>\n<p>使用递归来实现 <code>insert</code> 方法，非常简单，只需要将每个子树（特指节点不大于三的子树）的判断、移动、插入过程写进一个递归函数，然后自己调用自己就行了。实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 辅助函数，用于递归</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> insertNode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node, newNode</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newNode.key &lt; node.key) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.left === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      node.left = newNode; <span class=\"comment\">// 遇到空值就插入</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      insertNode(node.left, newNode); <span class=\"comment\">// 小了左边走</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.right === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      node.right = newNode; <span class=\"comment\">// 遇到空值就插入</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      insertNode(node.right, newNode);  <span class=\"comment\">// 大了或相等就右边走</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.insert = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> newNode = <span class=\"keyword\">new</span> Node(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    root = newNode; <span class=\"comment\">// 遇到空值就插入</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    insertNode(root, newNode);  <span class=\"comment\">// 从根节点开始</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用递归实现中序先序后序遍历\"><a href=\"#使用递归实现中序先序后序遍历\" class=\"headerlink\" title=\"使用递归实现中序先序后序遍历\"></a>使用递归实现中序先序后序遍历</h3><p>使用递归实现中序先序后序遍历，并实现 <code>values</code> 方法（输入遍历方法，遍历节点并 push 到数组中，最后返回数组），可以跑通如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> binarySearchTree = <span class=\"keyword\">new</span> BinarySearchTree();</span><br><span class=\"line\"></span><br><span class=\"line\">binarySearchTree.insert(<span class=\"number\">11</span>);</span><br><span class=\"line\">binarySearchTree.insert(<span class=\"number\">7</span>);</span><br><span class=\"line\">binarySearchTree.insert(<span class=\"number\">13</span>);</span><br><span class=\"line\">binarySearchTree.insert(<span class=\"number\">5</span>);</span><br><span class=\"line\">binarySearchTree.insert(<span class=\"number\">3</span>);</span><br><span class=\"line\">binarySearchTree.insert(<span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(binarySearchTree.values(<span class=\"string\">'inOrderTraverse'</span>)).toEqual([<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>]);</span><br><span class=\"line\">expect(binarySearchTree.values(<span class=\"string\">'preOrderTraverse'</span>)).toEqual([<span class=\"number\">11</span>, <span class=\"number\">7</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>, <span class=\"number\">13</span>]);</span><br><span class=\"line\">expect(binarySearchTree.values(<span class=\"string\">'postOrderTraverse'</span>)).toEqual([<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">13</span>, <span class=\"number\">11</span>]);</span><br></pre></td></tr></table></figure>\n<p>中序遍历指先访问左子树，然后访问根，最后访问右子树的遍历方式。那么使用递归实现的话，非常简单，只需要<strong>把每个子树的遍历写进递归函数</strong>中，自己调用自己就行了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> inOrderTraverseNode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node !== <span class=\"literal\">null</span>) &#123;  <span class=\"comment\">// 注意一定要写上终止条件</span></span><br><span class=\"line\">    inOrderTraverseNode(node.left, callback);</span><br><span class=\"line\">    callback(node.key);</span><br><span class=\"line\">    inOrderTraverseNode(node.right, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.inOrderTraverse = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  inOrderTraverseNode(root, callback);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>先序遍历指先访问根，然后访问子树的遍历方式。那么使用递归实现的话也非常简单，还是把每个子树的遍历写进递归函数中，自己调用自己就行了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> preOrderTraverseNode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node !== <span class=\"literal\">null</span>) &#123;  <span class=\"comment\">// 注意一定要写上终止条件</span></span><br><span class=\"line\">    callback(node.key);</span><br><span class=\"line\">    preOrderTraverseNode(node.left, callback);</span><br><span class=\"line\">    preOrderTraverseNode(node.right, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.preOrderTraverse = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  preOrderTraverseNode(root, callback);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>后序遍历指指先访问子树，然后访问根的遍历方式。那么使用递归实现的话也非常简单，还是把每个子树的遍历写进递归函数中，自己调用自己就行了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> postOrderTraverseNode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node !== <span class=\"literal\">null</span>) &#123;  <span class=\"comment\">// 注意一定要写上终止条件</span></span><br><span class=\"line\">    postOrderTraverseNode(node.left, callback);</span><br><span class=\"line\">    postOrderTraverseNode(node.right, callback);</span><br><span class=\"line\">    callback(node.key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.postOrderTraverse = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  postOrderTraverseNode(root, callback);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>最后，实现 <code>values</code> 方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.values = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">traverseFuc</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> keyList = [];</span><br><span class=\"line\">  <span class=\"keyword\">this</span>[traverseFuc](<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    keyList.push(key);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> keyList;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>values</code> 方法比较简单，不再详述。</p>\n<h3 id=\"使用非递归实现中序先序后序遍历\"><a href=\"#使用非递归实现中序先序后序遍历\" class=\"headerlink\" title=\"使用非递归实现中序先序后序遍历\"></a>使用非递归实现中序先序后序遍历</h3><p>使用递归实现中序先序后序遍历太过简单，面试官通常不屑于考这样的题目，但非递归遍历二叉树借助栈来实现，还是有点小复杂的，面试官考试最爱考了，所以我们接下来学习使用非递归实现中序先序后序遍历。</p>\n<p>中序遍历的非递归实现思路是：</p>\n<ul>\n<li>从根节点开始，左移到树的尽头，向栈中 push 移动过程中的每个节点。</li>\n<li>从栈中 pop 出一个节点，并访问它。</li>\n<li>如果该节点有右节点就从右节点开始，重复第一步。</li>\n<li>如果该节点没有右节点就重复第二步。</li>\n</ul>\n<p>上述思路可以简记为：</p>\n<ul>\n<li>左尽入栈</li>\n<li>出栈访问</li>\n<li>有右复一</li>\n<li>无右复二</li>\n</ul>\n<p>我自己编的，很有才吧！实现代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.inOrderTraverseUnRec = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack = <span class=\"keyword\">new</span> Stack(),</span><br><span class=\"line\">      node = root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty() || node) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node) &#123;   <span class=\"comment\">// 有右复一</span></span><br><span class=\"line\">        stack.push(node); <span class=\"comment\">// 左尽入栈</span></span><br><span class=\"line\">        node = node.left;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;   <span class=\"comment\">// 无右复二</span></span><br><span class=\"line\">        node = stack.pop(); <span class=\"comment\">// 出栈访问</span></span><br><span class=\"line\">        callback(node.key);</span><br><span class=\"line\">        node = node.right;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>先序遍历的非递归实现思路是：</p>\n<ul>\n<li>从根节点开始，先访问当前节点，然后将当前节点的右、左节点依次 push 到栈中。</li>\n<li>从栈中 pop 出一个节点，重复第一步。</li>\n</ul>\n<p>上述思路可以简记为：</p>\n<ul>\n<li>访问当前</li>\n<li>入栈右左</li>\n<li>出栈复一</li>\n</ul>\n<p>实现代码为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.preOrderTraverseUnRec = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> node = stack.pop(); <span class=\"comment\">// 出栈复一</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callback) &#123;  <span class=\"comment\">// 访问当前</span></span><br><span class=\"line\">        callback(node.key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.right) &#123;  <span class=\"comment\">// 入栈右左</span></span><br><span class=\"line\">        stack.push(node.right);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left) &#123;</span><br><span class=\"line\">        stack.push(node.left);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>后序遍历需要两个栈，它的非递归实现思路是通过先序遍历改编的，即将先序遍历中的<strong>访问操作</strong>改为<strong>入栈操作</strong>，等全部入栈后出栈访问：</p>\n<p>实现代码为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.postOrderTraverseUnRec = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack = <span class=\"keyword\">new</span> Stack(),</span><br><span class=\"line\">      outputStack = <span class=\"keyword\">new</span> Stack(),</span><br><span class=\"line\">      node;</span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">      node = stack.pop();</span><br><span class=\"line\">      outputStack.push(node);  <span class=\"comment\">// 将先序遍历中的访问操作改为入栈操作</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.left) &#123;</span><br><span class=\"line\">        stack.push(node.left);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.right) &#123;</span><br><span class=\"line\">        stack.push(node.right);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!outputStack.isEmpty()) &#123;</span><br><span class=\"line\">      node = outputStack.pop();  <span class=\"comment\">// 全部入栈后出栈访问</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callback) &#123;</span><br><span class=\"line\">        callback(node.key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>还有搜索和移除的方法，本文不再讲解，有兴趣的同学可以自己研究示例代码。今天到此为止！</p>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/javascript-datastructures-algorithms\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/javascript-datastructures-algorithms</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/数据结构与算法/\">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>"},{"title":"TypeScript: Angular 2 的秘密武器（译）","date":"2016-12-23T19:24:00.000Z","_content":"\n本文整理自Dan Wahlin在ng-conf上的talk。原视频地址：\n\nhttps://www.youtube.com/watch?v=e3djIqAGqZo\n\n/css/images/221.jpg\n\n<!--more-->\n\n## 开场白\n\n开场白主要分为三部分：\n\n- 感谢了ng-conf的组织者。\n- 阐述了TypeScript是JavaScript的超集，并不是另外一种语言。\n- 引用了他的两个朋友最喜欢的TypeScript特性。\n\n由于开场白内容不太重要，所以不再详述。下面开始讲解Dan Wahlin最喜欢的TypeScript的特性。\n\n## 类型支持（Type Support）\n\n让我们来聊下类型支持吧！先打开[TypeScript Playground](https://www.typescriptlang.org/play/)，我们会看到一个非常简单的例子。\n\n![](/css/images/222.jpg)\n\n\n左边是TypeScript，右边是编译后的JavaScript，它俩差异很大吗？并不是，呵呵！不过用来讲解类型支持还是不错的。我们给`x`和`y`各添加一个`number`类型，然后发现报错了：不能给`string`类型的参数指定`number`类型。\n\n![](/css/images/223.jpg)\n\n这太基础了！不过，事实上我们可以通过类型支持做更多的事情！你可以使用主要的几种类型：`string`、`number`、`boolean`、`Array`，还可以使用`any`表示任何类型。不过，真正很酷的是，你可以自定义类型。我们来看几个例子：\n\n![](/css/images/224.jpg)\n\n上述例子中，`name`是`string`类型，`age`是`number`类型，`isEnabled`是`boolean`类型，不过注意`accessories`，这是联合类型（Union Type），你可以给它传递`string`类型，也可以给它传递每项为`string`的数组，在一些特别的场景下，比如：如果你编写了一个可重用的组件，并想非常灵活地使用它！这时候你可能会使用联合类型。最下面那个是自定义类型，我非常喜欢它！它在Angular 2框架中被重度使用！不过，我们等会再讲解它。\n\n那么为何要使用类型？比如在写ng2组件时，你想通过`add`方法更新`total`，你将会知道正确的方法是什么（指的就是参数类型均为`number`）。\n![](/css/images/225.jpg)\n\n很明显，这是个非常简单的例子。让我们来聊点更有用的特性！\n\n## 工具支持（Tooling Support）\n\nTypeScript中有个很酷的特性就是工具支持，因为我们可以以此明确数据类型。比如，调用Promise去获取数据，想知道得到了什么？ 你得去查看JSON的格式，这在TypeScript神奇的智能提示的帮助下（很多编辑器都支持TypeScript的智能提示，比如Webstorm、VSC、Atom等）会变得非常容易。我要给你展示的例子返回了一个Obserable。当我输入`response.`时，编辑器弹出了非常非常明确的信息，来告诉我该数据的结构信息。\n\n![](/css/images/226.jpg)\n\n让我们总结下工具支持的几个主要特性：\n\n1. 代码帮助提示（Code Help/ Intellisense）：真的非常nice。\n2. 重构（Refactoring）：很牛，比如全局搜索替换。\n3. 窥视／跳转（Peek/Go To）：比如，我们可以了解一个对象中有什么，可以从中得到什么，得益于类型，我们可以获取更多的信息。\n4. 查找引用（Find References）：比如，查找多少人引用了某个特定方法。\n\n接下来，我们来看下编辑器。这是个名叫`dataService`的服务（Service，Angular2中的概念）。注意看`getCustomers`方法，我们假设它会返回一个Observable，我输入`this.http.`，结果得到了非常友好的帮助提示。\n\n![](/css/images/227.jpg)\n\n但真正酷的是，如果我想知道HTTP里都有啥，我可以选择“Peek Definition”，然后就跳转到了定义特定类型的位置，于是我又得到了一些有用信息。\n\n![](/css/images/228.jpg)\n\n我还可以知道有多少人调用了getCustomers这个方法，只需要点击“Find All References”即可。\n\n![](/css/images/229.jpg)\n\n\n## 接口（Interfaces）\n\n让我们来聊下接口吧，这是TypeScript的另一个秘密武器。接口是个非常棒的技术，在JavaScript中无法直接使用它，但在TypeScript中却可以。接口在ng2里被重度使用。如果你第一次接触接口，我会通过代码合约（Code Contract）这个概念来向你解释。代码合约就是说，你被告知要造一个这样的零件，而不是那样的零件。\n\n![](/css/images/230.jpg)\n\n在开发过程中，我们经常会遇到一个情况，就是开发者开发完的成品并不是我们想要的。通过接口，我可以非常明确，你应该传递给我什么。这是个接口的例子：\n\n![](/css/images/231.jpg)\n\n我们定义了一个`ICustomer`接口，你也可以使用`class`来定义（具体细节可以参考TypeScript文档）。接下来，当我们只输入一个`firstName`时，收到了报错信息。当再输入`lastName`时，则提示合法了。\n\n![](/css/images/232.jpg)\n\n这太基础了，让我们回到刚才的代码示例。当我直接在`getCustomers`方法上输入`subsribe`时，我得到的智能提示是返回一个Observable of any，这没有任何帮助。但是，当我们在`subscribe`的参数中填写接口`ICustomer[]`后，我们得到了非常友好详细的智能提示。\n\n![](/css/images/233.jpg)\n\n接口的另一个用法是这样的。比如，你把`ngOnInit`写成了`ngoninit`，导致运行结果不对，但是却没有任何提示，这可不是什么好事，就不能给我一点提示吗？ 当然可以，我们可以导入`OnInit`这个接口 ，然后使用`implements`将其连到类上：\n\n![](/css/images/234.jpg)\n\n然后，我们就得到了错误提示。当我们将`ngoninit`改为`ngOnInit`时，错误提示就消失了，这太棒了！\n\n## 泛型（Generics）\n\n让我们继续讲解泛型这个秘密武器吧！泛型也非常好用，有人在其他语言中用过泛型吗（然后他把手放到眼上，作远眺状）？泛型是个代码模板（Code Template）。如果你家有小孩，你一定知道曲奇饼干和曲奇饼干成型机（比如图中的剑型）。假如我在用小刀刻了一些字符，比如Halloween。当刻了一两个字符之后，你说突然要换一套方案，这就难办了！所以，你应该刻一些像图中的剑型那样的东西，这样便于你复用（他的这个例子举得不太好，不过大家只需关注“模板”和“复用”这两个关键词即可，因为这也是泛型的特点）。\n\n![](/css/images/235.jpg)\n\n泛型能以多种方式被使用，其中一种方式是，如果你有一个`class`，需要支持多种类型，比如有时候我需要`number`，有时候需要`string`，有时候需要数组，那么泛型将会大显身手！在这个例子中（如图），我们想写一个某种数据类型（用`T`表示）的列表，请注意`add`这个方法，它也是模板的一部分。然后使用它的方法就像这样，你可以写`new List<ICustomer>()`，当然`ICustomer`是本例的选择，你可以写`number`、`string`等任何类型，然后非常灵活方便地复用它们。回到编辑器中，写一个`add`方法，当我还没有写完`firstName`和`lastName`时，编辑器会报错，写完后，错误提示消失。另外，当我们`add`一个`205`时，编辑也会报错。\n\n![](/css/images/236.jpg)\n\n让我们回到`dataService`这个例子吧！当我在`getCustomers`这个方法后面输入`subscribe`，它只提示返回一个Observable of all，这不是一个好的智能提示。不过，当我在`getCustomers`方法后面加上`Observable<Icustomer[]>`后，就会改善很多！再次在在`getCustomers`这个方法后面输入`subscribe`，它提示返回了一个Observable of ICustomer[]，非常非常酷。而且，即便当你将`subscribe`中的参数类型去掉，里面的数据仍然会有非常明显的智能提示（输错字符会报错）。\n\n![](/css/images/237.jpg)\n\n![](/css/images/238.jpg)\n\n## 提前使用未来特性（The Future Today）\n\n最后一个秘密武器是提前使用未来特性。JavaScript现今以每年的频率来发布新特性，但是浏览器不能完全支持它们。所以我认为我们一直处于一个“举债经营”的模式，比如使用Typescript。因为我们不想用最低版本的JavaScript，而是想用一些新特性。我们已经在Angular2中做了这些事情，比如使用装饰器（Decorators），我们用装饰器编写组件或Injectable等。还可以使用一些未来的特性，比如async/await（一种新的处理异步的方式）等。\n\n![](/css/images/239.jpg)\n\n## 回顾\n\n让我们做个回顾吧！我们讲解了TypeScript的这几个方面：类型支持、工具支持、接口、泛型以及提前使用未来特性。\n\n![](/css/images/240.jpg)\n\n很感谢你们听我的演讲，希望你们可以用TypeScript编写App，谢谢！\n\n---\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n","source":"_posts/typescript-angular2-secret-weapon.md","raw":"---\ntitle: \"TypeScript: Angular 2 的秘密武器（译）\"\ndate: 2016-12-24 03:24:00\ntags: [技术讲座, TypeScript, Angular2]\n---\n\n本文整理自Dan Wahlin在ng-conf上的talk。原视频地址：\n\nhttps://www.youtube.com/watch?v=e3djIqAGqZo\n\n/css/images/221.jpg\n\n<!--more-->\n\n## 开场白\n\n开场白主要分为三部分：\n\n- 感谢了ng-conf的组织者。\n- 阐述了TypeScript是JavaScript的超集，并不是另外一种语言。\n- 引用了他的两个朋友最喜欢的TypeScript特性。\n\n由于开场白内容不太重要，所以不再详述。下面开始讲解Dan Wahlin最喜欢的TypeScript的特性。\n\n## 类型支持（Type Support）\n\n让我们来聊下类型支持吧！先打开[TypeScript Playground](https://www.typescriptlang.org/play/)，我们会看到一个非常简单的例子。\n\n![](/css/images/222.jpg)\n\n\n左边是TypeScript，右边是编译后的JavaScript，它俩差异很大吗？并不是，呵呵！不过用来讲解类型支持还是不错的。我们给`x`和`y`各添加一个`number`类型，然后发现报错了：不能给`string`类型的参数指定`number`类型。\n\n![](/css/images/223.jpg)\n\n这太基础了！不过，事实上我们可以通过类型支持做更多的事情！你可以使用主要的几种类型：`string`、`number`、`boolean`、`Array`，还可以使用`any`表示任何类型。不过，真正很酷的是，你可以自定义类型。我们来看几个例子：\n\n![](/css/images/224.jpg)\n\n上述例子中，`name`是`string`类型，`age`是`number`类型，`isEnabled`是`boolean`类型，不过注意`accessories`，这是联合类型（Union Type），你可以给它传递`string`类型，也可以给它传递每项为`string`的数组，在一些特别的场景下，比如：如果你编写了一个可重用的组件，并想非常灵活地使用它！这时候你可能会使用联合类型。最下面那个是自定义类型，我非常喜欢它！它在Angular 2框架中被重度使用！不过，我们等会再讲解它。\n\n那么为何要使用类型？比如在写ng2组件时，你想通过`add`方法更新`total`，你将会知道正确的方法是什么（指的就是参数类型均为`number`）。\n![](/css/images/225.jpg)\n\n很明显，这是个非常简单的例子。让我们来聊点更有用的特性！\n\n## 工具支持（Tooling Support）\n\nTypeScript中有个很酷的特性就是工具支持，因为我们可以以此明确数据类型。比如，调用Promise去获取数据，想知道得到了什么？ 你得去查看JSON的格式，这在TypeScript神奇的智能提示的帮助下（很多编辑器都支持TypeScript的智能提示，比如Webstorm、VSC、Atom等）会变得非常容易。我要给你展示的例子返回了一个Obserable。当我输入`response.`时，编辑器弹出了非常非常明确的信息，来告诉我该数据的结构信息。\n\n![](/css/images/226.jpg)\n\n让我们总结下工具支持的几个主要特性：\n\n1. 代码帮助提示（Code Help/ Intellisense）：真的非常nice。\n2. 重构（Refactoring）：很牛，比如全局搜索替换。\n3. 窥视／跳转（Peek/Go To）：比如，我们可以了解一个对象中有什么，可以从中得到什么，得益于类型，我们可以获取更多的信息。\n4. 查找引用（Find References）：比如，查找多少人引用了某个特定方法。\n\n接下来，我们来看下编辑器。这是个名叫`dataService`的服务（Service，Angular2中的概念）。注意看`getCustomers`方法，我们假设它会返回一个Observable，我输入`this.http.`，结果得到了非常友好的帮助提示。\n\n![](/css/images/227.jpg)\n\n但真正酷的是，如果我想知道HTTP里都有啥，我可以选择“Peek Definition”，然后就跳转到了定义特定类型的位置，于是我又得到了一些有用信息。\n\n![](/css/images/228.jpg)\n\n我还可以知道有多少人调用了getCustomers这个方法，只需要点击“Find All References”即可。\n\n![](/css/images/229.jpg)\n\n\n## 接口（Interfaces）\n\n让我们来聊下接口吧，这是TypeScript的另一个秘密武器。接口是个非常棒的技术，在JavaScript中无法直接使用它，但在TypeScript中却可以。接口在ng2里被重度使用。如果你第一次接触接口，我会通过代码合约（Code Contract）这个概念来向你解释。代码合约就是说，你被告知要造一个这样的零件，而不是那样的零件。\n\n![](/css/images/230.jpg)\n\n在开发过程中，我们经常会遇到一个情况，就是开发者开发完的成品并不是我们想要的。通过接口，我可以非常明确，你应该传递给我什么。这是个接口的例子：\n\n![](/css/images/231.jpg)\n\n我们定义了一个`ICustomer`接口，你也可以使用`class`来定义（具体细节可以参考TypeScript文档）。接下来，当我们只输入一个`firstName`时，收到了报错信息。当再输入`lastName`时，则提示合法了。\n\n![](/css/images/232.jpg)\n\n这太基础了，让我们回到刚才的代码示例。当我直接在`getCustomers`方法上输入`subsribe`时，我得到的智能提示是返回一个Observable of any，这没有任何帮助。但是，当我们在`subscribe`的参数中填写接口`ICustomer[]`后，我们得到了非常友好详细的智能提示。\n\n![](/css/images/233.jpg)\n\n接口的另一个用法是这样的。比如，你把`ngOnInit`写成了`ngoninit`，导致运行结果不对，但是却没有任何提示，这可不是什么好事，就不能给我一点提示吗？ 当然可以，我们可以导入`OnInit`这个接口 ，然后使用`implements`将其连到类上：\n\n![](/css/images/234.jpg)\n\n然后，我们就得到了错误提示。当我们将`ngoninit`改为`ngOnInit`时，错误提示就消失了，这太棒了！\n\n## 泛型（Generics）\n\n让我们继续讲解泛型这个秘密武器吧！泛型也非常好用，有人在其他语言中用过泛型吗（然后他把手放到眼上，作远眺状）？泛型是个代码模板（Code Template）。如果你家有小孩，你一定知道曲奇饼干和曲奇饼干成型机（比如图中的剑型）。假如我在用小刀刻了一些字符，比如Halloween。当刻了一两个字符之后，你说突然要换一套方案，这就难办了！所以，你应该刻一些像图中的剑型那样的东西，这样便于你复用（他的这个例子举得不太好，不过大家只需关注“模板”和“复用”这两个关键词即可，因为这也是泛型的特点）。\n\n![](/css/images/235.jpg)\n\n泛型能以多种方式被使用，其中一种方式是，如果你有一个`class`，需要支持多种类型，比如有时候我需要`number`，有时候需要`string`，有时候需要数组，那么泛型将会大显身手！在这个例子中（如图），我们想写一个某种数据类型（用`T`表示）的列表，请注意`add`这个方法，它也是模板的一部分。然后使用它的方法就像这样，你可以写`new List<ICustomer>()`，当然`ICustomer`是本例的选择，你可以写`number`、`string`等任何类型，然后非常灵活方便地复用它们。回到编辑器中，写一个`add`方法，当我还没有写完`firstName`和`lastName`时，编辑器会报错，写完后，错误提示消失。另外，当我们`add`一个`205`时，编辑也会报错。\n\n![](/css/images/236.jpg)\n\n让我们回到`dataService`这个例子吧！当我在`getCustomers`这个方法后面输入`subscribe`，它只提示返回一个Observable of all，这不是一个好的智能提示。不过，当我在`getCustomers`方法后面加上`Observable<Icustomer[]>`后，就会改善很多！再次在在`getCustomers`这个方法后面输入`subscribe`，它提示返回了一个Observable of ICustomer[]，非常非常酷。而且，即便当你将`subscribe`中的参数类型去掉，里面的数据仍然会有非常明显的智能提示（输错字符会报错）。\n\n![](/css/images/237.jpg)\n\n![](/css/images/238.jpg)\n\n## 提前使用未来特性（The Future Today）\n\n最后一个秘密武器是提前使用未来特性。JavaScript现今以每年的频率来发布新特性，但是浏览器不能完全支持它们。所以我认为我们一直处于一个“举债经营”的模式，比如使用Typescript。因为我们不想用最低版本的JavaScript，而是想用一些新特性。我们已经在Angular2中做了这些事情，比如使用装饰器（Decorators），我们用装饰器编写组件或Injectable等。还可以使用一些未来的特性，比如async/await（一种新的处理异步的方式）等。\n\n![](/css/images/239.jpg)\n\n## 回顾\n\n让我们做个回顾吧！我们讲解了TypeScript的这几个方面：类型支持、工具支持、接口、泛型以及提前使用未来特性。\n\n![](/css/images/240.jpg)\n\n很感谢你们听我的演讲，希望你们可以用TypeScript编写App，谢谢！\n\n---\n\n## 教程示例代码及目录\n\n示例代码：<https://github.com/lewis617/angular2-tutorial>\n\n目录：<http://www.liuyiqi.cn/tags/Angular2/>\n","slug":"typescript-angular2-secret-weapon","published":1,"updated":"2019-05-01T08:10:30.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvn4003stgytahs38doa","content":"<p>本文整理自Dan Wahlin在ng-conf上的talk。原视频地址：</p>\n<p><a href=\"https://www.youtube.com/watch?v=e3djIqAGqZo\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=e3djIqAGqZo</a></p>\n<p>/css/images/221.jpg</p>\n<a id=\"more\"></a>\n<h2 id=\"开场白\"><a href=\"#开场白\" class=\"headerlink\" title=\"开场白\"></a>开场白</h2><p>开场白主要分为三部分：</p>\n<ul>\n<li>感谢了ng-conf的组织者。</li>\n<li>阐述了TypeScript是JavaScript的超集，并不是另外一种语言。</li>\n<li>引用了他的两个朋友最喜欢的TypeScript特性。</li>\n</ul>\n<p>由于开场白内容不太重要，所以不再详述。下面开始讲解Dan Wahlin最喜欢的TypeScript的特性。</p>\n<h2 id=\"类型支持（Type-Support）\"><a href=\"#类型支持（Type-Support）\" class=\"headerlink\" title=\"类型支持（Type Support）\"></a>类型支持（Type Support）</h2><p>让我们来聊下类型支持吧！先打开<a href=\"https://www.typescriptlang.org/play/\" target=\"_blank\" rel=\"noopener\">TypeScript Playground</a>，我们会看到一个非常简单的例子。</p>\n<p><img src=\"/css/images/222.jpg\" alt=\"\"></p>\n<p>左边是TypeScript，右边是编译后的JavaScript，它俩差异很大吗？并不是，呵呵！不过用来讲解类型支持还是不错的。我们给<code>x</code>和<code>y</code>各添加一个<code>number</code>类型，然后发现报错了：不能给<code>string</code>类型的参数指定<code>number</code>类型。</p>\n<p><img src=\"/css/images/223.jpg\" alt=\"\"></p>\n<p>这太基础了！不过，事实上我们可以通过类型支持做更多的事情！你可以使用主要的几种类型：<code>string</code>、<code>number</code>、<code>boolean</code>、<code>Array</code>，还可以使用<code>any</code>表示任何类型。不过，真正很酷的是，你可以自定义类型。我们来看几个例子：</p>\n<p><img src=\"/css/images/224.jpg\" alt=\"\"></p>\n<p>上述例子中，<code>name</code>是<code>string</code>类型，<code>age</code>是<code>number</code>类型，<code>isEnabled</code>是<code>boolean</code>类型，不过注意<code>accessories</code>，这是联合类型（Union Type），你可以给它传递<code>string</code>类型，也可以给它传递每项为<code>string</code>的数组，在一些特别的场景下，比如：如果你编写了一个可重用的组件，并想非常灵活地使用它！这时候你可能会使用联合类型。最下面那个是自定义类型，我非常喜欢它！它在Angular 2框架中被重度使用！不过，我们等会再讲解它。</p>\n<p>那么为何要使用类型？比如在写ng2组件时，你想通过<code>add</code>方法更新<code>total</code>，你将会知道正确的方法是什么（指的就是参数类型均为<code>number</code>）。<br><img src=\"/css/images/225.jpg\" alt=\"\"></p>\n<p>很明显，这是个非常简单的例子。让我们来聊点更有用的特性！</p>\n<h2 id=\"工具支持（Tooling-Support）\"><a href=\"#工具支持（Tooling-Support）\" class=\"headerlink\" title=\"工具支持（Tooling Support）\"></a>工具支持（Tooling Support）</h2><p>TypeScript中有个很酷的特性就是工具支持，因为我们可以以此明确数据类型。比如，调用Promise去获取数据，想知道得到了什么？ 你得去查看JSON的格式，这在TypeScript神奇的智能提示的帮助下（很多编辑器都支持TypeScript的智能提示，比如Webstorm、VSC、Atom等）会变得非常容易。我要给你展示的例子返回了一个Obserable。当我输入<code>response.</code>时，编辑器弹出了非常非常明确的信息，来告诉我该数据的结构信息。</p>\n<p><img src=\"/css/images/226.jpg\" alt=\"\"></p>\n<p>让我们总结下工具支持的几个主要特性：</p>\n<ol>\n<li>代码帮助提示（Code Help/ Intellisense）：真的非常nice。</li>\n<li>重构（Refactoring）：很牛，比如全局搜索替换。</li>\n<li>窥视／跳转（Peek/Go To）：比如，我们可以了解一个对象中有什么，可以从中得到什么，得益于类型，我们可以获取更多的信息。</li>\n<li>查找引用（Find References）：比如，查找多少人引用了某个特定方法。</li>\n</ol>\n<p>接下来，我们来看下编辑器。这是个名叫<code>dataService</code>的服务（Service，Angular2中的概念）。注意看<code>getCustomers</code>方法，我们假设它会返回一个Observable，我输入<code>this.http.</code>，结果得到了非常友好的帮助提示。</p>\n<p><img src=\"/css/images/227.jpg\" alt=\"\"></p>\n<p>但真正酷的是，如果我想知道HTTP里都有啥，我可以选择“Peek Definition”，然后就跳转到了定义特定类型的位置，于是我又得到了一些有用信息。</p>\n<p><img src=\"/css/images/228.jpg\" alt=\"\"></p>\n<p>我还可以知道有多少人调用了getCustomers这个方法，只需要点击“Find All References”即可。</p>\n<p><img src=\"/css/images/229.jpg\" alt=\"\"></p>\n<h2 id=\"接口（Interfaces）\"><a href=\"#接口（Interfaces）\" class=\"headerlink\" title=\"接口（Interfaces）\"></a>接口（Interfaces）</h2><p>让我们来聊下接口吧，这是TypeScript的另一个秘密武器。接口是个非常棒的技术，在JavaScript中无法直接使用它，但在TypeScript中却可以。接口在ng2里被重度使用。如果你第一次接触接口，我会通过代码合约（Code Contract）这个概念来向你解释。代码合约就是说，你被告知要造一个这样的零件，而不是那样的零件。</p>\n<p><img src=\"/css/images/230.jpg\" alt=\"\"></p>\n<p>在开发过程中，我们经常会遇到一个情况，就是开发者开发完的成品并不是我们想要的。通过接口，我可以非常明确，你应该传递给我什么。这是个接口的例子：</p>\n<p><img src=\"/css/images/231.jpg\" alt=\"\"></p>\n<p>我们定义了一个<code>ICustomer</code>接口，你也可以使用<code>class</code>来定义（具体细节可以参考TypeScript文档）。接下来，当我们只输入一个<code>firstName</code>时，收到了报错信息。当再输入<code>lastName</code>时，则提示合法了。</p>\n<p><img src=\"/css/images/232.jpg\" alt=\"\"></p>\n<p>这太基础了，让我们回到刚才的代码示例。当我直接在<code>getCustomers</code>方法上输入<code>subsribe</code>时，我得到的智能提示是返回一个Observable of any，这没有任何帮助。但是，当我们在<code>subscribe</code>的参数中填写接口<code>ICustomer[]</code>后，我们得到了非常友好详细的智能提示。</p>\n<p><img src=\"/css/images/233.jpg\" alt=\"\"></p>\n<p>接口的另一个用法是这样的。比如，你把<code>ngOnInit</code>写成了<code>ngoninit</code>，导致运行结果不对，但是却没有任何提示，这可不是什么好事，就不能给我一点提示吗？ 当然可以，我们可以导入<code>OnInit</code>这个接口 ，然后使用<code>implements</code>将其连到类上：</p>\n<p><img src=\"/css/images/234.jpg\" alt=\"\"></p>\n<p>然后，我们就得到了错误提示。当我们将<code>ngoninit</code>改为<code>ngOnInit</code>时，错误提示就消失了，这太棒了！</p>\n<h2 id=\"泛型（Generics）\"><a href=\"#泛型（Generics）\" class=\"headerlink\" title=\"泛型（Generics）\"></a>泛型（Generics）</h2><p>让我们继续讲解泛型这个秘密武器吧！泛型也非常好用，有人在其他语言中用过泛型吗（然后他把手放到眼上，作远眺状）？泛型是个代码模板（Code Template）。如果你家有小孩，你一定知道曲奇饼干和曲奇饼干成型机（比如图中的剑型）。假如我在用小刀刻了一些字符，比如Halloween。当刻了一两个字符之后，你说突然要换一套方案，这就难办了！所以，你应该刻一些像图中的剑型那样的东西，这样便于你复用（他的这个例子举得不太好，不过大家只需关注“模板”和“复用”这两个关键词即可，因为这也是泛型的特点）。</p>\n<p><img src=\"/css/images/235.jpg\" alt=\"\"></p>\n<p>泛型能以多种方式被使用，其中一种方式是，如果你有一个<code>class</code>，需要支持多种类型，比如有时候我需要<code>number</code>，有时候需要<code>string</code>，有时候需要数组，那么泛型将会大显身手！在这个例子中（如图），我们想写一个某种数据类型（用<code>T</code>表示）的列表，请注意<code>add</code>这个方法，它也是模板的一部分。然后使用它的方法就像这样，你可以写<code>new List&lt;ICustomer&gt;()</code>，当然<code>ICustomer</code>是本例的选择，你可以写<code>number</code>、<code>string</code>等任何类型，然后非常灵活方便地复用它们。回到编辑器中，写一个<code>add</code>方法，当我还没有写完<code>firstName</code>和<code>lastName</code>时，编辑器会报错，写完后，错误提示消失。另外，当我们<code>add</code>一个<code>205</code>时，编辑也会报错。</p>\n<p><img src=\"/css/images/236.jpg\" alt=\"\"></p>\n<p>让我们回到<code>dataService</code>这个例子吧！当我在<code>getCustomers</code>这个方法后面输入<code>subscribe</code>，它只提示返回一个Observable of all，这不是一个好的智能提示。不过，当我在<code>getCustomers</code>方法后面加上<code>Observable&lt;Icustomer[]&gt;</code>后，就会改善很多！再次在在<code>getCustomers</code>这个方法后面输入<code>subscribe</code>，它提示返回了一个Observable of ICustomer[]，非常非常酷。而且，即便当你将<code>subscribe</code>中的参数类型去掉，里面的数据仍然会有非常明显的智能提示（输错字符会报错）。</p>\n<p><img src=\"/css/images/237.jpg\" alt=\"\"></p>\n<p><img src=\"/css/images/238.jpg\" alt=\"\"></p>\n<h2 id=\"提前使用未来特性（The-Future-Today）\"><a href=\"#提前使用未来特性（The-Future-Today）\" class=\"headerlink\" title=\"提前使用未来特性（The Future Today）\"></a>提前使用未来特性（The Future Today）</h2><p>最后一个秘密武器是提前使用未来特性。JavaScript现今以每年的频率来发布新特性，但是浏览器不能完全支持它们。所以我认为我们一直处于一个“举债经营”的模式，比如使用Typescript。因为我们不想用最低版本的JavaScript，而是想用一些新特性。我们已经在Angular2中做了这些事情，比如使用装饰器（Decorators），我们用装饰器编写组件或Injectable等。还可以使用一些未来的特性，比如async/await（一种新的处理异步的方式）等。</p>\n<p><img src=\"/css/images/239.jpg\" alt=\"\"></p>\n<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>让我们做个回顾吧！我们讲解了TypeScript的这几个方面：类型支持、工具支持、接口、泛型以及提前使用未来特性。</p>\n<p><img src=\"/css/images/240.jpg\" alt=\"\"></p>\n<p>很感谢你们听我的演讲，希望你们可以用TypeScript编写App，谢谢！</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>\n","site":{"data":{}},"excerpt":"<p>本文整理自Dan Wahlin在ng-conf上的talk。原视频地址：</p>\n<p><a href=\"https://www.youtube.com/watch?v=e3djIqAGqZo\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=e3djIqAGqZo</a></p>\n<p>/css/images/221.jpg</p>","more":"<h2 id=\"开场白\"><a href=\"#开场白\" class=\"headerlink\" title=\"开场白\"></a>开场白</h2><p>开场白主要分为三部分：</p>\n<ul>\n<li>感谢了ng-conf的组织者。</li>\n<li>阐述了TypeScript是JavaScript的超集，并不是另外一种语言。</li>\n<li>引用了他的两个朋友最喜欢的TypeScript特性。</li>\n</ul>\n<p>由于开场白内容不太重要，所以不再详述。下面开始讲解Dan Wahlin最喜欢的TypeScript的特性。</p>\n<h2 id=\"类型支持（Type-Support）\"><a href=\"#类型支持（Type-Support）\" class=\"headerlink\" title=\"类型支持（Type Support）\"></a>类型支持（Type Support）</h2><p>让我们来聊下类型支持吧！先打开<a href=\"https://www.typescriptlang.org/play/\" target=\"_blank\" rel=\"noopener\">TypeScript Playground</a>，我们会看到一个非常简单的例子。</p>\n<p><img src=\"/css/images/222.jpg\" alt=\"\"></p>\n<p>左边是TypeScript，右边是编译后的JavaScript，它俩差异很大吗？并不是，呵呵！不过用来讲解类型支持还是不错的。我们给<code>x</code>和<code>y</code>各添加一个<code>number</code>类型，然后发现报错了：不能给<code>string</code>类型的参数指定<code>number</code>类型。</p>\n<p><img src=\"/css/images/223.jpg\" alt=\"\"></p>\n<p>这太基础了！不过，事实上我们可以通过类型支持做更多的事情！你可以使用主要的几种类型：<code>string</code>、<code>number</code>、<code>boolean</code>、<code>Array</code>，还可以使用<code>any</code>表示任何类型。不过，真正很酷的是，你可以自定义类型。我们来看几个例子：</p>\n<p><img src=\"/css/images/224.jpg\" alt=\"\"></p>\n<p>上述例子中，<code>name</code>是<code>string</code>类型，<code>age</code>是<code>number</code>类型，<code>isEnabled</code>是<code>boolean</code>类型，不过注意<code>accessories</code>，这是联合类型（Union Type），你可以给它传递<code>string</code>类型，也可以给它传递每项为<code>string</code>的数组，在一些特别的场景下，比如：如果你编写了一个可重用的组件，并想非常灵活地使用它！这时候你可能会使用联合类型。最下面那个是自定义类型，我非常喜欢它！它在Angular 2框架中被重度使用！不过，我们等会再讲解它。</p>\n<p>那么为何要使用类型？比如在写ng2组件时，你想通过<code>add</code>方法更新<code>total</code>，你将会知道正确的方法是什么（指的就是参数类型均为<code>number</code>）。<br><img src=\"/css/images/225.jpg\" alt=\"\"></p>\n<p>很明显，这是个非常简单的例子。让我们来聊点更有用的特性！</p>\n<h2 id=\"工具支持（Tooling-Support）\"><a href=\"#工具支持（Tooling-Support）\" class=\"headerlink\" title=\"工具支持（Tooling Support）\"></a>工具支持（Tooling Support）</h2><p>TypeScript中有个很酷的特性就是工具支持，因为我们可以以此明确数据类型。比如，调用Promise去获取数据，想知道得到了什么？ 你得去查看JSON的格式，这在TypeScript神奇的智能提示的帮助下（很多编辑器都支持TypeScript的智能提示，比如Webstorm、VSC、Atom等）会变得非常容易。我要给你展示的例子返回了一个Obserable。当我输入<code>response.</code>时，编辑器弹出了非常非常明确的信息，来告诉我该数据的结构信息。</p>\n<p><img src=\"/css/images/226.jpg\" alt=\"\"></p>\n<p>让我们总结下工具支持的几个主要特性：</p>\n<ol>\n<li>代码帮助提示（Code Help/ Intellisense）：真的非常nice。</li>\n<li>重构（Refactoring）：很牛，比如全局搜索替换。</li>\n<li>窥视／跳转（Peek/Go To）：比如，我们可以了解一个对象中有什么，可以从中得到什么，得益于类型，我们可以获取更多的信息。</li>\n<li>查找引用（Find References）：比如，查找多少人引用了某个特定方法。</li>\n</ol>\n<p>接下来，我们来看下编辑器。这是个名叫<code>dataService</code>的服务（Service，Angular2中的概念）。注意看<code>getCustomers</code>方法，我们假设它会返回一个Observable，我输入<code>this.http.</code>，结果得到了非常友好的帮助提示。</p>\n<p><img src=\"/css/images/227.jpg\" alt=\"\"></p>\n<p>但真正酷的是，如果我想知道HTTP里都有啥，我可以选择“Peek Definition”，然后就跳转到了定义特定类型的位置，于是我又得到了一些有用信息。</p>\n<p><img src=\"/css/images/228.jpg\" alt=\"\"></p>\n<p>我还可以知道有多少人调用了getCustomers这个方法，只需要点击“Find All References”即可。</p>\n<p><img src=\"/css/images/229.jpg\" alt=\"\"></p>\n<h2 id=\"接口（Interfaces）\"><a href=\"#接口（Interfaces）\" class=\"headerlink\" title=\"接口（Interfaces）\"></a>接口（Interfaces）</h2><p>让我们来聊下接口吧，这是TypeScript的另一个秘密武器。接口是个非常棒的技术，在JavaScript中无法直接使用它，但在TypeScript中却可以。接口在ng2里被重度使用。如果你第一次接触接口，我会通过代码合约（Code Contract）这个概念来向你解释。代码合约就是说，你被告知要造一个这样的零件，而不是那样的零件。</p>\n<p><img src=\"/css/images/230.jpg\" alt=\"\"></p>\n<p>在开发过程中，我们经常会遇到一个情况，就是开发者开发完的成品并不是我们想要的。通过接口，我可以非常明确，你应该传递给我什么。这是个接口的例子：</p>\n<p><img src=\"/css/images/231.jpg\" alt=\"\"></p>\n<p>我们定义了一个<code>ICustomer</code>接口，你也可以使用<code>class</code>来定义（具体细节可以参考TypeScript文档）。接下来，当我们只输入一个<code>firstName</code>时，收到了报错信息。当再输入<code>lastName</code>时，则提示合法了。</p>\n<p><img src=\"/css/images/232.jpg\" alt=\"\"></p>\n<p>这太基础了，让我们回到刚才的代码示例。当我直接在<code>getCustomers</code>方法上输入<code>subsribe</code>时，我得到的智能提示是返回一个Observable of any，这没有任何帮助。但是，当我们在<code>subscribe</code>的参数中填写接口<code>ICustomer[]</code>后，我们得到了非常友好详细的智能提示。</p>\n<p><img src=\"/css/images/233.jpg\" alt=\"\"></p>\n<p>接口的另一个用法是这样的。比如，你把<code>ngOnInit</code>写成了<code>ngoninit</code>，导致运行结果不对，但是却没有任何提示，这可不是什么好事，就不能给我一点提示吗？ 当然可以，我们可以导入<code>OnInit</code>这个接口 ，然后使用<code>implements</code>将其连到类上：</p>\n<p><img src=\"/css/images/234.jpg\" alt=\"\"></p>\n<p>然后，我们就得到了错误提示。当我们将<code>ngoninit</code>改为<code>ngOnInit</code>时，错误提示就消失了，这太棒了！</p>\n<h2 id=\"泛型（Generics）\"><a href=\"#泛型（Generics）\" class=\"headerlink\" title=\"泛型（Generics）\"></a>泛型（Generics）</h2><p>让我们继续讲解泛型这个秘密武器吧！泛型也非常好用，有人在其他语言中用过泛型吗（然后他把手放到眼上，作远眺状）？泛型是个代码模板（Code Template）。如果你家有小孩，你一定知道曲奇饼干和曲奇饼干成型机（比如图中的剑型）。假如我在用小刀刻了一些字符，比如Halloween。当刻了一两个字符之后，你说突然要换一套方案，这就难办了！所以，你应该刻一些像图中的剑型那样的东西，这样便于你复用（他的这个例子举得不太好，不过大家只需关注“模板”和“复用”这两个关键词即可，因为这也是泛型的特点）。</p>\n<p><img src=\"/css/images/235.jpg\" alt=\"\"></p>\n<p>泛型能以多种方式被使用，其中一种方式是，如果你有一个<code>class</code>，需要支持多种类型，比如有时候我需要<code>number</code>，有时候需要<code>string</code>，有时候需要数组，那么泛型将会大显身手！在这个例子中（如图），我们想写一个某种数据类型（用<code>T</code>表示）的列表，请注意<code>add</code>这个方法，它也是模板的一部分。然后使用它的方法就像这样，你可以写<code>new List&lt;ICustomer&gt;()</code>，当然<code>ICustomer</code>是本例的选择，你可以写<code>number</code>、<code>string</code>等任何类型，然后非常灵活方便地复用它们。回到编辑器中，写一个<code>add</code>方法，当我还没有写完<code>firstName</code>和<code>lastName</code>时，编辑器会报错，写完后，错误提示消失。另外，当我们<code>add</code>一个<code>205</code>时，编辑也会报错。</p>\n<p><img src=\"/css/images/236.jpg\" alt=\"\"></p>\n<p>让我们回到<code>dataService</code>这个例子吧！当我在<code>getCustomers</code>这个方法后面输入<code>subscribe</code>，它只提示返回一个Observable of all，这不是一个好的智能提示。不过，当我在<code>getCustomers</code>方法后面加上<code>Observable&lt;Icustomer[]&gt;</code>后，就会改善很多！再次在在<code>getCustomers</code>这个方法后面输入<code>subscribe</code>，它提示返回了一个Observable of ICustomer[]，非常非常酷。而且，即便当你将<code>subscribe</code>中的参数类型去掉，里面的数据仍然会有非常明显的智能提示（输错字符会报错）。</p>\n<p><img src=\"/css/images/237.jpg\" alt=\"\"></p>\n<p><img src=\"/css/images/238.jpg\" alt=\"\"></p>\n<h2 id=\"提前使用未来特性（The-Future-Today）\"><a href=\"#提前使用未来特性（The-Future-Today）\" class=\"headerlink\" title=\"提前使用未来特性（The Future Today）\"></a>提前使用未来特性（The Future Today）</h2><p>最后一个秘密武器是提前使用未来特性。JavaScript现今以每年的频率来发布新特性，但是浏览器不能完全支持它们。所以我认为我们一直处于一个“举债经营”的模式，比如使用Typescript。因为我们不想用最低版本的JavaScript，而是想用一些新特性。我们已经在Angular2中做了这些事情，比如使用装饰器（Decorators），我们用装饰器编写组件或Injectable等。还可以使用一些未来的特性，比如async/await（一种新的处理异步的方式）等。</p>\n<p><img src=\"/css/images/239.jpg\" alt=\"\"></p>\n<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>让我们做个回顾吧！我们讲解了TypeScript的这几个方面：类型支持、工具支持、接口、泛型以及提前使用未来特性。</p>\n<p><img src=\"/css/images/240.jpg\" alt=\"\"></p>\n<p>很感谢你们听我的演讲，希望你们可以用TypeScript编写App，谢谢！</p>\n<hr>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p>示例代码：<a href=\"https://github.com/lewis617/angular2-tutorial\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/angular2-tutorial</a></p>\n<p>目录：<a href=\"http://www.liuyiqi.cn/tags/Angular2/\">http://www.liuyiqi.cn/tags/Angular2/</a></p>"},{"title":"使用 JavaScript 批量获取微博评论","date":"2017-11-03T02:36:00.000Z","_content":"\n今天，我们要讲的是如何用 JavaScript 批量获取微博评论。如果你想备份或者\b转移某个微博页面的评论内容，那么本博客对你而言，将会非常实用。\n\n你可以在这里获取源代码：\n\n<https://github.com/lewis617/practical-node/blob/master/src/weiboBackup.js>\n\n<!--more-->\n\n## 示例代码\n\n本文的示例代码非常简单，只有寥寥几行：\n\n```js\n/**\n * 获取微博以及评论文字\n * 先打开微博页面，\n * 然后将下面的js拷贝到浏览器的console面板中\n */\n\nvar nodeArray = Array.from(document.querySelectorAll('.list_con .WB_text'));\n\nvar textArray = nodeArray.map(function (node) {\n  return Array.from(node.childNodes).map(function (childNode) {\n    var value;\n    // 文字的情况\n    if (childNode.nodeName === '#text') value = childNode.nodeValue;\n    // 图片表情的情况\n    else if (childNode.nodeName === 'IMG') value = childNode.alt;\n    // 链接的情况\n    else if (childNode.nodeName === 'A') value = childNode.lastChild.nodeValue;\n    return value.replace(/(\\s+$)|(^\\s+)/g, '');\n  }).join('');\n});\n\nconsole.log(textArray.join('\\n'));\n```\n\n是不是很短很开心？接下来我们来看下这几行 JavaScript 代码的使用方法。\n\n## 使用方法\n\n使用上述代码的方法非常\b简单，只需要：\n\n1，打开微博页面，比如：<http://www.weibo.com/2207255374/Eqkmf0pL4>\n\n![](/css/images/241.jpg)\n\n我们可以看到一共有三条评论。\n\n2，然后将上述 \bJavaScript 代码拷贝到浏览器的 console 面板中，并按回车键。结果打印了：\n\n```\nGeo橙子：在过一阵子是不是要翻成英文，走出国门了\ndev_zk：现在好了[太开心][太开心]\ndev_zk：哈哈\n```\n\n每条评论单独占一行，完美。\n\n## 知识点解析\n\n\n首先，我们获取评论的节点并将其转换为数组。这里使用了 [Array.from](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) 和 [document.querySelectorAll](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll) 两个方法。后者返回符合选择器的所有节点，但格式为 [NodeList](https://developer.mozilla.org/en-US/docs/Web/API/NodeList)。前者是 ES6 的方法，将 `NodeList` 转换为普通数组。\n\n```js\nvar nodeArray = Array.from(document.querySelectorAll('.list_con .WB_text'));\n```\n\n然后，我们遍历每个评论，并将评论中的文字、图片、链接都提取出来。\b其中用到了 [nodeName](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeName)、[nodeValue](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeValue)、[lastChild](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/lastChild) 这三个 `Node` 的属性。还用了 `replace(/(\\s+$)|(^\\s+)/g, '')` 来去除首尾的空格。还使用了数组的 `join` 方法来将数组项连接成字符串。\n\n```js\nvar textArray = nodeArray.map(function (node) {\n  return Array.from(node.childNodes).map(function (childNode) {\n    var value;\n    // 文字的情况\n    if (childNode.nodeName === '#text') value = childNode.nodeValue;\n    // 图片表情的情况\n    else if (childNode.nodeName === 'IMG') value = childNode.alt;\n    // 链接的情况\n    else if (childNode.nodeName === 'A') value = childNode.lastChild.nodeValue;\n    return value.replace(/(\\s+$)|(^\\s+)/g, '');\n  }).join('');\n});\n```\n\n最后，打印评论。\n\n```js\nconsole.log(textArray.join('\\n'));\n```\n\n## 教程示例代码及目录\n\n<https://github.com/lewis617/practical-js>","source":"_posts/use-js-to-get-weibo-comments.md","raw":"---\ntitle: 使用 JavaScript 批量获取微博评论\ndate: 2017-11-03 10:36:00\ntags: [practical-js, 正则表达式]\n---\n\n今天，我们要讲的是如何用 JavaScript 批量获取微博评论。如果你想备份或者\b转移某个微博页面的评论内容，那么本博客对你而言，将会非常实用。\n\n你可以在这里获取源代码：\n\n<https://github.com/lewis617/practical-node/blob/master/src/weiboBackup.js>\n\n<!--more-->\n\n## 示例代码\n\n本文的示例代码非常简单，只有寥寥几行：\n\n```js\n/**\n * 获取微博以及评论文字\n * 先打开微博页面，\n * 然后将下面的js拷贝到浏览器的console面板中\n */\n\nvar nodeArray = Array.from(document.querySelectorAll('.list_con .WB_text'));\n\nvar textArray = nodeArray.map(function (node) {\n  return Array.from(node.childNodes).map(function (childNode) {\n    var value;\n    // 文字的情况\n    if (childNode.nodeName === '#text') value = childNode.nodeValue;\n    // 图片表情的情况\n    else if (childNode.nodeName === 'IMG') value = childNode.alt;\n    // 链接的情况\n    else if (childNode.nodeName === 'A') value = childNode.lastChild.nodeValue;\n    return value.replace(/(\\s+$)|(^\\s+)/g, '');\n  }).join('');\n});\n\nconsole.log(textArray.join('\\n'));\n```\n\n是不是很短很开心？接下来我们来看下这几行 JavaScript 代码的使用方法。\n\n## 使用方法\n\n使用上述代码的方法非常\b简单，只需要：\n\n1，打开微博页面，比如：<http://www.weibo.com/2207255374/Eqkmf0pL4>\n\n![](/css/images/241.jpg)\n\n我们可以看到一共有三条评论。\n\n2，然后将上述 \bJavaScript 代码拷贝到浏览器的 console 面板中，并按回车键。结果打印了：\n\n```\nGeo橙子：在过一阵子是不是要翻成英文，走出国门了\ndev_zk：现在好了[太开心][太开心]\ndev_zk：哈哈\n```\n\n每条评论单独占一行，完美。\n\n## 知识点解析\n\n\n首先，我们获取评论的节点并将其转换为数组。这里使用了 [Array.from](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) 和 [document.querySelectorAll](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll) 两个方法。后者返回符合选择器的所有节点，但格式为 [NodeList](https://developer.mozilla.org/en-US/docs/Web/API/NodeList)。前者是 ES6 的方法，将 `NodeList` 转换为普通数组。\n\n```js\nvar nodeArray = Array.from(document.querySelectorAll('.list_con .WB_text'));\n```\n\n然后，我们遍历每个评论，并将评论中的文字、图片、链接都提取出来。\b其中用到了 [nodeName](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeName)、[nodeValue](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeValue)、[lastChild](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/lastChild) 这三个 `Node` 的属性。还用了 `replace(/(\\s+$)|(^\\s+)/g, '')` 来去除首尾的空格。还使用了数组的 `join` 方法来将数组项连接成字符串。\n\n```js\nvar textArray = nodeArray.map(function (node) {\n  return Array.from(node.childNodes).map(function (childNode) {\n    var value;\n    // 文字的情况\n    if (childNode.nodeName === '#text') value = childNode.nodeValue;\n    // 图片表情的情况\n    else if (childNode.nodeName === 'IMG') value = childNode.alt;\n    // 链接的情况\n    else if (childNode.nodeName === 'A') value = childNode.lastChild.nodeValue;\n    return value.replace(/(\\s+$)|(^\\s+)/g, '');\n  }).join('');\n});\n```\n\n最后，打印评论。\n\n```js\nconsole.log(textArray.join('\\n'));\n```\n\n## 教程示例代码及目录\n\n<https://github.com/lewis617/practical-js>","slug":"use-js-to-get-weibo-comments","published":1,"updated":"2019-05-01T08:10:30.635Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjv4xxvn5003vtgytw9e8iku5","content":"<p>今天，我们要讲的是如何用 JavaScript 批量获取微博评论。如果你想备份或者\b转移某个微博页面的评论内容，那么本博客对你而言，将会非常实用。</p>\n<p>你可以在这里获取源代码：</p>\n<p><a href=\"https://github.com/lewis617/practical-node/blob/master/src/weiboBackup.js\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/practical-node/blob/master/src/weiboBackup.js</a></p>\n<a id=\"more\"></a>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><p>本文的示例代码非常简单，只有寥寥几行：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取微博以及评论文字</span></span><br><span class=\"line\"><span class=\"comment\"> * 先打开微博页面，</span></span><br><span class=\"line\"><span class=\"comment\"> * 然后将下面的js拷贝到浏览器的console面板中</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nodeArray = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'.list_con .WB_text'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> textArray = nodeArray.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(node.childNodes).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">childNode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">    <span class=\"comment\">// 文字的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'#text'</span>) value = childNode.nodeValue;</span><br><span class=\"line\">    <span class=\"comment\">// 图片表情的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'IMG'</span>) value = childNode.alt;</span><br><span class=\"line\">    <span class=\"comment\">// 链接的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'A'</span>) value = childNode.lastChild.nodeValue;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value.replace(<span class=\"regexp\">/(\\s+$)|(^\\s+)/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(textArray.join(<span class=\"string\">'\\n'</span>));</span><br></pre></td></tr></table></figure>\n<p>是不是很短很开心？接下来我们来看下这几行 JavaScript 代码的使用方法。</p>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><p>使用上述代码的方法非常\b简单，只需要：</p>\n<p>1，打开微博页面，比如：<a href=\"http://www.weibo.com/2207255374/Eqkmf0pL4\" target=\"_blank\" rel=\"noopener\">http://www.weibo.com/2207255374/Eqkmf0pL4</a></p>\n<p><img src=\"/css/images/241.jpg\" alt=\"\"></p>\n<p>我们可以看到一共有三条评论。</p>\n<p>2，然后将上述 \bJavaScript 代码拷贝到浏览器的 console 面板中，并按回车键。结果打印了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Geo橙子：在过一阵子是不是要翻成英文，走出国门了</span><br><span class=\"line\">dev_zk：现在好了[太开心][太开心]</span><br><span class=\"line\">dev_zk：哈哈</span><br></pre></td></tr></table></figure>\n<p>每条评论单独占一行，完美。</p>\n<h2 id=\"知识点解析\"><a href=\"#知识点解析\" class=\"headerlink\" title=\"知识点解析\"></a>知识点解析</h2><p>首先，我们获取评论的节点并将其转换为数组。这里使用了 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\" target=\"_blank\" rel=\"noopener\">Array.from</a> 和 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll\" target=\"_blank\" rel=\"noopener\">document.querySelectorAll</a> 两个方法。后者返回符合选择器的所有节点，但格式为 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/NodeList\" target=\"_blank\" rel=\"noopener\">NodeList</a>。前者是 ES6 的方法，将 <code>NodeList</code> 转换为普通数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nodeArray = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'.list_con .WB_text'</span>));</span><br></pre></td></tr></table></figure>\n<p>然后，我们遍历每个评论，并将评论中的文字、图片、链接都提取出来。\b其中用到了 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeName\" target=\"_blank\" rel=\"noopener\">nodeName</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeValue\" target=\"_blank\" rel=\"noopener\">nodeValue</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/lastChild\" target=\"_blank\" rel=\"noopener\">lastChild</a> 这三个 <code>Node</code> 的属性。还用了 <code>replace(/(\\s+$)|(^\\s+)/g, &#39;&#39;)</code> 来去除首尾的空格。还使用了数组的 <code>join</code> 方法来将数组项连接成字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> textArray = nodeArray.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(node.childNodes).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">childNode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">    <span class=\"comment\">// 文字的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'#text'</span>) value = childNode.nodeValue;</span><br><span class=\"line\">    <span class=\"comment\">// 图片表情的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'IMG'</span>) value = childNode.alt;</span><br><span class=\"line\">    <span class=\"comment\">// 链接的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'A'</span>) value = childNode.lastChild.nodeValue;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value.replace(<span class=\"regexp\">/(\\s+$)|(^\\s+)/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>最后，打印评论。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(textArray.join(<span class=\"string\">'\\n'</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p><a href=\"https://github.com/lewis617/practical-js\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/practical-js</a></p>\n","site":{"data":{}},"excerpt":"<p>今天，我们要讲的是如何用 JavaScript 批量获取微博评论。如果你想备份或者\b转移某个微博页面的评论内容，那么本博客对你而言，将会非常实用。</p>\n<p>你可以在这里获取源代码：</p>\n<p><a href=\"https://github.com/lewis617/practical-node/blob/master/src/weiboBackup.js\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/practical-node/blob/master/src/weiboBackup.js</a></p>","more":"<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><p>本文的示例代码非常简单，只有寥寥几行：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取微博以及评论文字</span></span><br><span class=\"line\"><span class=\"comment\"> * 先打开微博页面，</span></span><br><span class=\"line\"><span class=\"comment\"> * 然后将下面的js拷贝到浏览器的console面板中</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nodeArray = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'.list_con .WB_text'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> textArray = nodeArray.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(node.childNodes).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">childNode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">    <span class=\"comment\">// 文字的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'#text'</span>) value = childNode.nodeValue;</span><br><span class=\"line\">    <span class=\"comment\">// 图片表情的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'IMG'</span>) value = childNode.alt;</span><br><span class=\"line\">    <span class=\"comment\">// 链接的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'A'</span>) value = childNode.lastChild.nodeValue;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value.replace(<span class=\"regexp\">/(\\s+$)|(^\\s+)/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(textArray.join(<span class=\"string\">'\\n'</span>));</span><br></pre></td></tr></table></figure>\n<p>是不是很短很开心？接下来我们来看下这几行 JavaScript 代码的使用方法。</p>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><p>使用上述代码的方法非常\b简单，只需要：</p>\n<p>1，打开微博页面，比如：<a href=\"http://www.weibo.com/2207255374/Eqkmf0pL4\" target=\"_blank\" rel=\"noopener\">http://www.weibo.com/2207255374/Eqkmf0pL4</a></p>\n<p><img src=\"/css/images/241.jpg\" alt=\"\"></p>\n<p>我们可以看到一共有三条评论。</p>\n<p>2，然后将上述 \bJavaScript 代码拷贝到浏览器的 console 面板中，并按回车键。结果打印了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Geo橙子：在过一阵子是不是要翻成英文，走出国门了</span><br><span class=\"line\">dev_zk：现在好了[太开心][太开心]</span><br><span class=\"line\">dev_zk：哈哈</span><br></pre></td></tr></table></figure>\n<p>每条评论单独占一行，完美。</p>\n<h2 id=\"知识点解析\"><a href=\"#知识点解析\" class=\"headerlink\" title=\"知识点解析\"></a>知识点解析</h2><p>首先，我们获取评论的节点并将其转换为数组。这里使用了 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\" target=\"_blank\" rel=\"noopener\">Array.from</a> 和 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll\" target=\"_blank\" rel=\"noopener\">document.querySelectorAll</a> 两个方法。后者返回符合选择器的所有节点，但格式为 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/NodeList\" target=\"_blank\" rel=\"noopener\">NodeList</a>。前者是 ES6 的方法，将 <code>NodeList</code> 转换为普通数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nodeArray = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'.list_con .WB_text'</span>));</span><br></pre></td></tr></table></figure>\n<p>然后，我们遍历每个评论，并将评论中的文字、图片、链接都提取出来。\b其中用到了 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeName\" target=\"_blank\" rel=\"noopener\">nodeName</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeValue\" target=\"_blank\" rel=\"noopener\">nodeValue</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/lastChild\" target=\"_blank\" rel=\"noopener\">lastChild</a> 这三个 <code>Node</code> 的属性。还用了 <code>replace(/(\\s+$)|(^\\s+)/g, &#39;&#39;)</code> 来去除首尾的空格。还使用了数组的 <code>join</code> 方法来将数组项连接成字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> textArray = nodeArray.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(node.childNodes).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">childNode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">    <span class=\"comment\">// 文字的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'#text'</span>) value = childNode.nodeValue;</span><br><span class=\"line\">    <span class=\"comment\">// 图片表情的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'IMG'</span>) value = childNode.alt;</span><br><span class=\"line\">    <span class=\"comment\">// 链接的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childNode.nodeName === <span class=\"string\">'A'</span>) value = childNode.lastChild.nodeValue;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value.replace(<span class=\"regexp\">/(\\s+$)|(^\\s+)/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>最后，打印评论。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(textArray.join(<span class=\"string\">'\\n'</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"教程示例代码及目录\"><a href=\"#教程示例代码及目录\" class=\"headerlink\" title=\"教程示例代码及目录\"></a>教程示例代码及目录</h2><p><a href=\"https://github.com/lewis617/practical-js\" target=\"_blank\" rel=\"noopener\">https://github.com/lewis617/practical-js</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjv4xxvkq0001tgyth49yc47m","tag_id":"cjv4xxvkw0003tgytu4t7p17d","_id":"cjv4xxvl7000ctgyt2p05aak1"},{"post_id":"cjv4xxvkq0001tgyth49yc47m","tag_id":"cjv4xxvl10007tgyt9i8a2wec","_id":"cjv4xxvl8000etgytpwdz8ve7"},{"post_id":"cjv4xxvl6000btgytyftxx0tp","tag_id":"cjv4xxvkw0003tgytu4t7p17d","_id":"cjv4xxvl9000htgytus0xvtd5"},{"post_id":"cjv4xxvl8000gtgytutwdje3f","tag_id":"cjv4xxvkw0003tgytu4t7p17d","_id":"cjv4xxvla000jtgytesvfu1gs"},{"post_id":"cjv4xxvl9000itgytjq6n6uui","tag_id":"cjv4xxvkw0003tgytu4t7p17d","_id":"cjv4xxvlb000mtgyta96v3j3o"},{"post_id":"cjv4xxvl9000itgytjq6n6uui","tag_id":"cjv4xxvl10007tgyt9i8a2wec","_id":"cjv4xxvlc000otgytoxwf0181"},{"post_id":"cjv4xxvla000ltgytepkeftoo","tag_id":"cjv4xxvkw0003tgytu4t7p17d","_id":"cjv4xxvld000rtgytycdu6ry4"},{"post_id":"cjv4xxvlb000ntgytvnxwfb3a","tag_id":"cjv4xxvkw0003tgytu4t7p17d","_id":"cjv4xxvle000ttgytwjlshq4z"},{"post_id":"cjv4xxvlb000ntgytvnxwfb3a","tag_id":"cjv4xxvl10007tgyt9i8a2wec","_id":"cjv4xxvli000wtgytdh9t0znl"},{"post_id":"cjv4xxvku0002tgyt388dwszg","tag_id":"cjv4xxvl5000atgytgddssb80","_id":"cjv4xxvlj000ytgyt8q1s4gdv"},{"post_id":"cjv4xxvku0002tgyt388dwszg","tag_id":"cjv4xxvl8000ftgyty3s7ieqf","_id":"cjv4xxvll0011tgytu2vu1j0n"},{"post_id":"cjv4xxvku0002tgyt388dwszg","tag_id":"cjv4xxvla000ktgytdrrypd8w","_id":"cjv4xxvlm0013tgythx6j2jtn"},{"post_id":"cjv4xxvku0002tgyt388dwszg","tag_id":"cjv4xxvld000qtgyt3hy7rris","_id":"cjv4xxvln0016tgyt6yky99wq"},{"post_id":"cjv4xxvlm0014tgytc4v6h6pp","tag_id":"cjv4xxvkw0003tgytu4t7p17d","_id":"cjv4xxvlo0018tgytn2ftkder"},{"post_id":"cjv4xxvkx0004tgytnxauiukn","tag_id":"cjv4xxvl5000atgytgddssb80","_id":"cjv4xxvlt001ftgytc4fb04u4"},{"post_id":"cjv4xxvkx0004tgytnxauiukn","tag_id":"cjv4xxvl8000ftgyty3s7ieqf","_id":"cjv4xxvlu001htgytijehopag"},{"post_id":"cjv4xxvkx0004tgytnxauiukn","tag_id":"cjv4xxvla000ktgytdrrypd8w","_id":"cjv4xxvlv001ktgytuc2c7dr5"},{"post_id":"cjv4xxvkx0004tgytnxauiukn","tag_id":"cjv4xxvlq001atgytq7vvxex8","_id":"cjv4xxvlw001mtgytbxd83ovo"},{"post_id":"cjv4xxvls001etgyt4pcsd5y1","tag_id":"cjv4xxvkw0003tgytu4t7p17d","_id":"cjv4xxvlx001ptgyt5ly4ljbf"},{"post_id":"cjv4xxvls001etgyt4pcsd5y1","tag_id":"cjv4xxvl10007tgyt9i8a2wec","_id":"cjv4xxvly001rtgytt3j00yv2"},{"post_id":"cjv4xxvkz0005tgytoyohak5w","tag_id":"cjv4xxvls001dtgyt6r0kaux5","_id":"cjv4xxvm1001ytgytszyw8ho2"},{"post_id":"cjv4xxvkz0005tgytoyohak5w","tag_id":"cjv4xxvl5000atgytgddssb80","_id":"cjv4xxvm20020tgyte2wlf5ds"},{"post_id":"cjv4xxvkz0005tgytoyohak5w","tag_id":"cjv4xxvlw001ntgytnvthd8k0","_id":"cjv4xxvm30023tgytrtal0wp7"},{"post_id":"cjv4xxvkz0005tgytoyohak5w","tag_id":"cjv4xxvly001ttgytbeaqnath","_id":"cjv4xxvm40025tgyt5c17zjj9"},{"post_id":"cjv4xxvl10006tgytlkr0qvhp","tag_id":"cjv4xxvkw0003tgytu4t7p17d","_id":"cjv4xxvm50028tgytsnnwgyy8"},{"post_id":"cjv4xxvl10006tgytlkr0qvhp","tag_id":"cjv4xxvl10007tgyt9i8a2wec","_id":"cjv4xxvm6002atgytegbv7rmy"},{"post_id":"cjv4xxvl30008tgytbzl2u0sa","tag_id":"cjv4xxvm20021tgytxyvglkew","_id":"cjv4xxvm7002dtgytlccenmvg"},{"post_id":"cjv4xxvm50029tgyto8p2oe6q","tag_id":"cjv4xxvkw0003tgytu4t7p17d","_id":"cjv4xxvm8002ftgyt8guccjqb"},{"post_id":"cjv4xxvl40009tgytlhxoft20","tag_id":"cjv4xxvm40026tgythqjxwqyl","_id":"cjv4xxvma002itgytkrtib4bc"},{"post_id":"cjv4xxvl40009tgytlhxoft20","tag_id":"cjv4xxvm6002btgyt6zjm1sjj","_id":"cjv4xxvmb002ktgyt7wc18c8n"},{"post_id":"cjv4xxvl7000dtgyt0usvwnem","tag_id":"cjv4xxvm9002htgyt35nmrjye","_id":"cjv4xxvmo0030tgytboop5dse"},{"post_id":"cjv4xxvl7000dtgyt0usvwnem","tag_id":"cjv4xxvls001dtgyt6r0kaux5","_id":"cjv4xxvmp0032tgytoy20qfoi"},{"post_id":"cjv4xxvl7000dtgyt0usvwnem","tag_id":"cjv4xxvl5000atgytgddssb80","_id":"cjv4xxvmq0035tgytdliqvfi5"},{"post_id":"cjv4xxvl7000dtgyt0usvwnem","tag_id":"cjv4xxvlw001ntgytnvthd8k0","_id":"cjv4xxvmr0037tgytgc6x7w1v"},{"post_id":"cjv4xxvl7000dtgyt0usvwnem","tag_id":"cjv4xxvmh002stgytp07va8ij","_id":"cjv4xxvmt003atgyti97kfto7"},{"post_id":"cjv4xxvl7000dtgyt0usvwnem","tag_id":"cjv4xxvly001ttgytbeaqnath","_id":"cjv4xxvmu003ctgytmrk58hpa"},{"post_id":"cjv4xxvlc000ptgytt770quys","tag_id":"cjv4xxvl5000atgytgddssb80","_id":"cjv4xxvmv003ftgytzlx1bl6x"},{"post_id":"cjv4xxvlc000ptgytt770quys","tag_id":"cjv4xxvlw001ntgytnvthd8k0","_id":"cjv4xxvmx003htgyt7p5evllr"},{"post_id":"cjv4xxvlc000ptgytt770quys","tag_id":"cjv4xxvly001ttgytbeaqnath","_id":"cjv4xxvmy003ktgytl63wys75"},{"post_id":"cjv4xxvlc000ptgytt770quys","tag_id":"cjv4xxvls001dtgyt6r0kaux5","_id":"cjv4xxvmz003mtgyti3ny5cr7"},{"post_id":"cjv4xxvmt003btgyttbye6ch5","tag_id":"cjv4xxvkw0003tgytu4t7p17d","_id":"cjv4xxvn1003ptgyt18pqxpn1"},{"post_id":"cjv4xxvmu003etgytyvqop8o2","tag_id":"cjv4xxvkw0003tgytu4t7p17d","_id":"cjv4xxvn3003rtgytaxr8u9dz"},{"post_id":"cjv4xxvmw003gtgytoyylr48f","tag_id":"cjv4xxvkw0003tgytu4t7p17d","_id":"cjv4xxvn5003utgytgv0xml0g"},{"post_id":"cjv4xxvld000stgytxr4vebuy","tag_id":"cjv4xxvmu003dtgyt0cics33d","_id":"cjv4xxvn6003wtgytd6m7sppv"},{"post_id":"cjv4xxvld000stgytxr4vebuy","tag_id":"cjv4xxvmx003itgytmg03v96l","_id":"cjv4xxvn7003xtgyt20bb427s"},{"post_id":"cjv4xxvld000stgytxr4vebuy","tag_id":"cjv4xxvl5000atgytgddssb80","_id":"cjv4xxvn7003ztgytu3926vud"},{"post_id":"cjv4xxvn2003qtgytbavpvy6b","tag_id":"cjv4xxvkw0003tgytu4t7p17d","_id":"cjv4xxvn70040tgytyxcslk87"},{"post_id":"cjv4xxvle000utgytac6f35sw","tag_id":"cjv4xxvn1003otgytiljplp6s","_id":"cjv4xxvn70042tgyt2c5uhy37"},{"post_id":"cjv4xxvli000xtgytp8mmn6yn","tag_id":"cjv4xxvn5003ttgytgshvpmcs","_id":"cjv4xxvn90049tgytwrgw2md7"},{"post_id":"cjv4xxvli000xtgytp8mmn6yn","tag_id":"cjv4xxvn7003ytgyt5yu1x79o","_id":"cjv4xxvn9004atgyt0vueoxi4"},{"post_id":"cjv4xxvli000xtgytp8mmn6yn","tag_id":"cjv4xxvn70041tgytniok5qj6","_id":"cjv4xxvna004ctgyt13v2lhqp"},{"post_id":"cjv4xxvli000xtgytp8mmn6yn","tag_id":"cjv4xxvkw0003tgytu4t7p17d","_id":"cjv4xxvna004dtgytbytd97fv"},{"post_id":"cjv4xxvli000xtgytp8mmn6yn","tag_id":"cjv4xxvn80043tgyt7w6pizpr","_id":"cjv4xxvna004ftgyt4b1u6xx2"},{"post_id":"cjv4xxvli000xtgytp8mmn6yn","tag_id":"cjv4xxvn80044tgytwx12aobd","_id":"cjv4xxvna004gtgytunovdudd"},{"post_id":"cjv4xxvli000xtgytp8mmn6yn","tag_id":"cjv4xxvn80045tgytik6y40n6","_id":"cjv4xxvnb004itgytxw4oeifb"},{"post_id":"cjv4xxvli000xtgytp8mmn6yn","tag_id":"cjv4xxvn80046tgyt69oemefu","_id":"cjv4xxvnb004jtgyt35ezx250"},{"post_id":"cjv4xxvli000xtgytp8mmn6yn","tag_id":"cjv4xxvn80047tgytnwenlkwx","_id":"cjv4xxvnc004ltgytv1q1ofwi"},{"post_id":"cjv4xxvlj000ztgytugiwdp1s","tag_id":"cjv4xxvn80048tgytn8f833u6","_id":"cjv4xxvnc004mtgytyibdrh5h"},{"post_id":"cjv4xxvlj000ztgytugiwdp1s","tag_id":"cjv4xxvmx003itgytmg03v96l","_id":"cjv4xxvnc004ntgyt88fpic2j"},{"post_id":"cjv4xxvlj000ztgytugiwdp1s","tag_id":"cjv4xxvl5000atgytgddssb80","_id":"cjv4xxvnc004ptgytyrwzd4s8"},{"post_id":"cjv4xxvll0012tgyttufavdv8","tag_id":"cjv4xxvna004etgytfxtb2s2u","_id":"cjv4xxvnd004rtgytp3z3042h"},{"post_id":"cjv4xxvll0012tgyttufavdv8","tag_id":"cjv4xxvna004htgytnluotna0","_id":"cjv4xxvnd004stgytwrijn182"},{"post_id":"cjv4xxvll0012tgyttufavdv8","tag_id":"cjv4xxvnb004ktgytnbn392zg","_id":"cjv4xxvne004utgytzo977yvk"},{"post_id":"cjv4xxvll0012tgyttufavdv8","tag_id":"cjv4xxvnc004otgyt7kmrtxgq","_id":"cjv4xxvne004vtgytl246vu4n"},{"post_id":"cjv4xxvln0017tgytaza9k50e","tag_id":"cjv4xxvn80048tgytn8f833u6","_id":"cjv4xxvne004xtgytyviurdbz"},{"post_id":"cjv4xxvln0017tgytaza9k50e","tag_id":"cjv4xxvmx003itgytmg03v96l","_id":"cjv4xxvnf004ytgyto09ia6sd"},{"post_id":"cjv4xxvln0017tgytaza9k50e","tag_id":"cjv4xxvl5000atgytgddssb80","_id":"cjv4xxvnf0050tgyt2vapw3gt"},{"post_id":"cjv4xxvlp0019tgyt4qbp3m47","tag_id":"cjv4xxvne004wtgytmesjovds","_id":"cjv4xxvng0053tgytvv9j8yn3"},{"post_id":"cjv4xxvlp0019tgyt4qbp3m47","tag_id":"cjv4xxvnf004ztgyt558hpgrh","_id":"cjv4xxvng0054tgyt6hbyw9os"},{"post_id":"cjv4xxvlp0019tgyt4qbp3m47","tag_id":"cjv4xxvnf0051tgytsoiu0q0m","_id":"cjv4xxvng0056tgytzayf2q5n"},{"post_id":"cjv4xxvlq001btgytxhr3mleh","tag_id":"cjv4xxvne004wtgytmesjovds","_id":"cjv4xxvnh0058tgyt7xaxw2nf"},{"post_id":"cjv4xxvlq001btgytxhr3mleh","tag_id":"cjv4xxvng0055tgytlktuj9ce","_id":"cjv4xxvnh0059tgytdufbf5db"},{"post_id":"cjv4xxvlr001ctgyt9eevwxhv","tag_id":"cjv4xxvne004wtgytmesjovds","_id":"cjv4xxvni005ctgyt5szjojv6"},{"post_id":"cjv4xxvlr001ctgyt9eevwxhv","tag_id":"cjv4xxvnh005atgytumk1t4ja","_id":"cjv4xxvni005dtgytb2i75j4b"},{"post_id":"cjv4xxvlt001gtgytcahle8ii","tag_id":"cjv4xxvnh005btgytw81efm7k","_id":"cjv4xxvnj005ftgytg05m7j27"},{"post_id":"cjv4xxvlu001jtgyt7m7oklj2","tag_id":"cjv4xxvnh005btgytw81efm7k","_id":"cjv4xxvnk005htgytijvvc5vw"},{"post_id":"cjv4xxvlv001ltgyti3vo5oru","tag_id":"cjv4xxvnh005btgytw81efm7k","_id":"cjv4xxvnk005jtgyt5y3v33ny"},{"post_id":"cjv4xxvlw001otgyt5zscodws","tag_id":"cjv4xxvnh005btgytw81efm7k","_id":"cjv4xxvnl005ltgytuas9ed0y"},{"post_id":"cjv4xxvlx001qtgytrnw083fg","tag_id":"cjv4xxvnh005btgytw81efm7k","_id":"cjv4xxvnm005ntgytgabxuq31"},{"post_id":"cjv4xxvly001stgytfy2wuc7h","tag_id":"cjv4xxvnh005btgytw81efm7k","_id":"cjv4xxvnm005ptgytn6ato6dr"},{"post_id":"cjv4xxvlz001utgytq694duzk","tag_id":"cjv4xxvnh005btgytw81efm7k","_id":"cjv4xxvnn005rtgyt8oofu16s"},{"post_id":"cjv4xxvlz001vtgytjhmxc861","tag_id":"cjv4xxvnh005btgytw81efm7k","_id":"cjv4xxvno005ttgytifb7ghqo"},{"post_id":"cjv4xxvm1001xtgytt8k1o575","tag_id":"cjv4xxvnh005btgytw81efm7k","_id":"cjv4xxvno005vtgyt5sauh92z"},{"post_id":"cjv4xxvm1001ztgytc6oggr1j","tag_id":"cjv4xxvnh005btgytw81efm7k","_id":"cjv4xxvnp005xtgyt3iw3cloz"},{"post_id":"cjv4xxvm20022tgytlxx68xrd","tag_id":"cjv4xxvno005wtgyt8xliyvi1","_id":"cjv4xxvnr0065tgyt5sotcaae"},{"post_id":"cjv4xxvm20022tgytlxx68xrd","tag_id":"cjv4xxvnp005ytgytkogjquhi","_id":"cjv4xxvnr0066tgytp8kvdeb7"},{"post_id":"cjv4xxvm20022tgytlxx68xrd","tag_id":"cjv4xxvnp005ztgytampn2er1","_id":"cjv4xxvnr0068tgytxxkrxi8n"},{"post_id":"cjv4xxvm20022tgytlxx68xrd","tag_id":"cjv4xxvnp0060tgyty3eluatf","_id":"cjv4xxvnr0069tgytips3pvl8"},{"post_id":"cjv4xxvm20022tgytlxx68xrd","tag_id":"cjv4xxvnq0061tgytqc6iejc0","_id":"cjv4xxvns006btgytu6bbthiw"},{"post_id":"cjv4xxvm20022tgytlxx68xrd","tag_id":"cjv4xxvnq0062tgytngvpq6r1","_id":"cjv4xxvns006ctgytxhbmsz4n"},{"post_id":"cjv4xxvm20022tgytlxx68xrd","tag_id":"cjv4xxvnq0063tgytxv56u0hk","_id":"cjv4xxvnt006etgyte6viuiv2"},{"post_id":"cjv4xxvm30024tgyt271d9618","tag_id":"cjv4xxvnq0064tgytfniz89hx","_id":"cjv4xxvnt006ftgyt1bnnhxue"},{"post_id":"cjv4xxvm30024tgyt271d9618","tag_id":"cjv4xxvnr0067tgytxkjl3d70","_id":"cjv4xxvnt006htgytvkw44eyk"},{"post_id":"cjv4xxvm30024tgyt271d9618","tag_id":"cjv4xxvm6002btgyt6zjm1sjj","_id":"cjv4xxvnt006itgytfgw20qdu"},{"post_id":"cjv4xxvm40027tgyt5rcgyvyg","tag_id":"cjv4xxvn5003ttgytgshvpmcs","_id":"cjv4xxvnu006ntgytkodiu4ql"},{"post_id":"cjv4xxvm40027tgyt5rcgyvyg","tag_id":"cjv4xxvnt006gtgyt461t55sp","_id":"cjv4xxvnv006otgyt4ioy6eqm"},{"post_id":"cjv4xxvm40027tgyt5rcgyvyg","tag_id":"cjv4xxvnt006jtgytw3r802kx","_id":"cjv4xxvnv006qtgyttqbwdl1d"},{"post_id":"cjv4xxvm40027tgyt5rcgyvyg","tag_id":"cjv4xxvnt006ktgytee6ny893","_id":"cjv4xxvnv006rtgytl9hbaud0"},{"post_id":"cjv4xxvm40027tgyt5rcgyvyg","tag_id":"cjv4xxvnu006ltgyt7utpnfkd","_id":"cjv4xxvnw006ttgytwjh4tm2l"},{"post_id":"cjv4xxvm6002ctgytglfh2c6c","tag_id":"cjv4xxvnf004ztgyt558hpgrh","_id":"cjv4xxvnw006utgytrhso12yb"},{"post_id":"cjv4xxvm6002ctgytglfh2c6c","tag_id":"cjv4xxvnf0051tgytsoiu0q0m","_id":"cjv4xxvnw006wtgytjt7uev1a"},{"post_id":"cjv4xxvm7002etgytzw7l2am1","tag_id":"cjv4xxvnh005btgytw81efm7k","_id":"cjv4xxvnw006xtgytbio2dwli"},{"post_id":"cjv4xxvm8002gtgytjj70h966","tag_id":"cjv4xxvnf004ztgyt558hpgrh","_id":"cjv4xxvnx0070tgytzy5yv7sg"},{"post_id":"cjv4xxvm8002gtgytjj70h966","tag_id":"cjv4xxvnf0051tgytsoiu0q0m","_id":"cjv4xxvny0071tgyt7e9mgh1c"},{"post_id":"cjv4xxvma002jtgytwkaah8z1","tag_id":"cjv4xxvnf004ztgyt558hpgrh","_id":"cjv4xxvo0007atgyt9fpl83hq"},{"post_id":"cjv4xxvma002jtgytwkaah8z1","tag_id":"cjv4xxvnf0051tgytsoiu0q0m","_id":"cjv4xxvo1007btgyty2q12v04"},{"post_id":"cjv4xxvma002jtgytwkaah8z1","tag_id":"cjv4xxvny0073tgytse0pup5p","_id":"cjv4xxvo1007dtgytq7ehdy78"},{"post_id":"cjv4xxvma002jtgytwkaah8z1","tag_id":"cjv4xxvny0074tgytj2jqiav1","_id":"cjv4xxvo1007etgyt66cwk2x2"},{"post_id":"cjv4xxvma002jtgytwkaah8z1","tag_id":"cjv4xxvnp005ytgytkogjquhi","_id":"cjv4xxvo2007gtgyt7hhilqc6"},{"post_id":"cjv4xxvma002jtgytwkaah8z1","tag_id":"cjv4xxvnz0076tgyt4s96znvc","_id":"cjv4xxvo2007htgytep8tbevt"},{"post_id":"cjv4xxvma002jtgytwkaah8z1","tag_id":"cjv4xxvn7003ytgyt5yu1x79o","_id":"cjv4xxvo2007jtgytl08jvr38"},{"post_id":"cjv4xxvma002jtgytwkaah8z1","tag_id":"cjv4xxvnz0078tgytjozdrg95","_id":"cjv4xxvo2007ktgytvapg45y8"},{"post_id":"cjv4xxvmb002ltgytz4hwaazf","tag_id":"cjv4xxvnf004ztgyt558hpgrh","_id":"cjv4xxvo3007mtgyt5zgq0zdk"},{"post_id":"cjv4xxvmb002ltgytz4hwaazf","tag_id":"cjv4xxvnf0051tgytsoiu0q0m","_id":"cjv4xxvo3007ntgytovu6k0ok"},{"post_id":"cjv4xxvmc002ntgytfauad7uo","tag_id":"cjv4xxvnf004ztgyt558hpgrh","_id":"cjv4xxvo4007ptgyt2n9i1dh3"},{"post_id":"cjv4xxvmc002ntgytfauad7uo","tag_id":"cjv4xxvnf0051tgytsoiu0q0m","_id":"cjv4xxvo4007qtgytjz4dbsbd"},{"post_id":"cjv4xxvmd002otgytcjvygyxg","tag_id":"cjv4xxvnf004ztgyt558hpgrh","_id":"cjv4xxvo4007stgyty7kf1jkj"},{"post_id":"cjv4xxvmd002otgytcjvygyxg","tag_id":"cjv4xxvnf0051tgytsoiu0q0m","_id":"cjv4xxvo4007ttgyt0k1z5m99"},{"post_id":"cjv4xxvme002qtgyt8og0s0lq","tag_id":"cjv4xxvnf004ztgyt558hpgrh","_id":"cjv4xxvo5007wtgyt2ekxrp8c"},{"post_id":"cjv4xxvme002qtgyt8og0s0lq","tag_id":"cjv4xxvnf0051tgytsoiu0q0m","_id":"cjv4xxvo6007xtgytyulemecs"},{"post_id":"cjv4xxvmg002rtgyt27nd9c56","tag_id":"cjv4xxvnf004ztgyt558hpgrh","_id":"cjv4xxvo70080tgytluzdiru3"},{"post_id":"cjv4xxvmg002rtgyt27nd9c56","tag_id":"cjv4xxvnf0051tgytsoiu0q0m","_id":"cjv4xxvo70081tgyt2h17m8v4"},{"post_id":"cjv4xxvmh002ttgytg79fa7es","tag_id":"cjv4xxvnf004ztgyt558hpgrh","_id":"cjv4xxvo80084tgyte7yt75md"},{"post_id":"cjv4xxvmh002ttgytg79fa7es","tag_id":"cjv4xxvnf0051tgytsoiu0q0m","_id":"cjv4xxvo80085tgytk27sb7tt"},{"post_id":"cjv4xxvmi002utgyt72c70504","tag_id":"cjv4xxvnf004ztgyt558hpgrh","_id":"cjv4xxvo90088tgytqkrcwlrt"},{"post_id":"cjv4xxvmi002utgyt72c70504","tag_id":"cjv4xxvo80086tgytyto7ugai","_id":"cjv4xxvo90089tgytsiwi31mc"},{"post_id":"cjv4xxvmj002wtgyt6hxogny1","tag_id":"cjv4xxvnf0051tgytsoiu0q0m","_id":"cjv4xxvoa008ctgyt8ebib6bo"},{"post_id":"cjv4xxvmj002wtgyt6hxogny1","tag_id":"cjv4xxvo9008atgythn9kh6ub","_id":"cjv4xxvoa008dtgytmdsv5edm"},{"post_id":"cjv4xxvmk002xtgyth2kw7i3d","tag_id":"cjv4xxvnf004ztgyt558hpgrh","_id":"cjv4xxvob008htgytuq91uekd"},{"post_id":"cjv4xxvmk002xtgyth2kw7i3d","tag_id":"cjv4xxvoa008etgyt6mrbpfpn","_id":"cjv4xxvob008itgyt5k3ssvbu"},{"post_id":"cjv4xxvmk002xtgyth2kw7i3d","tag_id":"cjv4xxvl5000atgytgddssb80","_id":"cjv4xxvob008ktgyt30mk4zdn"},{"post_id":"cjv4xxvmk002xtgyth2kw7i3d","tag_id":"cjv4xxvmx003itgytmg03v96l","_id":"cjv4xxvob008ltgyt1n82b34y"},{"post_id":"cjv4xxvmm002ztgytdsfu4xgk","tag_id":"cjv4xxvng0055tgytlktuj9ce","_id":"cjv4xxvoc008ntgytufr8mzbz"},{"post_id":"cjv4xxvmm002ztgytdsfu4xgk","tag_id":"cjv4xxvob008jtgytqrk5ofni","_id":"cjv4xxvoc008otgytepm6ymmr"},{"post_id":"cjv4xxvmo0031tgyty25fy1us","tag_id":"cjv4xxvng0055tgytlktuj9ce","_id":"cjv4xxvod008qtgytflvva4ej"},{"post_id":"cjv4xxvmp0034tgytk5m037f1","tag_id":"cjv4xxvng0055tgytlktuj9ce","_id":"cjv4xxvof008vtgytdxqsjlc4"},{"post_id":"cjv4xxvmp0034tgytk5m037f1","tag_id":"cjv4xxvod008rtgyt9cz3tv1p","_id":"cjv4xxvof008wtgyt2te6vjor"},{"post_id":"cjv4xxvmp0034tgytk5m037f1","tag_id":"cjv4xxvod008stgytrods0l4a","_id":"cjv4xxvof008ytgyt1m5vsum5"},{"post_id":"cjv4xxvmp0034tgytk5m037f1","tag_id":"cjv4xxvny0074tgytj2jqiav1","_id":"cjv4xxvof008ztgyt44vy9pgy"},{"post_id":"cjv4xxvmq0036tgytagepmnuf","tag_id":"cjv4xxvn5003ttgytgshvpmcs","_id":"cjv4xxvog0093tgyt492rridx"},{"post_id":"cjv4xxvmq0036tgytagepmnuf","tag_id":"cjv4xxvof008xtgytg7q15n4q","_id":"cjv4xxvoh0094tgytu3kpjzsz"},{"post_id":"cjv4xxvmq0036tgytagepmnuf","tag_id":"cjv4xxvnf0051tgytsoiu0q0m","_id":"cjv4xxvoh0096tgyte4ioicx9"},{"post_id":"cjv4xxvmq0036tgytagepmnuf","tag_id":"cjv4xxvnf004ztgyt558hpgrh","_id":"cjv4xxvoh0097tgyt3ra48ojg"},{"post_id":"cjv4xxvms0039tgytubgcoh7w","tag_id":"cjv4xxvn5003ttgytgshvpmcs","_id":"cjv4xxvon009btgyt1gos8p98"},{"post_id":"cjv4xxvms0039tgytubgcoh7w","tag_id":"cjv4xxvof008xtgytg7q15n4q","_id":"cjv4xxvoo009ctgyto4y90w9e"},{"post_id":"cjv4xxvms0039tgytubgcoh7w","tag_id":"cjv4xxvnf0051tgytsoiu0q0m","_id":"cjv4xxvoo009etgytrygmpvsw"},{"post_id":"cjv4xxvms0039tgytubgcoh7w","tag_id":"cjv4xxvnf004ztgyt558hpgrh","_id":"cjv4xxvoo009ftgytlehyqk1d"},{"post_id":"cjv4xxvmx003jtgytvosf8uih","tag_id":"cjv4xxvm9002htgyt35nmrjye","_id":"cjv4xxvoo009htgyt509cmkbg"},{"post_id":"cjv4xxvmx003jtgytvosf8uih","tag_id":"cjv4xxvmx003itgytmg03v96l","_id":"cjv4xxvoo009itgyttm8icfbo"},{"post_id":"cjv4xxvmx003jtgytvosf8uih","tag_id":"cjv4xxvl5000atgytgddssb80","_id":"cjv4xxvop009ktgytomphkb6r"},{"post_id":"cjv4xxvmy003ltgyt0z5dqt8p","tag_id":"cjv4xxvoo009dtgyt69h87d3u","_id":"cjv4xxvop009mtgyt5tzjy4t3"},{"post_id":"cjv4xxvmy003ltgyt0z5dqt8p","tag_id":"cjv4xxvoo009gtgytsxtvdxfq","_id":"cjv4xxvop009ntgyt5u6243gq"},{"post_id":"cjv4xxvmy003ltgyt0z5dqt8p","tag_id":"cjv4xxvop009jtgytbcc3xw6i","_id":"cjv4xxvoq009ptgyty9fgaxo1"},{"post_id":"cjv4xxvn0003ntgytugfy9wsi","tag_id":"cjv4xxvn5003ttgytgshvpmcs","_id":"cjv4xxvos009xtgyta1dz5t7s"},{"post_id":"cjv4xxvn0003ntgytugfy9wsi","tag_id":"cjv4xxvop009otgytwq31k3c6","_id":"cjv4xxvos009ytgyt9nevvrf7"},{"post_id":"cjv4xxvn0003ntgytugfy9wsi","tag_id":"cjv4xxvoq009qtgytdgrhnmfn","_id":"cjv4xxvos00a0tgytf18ljj6l"},{"post_id":"cjv4xxvn0003ntgytugfy9wsi","tag_id":"cjv4xxvoq009rtgytqm2rxcjp","_id":"cjv4xxvos00a1tgyt8ae1fic5"},{"post_id":"cjv4xxvn0003ntgytugfy9wsi","tag_id":"cjv4xxvoq009stgyto0ur03jy","_id":"cjv4xxvos00a3tgytw3q5tnx8"},{"post_id":"cjv4xxvn0003ntgytugfy9wsi","tag_id":"cjv4xxvoq009ttgyt4w19rbe2","_id":"cjv4xxvot00a4tgyte37k5371"},{"post_id":"cjv4xxvn0003ntgytugfy9wsi","tag_id":"cjv4xxvor009utgyteg8m6ef4","_id":"cjv4xxvot00a6tgyth8s2p1e0"},{"post_id":"cjv4xxvn0003ntgytugfy9wsi","tag_id":"cjv4xxvor009vtgytbybw2ncm","_id":"cjv4xxvot00a7tgyt8ur6gezi"},{"post_id":"cjv4xxvn4003stgytahs38doa","tag_id":"cjv4xxvn5003ttgytgshvpmcs","_id":"cjv4xxvou00a9tgytd5sw3hpx"},{"post_id":"cjv4xxvn4003stgytahs38doa","tag_id":"cjv4xxvos009ztgyt7yjh4u4y","_id":"cjv4xxvou00aatgyti2tmpars"},{"post_id":"cjv4xxvn4003stgytahs38doa","tag_id":"cjv4xxvnh005btgytw81efm7k","_id":"cjv4xxvou00abtgytvfsdevxd"},{"post_id":"cjv4xxvn5003vtgytw9e8iku5","tag_id":"cjv4xxvno005wtgyt8xliyvi1","_id":"cjv4xxvou00actgytjtbd9azz"},{"post_id":"cjv4xxvn5003vtgytw9e8iku5","tag_id":"cjv4xxvnq0063tgytxv56u0hk","_id":"cjv4xxvou00adtgytfxg4ktvv"}],"Tag":[{"name":"数据结构与算法","_id":"cjv4xxvkw0003tgytu4t7p17d"},{"name":"LeetCode","_id":"cjv4xxvl10007tgyt9i8a2wec"},{"name":"测试","_id":"cjv4xxvl5000atgytgddssb80"},{"name":"自动化测试","_id":"cjv4xxvl8000ftgyty3s7ieqf"},{"name":"Appium","_id":"cjv4xxvla000ktgytdrrypd8w"},{"name":"Android","_id":"cjv4xxvld000qtgyt3hy7rris"},{"name":"IOS","_id":"cjv4xxvlq001atgytq7vvxex8"},{"name":"Puppeteer","_id":"cjv4xxvls001dtgyt6r0kaux5"},{"name":"端对端测试","_id":"cjv4xxvlw001ntgytnvthd8k0"},{"name":"e2e","_id":"cjv4xxvly001ttgytbeaqnath"},{"name":"面向对象编程","_id":"cjv4xxvm20021tgytxyvglkew"},{"name":"Jinja2","_id":"cjv4xxvm40026tgythqjxwqyl"},{"name":"Flask","_id":"cjv4xxvm6002btgyt6zjm1sjj"},{"name":"Jest","_id":"cjv4xxvm9002htgyt35nmrjye"},{"name":"黑盒测试","_id":"cjv4xxvmh002stgytp07va8ij"},{"name":"DOM","_id":"cjv4xxvmu003dtgyt0cics33d"},{"name":"单元测试","_id":"cjv4xxvmx003itgytmg03v96l"},{"name":"JS 调试","_id":"cjv4xxvn1003otgytiljplp6s"},{"name":"技术讲座","_id":"cjv4xxvn5003ttgytgshvpmcs"},{"name":"函数式编程","_id":"cjv4xxvn7003ytgyt5yu1x79o"},{"name":"不可变数据结构","_id":"cjv4xxvn70041tgytniok5qj6"},{"name":"纯函数","_id":"cjv4xxvn80043tgyt7w6pizpr"},{"name":"Trie 树","_id":"cjv4xxvn80044tgytwx12aobd"},{"name":"Mori","_id":"cjv4xxvn80045tgytik6y40n6"},{"name":"Immutable.js","_id":"cjv4xxvn80046tgyt69oemefu"},{"name":"Clojure","_id":"cjv4xxvn80047tgytnwenlkwx"},{"name":"Karma","_id":"cjv4xxvn80048tgytn8f833u6"},{"name":"机器学习","_id":"cjv4xxvna004etgytfxtb2s2u"},{"name":"TensorFlow","_id":"cjv4xxvna004htgytnluotna0"},{"name":"Object Detection API","_id":"cjv4xxvnb004ktgytnbn392zg"},{"name":"二值化","_id":"cjv4xxvnc004otgyt7kmrtxgq"},{"name":"Angular","_id":"cjv4xxvne004wtgytmesjovds"},{"name":"React","_id":"cjv4xxvnf004ztgyt558hpgrh"},{"name":"Redux","_id":"cjv4xxvnf0051tgytsoiu0q0m"},{"name":"RequireJs","_id":"cjv4xxvng0055tgytlktuj9ce"},{"name":"jQuery","_id":"cjv4xxvnh005atgytumk1t4ja"},{"name":"Angular2","_id":"cjv4xxvnh005btgytw81efm7k"},{"name":"practical-js","_id":"cjv4xxvno005wtgyt8xliyvi1"},{"name":"Node","_id":"cjv4xxvnp005ytgytkogjquhi"},{"name":"爬虫","_id":"cjv4xxvnp005ztgytampn2er1"},{"name":"superagent","_id":"cjv4xxvnp0060tgyty3eluatf"},{"name":"cheerio","_id":"cjv4xxvnq0061tgytqc6iejc0"},{"name":"字符编码","_id":"cjv4xxvnq0062tgytngvpq6r1"},{"name":"正则表达式","_id":"cjv4xxvnq0063tgytxv56u0hk"},{"name":"nginx","_id":"cjv4xxvnq0064tgytfniz89hx"},{"name":"跨域","_id":"cjv4xxvnr0067tgytxkjl3d70"},{"name":"Preact","_id":"cjv4xxvnt006gtgyt461t55sp"},{"name":"JSX","_id":"cjv4xxvnt006jtgytw3r802kx"},{"name":"虚拟DOM","_id":"cjv4xxvnt006ktgytee6ny893"},{"name":"性能","_id":"cjv4xxvnu006ltgyt7utpnfkd"},{"name":"Babel","_id":"cjv4xxvny0073tgytse0pup5p"},{"name":"Webpack","_id":"cjv4xxvny0074tgytj2jqiav1"},{"name":"Universal","_id":"cjv4xxvnz0076tgyt4s96znvc"},{"name":"图书","_id":"cjv4xxvnz0078tgytjozdrg95"},{"name":"Reflux","_id":"cjv4xxvo80086tgytyto7ugai"},{"name":"redux-amrc","_id":"cjv4xxvo9008atgythn9kh6ub"},{"name":"render-react-components","_id":"cjv4xxvoa008etgyt6mrbpfpn"},{"name":"Bootstrap","_id":"cjv4xxvob008jtgytqrk5ofni"},{"name":"r.js","_id":"cjv4xxvod008rtgyt9cz3tv1p"},{"name":"Gulp","_id":"cjv4xxvod008stgytrods0l4a"},{"name":"RxJS","_id":"cjv4xxvof008xtgytg7q15n4q"},{"name":"SVG","_id":"cjv4xxvoo009dtgyt69h87d3u"},{"name":"贝塞尔曲线","_id":"cjv4xxvoo009gtgytsxtvdxfq"},{"name":"SVG SMIL animation","_id":"cjv4xxvop009jtgytbcc3xw6i"},{"name":"物联网","_id":"cjv4xxvop009otgytwq31k3c6"},{"name":"伦理学","_id":"cjv4xxvoq009qtgytdgrhnmfn"},{"name":"电车问题","_id":"cjv4xxvoq009rtgytqm2rxcjp"},{"name":"left-pad","_id":"cjv4xxvoq009stgyto0ur03jy"},{"name":"Miri 僵尸网络","_id":"cjv4xxvoq009ttgyt4w19rbe2"},{"name":"Fitbit","_id":"cjv4xxvor009utgyteg8m6ef4"},{"name":"自动驾驶汽车","_id":"cjv4xxvor009vtgytbybw2ncm"},{"name":"TypeScript","_id":"cjv4xxvos009ztgyt7yjh4u4y"}]}}