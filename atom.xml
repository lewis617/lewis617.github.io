<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘一奇的个人博客</title>
  
  <subtitle>何以升华，唯有沉淀</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.liuyiqi.cn/"/>
  <updated>2019-01-23T08:27:18.041Z</updated>
  <id>http://www.liuyiqi.cn/</id>
  
  <author>
    <name>刘一奇</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度优先搜索和链表指针在 JSON 操作中的应用</title>
    <link href="http://www.liuyiqi.cn/2019/01/23/dfs-linked-list-in-json/"/>
    <id>http://www.liuyiqi.cn/2019/01/23/dfs-linked-list-in-json/</id>
    <published>2019-01-23T08:25:00.000Z</published>
    <updated>2019-01-23T08:27:18.041Z</updated>
    
    <content type="html"><![CDATA[<p>最近的工作涉及了大量 JSON 操作，用到了一些之前做过的算法题中的知识，深刻感觉到，传统数据结构与算法在前端开发中的应用也挺多的。所以，想借此文记录总结一番。</p><a id="more"></a><h2 id="深度优先搜索简介"><a href="#深度优先搜索简介" class="headerlink" title="深度优先搜索简介"></a>深度优先搜索简介</h2><p>深度优先搜索（Depth-First-Search，DFS）是一种用于遍历或搜索树或者图的算法。顾名思义，它的搜索的规则是深度优先：先访问根结点，如果有孩子节点（或者邻居节点）就优先访问孩子节点，并对孩子节点也进行上述递归访问。</p><p><img src="https://ws1.sinaimg.cn/mw690/83900b4egy1fcvp988h6bj20bu08vmxg" alt="enter image description here"></p><p>DFS 可谓是 LeetCode 中考察最多的知识点了，另外由于动态规划算法可以和 DFS 算法相互转换（就像是所有的递归都可以用“栈”来改写一样），所以 DFS 的题目简直不能更多。那么让我们先看下 DFS 算法题吧！</p><p>题目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给一个二叉树，找到它的最大深度。最大深度是指根节点到最远的叶子节点的长度。</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(n, l)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">                <span class="keyword">return</span> l </span><br><span class="line">            left=dfs(n.left, l+<span class="number">1</span>)</span><br><span class="line">            right=dfs(n.right, l+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> max(left,right)</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在上述代码中， <code>dfs</code> 就是一个使用了深度优先搜索算法的函数。先访问孩子节点（<code>n.left</code> 和 <code>n.right</code>），然后进行递归。这道题非常简单，不再过多赘述，有兴趣的同学可以去 LeetCode 做一下这道题：</p><p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p><h2 id="使用深度优先搜索打印-JSON"><a href="#使用深度优先搜索打印-JSON" class="headerlink" title="使用深度优先搜索打印 JSON"></a>使用深度优先搜索打印 JSON</h2><p>那么 DFS 在 JSON 操作中有什么用处呢？假如你想在网页上渲染一个 JSON，甚至想渲染出一个表单来编辑这个 JSON，那么就要用到 DFS 了。思路也很简单，先访问一个 JSON 的根结点，然后访问它的所有 key（也就是孩子节点），并对 key 也进行上述递归。</p><p>示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> json = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'hello'</span> &#125;, <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>] &#125;;</span><br><span class="line"><span class="keyword">const</span> dfs = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">String</span>(n) === <span class="string">'[object Object]'</span> || <span class="built_in">Array</span>.isArray(n))&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(n).forEach(<span class="function"><span class="params">k</span> =&gt;</span> &#123; dfs(n[k]); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line">dfs(json);</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://s2.ax1x.com/2019/01/23/kECv8A.png" alt="kECv8A.png"></p><p>可以发现 JSON 中每个节点都被遍历到了。然后你只需要更改 <code>dfs</code> 函数的参数，就可以渲染 JSON 树中的任意一项了，也可以渲染表单项来编辑它们。</p><h2 id="链表指针简介"><a href="#链表指针简介" class="headerlink" title="链表指针简介"></a>链表指针简介</h2><p><strong>链表</strong>（Linked list）是一种常见的基础数据结构，是一种<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8" title="线性表" target="_blank" rel="noopener">线性表</a>，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8" target="_blank" rel="noopener">指针</a> “指针 (计算机科学)”)(Pointer)。</p><p>链表遍历及操作也是 LeetCode 考察非常多的题目，我们来看一道简单的吧！</p><p>题目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">反转一个单链表。</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        p1,p2=<span class="keyword">None</span>,head</span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            p2.next,p1,p2=p1,p2,p2.next</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure><p>上述代码中，<code>p1</code>、<code>p2</code> 就是指针。两个指针都遍历了链表，但<code>p2</code> 比 <code>p1</code> 快一步，并在每一步把 <code>next</code> 指向 <code>p1</code>。最后，<code>p1</code> 就是原链表的反转版本。</p><p>题目地址：</p><p><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a> </p><h2 id="使用链表指针获取-JSON-中的叶子节点的值"><a href="#使用链表指针获取-JSON-中的叶子节点的值" class="headerlink" title="使用链表指针获取 JSON 中的叶子节点的值"></a>使用链表指针获取 JSON 中的叶子节点的值</h2><p>那么链表指针在 JSON 操作中有什么用呢？我们可以把 JS 中 Object 的 key 当作链表中的 <code>next</code>。那么如果知道一个叶子节点的路径，我们就可以用指针像遍历链表那样遍历到 JSON 的叶子节点处。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> json = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'hello'</span> &#125;, <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>] &#125;;</span><br><span class="line"><span class="keyword">const</span> path = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">let</span> point = json;</span><br><span class="line">path.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123; point = point[key] &#125;);</span><br><span class="line"><span class="comment">// point 为 'hello'，即 json.a.b 的值。</span></span><br><span class="line"><span class="built_in">console</span>.log(point);</span><br></pre></td></tr></table></figure><p>上述代码中，<code>json</code> 是我们要查找的 JSON 对象，<code>path</code> 是叶子节点的路径，<code>point</code> 是指针，通过遍历，<code>point</code> 最后指向了指定的叶子节点的值。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文讲述的算法都非常简单，在 LeetCode 上应该属于 Easy 中的 Easy 级别的，但是将算法应用到实际工作中也是一件有趣的事情，故记录下来，作为总结，也抛砖引玉，分享给大家。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近的工作涉及了大量 JSON 操作，用到了一些之前做过的算法题中的知识，深刻感觉到，传统数据结构与算法在前端开发中的应用也挺多的。所以，想借此文记录总结一番。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.liuyiqi.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.liuyiqi.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>搭建 Appium 自动化测试环境（IOS 篇）</title>
    <link href="http://www.liuyiqi.cn/2018/08/10/appium-ios-get-started/"/>
    <id>http://www.liuyiqi.cn/2018/08/10/appium-ios-get-started/</id>
    <published>2018-08-10T09:51:00.000Z</published>
    <updated>2018-08-10T09:51:05.127Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 IOS 系统的 App 进行自动化测试。</p><blockquote><p>本文仅讲解在 Mac 上的环境配置方法。</p></blockquote><a id="more"></a><h2 id="配置-IOS-的自动化驱动环境"><a href="#配置-IOS-的自动化驱动环境" class="headerlink" title="配置 IOS 的自动化驱动环境"></a>配置 IOS 的自动化驱动环境</h2><p>Appium 进行自动化的原理是：发送命令到各自系统对应的自动化驱动，来对相应的系统上的 App 进行自动化。这篇文章讲的是 IOS 自动化，对应驱动的名字叫 XCUITest。为了让驱动正常工作，我们要配置 XCUITest 的环境：</p><h3 id="安装-XCode7-或更高版本"><a href="#安装-XCode7-或更高版本" class="headerlink" title="安装 XCode7 或更高版本"></a>安装 XCode7 或更高版本</h3><p>如果你的 Mac 已经安装 XCode，请忽略，否则去 App Store 里安装。</p><h3 id="添加-udid-到-IOS-开发者账号上"><a href="#添加-udid-到-IOS-开发者账号上" class="headerlink" title="添加 udid 到 IOS 开发者账号上"></a>添加 udid 到 IOS 开发者账号上</h3><p>让有 IOS 开发者账号的人（可能是你或着你的 IOS 开发同事）把被测试的 iPhone 的 udid （udid 的获取办法请 Google）添加到开发者账户上。IOS 开发者都知道，如果你不是 IOS 开发就找他们做这一步，这里就不再赘述。</p><h3 id="安装开发者证书"><a href="#安装开发者证书" class="headerlink" title="安装开发者证书"></a>安装开发者证书</h3><p>让有 IOS 开发者账号的人（可能是你或着你的 IOS 开发同事）把证书文件给你，你把它们装在 Mac 上。</p><p>文件清单：</p><ul><li>xxx.cer</li><li>xxx.p12</li><li>xxx.mobileprovision</li></ul><p>三个文件都是双击安装，一路默认。</p><p>注意：</p><ul><li>安装 xxx.p12 文件时候，可能有密码，还是找有 IOS 开发者账号的人要密码。</li><li>双击 xxx.mobileprovision 文件时候，没有什么界面，但是只要你的电脑上有 XCode，就已经安装好了。</li></ul><h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h3><p>如果你的 Mac 已经有 Homebrew ，请忽略，否则执行此命令安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure><h3 id="安装-Carthage"><a href="#安装-Carthage" class="headerlink" title="安装 Carthage"></a>安装 Carthage</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install carthage</span><br></pre></td></tr></table></figure><h3 id="安装-libimobiledevice"><a href="#安装-libimobiledevice" class="headerlink" title="安装 libimobiledevice"></a>安装 libimobiledevice</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install libimobiledevice --HEAD</span><br></pre></td></tr></table></figure><h3 id="安装-ios-deploy"><a href="#安装-ios-deploy" class="headerlink" title="安装 ios-deploy"></a>安装 ios-deploy</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g ios-deploy</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ios-deploy</span><br></pre></td></tr></table></figure><p>至此，驱动环境就搭建好了！</p><h2 id="安装-Appium"><a href="#安装-Appium" class="headerlink" title="安装 Appium"></a>安装 Appium</h2><p>安装 Appium 有两种方式，NPM 和 桌面程序安装包，我们这次先选择前者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g appium</span><br></pre></td></tr></table></figure><h2 id="配置-WebDriverAgent"><a href="#配置-WebDriverAgent" class="headerlink" title="配置 WebDriverAgent"></a>配置 WebDriverAgent</h2><p>打开 WebDriverAgent.xcodeproj：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open $(npm root -g)/appium/node_modules/appium-xcuitest-driver/WebDriverAgent/WebDriverAgent.xcodeproj</span><br></pre></td></tr></table></figure><p>选择 WebDriverAgentRunner，并在下面两个 Signing 面板上选择之前安装的 provisioning 文件。</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/e60eccda5f84c981c7ba933b4cc37f00.png" alt="image.png"></p><h2 id="编写简单测试脚本"><a href="#编写简单测试脚本" class="headerlink" title="编写简单测试脚本"></a>编写简单测试脚本</h2><p>把 iPhone 插到 Mac 上。然后： </p><h3 id="准备被测试的-App-的安装包"><a href="#准备被测试的-App-的安装包" class="headerlink" title="准备被测试的 App 的安装包"></a>准备被测试的 App 的安装包</h3><p>准备一份被测试 IOS App 文件，就是 ipa 结尾的安装包。</p><h3 id="新建测试项目"><a href="#新建测试项目" class="headerlink" title="新建测试项目"></a>新建测试项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir appium-test</span><br><span class="line"></span><br><span class="line">cd appium-test</span><br><span class="line"></span><br><span class="line">npm i webdriverio</span><br></pre></td></tr></table></figure><p>添加 test.js 文件，并填写以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wdio = <span class="built_in">require</span>(<span class="string">"webdriverio"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> opts = &#123;</span><br><span class="line">  port: <span class="number">4723</span>,</span><br><span class="line">  desiredCapabilities: &#123;</span><br><span class="line">    platformName: <span class="string">"IOS"</span>,</span><br><span class="line">    deviceName: <span class="string">"iPhone的设备名称（Settings -&gt; General -&gt; About -&gt; Name ）"</span>,</span><br><span class="line">    app: <span class="string">"填写 xxx.ipa 的本地路径"</span>,</span><br><span class="line">    automationName: <span class="string">"XCUITest"</span>,</span><br><span class="line">    udid: <span class="string">"iPhone 的 udid"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = wdio.remote(opts);</span><br><span class="line"></span><br><span class="line">client</span><br><span class="line">  .init()</span><br><span class="line">  .end();</span><br></pre></td></tr></table></figure><p>在一个命令行中启动 appium：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appium</span><br></pre></td></tr></table></figure><p>在另一个命令行中执行测试脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node test.js</span><br></pre></td></tr></table></figure><p>然后就会发现手机被安装了 xxx.ipa ，并打开了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 IOS 系统的 App 进行自动化测试。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文仅讲解在 Mac 上的环境配置方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="自动化测试" scheme="http://www.liuyiqi.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Appium" scheme="http://www.liuyiqi.cn/tags/Appium/"/>
    
      <category term="IOS" scheme="http://www.liuyiqi.cn/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title>搭建 Appium 自动化测试环境（Android 篇）</title>
    <link href="http://www.liuyiqi.cn/2018/08/08/appium-android-get-started/"/>
    <id>http://www.liuyiqi.cn/2018/08/08/appium-android-get-started/</id>
    <published>2018-08-08T06:23:00.000Z</published>
    <updated>2018-08-10T09:52:20.557Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 Android 系统的 App 进行自动化测试。</p><blockquote><p>本文仅讲解在 Mac 上的环境配置方法。</p></blockquote><a id="more"></a><h2 id="配置-Android-的自动化驱动环境"><a href="#配置-Android-的自动化驱动环境" class="headerlink" title="配置 Android 的自动化驱动环境"></a>配置 Android 的自动化驱动环境</h2><p>Appium 进行自动化的原理是：发送命令到各自系统对应的自动化驱动，来对相应的系统上的 App 进行自动化。这篇文章讲的是 Android 自动化，对应驱动的名字叫 UiAutomator2。为了让驱动正常工作，我们要配置 UiAutomator2 的环境：</p><h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h3><p>如果你的 Mac 已经有 Homebrew ，请忽略，否则执行此命令安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure><h3 id="安装-Java"><a href="#安装-Java" class="headerlink" title="安装 Java"></a>安装 Java</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap caskroom/versions</span><br><span class="line">brew cask install java8</span><br></pre></td></tr></table></figure><h3 id="设置-JAVA-HOME-环境变量"><a href="#设置-JAVA-HOME-环境变量" class="headerlink" title="设置 JAVA_HOME 环境变量"></a>设置 JAVA_HOME 环境变量</h3><p>编辑登陆脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br></pre></td></tr></table></figure><p>添加这两行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="string">"<span class="variable">$(/usr/libexec/java_home)</span>"</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>使其生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><h3 id="安装-Android-SDK"><a href="#安装-Android-SDK" class="headerlink" title="安装 Android SDK"></a>安装 Android SDK</h3><p>Android SDK 最好的安装方法是安装 <a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">Android Studio</a>。安装过程一路默认就好。</p><p>安装完成后，点击这里查看 SDK 目录：</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/560667f7c3c2da24c502e5c9555367ac.png" alt="image.png"></p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/8191aafc8e1052d83d9dbad2315b4486.png" alt="image.png"></p><h3 id="设置-ADNROID-HOME-环境变量"><a href="#设置-ADNROID-HOME-环境变量" class="headerlink" title="设置 ADNROID_HOME 环境变量"></a>设置 ADNROID_HOME 环境变量</h3><p>将 ANDROID_HOME 环境变量设置为上步的 SDK 目录地址：</p><p>编辑登陆脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br></pre></td></tr></table></figure><p>添加这两行（注意把 username 改为自己的）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_HOME=<span class="string">"/Users/username/Library/Android/sdk"</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ANDROID_HOME</span>/platform-tools:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>使其生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>至此，驱动环境就搭建好了！</p><h2 id="安装-Appium"><a href="#安装-Appium" class="headerlink" title="安装 Appium"></a>安装 Appium</h2><p>安装 Appium 有两种方式，NPM 和 桌面程序安装包，我们这次先选择前者：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g appium</span><br></pre></td></tr></table></figure><h2 id="编写简单测试脚本"><a href="#编写简单测试脚本" class="headerlink" title="编写简单测试脚本"></a>编写简单测试脚本</h2><h3 id="查看设备名称"><a href="#查看设备名称" class="headerlink" title="查看设备名称"></a>查看设备名称</h3><p>打开手机开发者模式插到 Mac 上，输入此命令查看设备名称：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><h3 id="下载被测试的-App"><a href="#下载被测试的-App" class="headerlink" title="下载被测试的 App"></a>下载被测试的 App</h3><p><a href="https://github.com/appium/appium/raw/master/sample-code/apps/ApiDemos-debug.apk" target="_blank" rel="noopener">ApiDemos-debug.apk</a></p><h3 id="新建测试项目"><a href="#新建测试项目" class="headerlink" title="新建测试项目"></a>新建测试项目</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir appium-test</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> appium-test</span><br><span class="line"></span><br><span class="line">npm i webdriverio</span><br></pre></td></tr></table></figure><p>添加 test.js 文件，并填写以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wdio = <span class="built_in">require</span>(<span class="string">"webdriverio"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> opts = &#123;</span><br><span class="line">  port: <span class="number">4723</span>,</span><br><span class="line">  desiredCapabilities: &#123;</span><br><span class="line">    platformName: <span class="string">"Android"</span>,</span><br><span class="line">    deviceName: <span class="string">"填写 adb devices 中的名称"</span>,</span><br><span class="line">    app: <span class="string">"填写 ApiDemos-debug.apk 的本地路径"</span>,</span><br><span class="line">    automationName: <span class="string">"UiAutomator2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = wdio.remote(opts);</span><br><span class="line"></span><br><span class="line">client</span><br><span class="line">  .init()</span><br><span class="line">  .click(<span class="string">"~App"</span>)</span><br><span class="line">  .back()</span><br><span class="line">  .end();</span><br></pre></td></tr></table></figure><p>在一个命令行中启动 appium：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appium</span><br></pre></td></tr></table></figure><p>在另一个命令行中执行测试脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node test.js</span><br></pre></td></tr></table></figure><p>然后就会发现手机被安装了 ApiDemos.apk ，并模拟点击了脚本中的命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 Android 系统的 App 进行自动化测试。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文仅讲解在 Mac 上的环境配置方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="自动化测试" scheme="http://www.liuyiqi.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Appium" scheme="http://www.liuyiqi.cn/tags/Appium/"/>
    
      <category term="Android" scheme="http://www.liuyiqi.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>利用机器学习进行整张设计稿多组件识别的探索</title>
    <link href="http://www.liuyiqi.cn/2018/07/25/ml-component-recognition/"/>
    <id>http://www.liuyiqi.cn/2018/07/25/ml-component-recognition/</id>
    <published>2018-07-25T07:00:00.000Z</published>
    <updated>2018-07-25T07:06:14.899Z</updated>
    
    <content type="html"><![CDATA[<p>前不久，在集团内部做了一个 CR 系统，可以从设计稿上截图识别某个组件并给出代码。</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/253b2a3479efb954c13d29c33ebde193.gif" alt=""></p><p>但是，我不想只是识别单个组件，最好能识别整张设计稿的多个组件。于是，花了两三天进行了这项技术的探索调研，并将过程记录下来。</p><a id="more"></a><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="二值化处理"><a href="#二值化处理" class="headerlink" title="二值化处理"></a>二值化处理</h3><p>识别多个组件的本质是定位，我首先想到的是像车牌定位，或者跳一跳外挂那样的利用颜色，进行二值化等处理进行识别，但设计稿中的组件并没有非常明显的边界，这种方法显然是不可行的。</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/92540cd6fba715d2f87569ee4178045a.png" alt="image.png"></p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/327680fc4bbd5694af00345eff985b28.png" alt="image.png"></p><h3 id="TensorFlow-Object-Detection-API"><a href="#TensorFlow-Object-Detection-API" class="headerlink" title="TensorFlow Object Detection API"></a>TensorFlow Object Detection API</h3><p>后来发现了谷歌开放的 TensorFlow Object Detection API，顿时看到了希望。TensorFlow Object Detection API 可以创建一个精确的机器学习模型，该模型能够在单张图片中对多个物体进行定位、分类。看了几张效果图，认为应该有戏：</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b0d53971daa00b7368ce102128808ce2.png" alt="image.png"></p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/18885ecc69b4d3d41ba09b174b414653.png" alt="image.png"></p><h2 id="机器选择"><a href="#机器选择" class="headerlink" title="机器选择"></a>机器选择</h2><p>TensorFlow 可以在各个系统上跑，甚至可以在浏览器里运行和 retrain。但是如果要有更好的速度，最好选择可以用 GPU 的系统，由于 OSX 系统的在显卡方面的封闭性，TensorFlow 不支持在 OSX 上跑 GPU 版本，所以剩下的选择是：</p><ul><li>WIndows 或者 Linux 系统的电脑</li><li>谷歌云</li><li>集团的 PAI 平台</li><li>其他云平台</li></ul><p>由于云平台对我来说会增加一些熟悉成本，而我目前又只是急于知道多组件识别的可行性，所以就借了部门实习生的台式机来训练，正好这位实习生不习惯用 Windows 系统，自己带了 Macbook，所以就很爽快地借给我了。不过，不得不说集团给实习同学配置的电脑配置确实很基础，8g内存，Nvidia GeForce GT 730 的显卡，再差一点就跑不动 GPU 版本的 Tensorflow 了。</p><h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><p>TensorFlow Object Detection API 提供了一些<a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/detection_model_zoo.md" target="_blank" rel="noopener">现成的模型</a>来让你直接用或者重新训练，它们的区别在速度和精确度上。因为我的台式机配置较低，所以选择了速度较快，精度较低的模型（ssd_mobilenet_v1_coco）来重新训练。</p><h2 id="训练图片选择"><a href="#训练图片选择" class="headerlink" title="训练图片选择"></a>训练图片选择</h2><p>我们要进行的是整张设计稿的识别，所以最初我用的训练图片是整张设计稿，但训练下来，发现根本识别不出来什么。</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/7b973e2b8ba9e2444738610724a8f391.png" alt="image.png"></p><p>思考了一下，发现是因为：</p><ul><li>图片尺寸太大</li><li>而上步选择的模型只支持小尺寸的图片（毕竟那个模型是给移动端用的）</li></ul><p>于是我打算缩小图片尺寸，换成了表单项的识别，即在一个表单上识别出输入框、下拉框、文本框等。将尺寸缩小后，我在那台低配的台式机上训练了半个小时（没跑完），最终识别效果图如下：</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/2d708f7fec32820d1daec8087053804f.png" alt="image.png"></p><p>至少证明是可行的了。但是还有一些表单项没有识别出来，所以我继续缩小训练图片的尺寸，将七个表单项的识别换成三个，训练了一个小时（也是没跑完），测试了一下，可以全部识别出来了：</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/a3090c496957287e049199bd5110e939.png" alt="image.png"></p><h2 id="最终结论"><a href="#最终结论" class="headerlink" title="最终结论"></a>最终结论</h2><p>首先，整张设计稿的多组件识别是可行的，但是需要几个前提条件：</p><ul><li><p>有充足的 GPU 资源：如果你像我一样只有一台低配机器，那么精度高的模型，你跑都跑不动，显卡内存直接占满，程序崩溃。</p></li><li><p>有充足的设计稿素材：由于只是验证可行性，所以我只训练了十张图片，但是要达到很好的效果，至少得有一百张图片来训练，所以你得有足够多的设计稿素材。</p></li><li><p>有充足的人手和时间：训练 Object Detection 模型不像 Image Classification 那样简单，需要你手动标注位置，生成 xml 文件来给机器学习，这个工作非常无聊繁琐，所以如果要做，必须有足够多的人和时间。</p></li></ul><p>暂时就写这么多了，笔者研究较浅，请多多批评！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前不久，在集团内部做了一个 CR 系统，可以从设计稿上截图识别某个组件并给出代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/253b2a3479efb954c13d29c33ebde193.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是，我不想只是识别单个组件，最好能识别整张设计稿的多个组件。于是，花了两三天进行了这项技术的探索调研，并将过程记录下来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://www.liuyiqi.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow" scheme="http://www.liuyiqi.cn/tags/TensorFlow/"/>
    
      <category term="Object Detection API" scheme="http://www.liuyiqi.cn/tags/Object-Detection-API/"/>
    
      <category term="二值化" scheme="http://www.liuyiqi.cn/tags/%E4%BA%8C%E5%80%BC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>使用 render-react-components 来单独渲染每个 React 组件</title>
    <link href="http://www.liuyiqi.cn/2018/04/13/render-react-components/"/>
    <id>http://www.liuyiqi.cn/2018/04/13/render-react-components/</id>
    <published>2018-04-13T09:56:00.000Z</published>
    <updated>2018-04-24T20:03:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是如何使用 render-react-components 来单独渲染每个 React 组件。</p><a id="more"></a><h2 id="为何要单独渲染每个-React-组件？"><a href="#为何要单独渲染每个-React-组件？" class="headerlink" title="为何要单独渲染每个 React 组件？"></a>为何要单独渲染每个 React 组件？</h2><p>我之前参与了一位阿里前端专家架构的项目，这个项目的技术栈是 Angular1 ，经过几天的开发，我发现这是我来阿里后参与的开发体验最好的几个前端项目之一了。为何这么说呢？主要原因是这个项目使用了 Angular1 的指令（Angular1 的指令就是 Angular2 的组件，也等同于 React 的组件）将页面组件化，并且为每个单独的指令创建了一个 demo 页面，可以单独渲染展示每个指令。相当于一个复杂的项目被分为很多小项目，每个小项目都可以独立调试，这样的开发体验太好了！不仅如此，这么做还有很多好处：</p><ul><li>每个组件的 demo 页面也可以成为该组件的文档，方便别的前端同学快速掌握每个组件是干嘛的，这比在混杂在项目中清晰多了。</li><li>每个组件按道理都应该写单元测试的，如果我们能单独渲染每个 React 组件，相当于给每个组件进行了一次“看得见摸得着”的单元测试。</li><li>如果你喜欢写端对端测试，那么你可以对每个组件的 demo 页面进行完全模拟用户的端对端测试。</li><li>假如你编写的组件的父组件还没写出来，放到过去，你完全没招，只能等待，但现在每个组件都是可以单独开发调试的，再也不用受制于人，受制于环境了。</li><li>假如的项目特别庞大，运行一次，需要编译很久，那么你还可以使用 demo 页面来提升你的开发效率。</li><li>假如你的组件有很多种环境，但在项目中，只能模拟有限的环境，那么你可以在 demo 页面里自由的模拟各种环境，进行各种逻辑的开发。</li><li>……</li></ul><p>既然有这么多好处，然后我就想，在 React 项目中能不能也将项目中的每个小组件，单独渲染出来呢？答案是可以的，不过稍微麻烦一点，因为 React 组件不像 Angular1 那样可以直接在浏览器里面运行，需要编译一下，所以我就开发了一个名为 render-react-components 的命令行工具，帮我做这件事。</p><h2 id="render-react-components-是什么？"><a href="#render-react-components-是什么？" class="headerlink" title="render-react-components 是什么？"></a>render-react-components 是什么？</h2><p>render-react-components（简称 rrc） 是一个命令行工具，可以递归找出当前项目中所有的 React 组件（仅限于 src 目录下的所有组件），并为它们创建相互隔离的 demo 页面。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>使用 rrc 非常简单，只需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 本地或者全局安装</span></span><br><span class="line">$ npm i render-react-components -g</span><br><span class="line"></span><br><span class="line"><span class="comment">## 为项目中所有的 React 组件，创建 demo 页面</span></span><br><span class="line">$ rrc init</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果你只想给部分组件创建 demo 页面，可以使用 filter 参数，输入组件路径的关键词即可</span></span><br><span class="line">$ rrc init --filter=Component1</span><br><span class="line"><span class="comment">## 或者简写</span></span><br><span class="line">$ rrc init -f=Component1</span><br><span class="line"></span><br><span class="line"><span class="comment">## 本地开发，支持代码热加载</span></span><br><span class="line">$ rrc dev</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除了 rrc init 创建的所有文件</span></span><br><span class="line">$ rrc clean</span><br></pre></td></tr></table></figure><p>以下动图，演示了如何使用这个工具，先后做了这几件事：</p><ul><li>运行 <code>find . -name *.js</code> （<code>find</code> 命令和本工具无关，只是为了对比展示文件的变化）列出原始项目中的 js。</li><li>运行 <code>rrc init</code>，为项目中所有的 React 组件创建 demo 页面。再次运行 <code>find . -name *.js</code> 发现多了一些文件，不过放心，这只是一些 js、html 文件，不会给你添加多余的依赖，非常干净、非常隔离。</li><li>运行 <code>rrc dev</code> ，自动弹出一个页面，我们发现每个组件都可以展示了。并且，修改代码，页面会自动更新，非常方便。</li></ul><p><img src="https://img.alicdn.com/tfs/TB1VPzQnHGYBuNjy0FoXXciBFXa-894-444.gif" alt=""></p><h2 id="修改组件的-demo-页面"><a href="#修改组件的-demo-页面" class="headerlink" title="修改组件的 demo 页面"></a>修改组件的 demo 页面</h2><p>每个 React 组件的 props 都不同，需要我们单独编写。如果你想修改某个组件的 props ，只需要去项目根目录的 rrc 文件夹中找到组件对应的 demo 页面的入口文件即可。那么组件的对应的入口文件如何寻找呢？非常简单明了：</p><ul><li>假如一个组件的路径是 src/Component1.js，那么这个组件的入口文件的路径就是：rrc/Component1.js。</li><li>假如一个组件的路径是 src/Component2/index.js，那么这个组件的入口文件的路径就是：rrc/Component2.js。</li><li>假如一个组件的路径是 src/Component2/Component3/index.js，那么这个组件的入口文件的路径就是：rrc/Component2_Component3.js。</li></ul><h2 id="修改渲染组件的-webpack-配置"><a href="#修改渲染组件的-webpack-配置" class="headerlink" title="修改渲染组件的 webpack 配置"></a>修改渲染组件的 webpack 配置</h2><p>虽然在大多数情况下，你都不用操心 webpack 配置，但如果你实在想修改渲染组件的 webpack 配置，那么你可以直接在根目录下的 <code>.rrc.js</code> 中修改，具体配置可以在<a href="https://github.com/lewis617/render-react-components/blob/master/README_zh-cn.md#%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">这里</a>参考。</p><h2 id="真实小例子"><a href="#真实小例子" class="headerlink" title="真实小例子"></a>真实小例子</h2><p>上面动图中真实小例子可以在<a href="https://github.com/lewis617/render-react-components/tree/master/examples/dead-simple" target="_blank" rel="noopener">这里</a>找到。</p><p>本工具的 Github 地址： <a href="https://github.com/lewis617/render-react-components" target="_blank" rel="noopener">https://github.com/lewis617/render-react-components</a>，欢迎 star、提 issue 和 pull request。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，我们要讲的是如何使用 render-react-components 来单独渲染每个 React 组件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="单元测试" scheme="http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="React" scheme="http://www.liuyiqi.cn/tags/React/"/>
    
      <category term="render-react-components" scheme="http://www.liuyiqi.cn/tags/render-react-components/"/>
    
  </entry>
  
  <entry>
    <title>如何在端对端测试中模拟 HTTP 请求</title>
    <link href="http://www.liuyiqi.cn/2017/12/18/how-to-mock-http-in-e2e-testing/"/>
    <id>http://www.liuyiqi.cn/2017/12/18/how-to-mock-http-in-e2e-testing/</id>
    <published>2017-12-18T11:15:00.000Z</published>
    <updated>2017-12-20T02:49:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是如何在端对端测试中模拟 HTTP 请求。这个技术在复杂系统中非常实用，让我们一睹为快。</p><blockquote><p>注意，本文是给有一定端对端测试经验的测试工程师或前端工程师看的，如果你对端对端测试一无所知，请先阅读我之前写的<a href="http://www.liuyiqi.cn/tags/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95/">关于端对端测试的文章</a>。</p></blockquote><a id="more"></a><h2 id="复杂系统中的端对端测试的问题"><a href="#复杂系统中的端对端测试的问题" class="headerlink" title="复杂系统中的端对端测试的问题"></a>复杂系统中的端对端测试的问题</h2><p>最近想在公司内部一个非常复杂的后台系统中添加端对端测试。这个系统拥有很多页面，每个页面都有很多功能，在这些功能中，不仅涉及许多数据库操作，还包含一些对用户来说不可控的外部数据来源。给这样的系统添加端对端测试，我的内心是崩溃的，因为如果完全模拟用户操作，我会面临很多问题：</p><ul><li>把数据库搞得一团糟：添加很多乱数据，不小心删除一些关键数据（试想这些数据万一是巨额钱款呢？！）</li><li>因为一些不可控的外部数据，我的测试脚本面对的场景可能每次都不一样，可我的脚本却只有一份，也许今天脚本能跑，明天脚本就出错了。</li><li>在真实场景下，一些边界情况的逻辑往往测试不到，比如空数据，错误数据的处理等。</li></ul><h2 id="是否应该简化或放弃端对端测试？"><a href="#是否应该简化或放弃端对端测试？" class="headerlink" title="是否应该简化或放弃端对端测试？"></a>是否应该简化或放弃端对端测试？</h2><p>面对这些问题，我当时冒出了放弃的想法，我咨询了一些同事，他们有的人让我评估可行性、必要性，有的人说让端对端测试测一些简单的跨页功能即可，把复杂逻辑留给人工或单元测试。他们说的都很 reasonable。但我认为端对端测试还是有必要的，一些国外的大公司的端对端测试真的是测试了软件中用户所可能用到的每个功能。这确实是可行，而且有意义的，我们不应该偷懒或者放弃。</p><h2 id="面向前端集成的端对端测试"><a href="#面向前端集成的端对端测试" class="headerlink" title="面向前端集成的端对端测试"></a>面向前端集成的端对端测试</h2><p>我第一次接触端对端测试是在 Angular 中，于是我看了很多 Angular 中端对端测试的例子，发现很多人面对和我一样问题时，所采取的办法是模拟 HTTP 请求。有人会说，这还算端对端测试吗？这已经不是在完全模拟真实的用户场景了！这种做法只有在后端没有任何 bug 的前提下才是有效的……这些说法都是对的，模拟 HTTP 请求确实是一种 trade off。但作为前端工程师，这样的做法至少能保证我负责的前端系统被测试到了，而且是集成测试，这就够了！后端完全可以另写针对后端的集成测试。当然，模拟 HTTP 请求是在那种迫不得已的情况下才做的，如果你的系统比较简单，比如这些类型：</p><ul><li>纯展示型的页面，只是“查找”数据，比较安全。</li><li>通过用户操作或在你控制范围内的操作下，可以让数据形成闭环，比如你操作完后，所有的数据恢复如初，就像在沙盒里跑一样</li></ul><p>那么就无需模拟 HTTP 了，毕竟我们还是希望能尽量还原真实场景。</p><h2 id="端对端测试中模拟-HTTP-请求的几种方法"><a href="#端对端测试中模拟-HTTP-请求的几种方法" class="headerlink" title="端对端测试中模拟 HTTP 请求的几种方法"></a>端对端测试中模拟 HTTP 请求的几种方法</h2><p>好了，回归正题。那么如何在端对端测试中模拟 HTTP 请求？有几种方法：</p><ul><li>使用代理工具，比如 Charles 代理一些请求，进行模拟。这种方法太麻烦了，不仅要在浏览器上设置代理，还要在 Charles 中配置一堆东西。不推荐！</li><li>如果使用 Puppeteer 的话，使用 <code>request.continue</code> 重写一些请求的 url，指向别的链接。你可以自己搭建一个测试服务器进行重写。简单好用，推荐！</li><li>如果使用 Puppeteer 的话，使用 <code>request.respond</code> 拦截请求，并直接返回响应结果。简单好用，推荐！</li></ul><p>以上三种方法都是可行的，但是后两种更简单。其中，第二种适合那种拥有测试服务器的场景，你只需要对请求链接进行重定向即可。比如原来是 <code>a.com</code>，你将其改为 <code>b.com</code>。但这种方法还是不能非常灵活的模拟每个 case，这时候，第三种方法就更加推荐，你想返回什么都可以直接在函数中写出来。让我们快看看代码实现吧！</p><h2 id="真实例子"><a href="#真实例子" class="headerlink" title="真实例子"></a>真实例子</h2><p>介绍了背景和方法，我们来看下真实的例子！例子代码在这里：</p><p><a href="https://github.com/lewis617/fe-test/tree/master/puppeteer-demo/mock-demo" target="_blank" rel="external">https://github.com/lewis617/fe-test/tree/master/puppeteer-demo/mock-demo</a></p><p>先说下运行方法：将整个项目 clone 下来后在根目录（不是 mock-demo 这个目录哦）执行以下命令开启服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http-server -p 8081</div></pre></td></tr></table></figure><p>然后就可以在 <code>http://localhost:8081/puppeteer-demo/mock-demo</code>，看到程序了。</p><p><img src="https://wx1.sinaimg.cn/mw690/83900b4egy1fml6rd07n2j20n2074wet.jpg" alt=""></p><p>这个程序的功能是这样的：</p><p>1，在一个简单的 HTML 页面中进行 <code>data1.json</code> 这个文件的请求，并将 JSON 文件中的 <code>name</code> 字段的值显示在 <code>h1</code> 标签中。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">  fetch(<span class="string">'http://localhost:8081/puppeteer-demo/mock-demo/data1.json'</span>)</span></div><div class="line"><span class="javascript">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span></div><div class="line"><span class="javascript">    .then(<span class="function"><span class="params">json</span> =&gt;</span> <span class="built_in">document</span>.body.innerHTML = <span class="string">`&lt;h1&gt;<span class="subst">$&#123;json.name&#125;</span>&lt;/h1&gt;`</span>)</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>2，我们要做的是，运行 puppeteer，打开页面，并进行请求劫持，将 data1.json 的数据换成 data2.json 的数据。</p><p>另开一个终端，执行这些命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yarn</div><div class="line"></div><div class="line">npm <span class="built_in">test</span> -- mock-demo</div></pre></td></tr></table></figure><p>然后就会发现 Puppeteer 中显示的数据是 <code>data2</code>。</p><p><img src="https://wx1.sinaimg.cn/mw690/83900b4egy1fml6wsw1goj20oc090wfj.jpg" alt=""></p><p>我们看下测试脚本是如何进行拦截重写的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">await</span> page.setRequestInterception(<span class="literal">true</span>);</div><div class="line">page.on(<span class="string">'request'</span>, request =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (request.url.endsWith(<span class="string">'data1.json'</span>)) &#123;</div><div class="line">    request.continue(&#123;</div><div class="line">      url: <span class="string">'http://localhost:8081/puppeteer-demo/mock-demo/data2.json'</span></div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    request.continue();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>上述代码，先设置可以进行请求拦截：<code>await page.setRequestInterception(true);</code>。然后在 <code>request</code> 事件中进行 url 改写。另外，还可以换成 <code>request.respond</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">await</span> page.setRequestInterception(<span class="literal">true</span>);</div><div class="line">page.on(<span class="string">'request'</span>, request =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (request.url.endsWith(<span class="string">'data1.json'</span>)) &#123;</div><div class="line">    request.respond(&#123;</div><div class="line">      body: <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">name</span>: <span class="string">'data2'</span> &#125;)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    request.continue();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>就是这么简单。这太好用了！我们甚至可以在日常开发中也使用 Puppeteer 来模拟请求，不需要等待后端的工作。</p><h2 id="测试金字塔"><a href="#测试金字塔" class="headerlink" title="测试金字塔"></a>测试金字塔</h2><p>最后再聊一下端对端测试和单元测试的比例问题。谷歌的测试团队曾经提出过一个<a href="https://docs.google.com/presentation/d/15gNk21rjer3xo-b1ZqyQVGebOp_aPvHU3YH7YnOMxtE/edit#slide=id.g437663ce1_53_98" target="_blank" rel="external">测试金字塔的概念</a>。大概就是单元测试应该最多，然后是集成测试（部分单元之间的集成，不像端对端那样完全黑盒），最少的应该是端对端测试：</p><p><img src="https://ws1.sinaimg.cn/mw690/83900b4egy1fml7bqxe25j20al095t8v.jpg" alt=""></p><p>为何会这样呢？因为他们认为端对端测试不能像单元测试那样快速的定位问题所在，端对端测试所发现的问题，可能存在系统中的任何位置，但单元测试的反馈定位就更加直接准确。另外，单元测试写起来更加简单快速，而端对端测试则需要整个系统部署好之后才能测试，这样比较慢，毕竟有时候开发周期还是很长的，人家开发一周前写完的代码，你现在才开始测试，有点拖后腿。以上说法非常有道理，我也认为单元测试非常好，但是端对端测试也是有意义的，它可以检测出所有单元连接后的问题，这些问题只能通过端对端测试才能测出来。所以，两者都要写，不要怕麻烦，后期的收益是很大的！</p><h2 id="更多测试文章："><a href="#更多测试文章：" class="headerlink" title="更多测试文章："></a>更多测试文章：</h2><p><a href="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，我们要讲的是如何在端对端测试中模拟 HTTP 请求。这个技术在复杂系统中非常实用，让我们一睹为快。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，本文是给有一定端对端测试经验的测试工程师或前端工程师看的，如果你对端对端测试一无所知，请先阅读我之前写的&lt;a href=&quot;http://www.liuyiqi.cn/tags/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95/&quot;&gt;关于端对端测试的文章&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Puppeteer" scheme="http://www.liuyiqi.cn/tags/Puppeteer/"/>
    
      <category term="测试" scheme="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="端对端测试" scheme="http://www.liuyiqi.cn/tags/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95/"/>
    
      <category term="e2e" scheme="http://www.liuyiqi.cn/tags/e2e/"/>
    
  </entry>
  
  <entry>
    <title>端对端测试中常用的 Puppeteer 操作总结</title>
    <link href="http://www.liuyiqi.cn/2017/12/05/common-puppeteer-api-collection/"/>
    <id>http://www.liuyiqi.cn/2017/12/05/common-puppeteer-api-collection/</id>
    <published>2017-12-05T06:51:00.000Z</published>
    <updated>2017-12-18T12:47:22.153Z</updated>
    
    <content type="html"><![CDATA[<p>上篇博客我们讲解了<a href="http://www.liuyiqi.cn/2017/12/05/e2e-testing-with-jest-and-puppeteer/">《使用 Jest 与 Puppeteer 来进行端对端测试》</a>，但内容偏向于“快速开始”这种风格，并不涉及一些具体的、实用的操作，所以本篇博客将会补充这一点，即，总结一下端对端测试中常用的 Puppeteer 操作，比如模拟用户输入、执行 JavaScript 脚本、获取某个 DOM 节点中的文本等。</p><a id="more"></a><h2 id="让所有操作可见"><a href="#让所有操作可见" class="headerlink" title="让所有操作可见"></a>让所有操作可见</h2><p>还记得上篇博客中的端对端测试的动图演示吗？</p><p><img src="https://wx2.sinaimg.cn/large/83900b4egy1fm5wgcwvylg20af0jn7wh.gif" alt=""></p><p>想实现这个效果，就需要将 Puppeteer 的 <code>headless</code> 选项设为 <code>false</code>，并将 <code>slowMo</code> 设为 20-100 中的某个值，前者使得所有浏览器自动化操作可见，后者控制了动作之间的间隔，使其变慢，从而通过人眼可以看清每步操作。示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">browser = <span class="keyword">await</span> puppeteer.launch(&#123;</div><div class="line">    headless: <span class="literal">false</span>,</div><div class="line">    slowMo: <span class="number">20</span></div><div class="line">  &#125;);</div></pre></td></tr></table></figure><h2 id="导航到某个页面"><a href="#导航到某个页面" class="headerlink" title="导航到某个页面"></a>导航到某个页面</h2><p>这个操作太常用了！第一步是启动浏览器，那么第二步就是导航到某个页面，代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">page = <span class="keyword">await</span> browser.newPage();</div><div class="line"><span class="keyword">await</span> page.goto(<span class="string">'https://baidu.com'</span>);</div></pre></td></tr></table></figure><p>上述代码会开启一个新页面，并将其导航到 <code>https://baidu.com</code>。</p><h2 id="等待某个-DOM-节点出现"><a href="#等待某个-DOM-节点出现" class="headerlink" title="等待某个 DOM 节点出现"></a>等待某个 DOM 节点出现</h2><p>在进行某些页面操作前，我们必须要等待指定的 DOM 加载完成后才能操作，比如，一个 Input 没有加载出来时，你是无法在里面输入字符的等等。在 Puppeteer 中，你可以使用 <code>page.waitForSelector</code> 和选择器来等待某个 DOM 节点出现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">await</span> page.waitForSelector(<span class="string">'#loginForm'</span>);</div></pre></td></tr></table></figure><p>上述代码会等待 ID 为 <code>loginForm</code> 的节点出现。</p><h2 id="等待几毫秒"><a href="#等待几毫秒" class="headerlink" title="等待几毫秒"></a>等待几毫秒</h2><p>有时候，你找不到某个特定的时刻，只能通过时间间隔来确定，那么此时你可以使用 <code>page.waitFor(number)</code> 来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">await</span> page.waitFor(<span class="number">500</span>);</div></pre></td></tr></table></figure><p>上述代码会等待 500 毫秒。</p><h2 id="等待某个-JavaScript-函数返回-true"><a href="#等待某个-JavaScript-函数返回-true" class="headerlink" title="等待某个 JavaScript 函数返回 true"></a>等待某个 JavaScript 函数返回 true</h2><p>有时候，你需要等待某个复杂的时刻，这个时刻只能通过一些复杂的 JavaScript 函数来判断，那么此时你可以使用 <code>page.waitFor(Function)</code> 来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">await</span> page.waitFor(<span class="function"><span class="params">()</span> =&gt;</span> !<span class="built_in">document</span>.querySelector(<span class="string">'.ant-spin.ant-spin-spinning'</span>));</div></pre></td></tr></table></figure><p>上述代码会等待 Antd 中的旋转图标消失。</p><h2 id="向某个-Input-中输入字符"><a href="#向某个-Input-中输入字符" class="headerlink" title="向某个 Input 中输入字符"></a>向某个 Input 中输入字符</h2><p>为了模拟用户登陆或仅仅就是输入某个表单，我们经常会向某个 Input 中输入字符，那么我们可以使用这个方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">await</span> page.type(<span class="string">'#username'</span>, <span class="string">'lewis'</span>);</div></pre></td></tr></table></figure><p>上述代码向 ID 为 <code>username</code> 的 Input 中输入了 <code>lewis</code>。值得一提的是，该方法还会触发 Input 的 <code>keydown</code>、<code>keypress</code>, 和 <code>keyup</code> 事件，所以如果你有该事件的相关功能，也会被测试到哦，是不是很强大？</p><h2 id="点击某个节点"><a href="#点击某个节点" class="headerlink" title="点击某个节点"></a>点击某个节点</h2><p>在 Puppeteer 中模拟点击某个节点，非常简单，只需要：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">await</span> page.click(<span class="string">'#btn-submit'</span>);</div></pre></td></tr></table></figure><p>上述代码点击了 ID 为 <code>btn-submit</code> 的节点。</p><h2 id="在浏览器中执行一段-JavaScript-代码"><a href="#在浏览器中执行一段-JavaScript-代码" class="headerlink" title="在浏览器中执行一段 JavaScript 代码"></a>在浏览器中执行一段 JavaScript 代码</h2><p>有时候我们需要在浏览器中执行一段 JavaScript 代码，此时你可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> alert(<span class="string">'1'</span>));</div></pre></td></tr></table></figure><p>上述代码会在浏览器执行 <code>alert(&#39;1&#39;)</code>。</p><h2 id="获取某一个节点的某个属性"><a href="#获取某一个节点的某个属性" class="headerlink" title="获取某一个节点的某个属性"></a>获取某一个节点的某个属性</h2><p>有时候我们需要获取某个 Input 的 <code>value</code>，某个链接的 <code>href</code>，某个节点的文本 <code>textContent</code>，或者 <code>outerHTML</code>，那么你可以使用这个方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> searchValue = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">'#search'</span>, el =&gt; el.value);</div><div class="line"><span class="keyword">const</span> preloadHref = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">'link[rel=preload]'</span>, el =&gt; el.href);</div><div class="line"><span class="keyword">const</span> text = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">'.text'</span>, el =&gt; el.textContent);</div><div class="line"><span class="keyword">const</span> html = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">'.main-container'</span>, e =&gt; e.outerHTML);</div></pre></td></tr></table></figure><h2 id="获取某一类节点的某个属性集合"><a href="#获取某一类节点的某个属性集合" class="headerlink" title="获取某一类节点的某个属性集合"></a>获取某一类节点的某个属性集合</h2><p>有时候我们需要获取某一类节点的某个属性集合，那么你可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> textArray = <span class="keyword">await</span> page.$$<span class="built_in">eval</span>(<span class="string">'.text'</span>, els =&gt; <span class="built_in">Array</span>.from(els).map(<span class="function"><span class="params">el</span> =&gt;</span> el.textContent));</div></pre></td></tr></table></figure><p>上述代码将页面中所有类为 <code>text</code> 的节点中的文本拼装为数组放到了 <code>textArray</code> 中。</p><p>以上就是 Puppeteer 的一些常用操作，当然仅仅掌握这些是不够的，更多的操作请参考 Puppeteer 的 API 文档：</p><p><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md" target="_blank" rel="external">https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md</a></p><h2 id="综合应用小例子"><a href="#综合应用小例子" class="headerlink" title="综合应用小例子"></a>综合应用小例子</h2><p>单个操作讲了这么多，我们来进行一次综合应用吧！我们依次让浏览器进行以下自动化操作：</p><ul><li>打开百度首页</li><li>输入<code>刘一奇的个人博客</code></li><li>点击搜索按钮</li><li>点击第一个搜索项</li><li>进入<code>刘一奇的个人博客</code></li><li>断言新页面的 <code>logo</code> 为<code>刘一奇的个人博客</code></li><li>断言新页面的导航栏包括：<code>主页,归档,关于我</code> 三项</li></ul><p>示例代码： </p><p><a href="https://github.com/lewis617/fe-test/blob/master/puppeteer-demo/liuyiqi-blog.test.js" target="_blank" rel="external">https://github.com/lewis617/fe-test/blob/master/puppeteer-demo/liuyiqi-blog.test.js</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> browser, page;</div><div class="line"></div><div class="line">beforeAll(<span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  browser = <span class="keyword">await</span> puppeteer.launch(&#123;</div><div class="line">    headless: <span class="literal">false</span>,</div><div class="line">    slowMo: <span class="number">80</span></div><div class="line">  &#125;);</div><div class="line">  page = <span class="keyword">await</span> browser.newPage();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">afterAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  browser.close();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">test(<span class="string">'open baidu page'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://baidu.com'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">test(<span class="string">'search liuiqi\'s blog'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">await</span> page.waitForSelector(<span class="string">'#kw'</span>);</div><div class="line">  <span class="keyword">await</span> page.type(<span class="string">'#kw'</span>, <span class="string">'刘一奇的个人博客'</span>);</div><div class="line">  <span class="keyword">await</span> page.click(<span class="string">'#su'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">test(<span class="string">'goto liuyiqi\'s blog'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">await</span> page.waitForSelector(<span class="string">'h3.t &gt; a'</span>);</div><div class="line">  <span class="keyword">await</span> page.click(<span class="string">'h3.t:nth-of-type(1) &gt; a'</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> pages = <span class="keyword">await</span> browser.pages();</div><div class="line">  page = pages.pop();</div><div class="line">  <span class="keyword">await</span> page.bringToFront();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">test(<span class="string">'expect logo is 刘一奇的个人博客'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">await</span> page.waitForSelector(<span class="string">'#logo'</span>);</div><div class="line">  <span class="keyword">const</span> text = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">'#logo'</span>, el =&gt; el.textContent)</div><div class="line">  expect(text).toBe(<span class="string">'刘一奇的个人博客'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">test(<span class="string">'expect main-nav-link is 主页,归档,关于我'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> textArray = <span class="keyword">await</span> page.$$<span class="built_in">eval</span>(<span class="string">'.main-nav-link'</span>, els =&gt; <span class="built_in">Array</span>.from(els).map(<span class="function"><span class="params">el</span> =&gt;</span> el.textContent));</div><div class="line">  expect(textArray).toEqual([<span class="string">'主页'</span>, <span class="string">'归档'</span>, <span class="string">'关于我'</span>]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://wx1.sinaimg.cn/large/83900b4egy1fm5zpm2qleg20o10jnqn5.gif" alt=""></p><p>至此，端对端测试中常用的 Puppeteer 操作总结就讲完了。有更多操作请查阅官网文档，或给我发邮件，或在本文下方评论。</p><h2 id="更多测试文章："><a href="#更多测试文章：" class="headerlink" title="更多测试文章："></a>更多测试文章：</h2><p><a href="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇博客我们讲解了&lt;a href=&quot;http://www.liuyiqi.cn/2017/12/05/e2e-testing-with-jest-and-puppeteer/&quot;&gt;《使用 Jest 与 Puppeteer 来进行端对端测试》&lt;/a&gt;，但内容偏向于“快速开始”这种风格，并不涉及一些具体的、实用的操作，所以本篇博客将会补充这一点，即，总结一下端对端测试中常用的 Puppeteer 操作，比如模拟用户输入、执行 JavaScript 脚本、获取某个 DOM 节点中的文本等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Puppeteer" scheme="http://www.liuyiqi.cn/tags/Puppeteer/"/>
    
      <category term="测试" scheme="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="端对端测试" scheme="http://www.liuyiqi.cn/tags/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95/"/>
    
      <category term="e2e" scheme="http://www.liuyiqi.cn/tags/e2e/"/>
    
  </entry>
  
  <entry>
    <title>使用 Jest 与 Puppeteer 来进行端对端测试</title>
    <link href="http://www.liuyiqi.cn/2017/12/05/e2e-testing-with-jest-and-puppeteer/"/>
    <id>http://www.liuyiqi.cn/2017/12/05/e2e-testing-with-jest-and-puppeteer/</id>
    <published>2017-12-05T02:07:00.000Z</published>
    <updated>2017-12-18T12:47:30.773Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们要讲的是如何使用 Jest 与 Puppeteer 来进行端对端测试（e2e testing）。</p><a id="more"></a><h2 id="端对端测试-vs-单元测试"><a href="#端对端测试-vs-单元测试" class="headerlink" title="端对端测试 vs. 单元测试"></a>端对端测试 vs. 单元测试</h2><p>在前面<a href="http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">很多文章</a>中，我们都介绍了单元测试。如果你了解单元测试，或者读过我之前写的单元测试的文章，那么你一定知道，单元测试的测试对象是单独的、隔离的小代码片段或者代码单元。与单元测试不同，端对端测试的测试对象则是页面上的用户交互，我们对底层实现一无所知，也就是说我们的测试是黑盒的。另外，一些跨页测试，比如链接检查，登陆跳转等功能必须使用端对端测试才能检查出来，单元测试是无法测这些功能的。以前我只写单元测试，不写端对端测试，结果有一次所负责的页面上有个链接不能点了，还好及时修复，但还是让我感受到了端对端测试，或者说是自动化端对端测试的重要性。这是我在物流服务中做的端对端测试演示：</p><p><img src="https://wx2.sinaimg.cn/large/83900b4egy1fm5wgcwvylg20af0jn7wh.gif" alt=""></p><p>话不多说，让我们开始学习端对端测试吧！</p><blockquote><p>Puppeteer 默认情况下，所有操作是不可见的，如果你想像我这样监视发生的一切，需要将 Puppeteer 的 <code>headless</code> 选项设为 <code>false</code>，具体操作将会在<a href="http://www.liuyiqi.cn/2017/12/05/common-puppeteer-api-collection/">下篇博文</a>中介绍。</p></blockquote><h2 id="使用-Puppeteer-进行浏览器自动化"><a href="#使用-Puppeteer-进行浏览器自动化" class="headerlink" title="使用 Puppeteer 进行浏览器自动化"></a>使用 Puppeteer 进行浏览器自动化</h2><p>我使用过很多端对端测试的轮子，比如 Selenium、Appium、Protractor、Zombie.js、Cypress、Nightmare、Puppeteer 等。但最终还是选择了 Puppeteer，因为 Selenium 和 Appium 太难用了，Protractor 则像是专门给 Angular 设计的，Zombie.js 太简单了，而且使用的浏览器内核不是市面上流行的任何一个，而是自定义的。Cypress 有平台依赖，我只是想要个本地运行的工具而已。只剩 Nightmare 和 Puppeteer 了，其实这两个都是好选择，但是我是个 star 控，Puppeteer 的 star 比 Nightmare 多，所以我选择了 Puppeteer。但事实上 Nightmare 更流行，因为我发现蚂蚁最新的那个 Antd Pro 就是用的 Nightmare，阿里一些其他端对端测试的工具也有基于 Nightmare 来做的。所以如果你想使用 Nightmare 来进行自动化端对端测试也是完全没有问题的。</p><p>使用 Puppeteer 非常简单，首先安装它：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yarn add puppeteer</div><div class="line"><span class="comment"># or "npm i puppeteer"</span></div></pre></td></tr></table></figure><p>然后就可以在 Node 脚本中使用它了！来个简单的导航并截屏例子吧！这个例子先启动浏览器，导航到 <code>https://baidu.com</code> 页面，然后截屏并保存为 <code>baidu.png</code>，最后关闭浏览器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</div><div class="line"></div><div class="line">(<span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</div><div class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</div><div class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://baidu.com'</span>);</div><div class="line">  <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'baidu.png'</span>&#125;);</div><div class="line"></div><div class="line">  <span class="keyword">await</span> browser.close();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>将上述代码写进 Node 脚本中，并运行就可以了！看下生成的截图：</p><p><img src="https://ws4.sinaimg.cn/large/83900b4egy1fm5t4ehv5pj20m80gomxw.jpg" alt="image"></p><p>是不是很简单？短短几行代码就做了这么多事。如果你对 <code>async</code>、<code>await</code> 这种语法不熟悉，那么我强烈建议你去学习一下，这种语法在 Puppeteer 中使用率简直不要太高。不过也不要担心学习成本， <code>async</code>、<code>await</code> 语法非常简单，就是 Promise 的一种新写法而已，让你的异步代码看起来就像是同步的一样。</p><h2 id="使用-Jest-来进行测试"><a href="#使用-Jest-来进行测试" class="headerlink" title="使用 Jest 来进行测试"></a>使用 Jest 来进行测试</h2><p>要知道，Puppeteer 是一个浏览器自动化工具，它只能进行浏览器的自动化，本身并不具有测试功能。我说的测试功能指的是，断言啊，生成测试报告啊这些功能。如果你不熟悉这些概念，那么请移步：<a href="http://www.liuyiqi.cn/2017/02/15/start-jest/">《Jest 单元测试入门》</a>。所以，除了 Puppeteer 外，我们还需要使用一个测试工具，我选择了 Jest，理由在<a href="http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">之前的博文中</a>已经说过很多遍了，这里不再赘述。使用 Jest 非常简单，只需要</p><ul><li>安装 Jest</li><li>编写测试脚本 *.test.js</li><li>最后在终端中输入 jest 命令运行测试</li></ul><p>具体用法看之前的博文：<a href="http://www.liuyiqi.cn/2017/02/15/start-jest/">《Jest 单元测试入门》</a>。</p><h2 id="将-Jest-与-Puppeteer-结合使用"><a href="#将-Jest-与-Puppeteer-结合使用" class="headerlink" title="将 Jest 与 Puppeteer 结合使用"></a>将 Jest 与 Puppeteer 结合使用</h2><p>讲完了 Puppeteer 和 Jest 的基本用法，我们来看一下，如何将两者结合起来使用。其实将 Jest 与 Puppeteer 结合使用非常简单，因为 Puppeteer 的本质就是个 NPM 模块而已，所以我们只需要在 Jest 测试脚本中引入它即可使用了。为何如此呢？因为测试脚本的本质其实也是 Node 脚本，既然是 Node 脚本那么当然可以直接引入 NPM 模块来用了！</p><blockquote><p>需要注意的是，因为 Puppeteer 通常需要使用 <code>async</code>、<code>await</code> 这种语法，如果你的 Node 版本在7.6及以上，那么恭喜你，直接大胆使用，否则需要在 Jest 中配置 Babel，来使其支持这种新语法。在 Jest 中配置 Babel 非常简单，你可以在<a href="http://facebook.github.io/jest/docs/en/getting-started#using-babel" target="_blank" rel="external">这里</a>找到具体方法。</p></blockquote><p>让我们来个小例子吧！首先，我们打开百度页面，并断言百度页面的 <code>title</code> 是 <code>百度一下，你就知道</code>。那么测试脚本应该这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</div><div class="line"></div><div class="line">test(<span class="string">'baidu title is correct'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</div><div class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</div><div class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://baidu.com'</span>);</div><div class="line">  <span class="keyword">const</span> title = <span class="keyword">await</span> page.title();</div><div class="line">  expect(title).toBe(<span class="string">'百度一下，你就知道'</span>);</div><div class="line">  <span class="keyword">await</span> browser.close();</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>看到 <code>test</code> 和 <code>expect</code> 两个全局函数了吗？这就是 Jest 所赋予的能力，让你可以编写测试用例和断言。最后在命令行输入 <code>npm test</code>，即 <code>jest</code>（这是在 package.json 中配置好的命令），即可看到生成的测试报告：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ npm <span class="built_in">test</span></div><div class="line"></div><div class="line">&gt; fe-test@1.0.0 <span class="built_in">test</span> /Users/liuyiqi/code/fe-test</div><div class="line">&gt; jest</div><div class="line"></div><div class="line"> PASS  puppeteer-demo/baidu-title.test.js</div><div class="line"> PASS  puppeteer-demo/screenshot.test.js</div><div class="line"></div><div class="line">Test Suites: 2 passed, 2 total</div><div class="line">Tests:       2 passed, 2 total</div><div class="line">Snapshots:   0 total</div><div class="line">Time:        3.241s</div><div class="line">Ran all <span class="built_in">test</span> suites.</div></pre></td></tr></table></figure><p>其中 <code>screenshot.test.js</code> 是截屏的那个例子，<code>baidu-title.test.js</code> 是断言百度首页 title 的例子。你可以在这里找到源码：</p><p><a href="https://github.com/lewis617/fe-test/tree/master/puppeteer-demo" target="_blank" rel="external">https://github.com/lewis617/fe-test/tree/master/puppeteer-demo</a></p><p>至此，使用 Jest 与 Puppeteer 来进行端对端测试的基本用法就讲完了。下篇博文我们将会集中讲解常用 Puppeteer 功能，比如模拟用户输入、执行 JavaScript 脚本、获取某个 DOM 节点中的文本等。</p><h2 id="更多测试文章："><a href="#更多测试文章：" class="headerlink" title="更多测试文章："></a>更多测试文章：</h2><p><a href="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们要讲的是如何使用 Jest 与 Puppeteer 来进行端对端测试（e2e testing）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Puppeteer" scheme="http://www.liuyiqi.cn/tags/Puppeteer/"/>
    
      <category term="测试" scheme="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="端对端测试" scheme="http://www.liuyiqi.cn/tags/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95/"/>
    
      <category term="e2e" scheme="http://www.liuyiqi.cn/tags/e2e/"/>
    
      <category term="Jest" scheme="http://www.liuyiqi.cn/tags/Jest/"/>
    
      <category term="黑盒测试" scheme="http://www.liuyiqi.cn/tags/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何测试 DOM 操作类的 JS 代码</title>
    <link href="http://www.liuyiqi.cn/2017/11/09/how-to-test-dom-manipulation/"/>
    <id>http://www.liuyiqi.cn/2017/11/09/how-to-test-dom-manipulation/</id>
    <published>2017-11-09T03:05:00.000Z</published>
    <updated>2017-11-14T08:33:09.711Z</updated>
    
    <content type="html"><![CDATA[<p>前几天写了一篇博客：<a href="http://www.liuyiqi.cn/2017/11/03/use-js-to-get-weibo-comments/">《使用 JavaScript 批量获取微博评论》</a>。今天我们来学习如何测试我们之前编写的代码。从本质上来说，我们今天要学习的是如何测试 DOM 操作类的 JS 代码。你可以在这里获取测试代码：</p><p><a href="https://github.com/lewis617/practical-js/blob/master/src/weiboBackup.test.js" target="_blank" rel="external">https://github.com/lewis617/practical-js/blob/master/src/weiboBackup.test.js</a></p><a id="more"></a><h2 id="选择测试框架"><a href="#选择测试框架" class="headerlink" title="选择测试框架"></a>选择测试框架</h2><p>我使用过很多测试框架，比如 Karma、Mocha、Jest 等，但因为对 Facebook 开源项目的偏爱，我选择了 Jest 来测试，事实证明，Jest 确实最为简单，无需进行繁琐的浏览器环境模拟，就可以直接使用浏览器环境的各种 API，让我们一睹为快！不过先安装 Jest：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yarn add --dev jest</div></pre></td></tr></table></figure><h2 id="处理被测试文件"><a href="#处理被测试文件" class="headerlink" title="处理被测试文件"></a>处理被测试文件</h2><p>被测试文件原来是这样的：</p><p>weiboBackup.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 获取微博以及评论文字</span></div><div class="line"><span class="comment"> * 先打开微博页面，</span></div><div class="line"><span class="comment"> * 然后将下面的js拷贝到浏览器的console面板中</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> nodeArray = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'.list_con .WB_text'</span>));</div><div class="line"></div><div class="line"><span class="keyword">var</span> textArray = nodeArray.map(<span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(node.childNodes).map(<span class="function"><span class="keyword">function</span> (<span class="params">childNode</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> value;</div><div class="line">    <span class="comment">// 文字的情况</span></div><div class="line">    <span class="keyword">if</span> (childNode.nodeName === <span class="string">'#text'</span>) value = childNode.nodeValue;</div><div class="line">    <span class="comment">// 图片表情的情况</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (childNode.nodeName === <span class="string">'IMG'</span>) value = childNode.alt;</div><div class="line">    <span class="comment">// 链接的情况</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (childNode.nodeName === <span class="string">'A'</span>) value = childNode.lastChild.nodeValue;</div><div class="line">    <span class="keyword">return</span> value.replace(<span class="regexp">/(\s+$)|(^\s+)/g</span>, <span class="string">''</span>);</div><div class="line">  &#125;).join(<span class="string">''</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(textArray.join(<span class="string">'\n'</span>));</div></pre></td></tr></table></figure><p>为了方便测试，我们在底部添加一行代码，将其导出，方便测试。另外，为了让测试报告更纯净，我们把 console 注释掉：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// console.log(textArray.join('\n'));</span></div><div class="line"></div><div class="line"><span class="comment">// 本行代码用于单元测试，请不要拷贝到浏览器的console中运行</span></div><div class="line"><span class="built_in">module</span>.exports = textArray;</div></pre></td></tr></table></figure><h2 id="编写测试文件"><a href="#编写测试文件" class="headerlink" title="编写测试文件"></a>编写测试文件</h2><p>前面说了 Jest 自带浏览器模拟环境，无需手动配置。所以我们直接添加用于测试的 html 即可：</p><blockquote><p>这段 html 字符串相当于模拟数据，即假数据。在这里，相当于模拟一个微博评论。模拟数据你可以随意编写，但是通常需要和真实数据保持结构和规律上的一致，而且需要覆盖所有的情况，这样才能测试到所有的边界。</p></blockquote><p>weiboBackup.test.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">'\</span></div><div class="line"><span class="string">  &lt;div class="list_con"&gt;\</span></div><div class="line"><span class="string">    &lt;div class="WB_text"&gt;\</span></div><div class="line"><span class="string">      &lt;a target="_blank" href="//weibo.com/2809324184" usercard="id=2809324184"&gt;Geo橙子&lt;/a&gt;：在过一阵子是不是要翻成英文，走出国门了\</span></div><div class="line"><span class="string">    &lt;/div&gt;\</span></div><div class="line"><span class="string">    &lt;div class="WB_text"&gt;\</span></div><div class="line"><span class="string">      &lt;a target="_blank" href="//weibo.com/2497287343" usercard="id=2497287343"&gt;dev_zk&lt;/a&gt;\</span></div><div class="line"><span class="string">      &lt;a target="_blank" suda-data="key=pc_apply_entry&amp;amp;value=feed_icon" href="http://club.weibo.com/intro"&gt;\</span></div><div class="line"><span class="string">        &lt;i title="微博达人" class="W_icon icon_club" node-type="daren"&gt;&lt;/i&gt;\</span></div><div class="line"><span class="string">      &lt;/a&gt;\</span></div><div class="line"><span class="string">      ：现在好了\</span></div><div class="line"><span class="string">      &lt;img render="ext" src="//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif" title="[太开心]" alt="[太开心]" type="face"&gt;\</span></div><div class="line"><span class="string">      &lt;img render="ext" src="//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif" title="[太开心]" alt="[太开心]" type="face"&gt;\</span></div><div class="line"><span class="string">    &lt;/div&gt;\</span></div><div class="line"><span class="string">    &lt;div class="WB_text"&gt;\</span></div><div class="line"><span class="string">      &lt;a target="_blank" href="//weibo.com/2497287343" usercard="id=2497287343"&gt;dev_zk&lt;/a&gt;\</span></div><div class="line"><span class="string">      &lt;a target="_blank" suda-data="key=pc_apply_entry&amp;amp;value=feed_icon" href="http://club.weibo.com/intro"&gt;\</span></div><div class="line"><span class="string">      &lt;i title="微博达人" class="W_icon icon_club" node-type="daren"&gt;&lt;/i&gt;\</span></div><div class="line"><span class="string">      &lt;/a&gt;\</span></div><div class="line"><span class="string">      ：哈哈\</span></div><div class="line"><span class="string">    &lt;/div&gt;\</span></div><div class="line"><span class="string">  &lt;/div&gt;'</span>;</div></pre></td></tr></table></figure><p>然后直接调用被测试文件 weiboBackup.js，相当于运行了它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> textArray = <span class="built_in">require</span>(<span class="string">'./weiboBackup'</span>);</div></pre></td></tr></table></figure><p>现在评论文本已经被保存到数组 <code>textArray</code> 中了，然后我们直接编写断言即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">expect(textArray).toEqual([</div><div class="line">    <span class="string">"Geo橙子：在过一阵子是不是要翻成英文，走出国门了"</span>,</div><div class="line">    <span class="string">"dev_zk：现在好了[太开心][太开心]"</span>,</div><div class="line">    <span class="string">"dev_zk：哈哈"</span>,</div><div class="line">  ]);</div></pre></td></tr></table></figure><blockquote><p>关于断言等测试的基础知识，如果你不了解，请看我之前写的 <a href="http://www.liuyiqi.cn/2017/02/15/start-jest/">《Jest 单元测试入门》</a>。</p></blockquote><p>最后我们将上述代码包在 <code>test</code> 函数中，这个函数用于打包一个测试用例，并附带测试用例说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">test(<span class="string">'getweiboBackup'</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">document</span>.body.innerHTML = <span class="string">'\</span></div><div class="line"><span class="string">  &lt;div class="list_con"&gt;\</span></div><div class="line"><span class="string">    &lt;div class="WB_text"&gt;\</span></div><div class="line"><span class="string">      &lt;a target="_blank" href="//weibo.com/2809324184" usercard="id=2809324184"&gt;Geo橙子&lt;/a&gt;：在过一阵子是不是要翻成英文，走出国门了\</span></div><div class="line"><span class="string">    &lt;/div&gt;\</span></div><div class="line"><span class="string">    &lt;div class="WB_text"&gt;\</span></div><div class="line"><span class="string">      &lt;a target="_blank" href="//weibo.com/2497287343" usercard="id=2497287343"&gt;dev_zk&lt;/a&gt;\</span></div><div class="line"><span class="string">      &lt;a target="_blank" suda-data="key=pc_apply_entry&amp;amp;value=feed_icon" href="http://club.weibo.com/intro"&gt;\</span></div><div class="line"><span class="string">        &lt;i title="微博达人" class="W_icon icon_club" node-type="daren"&gt;&lt;/i&gt;\</span></div><div class="line"><span class="string">      &lt;/a&gt;\</span></div><div class="line"><span class="string">      ：现在好了\</span></div><div class="line"><span class="string">      &lt;img render="ext" src="//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif" title="[太开心]" alt="[太开心]" type="face"&gt;\</span></div><div class="line"><span class="string">      &lt;img render="ext" src="//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif" title="[太开心]" alt="[太开心]" type="face"&gt;\</span></div><div class="line"><span class="string">    &lt;/div&gt;\</span></div><div class="line"><span class="string">    &lt;div class="WB_text"&gt;\</span></div><div class="line"><span class="string">      &lt;a target="_blank" href="//weibo.com/2497287343" usercard="id=2497287343"&gt;dev_zk&lt;/a&gt;\</span></div><div class="line"><span class="string">      &lt;a target="_blank" suda-data="key=pc_apply_entry&amp;amp;value=feed_icon" href="http://club.weibo.com/intro"&gt;\</span></div><div class="line"><span class="string">      &lt;i title="微博达人" class="W_icon icon_club" node-type="daren"&gt;&lt;/i&gt;\</span></div><div class="line"><span class="string">      &lt;/a&gt;\</span></div><div class="line"><span class="string">      ：哈哈\</span></div><div class="line"><span class="string">    &lt;/div&gt;\</span></div><div class="line"><span class="string">  &lt;/div&gt;'</span>;</div><div class="line">  <span class="keyword">var</span> textArray = <span class="built_in">require</span>(<span class="string">'./weiboBackup'</span>);</div><div class="line">  expect(textArray).toEqual([</div><div class="line">    <span class="string">"Geo橙子：在过一阵子是不是要翻成英文，走出国门了"</span>,</div><div class="line">    <span class="string">"dev_zk：现在好了[太开心][太开心]"</span>,</div><div class="line">    <span class="string">"dev_zk：哈哈"</span>,</div><div class="line">  ]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>测试文件写好了，我们需要运行它，首先在 package.json 中添加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">  "test": "jest"</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后在命令行中运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="built_in">test</span></div></pre></td></tr></table></figure><p>最后就会看测试报告了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> PASS  ./weiboBackup.test.js</div><div class="line">  ✓ getweiboBackup (27ms)</div><div class="line"></div><div class="line">Test Suites: 1 passed, 1 total</div><div class="line">Tests:       1 passed, 1 total</div><div class="line">Snapshots:   0 total</div><div class="line">Time:        0.907s, estimated 1s</div></pre></td></tr></table></figure><p>尝试改变 html 中的测试文本，或断言中的预期文本，看看预期与结果不一致的情况。比如，将断言改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expect(textArray).toEqual([]);</div></pre></td></tr></table></figure><p>结果测试报告变为这样：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"> FAIL  ./weiboBackup.test.js</div><div class="line">  ✕ getweiboBackup (310ms)</div><div class="line"></div><div class="line">  ● getweiboBackup</div><div class="line"></div><div class="line">    expect(received).toEqual(expected)</div><div class="line"></div><div class="line">    Expected value to equal:</div><div class="line">      []</div><div class="line">    Received:</div><div class="line">      [<span class="string">"Geo橙子：在过一阵子是不是要翻成英文，走出国门了"</span>, <span class="string">"dev_zk：现在好了[太开心][太开心]"</span>, <span class="string">"dev_zk：哈哈"</span>]</div><div class="line"></div><div class="line">    Difference:</div><div class="line"></div><div class="line">    - Expected</div><div class="line">    + Received</div><div class="line"></div><div class="line">    - Array []</div><div class="line">    + Array [</div><div class="line">    +   <span class="string">"Geo橙子：在过一阵子是不是要翻成英文，走出国门了"</span>,</div><div class="line">    +   <span class="string">"dev_zk：现在好了[太开心][太开心]"</span>,</div><div class="line">    +   <span class="string">"dev_zk：哈哈"</span>,</div><div class="line">    + ]</div><div class="line"></div><div class="line">      at Object.&lt;anonymous&gt;.<span class="built_in">test</span> (weiboBackup.test.js:25:21)</div><div class="line">          at new Promise (&lt;anonymous&gt;)</div><div class="line">          at &lt;anonymous&gt;</div><div class="line">      at process._tickCallback (internal/process/next_tick.js:188:7)</div><div class="line"></div><div class="line">Test Suites: 1 failed, 1 total</div><div class="line">Tests:       1 failed, 1 total</div><div class="line">Snapshots:   0 total</div><div class="line">Time:        0.897s, estimated 1s</div><div class="line">Ran all <span class="built_in">test</span> suites.</div><div class="line">npm ERR! Test failed.  See above <span class="keyword">for</span> more details.</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>编写测试还是很重要的，可以保证你的代码质量，而你的代码质量关系到你的 KPI，所以我建议大家还是养成编写测试的好习惯。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天写了一篇博客：&lt;a href=&quot;http://www.liuyiqi.cn/2017/11/03/use-js-to-get-weibo-comments/&quot;&gt;《使用 JavaScript 批量获取微博评论》&lt;/a&gt;。今天我们来学习如何测试我们之前编写的代码。从本质上来说，我们今天要学习的是如何测试 DOM 操作类的 JS 代码。你可以在这里获取测试代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lewis617/practical-js/blob/master/src/weiboBackup.test.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/lewis617/practical-js/blob/master/src/weiboBackup.test.js&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="DOM" scheme="http://www.liuyiqi.cn/tags/DOM/"/>
    
      <category term="单元测试" scheme="http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>使用 JavaScript 批量获取微博评论</title>
    <link href="http://www.liuyiqi.cn/2017/11/03/use-js-to-get-weibo-comments/"/>
    <id>http://www.liuyiqi.cn/2017/11/03/use-js-to-get-weibo-comments/</id>
    <published>2017-11-03T02:36:00.000Z</published>
    <updated>2017-11-09T09:54:04.354Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是如何用 JavaScript 批量获取微博评论。如果你想备份或者转移某个微博页面的评论内容，那么本博客对你而言，将会非常实用。</p><p>你可以在这里获取源代码：</p><p><a href="https://github.com/lewis617/practical-node/blob/master/src/weiboBackup.js" target="_blank" rel="external">https://github.com/lewis617/practical-node/blob/master/src/weiboBackup.js</a></p><a id="more"></a><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>本文的示例代码非常简单，只有寥寥几行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 获取微博以及评论文字</span></div><div class="line"><span class="comment"> * 先打开微博页面，</span></div><div class="line"><span class="comment"> * 然后将下面的js拷贝到浏览器的console面板中</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> nodeArray = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'.list_con .WB_text'</span>));</div><div class="line"></div><div class="line"><span class="keyword">var</span> textArray = nodeArray.map(<span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(node.childNodes).map(<span class="function"><span class="keyword">function</span> (<span class="params">childNode</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> value;</div><div class="line">    <span class="comment">// 文字的情况</span></div><div class="line">    <span class="keyword">if</span> (childNode.nodeName === <span class="string">'#text'</span>) value = childNode.nodeValue;</div><div class="line">    <span class="comment">// 图片表情的情况</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (childNode.nodeName === <span class="string">'IMG'</span>) value = childNode.alt;</div><div class="line">    <span class="comment">// 链接的情况</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (childNode.nodeName === <span class="string">'A'</span>) value = childNode.lastChild.nodeValue;</div><div class="line">    <span class="keyword">return</span> value.replace(<span class="regexp">/(\s+$)|(^\s+)/g</span>, <span class="string">''</span>);</div><div class="line">  &#125;).join(<span class="string">''</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(textArray.join(<span class="string">'\n'</span>));</div></pre></td></tr></table></figure><p>是不是很短很开心？接下来我们来看下这几行 JavaScript 代码的使用方法。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>使用上述代码的方法非常简单，只需要：</p><p>1，打开微博页面，比如：<a href="http://www.weibo.com/2207255374/Eqkmf0pL4" target="_blank" rel="external">http://www.weibo.com/2207255374/Eqkmf0pL4</a></p><p><img src="https://ws1.sinaimg.cn/mw690/83900b4egy1fl4pa7prsyj20xo0qkq8m.jpg" alt=""></p><p>我们可以看到一共有三条评论。</p><p>2，然后将上述 JavaScript 代码拷贝到浏览器的 console 面板中，并按回车键。结果打印了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Geo橙子：在过一阵子是不是要翻成英文，走出国门了</div><div class="line">dev_zk：现在好了[太开心][太开心]</div><div class="line">dev_zk：哈哈</div></pre></td></tr></table></figure><p>每条评论单独占一行，完美。</p><h2 id="知识点解析"><a href="#知识点解析" class="headerlink" title="知识点解析"></a>知识点解析</h2><p>首先，我们获取评论的节点并将其转换为数组。这里使用了 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="external">Array.from</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll" target="_blank" rel="external">document.querySelectorAll</a> 两个方法。后者返回符合选择器的所有节点，但格式为 <a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList" target="_blank" rel="external">NodeList</a>。前者是 ES6 的方法，将 <code>NodeList</code> 转换为普通数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nodeArray = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'.list_con .WB_text'</span>));</div></pre></td></tr></table></figure><p>然后，我们遍历每个评论，并将评论中的文字、图片、链接都提取出来。其中用到了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeName" target="_blank" rel="external">nodeName</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeValue" target="_blank" rel="external">nodeValue</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/lastChild" target="_blank" rel="external">lastChild</a> 这三个 <code>Node</code> 的属性。还用了 <code>replace(/(\s+$)|(^\s+)/g, &#39;&#39;)</code> 来去除首尾的空格。还使用了数组的 <code>join</code> 方法来将数组项连接成字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> textArray = nodeArray.map(<span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(node.childNodes).map(<span class="function"><span class="keyword">function</span> (<span class="params">childNode</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> value;</div><div class="line">    <span class="comment">// 文字的情况</span></div><div class="line">    <span class="keyword">if</span> (childNode.nodeName === <span class="string">'#text'</span>) value = childNode.nodeValue;</div><div class="line">    <span class="comment">// 图片表情的情况</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (childNode.nodeName === <span class="string">'IMG'</span>) value = childNode.alt;</div><div class="line">    <span class="comment">// 链接的情况</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (childNode.nodeName === <span class="string">'A'</span>) value = childNode.lastChild.nodeValue;</div><div class="line">    <span class="keyword">return</span> value.replace(<span class="regexp">/(\s+$)|(^\s+)/g</span>, <span class="string">''</span>);</div><div class="line">  &#125;).join(<span class="string">''</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>最后，打印评论。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(textArray.join(<span class="string">'\n'</span>));</div></pre></td></tr></table></figure><h2 id="教程示例代码及目录"><a href="#教程示例代码及目录" class="headerlink" title="教程示例代码及目录"></a>教程示例代码及目录</h2><p><a href="https://github.com/lewis617/practical-js" target="_blank" rel="external">https://github.com/lewis617/practical-js</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，我们要讲的是如何用 JavaScript 批量获取微博评论。如果你想备份或者转移某个微博页面的评论内容，那么本博客对你而言，将会非常实用。&lt;/p&gt;
&lt;p&gt;你可以在这里获取源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lewis617/practical-node/blob/master/src/weiboBackup.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/lewis617/practical-node/blob/master/src/weiboBackup.js&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="practical-js" scheme="http://www.liuyiqi.cn/tags/practical-js/"/>
    
      <category term="正则表达式" scheme="http://www.liuyiqi.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Emily Gorcenski：物联网的伦理问题（译）</title>
    <link href="http://www.liuyiqi.cn/2017/11/02/the-ethics-of-the-internet-of-things/"/>
    <id>http://www.liuyiqi.cn/2017/11/02/the-ethics-of-the-internet-of-things/</id>
    <published>2017-11-02T10:12:00.000Z</published>
    <updated>2017-11-02T10:17:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译整理自 YouTube 视频：</p><p><a href="https://www.youtube.com/watch?v=xLL7Fo_em2E" target="_blank" rel="external">https://www.youtube.com/watch?v=xLL7Fo_em2E</a></p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vl220z3j20hs0a07ag.jpg" alt=""></p><a id="more"></a><p>非常感谢大家！接下来我要讲的是物联网的伦理问题，保证不会有太多说教哦。我是 Emily Gorcenski，我并不经常在推特上讲物联网这些事，但我却对物联网以及它所构建的蓝图非常感兴趣。那么，我为何要在 JavaScript 大会上讲物联网的伦理问题呢？事情是这样的，我之前已经讲过几次这个主题，而且我开玩笑说，每次我都能给出一个全新的演讲，因为在物联网中，有太多的失败案例、漏洞和安全问题频繁出现。如果我只是专注案例研究，那么每次讲的东西都完全不同。而这次，我决定不这么做了，而是简单聊一下为何伦理很重要，为何伦理对作为 JavaScript 开发者的你很重要，以及我们如何将 JavaScript ，将科技注入一系列原本没有这些技术的设备和服务。聊伦理问题而不提及一些沉重话题是不可能的。所以这里给出了一些警告性的内容（看PPT）：</p><ul><li>人类伤亡的频繁讨论</li><li>性侵犯的探讨</li><li>一张生肉图片（留点悬念）</li></ul><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vltxrxkj20hs0a0n2v.jpg" alt=""></p><p>如果这些话题吓到你了，那么我会尽量在十分钟内结束这些话题。</p><p>我是谁？这里我需要先承认，我在这个大会上有点像江湖骗子，因为我不是个 JavaScript 开发者。我是个数据科学家，以数学家的方式被培养，但也是个工程师，我在学校学习了航空工程和机械工程。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vmigt9dj20hs0a0q8a.jpg" alt=""></p><p>我曾经在航空、生物科技领域工作，现在在金融业。这些领域或行业有个共同点就是，它们都被严格调控。在这些领域工作的人们都会遵循一些专业的伦理法规，通过一个独立社会或其他协助指导什么是道德产品的组织。</p><p>当讨论物联网时，总觉得这是个有点空洞无聊的概念。我们会想到智能冰箱、智能汽车这一类东东。我个人更喜欢把物联网想象为：把互联网放进原本不属于它的地方。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vnei7ngj20hs0a0afh.jpg" alt=""></p><p>所以物联网可以指智能设备，但我也可以把 Uber 想象为出租车物联网。当我们看待这是否存在伦理问题时，我们必须要看看：我们使用科技做了什么，连接了什么。前后的差异并不在于这些设备、产品或服务有没有被计算机化，而是我们让用户拥有了连接什么的能力。如果你是个 JavaScript 开发者，或许你想要个物联网面包机，这样的话，你就可以在烤面包时插入一些代码进去。这很重要，因为物联网是下一代的便利优化。我们花了30年时间来优化产品使其更加方便易用。所以，现在你有个像冰箱这样的非物联网设备根本没有什么竞争优势。你必须要让它们连接起来！</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vntfc2aj20hs0a0451.jpg" alt=""></p><p>你或许会关心物联网设备的监控能力，比如监控 Uber 引起的一些惨案。但是如果你没有能力到处逛逛，或没有住在方便打车的地方，或有其他需要，比如 有时候 Uber 可能会成为救生员，这些都改变了你的生活。我们不能简单说物联网是荒谬的、轻浮的，就像个玩具，就像是一个垃圾推特账号，非常滑稽，整天发一下低质量内容。事实上，物联网还是带来了很多好的事情。</p><p>当我们说伦理这个词时，我们在说什么？你知道因为自动驾驶汽车，现在<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E8%BD%A8%E7%94%B5%E8%BD%A6%E9%9A%BE%E9%A2%98" target="_blank" rel="external">电车问题</a>很流行。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vp16viwj20hs0a0dlj.jpg" alt=""></p><p>你或许已经看过这个图了（看PPT）：一个诺贝尔奖获得者被绑在一个轨道上，另外五个普通人被绑在另一个轨道上。不知怎的，你被安排在控制杠杆的位置上。这是个在互联网上非常流行的问题，因为：一，如果将该问题抽象出来，我们可以用类别理论来解决它。二，这确实是个<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E7%88%86%E7%B4%85%E4%BA%8B%E7%89%A9" target="_blank" rel="external">网络模因</a>。既然电车问题的关键不在电车，那么为何自动驾驶汽车会成为问题呢？</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vpxw759j20hs0a07al.jpg" alt=""></p><p>我们喜欢把事情当作难题来解决 - 这就是我们作为开发人员和工程师的本性。在技​​术上，我们实际上并没有经常面临伦理困境。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vqgbs26j20hs0a0gqt.jpg" alt=""></p><p>当有两个竞争的伦理框架同时存在，且你的行为不能违反至少其中一个。那么此时，伦理困境就出现了。我认为 JavaScript 非常引人入胜，因为 JavaScript 社区对在未来十年的技术发展中出现的最有意思伦理困境负有责任。这个话题我等会儿会细说，有些人或许已经知道我待会要说什么了。技术的问题是，我们往往不遵守道德准则。我不是说要写一个起诉书，说你是坏的，不道德的人。说到这，有些公司可能要对我斜眼了。但我的意思是，在我们行业，我们没有一个专业的法规。有一些社团，你可以加入。如果你是像 ACM 或 I888 这样的组织的成员，举起你的手。哦，有一些但不是大多数。</p><p>在实践中，伦理学是关于损害的分析和风险的缓解。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vsf3nb2j20hs0a0dkp.jpg" alt=""></p><p>所以，当我们讨论伦理行为时，特别是伦理研究时，我们要做的不是消除人员受伤的可能性，而是去理解人员可能被科技所伤害的各种方式，寻找能减少风险发生的方法，并在必要时提供整治。当我们为物联网开发各种技术时，上述做法就是我们需要提出的道德框架。事故可能会以三种方式发生： <strong>不法行为</strong>、 <strong>故障</strong>、<strong>边界情况</strong>。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vt0ro5xj20hs0a0n25.jpg" alt=""></p><p>不法行为在物联网中是最常见的话题，这是个安全问题，是人们常说的黑客行为。去年秋天，Miri 僵尸网络发生 DDoS 攻击，这是目前的最大的 DDoS 攻击，这次攻击发生在不安全的物联网设备上。你或许知道，物联网安全性现在处于非常糟糕的状态。当这次事故发生时，它的时间安排和方式让很多人担心这是对美国总统大选的攻击的前兆，这将试图影响这次选举的结果。事实证明，这个恐惧是没有根据的。我不想在这次演讲中讨论这个事故。因为，首先我没法覆盖所有事。另外，其他方式的事故依然可能会发生，比如故障和边界情况。当设备在出乎开发人员预料的情况下被运行时，边界情况就会发生。另外值得一提的是，很多时候我们把软件漏洞和边界情况混为一谈，事实上这两者除了表达方式外确实没有太多不同。</p><p>这是 Twitter上一个很好的例子。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vuhafb9j20hs0a0n31.jpg" alt=""></p><p>这个可怜的绅士安德鲁，有一个物联网的水冷却器，他的 TLS 证书过期了，导致一些阻塞代码，硬件互锁失败，导致他家里都是水。这是一个真实的问题，对吧？是的，这是个真实的问题。如果 TLS 证书在 Web 服务中过期，我们忘记了 TLS 证书，我们有一段阻止代码，这是个操作问题，我们需要有相关人员来处理。但我们无法把物联网设备当成人来看待，我们需要将其当作宠物。这些宠物生活在人类的家里，而且因为没有喂食而非常暴躁易怒。有一天，如果我们不小心把 JavaScript 放入一个物联网水壶，结果因为<code>&quot;undefined&quot; is not a function</code>，房子被这个水壶烧了。</p><p>另外一个例子，这是我做的，我很自豪。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vvbezhdj20hs0a0jxc.jpg" alt=""></p><p>几年前我做了这个，如果可以的话，我想全屏显示。这是一个 <a href="https://zh.wikipedia.org/wiki/Microsoft_Band" target="_blank" rel="external">Microsoft Band</a>，我没有故意选择微软的产品。这是一块生鸡肉，我没有对活鸡做一些可怕的事，比如做僵尸鸡。这只是一块我从杂货店买的肉。从视频上看，它正在读取每分钟120次的心率！在现实世界中，传感器是凌乱的、嘈杂的、不完美的。所以当我们设计物联网设备时，我们必须考虑到这一点。可以读一个鸡胸肉的心率是荒谬的，但这可以对很多事产生深刻的影响。举个例子，有一些学校强制学生戴 <a href="https://en.wikipedia.org/wiki/Fitbit" target="_blank" rel="external">Fitbit</a>。也有雇主有健康保险激励计划来做这样的事。这样的话，我们就有监控设备，来监测我们的健康状况，并可以及时生成健康报告。这并不是假设的，而是真的发生了。</p><p>2015年，一名女子正在兰开斯特 (宾夕法尼亚州)看望一个同事。 她向警方报告性侵犯。警方发现了她的 Fitbit，并在她允许的情况下分析了数据，结果警方不仅停止了调查，还指控该女子假报警。去年，她对承认了这些指控，被定罪并实行缓刑。检方律师说 FitBit 数据也证明了这个。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vvtjfkcj20hs0a00yu.jpg" alt=""></p><p>我可以从一块生鸡肉中测出每分钟120次的心率，一个女人的生活也可能会被毁掉，因为没有 Fi​​tBit 的人站起来说不：“我们的设备不是这样准确。” 你不能这样做。我们的设备会出错。问题是我们如何建立它们是没有规定，质量保证或标准的。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vwsvjthj20hs0a0446.jpg" alt=""></p><p>我们只是编写代码，制造硬件。 我们创新，快，快，快。我们不问自己，当出现错误时会发生什么样的伤害？而这种情况越来越频繁。这些装置正在用于刑事和民事调查。就在上周，CNN 报道说一个男人被指控谋杀了他的妻子，根据他妻子的 Fitbit 数据记录。任何人带着 Fitbit 走，Fitbit 都会记录，即便当时你正坐在沙发上。我们怎么能让这种事情发生呢？我们怎么能让这种信息影响人们的生活？另一个事件：去年，一个智能水表被用于谋杀调查。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vxhp998j20hs0a0q9p.jpg" alt=""></p><p>问题是：谁去监狱？ 当一个设备向警方作出虚假陈述时，谁将要接受缓刑？此外，说一些事情真实发生，说一些事情是假的，说有人受伤或被杀了，如果该设备有故障，谁将承担责任？是设备主人吗？ 是开发者吗？ 是制造设备的公司吗？这似乎应该是一个解决的问题，但事实却没有。这已经发生了。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vy0pr1qj20hs0a0wk2.jpg" alt=""></p><p>在这个框架下，你将看到几辆汽车，右边的白色汽车是 Google 自动驾驶汽车，这张图像是静止图像 - 这是从拍摄的视频中截取的屏幕截图，来自在加利福尼亚州山景城的一辆市政公共汽车的行车记录仪。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vzabk5wj20hs0a0wls.jpg" alt=""></p><p>那辆 Google SUV 即将在公共汽车前面出来，发生意外。幸运的是，没有人受伤。这是自驾车首次被发现对一次意外承担责任。谷歌说：“我们的错，我们会进行相关损害赔偿。”他们调查了事情经过，得出结论，车子预测了因为我们领先于公共汽车，所以公共汽车应该让着我们。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vzjc1m6j20hs0a0te9.jpg" alt=""></p><p>Google 现在正想卖他们的自动驾驶汽车，所以他们当然会承担责任，而不是去法庭上测试他们的车。但是，随着我们进入物联网的未来，我们不能依靠这一点。 一旦这个规模出现，我们就不能依靠仁慈的公司承担责任。顺便说一下，即使 Google 是正确的，这仍然是一个历史时刻。因为如果公共汽车已经让了自动驾驶汽车，这将是市政府的公共汽车第一次屈服！</p><p>几年前，旧金山有一名法官。他研究自主系统是否不受现有的责任理论限制。深入研究后，他发现那些自己做决定的，使用神经网络的，使用自适应自调节控制系统的，设计自己的手段来完成任务的机器在现有的侵权理论下，可能不受任何责任。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3w02p1c2j20hs0a00z5.jpg" alt=""></p><p>这有巨大的影响。因为如果你买普通的冰箱，它会损坏，你可以说，“嘿，制造商， 你负责这个损坏。”如果你买一个咖啡机，并且由于一个小故障，它会烧毁你的房子。但你可以安全地出门，然后从公司和您的保险公司收回损害赔偿。这是一个完整的道德框架，也有法律架构。显然，自驾车将会更安全，他们将会挽救生命。这是一件非常重要的事情。 我们要拯救生命。 我们希望道路更好。但是，救赎的人数并不是我们的道德演算中唯一的术语。我们必须看看当人受伤时发生了什么？ 他们如何被照顾？他们是否能够支付医疗费用或重新上班？还是虽然在他们恢复健康时失去工作，但仍然能够支付租金和买得起食物？</p><p>那么关于这个的问题对作为开发人员的我们有什么意义？这是否给我们免费通行证？我们不对 IoT 设备负责。那意味着我们可以做任何事情。让我们创造一切，直到事故发生，直到先例发生。这真的是我们想留下的东西吗？我们是否愿意对我们所制造的东西不负责任，就因为我们可以这么做，就因为我们没有能力给予我们伤害的人任何补偿？ 一些公司实际上仍然只想要创新的环境下工作，他们只想建造东西，运送东西，在事后处理后果。但你必须问自己：我想对此负责吗？这就是伦理或道德关注的。</p><p>我说过 JavaScript 社区中有最有意思技术伦理问题之一，比如 <a href="http://taobaofed.org/blog/2016/03/31/what-can-we-learn-from-left-pad-event/" target="_blank" rel="external">left-pad 事件</a>。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3w0wggp6j20hs0a00xt.jpg" alt=""></p><p>当 Ashley 昨天晚上谈到 left-pad，这真的很有意思，因为她看到了这个事件的很多反弹。她表示互联网在 left-pad 发生时被炸毁。人们对很多事情感到愤怒，JavaScript 社区开发了一个小模块系统，也许它是错误的，也许它是正确的，来回有很多争论，甚至在这个事件中失去了友谊。人们没有意识到的是所有愤怒和侮辱，是因为 left-pad 事件实际上暴露了什么是真正的伦理困境。现在我们还只见树木，未见树林。left-pad 事件拥有两个竞争性的伦理决定。一个是极客文化伦理，开源是最重要的事，开源是一种美德。控制你代码就是极客，就是开源开发者。当然，其他人可以 fork 这个模块，但你要选择把它放在哪里。 当 left-pad 作者删除了他的所有模块，并在互联网上打碎了一堆东西。NPM 也提出了自己的伦理框架，NPM 要求模块作者对使用他们模块的产品负有责任。他们有有作为工程师的责任。不过，NPM 依然认为开源有价值。NPM 本身就是个开源社区。所以这本身就是个很难的决定。你能想象如果这件事没有发生在2016年而是2018年，2020年，NPM 在运行在车子、冰箱上，这对整个网络会造成多大的影响？你正在高速公路上以一小时70英里的速度行驶，有人突然删除了一个模块，你的车子出现问题。你认为这不可能发生。 没有人会在运行IoT设备的汽车上进行实时部署。省省吧！就像我们现在在生产系统中做的那样，物联网安全简直就是一团糟。我们正在快速创新，这当然会有问题。你不想成为对冰箱负责的人，让用户失去了所有的食物，或失去了原本在冰箱中的他们需要的重要药物。你不想对此负责，但这是可能发生的。也许你认为开源更重要，那么这才是真正的伦理困境。所以作为工程师，我们要做些什么？当我们谈论伦理时，我们可以做些什么？这是为什么我不想做这个演讲，而是让大家能够做这个演讲，因为我们可以像工程师、开发人员那样做很多可操作的事情，使我们的工作场所更好，做更多有道德的事。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3w1jeodjj20hs0a07a7.jpg" alt=""></p><p>第一个就是与老板达成期望。如果你的老板有一些压力，要你做一些你觉得不舒服的事情。这时，你需要知道，你可以去找老板，告诉他你不愿意做这个。你需要知道如果你这样做会发生什么？ 这是重要的事情。你也必须准备说不。 如果有人来找你说，“嘿，我需要你编写一种发送方法，将某人的心率跟踪数据实时回到我们的服务器。”你会愿意这样做吗？也许你不愿意，但是你知道如何拒绝吗？你是否愿意拒绝？把你的职业生涯放置于危险的境地，就因为这么做违反了你相信的东西。您还需要能够与您的同事坦诚讨论这意味着什么。我在金融领域工作，我是数据科学家，所以我有大量的人力资料以及这些数据带来的强大能力。所以我们经常讨论，当我们记录客户数据时，当我们记录他们的财务信息时，我们当下的行为会产生什么影响。我们总是在讨论，比如你不愿意做什么？我们有法律义务做什么？在金融领域，我们在报告欺诈方面具有法律责任，例如洗钱。 所以我们必须相互讨论这些事情。作为工程师，你应该能够坦白地和你的同事坦言，“我不喜欢这样做。“ 我们如何确保不会那样？我们如何确保它保持在安全的一面而不是危险的一面？最重要的是知道你的底线，知道你何时愿意收手。因为科技真的有利可图，我们有很多的特权。我们在技术上有很多特权。即使只是看看我们所在的屋子，这也是一个非凡的会议室，这里有各种各样的设施。不是每个行业都这样的。什么是你的底线？超过了这个底线，你应该说：“我不能继续做这个”。如果你不知道这个底线是什么，你不会发现你已经越界了，直到一切已经来不及挽回。这就是我要讲的，非常谢谢大家。</p><p><img src="https://ws3.sinaimg.cn/mw690/83900b4egy1fl3w2f1szrj20hs0a0n3a.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译整理自 YouTube 视频：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=xLL7Fo_em2E&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.youtube.com/watch?v=xLL7Fo_em2E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/mw690/83900b4egy1fl3vl220z3j20hs0a07ag.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术讲座" scheme="http://www.liuyiqi.cn/tags/%E6%8A%80%E6%9C%AF%E8%AE%B2%E5%BA%A7/"/>
    
      <category term="物联网" scheme="http://www.liuyiqi.cn/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
      <category term="伦理学" scheme="http://www.liuyiqi.cn/tags/%E4%BC%A6%E7%90%86%E5%AD%A6/"/>
    
      <category term="电车问题" scheme="http://www.liuyiqi.cn/tags/%E7%94%B5%E8%BD%A6%E9%97%AE%E9%A2%98/"/>
    
      <category term="left-pad" scheme="http://www.liuyiqi.cn/tags/left-pad/"/>
    
      <category term="Miri 僵尸网络" scheme="http://www.liuyiqi.cn/tags/Miri-%E5%83%B5%E5%B0%B8%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Fitbit" scheme="http://www.liuyiqi.cn/tags/Fitbit/"/>
    
      <category term="自动驾驶汽车" scheme="http://www.liuyiqi.cn/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%B1%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Anjana Vakil：函数式 JS 中的不可变数据结构（译）</title>
    <link href="http://www.liuyiqi.cn/2017/10/22/immutable-data-structures-for-functional-js/"/>
    <id>http://www.liuyiqi.cn/2017/10/22/immutable-data-structures-for-functional-js/</id>
    <published>2017-10-22T09:32:00.000Z</published>
    <updated>2017-11-01T09:36:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译整理自 YouTube 视频：</p><p><a href="https://www.youtube.com/watch?v=Wo0qiGPSV-s" target="_blank" rel="external">https://www.youtube.com/watch?v=Wo0qiGPSV-s</a></p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks91iprbej20hs0a07be.jpg" alt=""></p><a id="more"></a><h2 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h2><p>嗨，各位。大家好吗？我是 Anjana Vakil ，你们可以在推特上通过这个名字找到我。今天，我想讲的是，函数式 JS 中的不可变数据结构。我们将要看一下：什么是不可变数据结构？为何它能很好地处理我们经常在函数式编程中使用的不可变特性？以及我们如何在 JavaScript 中使用不可变数据结构（既然你们都喜欢 JavaScript）</p><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>简单介绍一下我吧，我可能是这个屋里唯一的非 web 开发者。我是 Uber Research 的一个工程师。我和同事一起为科研资金领域的数据开发一种自定义查询语言。我也曾是 Recurse Center 的一个成员，Recurse Center 是纽约的一个很棒的编程社区。我也曾是 Outreach 项目的一个成员，如果你没听过 Outreach，（那么我可以告诉你）这个项目（做的事情是）通过给一些女性和亲属一些 Mozilla 的实习机会，来让他们参与到开源项目中来。所以，如果你想在讲座后找我聊这些事，我会很愿意。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks937eocbj20hs0a0n4b.jpg" alt=""></p><h2 id="函数式编程与纯函数"><a href="#函数式编程与纯函数" class="headerlink" title="函数式编程与纯函数"></a>函数式编程与纯函数</h2><p>你们或许知道我很喜欢函数式编程，我认为它很赞。有其他人同意我的想法嘛？（观众开始呼应）其他编程范式比如命令式或面向对象编程都会有一些令人头疼的缺点，而函数式编程则是避开这些缺点的较好方式。在函数式编程中，我们通常做的就是把我们的程序设想为一系列纯函数。这意味着，它们（指的是一系列纯函数）只是把输入转换为输出，这就是它们所做的所有事了，没有任何副作用，比如，在命令行中打印一些东东，改变一些全局变量等。 所以，我们的函数就成了“纯的”数据输入和数据输出，就像是一个数据转换器。另外一个“和纯函数手牵手”的，用来避免副作用的法宝是——不可变数据。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks983l91bj20hs0a0q9r.jpg" alt=""></p><h2 id="不可变数据简介"><a href="#不可变数据简介" class="headerlink" title="不可变数据简介"></a>不可变数据简介</h2><p>不可变数据指的是，一旦创建就不会改变的数据。所以，这是一个很好的，避免意外在函数外面改变数据的方式。 如果一切都是不可变的， 你不能改变任何东西。 不可变性是另外一个很赞的概念。为什么说它很赞，我们等会再看。说到了“赞”这个词（英文是 Rock），我们先来说下石头（英文也是 Rock）。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks99m3f24j20hs0a0gru.jpg" alt=""></p><h2 id="用石头类比不可变数据"><a href="#用石头类比不可变数据" class="headerlink" title="用石头类比不可变数据"></a>用石头类比不可变数据</h2><p>这是个石头，不可变性和石头赞的方式很像。我最近参加了不少技术会议，我感觉技术会议上没有太多诗，所以我打算为大家读一首诗。</p><blockquote><p>Nobody sits like this rock sits. You rock, rock. The rock just sits and is. You show us how to just sit here and that’s what we need.<br>诗词大意：无人能像这块巨石般岿然不动，你，巨石，岿然不动，好样的，你为我们证明坚持的力量，而这是我们全部所需。</p></blockquote><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9ad06r3j20hs0a0gsu.jpg" alt=""></p><p>这首诗很有道理，很有深意啊！它来自于《I heart Huckabees》。（下面开始鼓掌）别谢我，谢谢《I heart Huckabees》，一部很好的电影，去看看吧，很有趣。</p><blockquote><p>《I Heart Huckabees》，（中文名： 我爱哈克比），是一部喜剧、哲理电影，由詹森·舒瓦兹曼领衔主演。</p></blockquote><p>所以，这就是为何不可变数据很赞！它就是“坐在那里”，即坚持不变。一旦我们创建了它， 它从不改变。这很棒，因为这帮我们避免了一些变化的“头疼之处”。使用不可变数据，一些事情变得简单，而另外一些事情变得复杂。让我们一睹为快！</p><h2 id="可变性的缺点"><a href="#可变性的缺点" class="headerlink" title="可变性的缺点"></a>可变性的缺点</h2><p>假如我们有个数组叫 <code>foo</code>，里面有一些数字。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9bkogayj20hs0a0agh.jpg" alt=""></p><p>这太无聊了，让我们把它变得更有趣一些。假如我们有一个动物园，里面有一些动物，这就比较有趣了。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9c39kcdj20hs0a0agq.jpg" alt=""></p><p>我决定要改变一下这个动物园，我想把兔子换成外星人，这很酷。 我很开心，因为我想让这个动物园更加具有外太空感觉。 除了兔子那个位置，我没有改变这个动物园数组的其他任何地方。我觉得很棒，但我的同事觉得动物园里应该是地球上的动物，他无法统计外星人，他估计会说：“谁特么把外星人放到这里了？！我的程序都没法工作了！”</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9czg0kfj20hs0a0jy3.jpg" alt=""></p><p>所以，可变性具有一系列的问题，我们不得不管理谁，改变了什么，在什么时间，谁在动物园放了什么动物。 我们不得不管理很多状态，这太头疼了！不管是个人还是一个团队。我们还会从代码中得到很多 bug，比如我同事只考虑了地球生物，没有把外星生物的情况考虑进去，所以程序就崩溃了。这是可变性的副作用让我们不开心的地方。让我们尝试用一下不可变的方式。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9dmcdn9j20hs0a0n3y.jpg" alt=""></p><h2 id="不可变的优缺点"><a href="#不可变的优缺点" class="headerlink" title="不可变的优缺点"></a>不可变的优缺点</h2><p>在不可变的世界，我的数组，我的动物园，一旦创建就永远不会变了，我也不能改变它。如果我想要个具有外星感觉的动物园，那么我需要拷贝一份相同尺寸的，作为我的原始数组。接下来，我就可以做一些修改了，比如把兔子换为外星人。然后，我把其他没变的项都拷贝过来。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9ewi28qj20hs0a0n2p.jpg" alt=""></p><p>这很棒，我的同事会很开心，因为程序没有崩溃，动物园里仍然是地球生物。但我得拷贝整个数组。我不得不为整个数组（甚至包括那些没有改变的项）分配一些空间。 这意味着，我的代码运行速度很慢，也消耗了很多内存。这些复杂的事很糟糕，因为拷贝浪费了大量的空间和时间，这让我们很难过，我们不想这样。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9ft1p3zj20hs0a0tef.jpg" alt=""></p><p>所以，如果我们想使用不可变，我们必须找到更好的方式。 幸运的是，很多聪明人很努力去思考解决这个问题，他们也找到一些很好的解决方案，来让我们更高效地使用不可变——不可变数据结构。</p><h2 id="不可变数据结构"><a href="#不可变数据结构" class="headerlink" title="不可变数据结构"></a>不可变数据结构</h2><p>或许你之前听过不可变数据结构这个概念，特别是使用过函数式编程或者 React 的人。从技术层面上来讲，不可变数据结构就像是石头一样， 一旦你创建了它，它就不会变了。或许你也听过持久化数据结构。有时候，这两个数据结构具有互换性，但是，两者还是稍有不同。如果说不可变数据是永不改变的数据，那么持久化数据就是一种可以获取老版本数据的数据。我们创建了一个更改过的新数据，我让老数据就在新数据附近（指的是你可以通过一些方法获取到老数据）。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9h2xm5aj20hs0a0q9s.jpg" alt=""></p><p>你或许听说过，不完全持久化数据结构可以让我们看到老数据，获取到老数据。但我们无法回去并更新任何老数据。我们能更新的就是当前的数据。 你或许还听说过，完全持久化数据结构。我们可以完全地进行时间旅行，我们可以回到过去，更新任何老数据。 这跟一些版本控制系统比如 Git 有异曲同工之妙。</p><h2 id="持久化不可变数据结构"><a href="#持久化不可变数据结构" class="headerlink" title="持久化不可变数据结构"></a>持久化不可变数据结构</h2><p>接下来，我们要讨论持久化不可变数据结构，它既持久化还不可变。让我们看它如何运作。这一切的关键在于，我们想让原始数据（比如最初的动物园）保存下来，但同时创建新数据也非常高效。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9iurt4kj20hs0a0q8x.jpg" alt=""></p><p>所以是什么魔法让这一切成为可能？ 我们需要让函数调用向空间时间复杂度之神跳舞祈祷吗？（小姐姐太文艺了）</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9k4e622j20hs0a0tdz.jpg" alt=""></p><h2 id="树和共享"><a href="#树和共享" class="headerlink" title="树和共享"></a>树和共享</h2><p>不！其实非常简单——Trees &amp; sharing（树和共享，这里的树就是数据结构中的树）。这很可爱吧！这两个简单的概念将会让我们得到一种很高效的不可变数据。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9klxrbsj20hs0a0n2d.jpg" alt=""></p><p>如何得到？让我们先来看看“树”，因为“树”也很酷，但不幸的是，我没有相关的诗词，抱歉。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9lmfwkvj20hs0a0wk7.jpg" alt=""></p><p>想象我们能用“树”这种数据结构来表示动物园数组。我能做的一件事就是把所有的动物，即所有的值都放在叶子节点上，保持一个叶子节点两个值，这样它们才不会孤单。然后我们使用一个中间节点将它们连接起来，再用新的中间节点把这些中间节点也连接起来，一直往上直到根节点。这个根节点就是我们当前的“数组”，当然这个“数组”是用树这种数据结构来表示的。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9mtpf2tj20hs0a0afe.jpg" alt=""></p><h2 id="如何更新"><a href="#如何更新" class="headerlink" title="如何更新"></a>如何更新</h2><p>有了这种类型的数据结构，我们如何更新一些值呢？</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9nk4byij20hs0a0afm.jpg" alt=""></p><p> 假设我的动物园是不可变的，那么我如何得到一个新版本的动物园，里面有外星人呢？我需要的就是，找到包含我想改变的值的节点，拷贝这个节点，然后在新节点中进行值的修改，最后把相关的一系列中间节点也拷贝过来，那么新的根节点就是新版本的数据 。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9pa4y14j20hs0a044a.jpg" alt=""></p><p>这种通过拷贝路径（即一系列中间节点）来进行更新的技术叫——路径拷贝（path copying）。这个技术很酷，因为现在我不再需要去拷贝整个数组了，只需要拷贝要改变的节点和该节点到根节点的一系列中间节点，即路径。这样相当于我们把某种线性的算法转换成了对数型的，如此一来，性能就好多了。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9pnkjgxj20hs0a0afl.jpg" alt=""></p><p>另外还有一个好处就是，新旧两个版本的树之间有大量的共享节点，这节约了很多空间。我们复用了老版本中的很多没有改变的部分，然而在之前，我们是需要去拷贝这部分的。这意味着，大量的内存消耗不复存在，因为我不需要再去存储很多没有改变的拷贝了。这叫结构共享，因为我们在两个版本之间共享了树的很多结构。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9qs6c8wj20hs0a0teh.jpg" alt=""></p><h2 id="如何查找"><a href="#如何查找" class="headerlink" title="如何查找"></a>如何查找</h2><p>我们已经讨论很多关于更新的技术，那么我们如何得到某个值呢？从结果来看，目前这个数据结构已经不只是个简单的树了，而是一种特殊的树，叫——<a href="https://baike.baidu.com/item/Trie%E6%A0%91" target="_blank" rel="external">Trie 树</a>。Trie 来自“retrieval”（取回）这个词。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9rj1robj20hs0a043u.jpg" alt=""></p><p>在 Trie 树中，叶子节点存储值，路径代表键。你经常会看到 Trie 树被用来把单词作为键来存储。比如，我有一个 “tea” 作为键来存储，为了得到这个单词对应的值，我要做的就是从根节点遍历树，先到 “t”，再到 “e”，再到“a”。结果得到了3。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9semwkcj20hs0a0gr6.jpg" alt=""></p><p>这很酷，但在我们的数据结构中，我们不会使用单词作为键，而会选择更有数组风格的index，也就是索引。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9t155qnj20hs0a0n30.jpg" alt=""></p><p>如果我们把索引当作二进制数字，我们可以假装那是单词，然后我们逐个比特向下遍历树，就像是先前的字母那样。让我们看看这如何运作。如果我想从数组中得到5，即索引为5的动物。我就把它转换为二进制，也就是101。然后我逐个比特查找它。先从根节点开始，然后进入分支1，然后分支0，最后分支1，得到了青蛙。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9tyq32sj20hs0a0dlg.jpg" alt=""></p><p>这很简单，但却非常强大。因为它让我们在这种树状数据结构很快地进行查找，而这个树状数据结构则让我们使用结构共享来更高效的描述不可变数据结构的新拷贝。另外，值得一提的是，我们没必要非使用二叉树来表示，二叉树很适合在幻灯片上展示，但在实际中通常都是32叉树。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9viy5c1j20hs0a0tew.jpg" alt=""></p><p>在我们刚才看的那棵树中，每一层只有一个比特的信息，我们需要向下逐个比特查找。但是，如果我们有一颗32叉树，那么每一层将会有5个比特的信息（2^5=32）。举个例子吧！如果我们有个更大的数字，比如18977。如果每层只有一个比特，那么这将是个很深的树，一共有15层，太多，太长了 。如果我在每层创建更多的叉，那么我就可以把它变为5比特，进而也就只需要3层就可以了。其实这是个权衡问题，看你是想要更深的树，还是更多叉叉的树。通常，32叉树是个很好的权衡。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9wpjcqoj20hs0a079x.jpg" alt=""></p><p>我们刚才看见的其实就是 Bitmapped Vector Trie。这是行话，你可以自行谷歌这种数据结构。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fks9x61wmej20hs0a0dld.jpg" alt=""></p><h2 id="对象的情况"><a href="#对象的情况" class="headerlink" title="对象的情况"></a>对象的情况</h2><p>对于数组来说，这很酷，有个索引，然后跳转过去。但是，对于对象呢？我们也想能够把对象和一些随意的键关联起来，不只是索引，我们想要非整型的键。这该如何工作呢？比如，M 对应 Monkey，P 对应 panda等。我们能做的就是把字母键使用哈希算法变为数字来表示键。所以每个键都有一个数字，也不需要有序什么的，因为对象本来就是无序的。然后我们就可以像先前一样用数字来进行查找了。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fksa4p2f8uj20hs0a0jxm.jpg" alt=""></p><p>如果我想查找键为 F 的值，那么我就先对 F 进行哈希运算，然后得到一些数字，比如5吧！5的二进制就是101，然后像之前那样逐个比特来查找，最后得到了我们想要的动物，也就是青蛙。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fksa5f0qpoj20hs0a0te8.jpg" alt=""></p><p>其实，这是个 <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie" target="_blank" rel="external">Hash Array Mapped Trie</a>。这个数据结构由 Phil Bagwell 和 Rich Hickey 发明，最初用在 Clojure 这门语言中来提升一些数据的运算效率。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fksa65r741j20hs0a044e.jpg" alt=""></p><p>关于该数据结构，还有很多优化方法，可以让它变得超级快，很多细节，我们今天就不一一说了。但是，这是个基本概念：树代表数据，结构共享让我们可以在新老版本之间复用更多信息，使用二进制代表键去向下查找指定值。</p><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>概括一下：可变性引出很多问题。这些问题需要被解决，尤其是在函数式编程中，因为函数式编程的基本思想就是不能有副作用，只能用纯函数。纯函数不能改变任何数据，它只对输入做计算，然后返回全新的输出。另一方面，不可变则很棒。因为如果我用了不可变数据，我就不会把我同事的程序搞挂掉。但是，拷贝是个处理不可变数据的糟糕的方式，因为它不高效，不管是时间层面还是空间层面，而新老版本树中的结构共享是个高效的方法。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fksa71imm2j20hs0a0gs8.jpg" alt=""></p><h2 id="Mori-和-Immutable-js-简介"><a href="#Mori-和-Immutable-js-简介" class="headerlink" title="Mori 和 Immutable.js 简介"></a>Mori 和 Immutable.js 简介</h2><p>这些数据结构很酷，但是，我应该怎么用它们？在 JavaScript 中，有一些很棒的库帮你立马用上这些数据结构。有很多不同的方案，但我将会介绍其中几个。有一个库叫 Mori。基本来说，Mori 是个 ClojureScript 的一个 JavaScript 接口。它能让你使用上 ClojureScript 中的一些数据结构。这个库很有 Clojure 的感觉，很有函数式编程的感觉。API 是函数式的，我们等会看看。但这也使得这个库比较冷门。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fksa7fsizxj20hs0a0n43.jpg" alt=""></p><p>另一个是 Immutable.js。这是 Facebook 出的一个库，由 Lee Byron建立。这是（刚才讨论的）那些数据结构的 JavaScript 实现。这个库很有原生 JavaScript 的感觉，没有任何 Clojure 背景。这意味着，它也有点面向对象风格的 API，尽管它仍然是返回新的数据结构，而不是改变可变的数据结构。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fksa88tt5cj20hs0a0acq.jpg" alt=""></p><h2 id="Mori-和-Immutable-js-代码片段"><a href="#Mori-和-Immutable-js-代码片段" class="headerlink" title="Mori 和 Immutable.js 代码片段"></a>Mori 和 Immutable.js 代码片段</h2><p>让我们看看它们长啥样。 这是 Mori。<code>vector</code> 就像是数组，<code>conj</code> 就像是 <code>push</code> 方法。从结果看，<code>a</code> 没有变化，而 <code>a2</code> 则是新的数据。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fksa8kvrcxj20hs0a0q5i.jpg" alt=""></p><p>这是相同算法的 Immutable.js 版本。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fksa8yqyssj20hs0a076q.jpg" alt=""></p><p>刚才是数组，现在看看 map 这个数据结构。 这是 Mori 版本。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fksaszxp8ej20hs0a07aq.jpg" alt=""></p><p>这是 Immutable.js 版本。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fksat7rvtdj20hs0a0dm2.jpg" alt=""></p><p>这是真正的不可变数据结构，如果你在命令行中查看它们，就会发现它们非常奇怪。非常建议大家使用这些库，看看效果如何。</p><h2 id="Mori-和-Immutable-js-简单对比"><a href="#Mori-和-Immutable-js-简单对比" class="headerlink" title="Mori 和 Immutable.js 简单对比"></a>Mori 和 Immutable.js 简单对比</h2><p>我可以在结束前简单对比一下它们。Mori 来自 Clojure 世界，它是 ClojureScript（的 JavaScript 接口）。但是 Immutable.js 则拥有更多像 <code>o.get()</code> 这样（面向对象风格的）方法，如果你喜欢在 JavaScript 中这么写。然而对我来说，Immutable.js 的这种写法会让我感到不和谐，因为这看起来很像是可变的写法，但实际并不是。为了获取更多的函数式编程的感觉，我更喜欢 Mori，因为我更喜欢所有都是纯函数，接受输入，返回输出，仅此而已。这里也提供了一些次要的性能对比，Mori 稍微快一些，而 Immutable.js 则相对小一点。它们都是好选择，试试吧！ 希望其中一个适合你。</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fksa9qzq35j20hs0a0n3k.jpg" alt=""></p><p>这就是我的演讲，希望对大家有用。 加油向前，不要改变数据！（鼓掌）</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fksaa4qvadj20hs0a0tea.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译整理自 YouTube 视频：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Wo0qiGPSV-s&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.youtube.com/watch?v=Wo0qiGPSV-s&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx3.sinaimg.cn/mw690/83900b4egy1fks91iprbej20hs0a07be.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.liuyiqi.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="技术讲座" scheme="http://www.liuyiqi.cn/tags/%E6%8A%80%E6%9C%AF%E8%AE%B2%E5%BA%A7/"/>
    
      <category term="函数式编程" scheme="http://www.liuyiqi.cn/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="不可变数据结构" scheme="http://www.liuyiqi.cn/tags/%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="纯函数" scheme="http://www.liuyiqi.cn/tags/%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    
      <category term="Trie 树" scheme="http://www.liuyiqi.cn/tags/Trie-%E6%A0%91/"/>
    
      <category term="Mori" scheme="http://www.liuyiqi.cn/tags/Mori/"/>
    
      <category term="Immutable.js" scheme="http://www.liuyiqi.cn/tags/Immutable-js/"/>
    
      <category term="Clojure" scheme="http://www.liuyiqi.cn/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>SVG轨迹回放实践</title>
    <link href="http://www.liuyiqi.cn/2017/09/27/svg-path-playback/"/>
    <id>http://www.liuyiqi.cn/2017/09/27/svg-path-playback/</id>
    <published>2017-09-27T11:00:00.000Z</published>
    <updated>2017-10-10T03:19:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近做了埋点方案XTracker的轨迹回放功能，大致效果就是，在指定几个顺序的点之间形成轨迹，来模拟用户在页面上的先后行为（比如一个用户先点了啥，后点了啥）。效果图如下：</p><p><img src="https://wx1.sinaimg.cn/mw690/83900b4egy1fk1jn3atyng204h04ead8.gif" alt=""></p><p>在这篇文章中，我们来聊聊轨迹回放的一些技术细节。</p><blockquote><p>注意，本文只关注轨迹的绘制，并不讨论轨迹的各种生成算法。</p></blockquote><a id="more"></a><h2 id="绘制红点坐标"><a href="#绘制红点坐标" class="headerlink" title="绘制红点坐标"></a>绘制红点坐标</h2><p>在绘制轨迹前，需要先绘制轨迹经过的红点坐标。使用SVG绘制红点非常简单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"500"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">r</span>=<span class="string">"5"</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"55"</span> <span class="attr">fill</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;/<span class="name">circle</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></div></pre></td></tr></table></figure><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fjy4xjj4aij203403g0py.jpg" alt=""></p><p>然后根据需要多画几个红点就可以了，也可以通过js批量生成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCircles</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> r = <span class="string">"5"</span>,</div><div class="line">    fill = <span class="string">"red"</span>,</div><div class="line">    <span class="comment">// circleGroup是红点的容器</span></div><div class="line">    circleGroup = <span class="built_in">document</span>.querySelector(<span class="string">"#circle-group"</span>);</div><div class="line">  <span class="comment">// pointList是红点的坐标集合</span></div><div class="line">  pointList.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">point</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> circle = <span class="built_in">document</span>.createElementNS(</div><div class="line">      <span class="string">"http://www.w3.org/2000/svg"</span>,</div><div class="line">      <span class="string">"circle"</span></div><div class="line">    );</div><div class="line">    circle.setAttribute(<span class="string">"r"</span>, r);</div><div class="line">    circle.setAttribute(<span class="string">"cx"</span>, point[<span class="number">0</span>]);</div><div class="line">    circle.setAttribute(<span class="string">"cy"</span>, point[<span class="number">1</span>]);</div><div class="line">    circle.setAttribute(<span class="string">"fill"</span>, fill);</div><div class="line">    circleGroup.appendChild(circle);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fjy50l2qlrj20dw0d8wei.jpg" alt=""></p><h2 id="两点之间的轨迹"><a href="#两点之间的轨迹" class="headerlink" title="两点之间的轨迹"></a>两点之间的轨迹</h2><p>红点坐标画完了，我们来画轨迹。在画多点的轨迹之前，我们先来学习两点之间的轨迹，也就是两点之间曲线的画法。</p><h3 id="二次贝塞尔曲线、三次贝塞尔曲线还是圆弧？"><a href="#二次贝塞尔曲线、三次贝塞尔曲线还是圆弧？" class="headerlink" title="二次贝塞尔曲线、三次贝塞尔曲线还是圆弧？"></a>二次贝塞尔曲线、三次贝塞尔曲线还是圆弧？</h3><p>SVG通过path可以画多种曲线主要包括：</p><ul><li>二次贝塞尔曲线：需要一个控制点，用来确定起点和终点的曲线斜率。<br>  <img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fjy6fw4aeuj205a04g3yd.jpg" alt=""></li><li>三次贝塞尔曲线：需要两个控制点，用来确定起点和终点的曲线斜率。<br>  <img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fjy6fi0z8pj205a04gglj.jpg" alt=""></li><li>圆弧：需要两个半径、旋转角度、逆时针还是顺时针、大圆弧还是小圆弧等多个属性。<br>  <img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fjy6hbu8zlj205k05kt8o.jpg" alt=""></li></ul><p>显然，二次贝塞尔曲线最为简单，所以我们决定用二次贝塞尔曲线来画两点之间的弧线。在SVG的path中，二次贝塞曲线的参数是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">M x1 y1 Q x2 y2 x3 y3</div></pre></td></tr></table></figure><p>其中<code>x1 y1</code>是起点，<code>x2 y2</code>是控制点，<code>x3 y3</code>是终点。来个demo吧！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"320px"</span> <span class="attr">height</span>=<span class="string">"320px"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">path</span> <span class="attr">id</span>=<span class="string">"line1"</span> <span class="attr">stroke</span>=<span class="string">"black"</span> <span class="attr">fill</span>=<span class="string">"none"</span> <span class="attr">d</span>=<span class="string">"M 0 50 Q 25 10 50 50"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></div></pre></td></tr></table></figure><p>效果：</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fjy6s1oe7uj203c02gq2p.jpg" alt=""></p><h3 id="确定控制点"><a href="#确定控制点" class="headerlink" title="确定控制点"></a>确定控制点</h3><p>确定了使用二次贝塞尔曲线，那么问题又来了，如何确定控制点呢？控制点决定了曲线的斜率和方向，我们期望曲线：</p><ul><li>对称。</li><li>接近直线，稍微弯曲即可，太弯可能会超出画布范围。</li><li>曲线永远顺时针，这样可以保证，A点到B点的曲线和B点到A点的曲线不重合。</li></ul><p>要想做到这三点，我们只需要让控制点：</p><ul><li>在两点的中垂线上。</li><li>距离两点的中点等于某个较小的固定值。</li><li>在起点和终点的顺时针区域。</li></ul><p>画个图吧！</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fjy7sndvwjj20hy0cgjrr.jpg" alt=""></p><ul><li>在顺时针区域画中垂线。中垂线和垂直线的角度为<code>angle</code></li><li>规定<code>offset</code>为某个定值（比如40，或者其他比较小的定值）。</li><li>那么控制点相对于中点的偏移值就确定了：<ul><li><code>offsetX = Math.sin(angle) * offset;</code></li><li><code>offsetY = -Math.cos(angle) * offset;</code></li></ul></li></ul><p>完整算法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCtlPoint</span>(<span class="params">startX, startY, endX, endY, offset</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> offset = offset || <span class="number">40</span>;</div><div class="line">  <span class="keyword">var</span> angle = <span class="built_in">Math</span>.atan2(endY - startY, endX - startX);</div><div class="line">  <span class="keyword">var</span> offsetX = <span class="built_in">Math</span>.sin(angle) * offset;</div><div class="line">  <span class="keyword">var</span> offsetY = -<span class="built_in">Math</span>.cos(angle) * offset;</div><div class="line">  <span class="keyword">var</span> ctlX = (startX + endX) / <span class="number">2</span> + offsetX;</div><div class="line">  <span class="keyword">var</span> ctlY = (startY + endY) / <span class="number">2</span> + offsetY;</div><div class="line">  <span class="keyword">return</span> [ctlX, ctlY];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="起点终点相同的情况"><a href="#起点终点相同的情况" class="headerlink" title="起点终点相同的情况"></a>起点终点相同的情况</h3><p>如果起点终点相同，我们就不能使用二次贝塞尔曲线了，而是应该在该点右侧画一个小圆弧，就像这样：</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fjy8a993prj203e032a9t.jpg" alt=""></p><p>在Path中圆弧的参数格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A rx ry x-axis-rotation large-arc-flag sweep-flag x y</div></pre></td></tr></table></figure><ul><li>弧形命令A的前两个参数分别是x轴半径和y轴半径。</li><li><code>x-axis-rotation</code>表示弧形的旋转情况。</li><li><code>large-arc-flag</code>决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。</li><li><code>sweep-flag</code>表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧。</li><li>最后两个参数是指定弧形的终点。</li></ul><blockquote><p>弧形命令A的具体用法不属于本文范畴，请参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths</a> 。</p></blockquote><p>因为我们要求：</p><ul><li>圆弧接近于圆，不是椭圆。</li><li>圆弧在右侧。</li><li>大于180度。</li></ul><p>所以，我们的圆弧参数为：</p><ul><li>x轴和y轴半径同为某个很小的定值（我们就设为10吧）</li><li><code>x-axis-rotation</code>为0，不需要旋转，既然是圆，转了也白转。</li><li><code>large-arc-flag</code>为1，显然大于180度。</li><li><code>sweep-flag</code>为1或0都行，不过要保证为1时，终点稍微比起点靠下一点，这样才能保证圆弧在右边。</li></ul><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"320px"</span> <span class="attr">height</span>=<span class="string">"320px"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">path</span> <span class="attr">id</span>=<span class="string">"line1"</span> <span class="attr">stroke</span>=<span class="string">"black"</span> <span class="attr">fill</span>=<span class="string">"none"</span> <span class="attr">d</span>=<span class="string">"M 50 50 A 10 10 0 1 1 50 50.1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></div></pre></td></tr></table></figure><p>效果截图：</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fjy8a993prj203e032a9t.jpg" alt=""></p><p>将两种情况封装成获取d属性的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getD</span>(<span class="params">startX, startY, endX, endY</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ctlPoint = getCtlPoint(startX, startY, endX, endY, <span class="number">40</span>);</div><div class="line">  <span class="keyword">var</span> d = [<span class="string">"M"</span>, startX, startY].join(<span class="string">" "</span>);</div><div class="line">  <span class="keyword">if</span> (startX !== endX || startY !== endY) &#123;</div><div class="line">    d += [<span class="string">" Q"</span>, ctlPoint[<span class="number">0</span>], ctlPoint[<span class="number">1</span>], endX, endY].join(<span class="string">" "</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    d += [<span class="string">" A"</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, endX, endY + <span class="number">0.1</span>].join(<span class="string">" "</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> d;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>完整demo：</p><p><a href="https://codepen.io/lewis617/pen/JrWMBy/" target="_blank" rel="external">https://codepen.io/lewis617/pen/JrWMBy/</a></p><h2 id="多点之间的轨迹"><a href="#多点之间的轨迹" class="headerlink" title="多点之间的轨迹"></a>多点之间的轨迹</h2><p>两点之间弧线确定了，那么如何确定多点之间的轨迹呢？其实很简单，只需要在命令后面加上新的控制点和终点即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">M x1 y1 Q x2 y2 x3 y3 Q x4 y4 x5 y5</div></pre></td></tr></table></figure><p>所以只需要简单更新一下之前封装的函数即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getD</span>(<span class="params">pointList</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> offset = offset || <span class="number">40</span>;</div><div class="line">  <span class="keyword">var</span> d = ([<span class="string">'M'</span> ,pointList[<span class="number">0</span>][<span class="number">0</span>], pointList[<span class="number">0</span>][<span class="number">1</span>]]).join(<span class="string">' '</span>);</div><div class="line">  pointList.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">point, i</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</div><div class="line">      <span class="keyword">var</span> startX = pointList[i<span class="number">-1</span>][<span class="number">0</span>],</div><div class="line">          startY = pointList[i<span class="number">-1</span>][<span class="number">1</span>],</div><div class="line">          endX = point[<span class="number">0</span>], </div><div class="line">          endY = point[<span class="number">1</span>];</div><div class="line">      </div><div class="line">      <span class="keyword">var</span> ctlPoint = getCtlPoint(startX, startY, endX, endY, offset);</div><div class="line">      </div><div class="line">      <span class="keyword">if</span>(startX !== endX || startY !== endY)&#123;</div><div class="line">        d+=([<span class="string">' Q'</span>, ctlPoint[<span class="number">0</span>], ctlPoint[<span class="number">1</span>], endX, endY]).join(<span class="string">' '</span>);</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        d+=([<span class="string">' A'</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, endX, endY + <span class="number">0.1</span>]).join(<span class="string">' '</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">return</span> d;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果<code>pointList</code>为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pointList = [</div><div class="line">  [<span class="number">0</span>, <span class="number">50</span>],</div><div class="line">  [<span class="number">0</span>, <span class="number">50</span>],</div><div class="line">  [<span class="number">50</span>, <span class="number">50</span>],</div><div class="line">  [<span class="number">100</span>, <span class="number">50</span>],</div><div class="line">  [<span class="number">0</span>, <span class="number">100</span>],</div><div class="line">  [<span class="number">50</span>, <span class="number">100</span>],</div><div class="line">  [<span class="number">100</span>, <span class="number">100</span>],</div><div class="line">];</div></pre></td></tr></table></figure><p>那么效果图：</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fjy8i3vmmij206w05s3yh.jpg" alt=""></p><p>完整demo：</p><p><a href="https://codepen.io/lewis617/pen/wrJpGY/" target="_blank" rel="external">https://codepen.io/lewis617/pen/wrJpGY/</a></p><h2 id="让轨迹回放起来"><a href="#让轨迹回放起来" class="headerlink" title="让轨迹回放起来"></a>让轨迹回放起来</h2><p>轨迹画完了，如何让它回放呢？这里需要用到这两个属性：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/stroke-dasharray" target="_blank" rel="external">stroke-dasharray</a>：控制用来描边的点划线的图案范式。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/stroke-dashoffset" target="_blank" rel="external">stroke-dashoffset</a>：指定了dash模式到路径开始的距离。</p><ul><li>先设置<code>stroke-dasharray</code>为 <code>&quot;length length&quot;</code>，来让曲线颜色和空白的长度均为曲线长度。</li><li>然后设置<code>stroke-dashoffset</code>初始状态为曲线长度，来保证整个曲线”看起来”都是空白。</li><li>最后渐变<code>stroke-dashoffset</code>属性为0，来模拟画线。</li></ul><p>如何渐变呢？使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/SVG_animation_with_SMIL" target="_blank" rel="external">SVG SMIL animation</a>。</p><p>关键代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> length = path.getTotalLength();</div><div class="line">path.setAttribute(<span class="string">"stroke-dasharray"</span>, length + <span class="string">" "</span> + length);</div><div class="line">path.setAttribute(<span class="string">"stroke-dashoffset"</span>, length);</div><div class="line">path.innerHTML= <span class="string">'&lt;animate attributeName="stroke-dashoffset" to="0"  dur="7s" begin="0s" fill="freeze" repeatCount="indefinite"/&gt;'</span>;</div></pre></td></tr></table></figure><p>完整demo：</p><p><img src="https://wx3.sinaimg.cn/mw690/83900b4egy1fk1jn3f98vg204h04edfz.gif" alt=""></p><p><a href="https://codepen.io/lewis617/pen/vexjyp/" target="_blank" rel="external">https://codepen.io/lewis617/pen/vexjyp/</a></p><h2 id="给轨迹加上“圆头”"><a href="#给轨迹加上“圆头”" class="headerlink" title="给轨迹加上“圆头”"></a>给轨迹加上“圆头”</h2><p>马上就可以看见胜利的曙光了，最后我们来做轨迹的“圆头”：</p><ul><li>圆头就是个圆点（circle）</li><li>圆点需要跟着轨迹一起移动</li></ul><p>画一个圆点很简单，那么如何画一个按照轨迹移动的圆点呢？答案是：<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/animateMotion" target="_blank" rel="external">animateMotion元素</a>。</p><p>关键代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPathHead</span>(<span class="params">pathObj, d</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> r = <span class="number">3</span>;</div><div class="line">  <span class="keyword">var</span> head = <span class="built_in">document</span>.createElementNS(<span class="string">"http://www.w3.org/2000/svg"</span>, <span class="string">"circle"</span>);</div><div class="line">  head.setAttribute(<span class="string">"id"</span>, pathObj.id + <span class="string">"-head"</span>);</div><div class="line">  head.setAttribute(<span class="string">"r"</span>, r);</div><div class="line">  head.setAttribute(<span class="string">"fill"</span>, pathObj.stroke);</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> animateMotion = <span class="built_in">document</span>.createElementNS(<span class="string">"http://www.w3.org/2000/svg"</span>, <span class="string">"animateMotion"</span>);</div><div class="line">  animateMotion.setAttribute(<span class="string">"path"</span>, d);</div><div class="line">  animateMotion.setAttribute(<span class="string">"begin"</span>, <span class="string">"indefinite"</span>);</div><div class="line">  animateMotion.setAttribute(<span class="string">"dur"</span>, <span class="string">"7s"</span>);</div><div class="line">  animateMotion.setAttribute(<span class="string">"fill"</span>, <span class="string">"freeze"</span>);</div><div class="line">  animateMotion.setAttribute(<span class="string">"rotate"</span>, <span class="string">"auto"</span>);</div><div class="line">  head.appendChild(animateMotion);</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>至此，轨迹回放的关键技术点就讲完了，再次欣赏下最终的效果：</p><p><img src="https://wx1.sinaimg.cn/mw690/83900b4egy1fk1jn3atyng204h04ead8.gif" alt=""></p><p>完整的demo在这里：</p><p><a href="https://codepen.io/lewis617/pen/RLpxPj/" target="_blank" rel="external">https://codepen.io/lewis617/pen/RLpxPj/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做了埋点方案XTracker的轨迹回放功能，大致效果就是，在指定几个顺序的点之间形成轨迹，来模拟用户在页面上的先后行为（比如一个用户先点了啥，后点了啥）。效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/mw690/83900b4egy1fk1jn3atyng204h04ead8.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们来聊聊轨迹回放的一些技术细节。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，本文只关注轨迹的绘制，并不讨论轨迹的各种生成算法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="SVG" scheme="http://www.liuyiqi.cn/tags/SVG/"/>
    
      <category term="贝塞尔曲线" scheme="http://www.liuyiqi.cn/tags/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/"/>
    
      <category term="SVG SMIL animation" scheme="http://www.liuyiqi.cn/tags/SVG-SMIL-animation/"/>
    
  </entry>
  
  <entry>
    <title>Jason Miller：Preact：Into the void 0（译）</title>
    <link href="http://www.liuyiqi.cn/2017/09/04/preact-into-the-void-0/"/>
    <id>http://www.liuyiqi.cn/2017/09/04/preact-into-the-void-0/</id>
    <published>2017-09-04T11:00:00.000Z</published>
    <updated>2017-11-01T09:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理自Jason Miller在JSConf上的talk。原视频地址：</p><p><a href="https://www.youtube.com/watch?v=LY6y3HbDVmg" target="_blank" rel="external">https://www.youtube.com/watch?v=LY6y3HbDVmg</a></p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj6o29y7yvj21gk0t8gp1.jpg" alt=""></p><a id="more"></a><h2 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h2><p>嗨，大家好，我是Jason，Github上那个developit和推特上的_developit，是一系列库的作者（serial library author），我喜欢甜甜圈、肉汁乳酪薯条和斧头，这意味着我是加拿大人（枫叶国的人喜欢斧头——<a href="https://dushi.singtao.ca/toronto/%E8%B4%A2%E7%BB%8F-%E5%88%86%E7%B1%BB/%E5%88%9B%E4%B8%9A%E6%95%85%E4%BA%8B-%E5%88%86%E7%B1%BB/%E5%9C%A8%E5%8A%A0%E6%8B%BF%E5%A4%A7%E6%8A%8A%E6%89%94%E6%96%A7%E5%A4%B4%E5%81%9A%E6%88%9015%E4%B8%87%E7%94%A8%E6%88%B7%E7%9A%84%E5%A4%A7%E7%94%9F%E6%84%8F/" target="_blank" rel="external">在加拿大把扔斧头做成15万用户的大生意</a>）。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj6n75o3dfj21fm0yyk30.jpg" alt=""></p><p>我也喜欢“限制”。我在移动web广泛应用前就开始开发它了，那时候还是windows mobile 5。我写了很多UI框架，遇到了很多问题，然后努力去解决它们。这样的理由是我发现“限制”是很有趣的“挑战”，我有些ADHD（注意（力）缺陷多动障碍），你或许熟悉这个东西，为了高效做一些事，最好可以非常专注在上面，这些有趣的“限制”挑战可以帮助我营造这个环境。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj6n7uvhe1j21ag0uetbg.jpg" alt=""></p><h2 id="点题"><a href="#点题" class="headerlink" title="点题"></a>点题</h2><p>我写了Preact，这个展示叫“Preact: Into the void 0”，我觉得这么叫很聪明（这哥们太极客了，void(0)是js中返回undefined的最小脚本），这也是这个幻灯片中唯一的一个分号哦。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj6o29y7yvj21gk0t8gp1.jpg" alt=""></p><p>或许你会好奇啥是Preact，这就是Preact。我移除了源代码映射的注释，今天我们主要讲一下这几个圆圈圈中的部分。因为这是Preact的展示，所以我们需要一些紫色，不管那是啥，那都是我们最后要讲的东西。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7b4qalvoj21v811i7wj.jpg" alt=""></p><h2 id="JSX简介"><a href="#JSX简介" class="headerlink" title="JSX简介"></a>JSX简介</h2><p>不过在开始讲这些东西前，我们需要聊聊JSX。如果你对JSX不熟悉，我不知道你之前是靠在哪个山头。不过别担心，JSX真的非常容易理解。JSX的核心非常简单，等我讲完时候，你完全可以用JSX重写你Webpack配置，让它变得更长、更复杂，这是个好事。如果你不相信我，去看看webpack2的文档吧，都在里面写着呢。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7cmp9hotj21aa0ms75t.jpg" alt=""></p><p>那么什么是JSX？JSX是一个XML风格的表达式，然后被编译为函数调用。我们编写左边的那个很像HTML的尖括号语法。右边是像babel这样的编译器输出的结果，现在貌似已经有十种编译器了。我最喜欢的JSX的点就是很喜欢这种写法，这种带有点DOM风格的写法，编译在前面做了一些事，好让我们可以更好地理解它。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7hwm3j0aj21e80vmq6t.jpg" alt=""></p><p>再来看一个稍微复杂一点的写法。这些尖括号语法被编译为了JavaScript，其中<code>one</code> 和变量 <code>world</code>都被保留了下来，另外一个复杂的地方是，如果你的标签名首字母大写，那么它在生成代码中将会是个变量引用。</p><blockquote><p>译者注：JSX中的标签名大小写是有讲究的，小写代表是HTML标签，大写代表一个组件，具体可以看JSX的文档。</p></blockquote><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7i7h7npgj21e60ym7aw.jpg" alt=""></p><p>JSX的精髓就是我们看过的那个工厂函数，它非常简单，只有一个接受节点名称、属性、children的签名。节点名称就是之前说的标签名称，它可以是字符串或者函数，属性是可选的，它可以是个对象，剩余的参数就是children，这就是我们编写的形式。<br><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7imbjvoaj21es0wyaf8.jpg" alt=""></p><p>你或许会想，我刚才编写不是hyperscript吗？你想的也不算错，hyperscript确实跟JSX很相似，有点JSX超集的意思。看看这两个例子吧！hyperscript支持这种附加的标签写法，本质上来说是CSS选择器的写法，去预定义元素上的属性，而JSX却不支持这种写法。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7iwejmd8j21h80zctcs.jpg" alt=""></p><p>JSX真正的能力是可以支持这种拓展标签名称。理解好JSX是很重要的，JSX是我们连接各种虚拟DOM库的接口，JSX不是DOM，它跟DOM没啥关联，它只是一种语法，它并不理解你的代码或它被用来做的事，你甚至可以用它编写Webpack配置，但还是别了。你可以用它编写XML，如果你想编写一个SOAP客户端，而且你想用解析和序列化，你就可以使用JSX做这个。总之，我想说JSX是问题的有趣解决方案。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7j3w1fauj216a0uowil.jpg" alt=""></p><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>下个话题是虚拟DOM。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7jgwtbo2j21ku0pm40e.jpg" alt=""></p><p>虚拟DOM仅仅只是个代表树状结构的对象而已，仅仅如此，没啥别的玄乎的！我经常把它想成一个传递给DOM构建器的一个配置，好让DOM构建器不那么理论化。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7jgd8tvwj21cg0tijuo.jpg" alt=""></p><p>不过，首先我们要理解的是，我们如何从JSX到虚拟DOM。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7jqrweslj21dg0xin25.jpg" alt=""></p><p>我们所做的方式是调用刚才定义参数的那个h函数。这非常容易理解，我们编写JSX，然后调用h函数，我们要做的就是定义一个h函数，生成这样的对象。这个对象就是虚拟DOM，虚拟DOM就是一个嵌套对象。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7ju59ctmj21j40ymdkp.jpg" alt=""></p><p>令人惊讶的简单，我们要做的就是这个而已！一个只有一行代码的函数！当然，你可以在这里做更多的事情，如果你想扁平化children，去除空值，连接相邻的字符串节点等。但核心是，你可以通过这个函数编写一个虚拟DOM渲染器。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7jzhp1zkj21au0xkado.jpg" alt=""></p><p>所以，让我们做这个吧！让我们编写一个虚拟DOM渲染器！第一件事，我们要传递给我们自己一个虚拟节点，这是我们之前见过的那个对象，看右上方的滚动框。所以，第一件事是我们需要创建一个DOM对象，匹配传递进来的虚拟节点的类型。所以我们使用<code>document.createElement</code>来做这个。然后我们循环给DOM赋予属性。接着，我们又写了一个递归来循环渲染子节点。最后，我们在类型为字符串时，直接返回DOM对象。这就是我们编写的虚拟DOM渲染器！</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7k5n7wtaj21fw10gtir.jpg" alt=""></p><p>这里有个稍微复杂的地方，那就是attributes。如果有人用过React，那么你可能会怒气冲冲地说那不是attrbutes，那是properties！事实上应该叫“props”。attributes和properties是两个不同东东的抽象！大多HTML元素会接受数据作为attributes，它们也可以接受类似的，定型数据作为properties，通过一个叫DOM property reflection的东东。但事实上，这两种都是不太对的，有时候我们可以使用properties，不能使用attributes，有时候又反过来。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7kwyjmokj21d60vaagy.jpg" alt=""></p><p>我们需要的是将两种写法都写出来！我们有一个DOM节点的引用，我们问它，你支持foo这个property吗？如果它支持，就用property，否则就用attributes。这对自定义元素很好，因为自定义元素倾向于为property定义getter setter对。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7l08enxfj21bk0w6449.jpg" alt=""></p><p>这时你可能想问，这能运行吗？这是个虚拟DOM，我们把它传给编写的渲染函数。右边显示的是结果，它可以运行哈哈。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7lfhftmqj21e00vgdjz.jpg" alt=""></p><h2 id="DIFF算法"><a href="#DIFF算法" class="headerlink" title="DIFF算法"></a>DIFF算法</h2><p>我们刚才编写了一个非常简单的虚拟DOM渲染器，也是个非常糟糕的虚拟DOM渲染器，这是版本0。说它糟糕是因为它不能DIFF，它不关注当前的DOM状态，只是完全替换了新dom。虚拟DOM中的DIFF算法是一个争议和神秘的主题，争议是有必要的，因为过程中充满了权衡，并不是非黑即白，而神秘是没有必要的，我试图去揭开它神秘的面纱！</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7lpsb50wj21hm0r440j.jpg" alt=""></p><p>DIFF舍弃从上到下渲染，创建新的DOM。我们将会传递给我们自己一个现在DOM，然后把它变为JSX中写的样子，只是应用一下差异而已。<br><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7luaibjhj21bk0vwgrb.jpg" alt=""></p><p>在左边，你可以看到虚拟DOM长啥样，只是一个对象。在右边，是一个真实的DOM。你可以看到，名字都差不多。你可以比较一下，然后把差异应用到右边。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7m2a5zgtj21c00vq43d.jpg" alt=""></p><p>运行DIFF，只需要三步。第一步是type，在所有事情前，我们必须要创建一个准确类型的DOM。第二步是循环遍历children，去双向比较它们，然后找出我们是否需要添加、移除、重排它们等。最后一步是更新attributes/props。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7mnc3fnpj21980tkn17.jpg" alt=""></p><p>所以，让我们从type 开始吧！第一件事是判断节点是否是组件创建的。如果不是，事情就简单了！如果同类型就更新，否则就抛弃原来的，创建一个新的。如果是组件创建的，事情会稍微复杂一点。我们需要创建一个实例，通过比较创建或更新组件的props，然后调用render方法。</p><blockquote><p>译者注：实际情况其实更加复杂，这里需要对组件、组件实例、组件生命周期非常熟悉才能理解。在组件生命周期中，真正操控大局的是组件实例，所以这里需要先创建一个组件实例。</p></blockquote><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7mzdwm1fj21eo0wq0yj.jpg" alt=""></p><p>children更加简单，只有三步。第一步是循环遍历所有的children，把它们放到列表中，没key的话就放到unkey列表，有key就放到keyed map中。第二步是我们把新的虚拟children转移过去，我们在列表中发现匹配的，然后和虚拟DOM做对比，最后把它插入到当前的index中。最后一步是最简单的，如果有kids剩余，就删除它们，因为它们已经用不到了。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7myx049ij21eu104n3t.jpg" alt=""></p><p>你或许对keyed map和unkey list感兴趣。我今天很想讨论这个话题，我曾在stack overflow上回答过这个问题，这是我在stack overflow上回答的唯一的问题。所以，让我们用PPT来演示它。keys是一些虚拟DOM上有意义的顺序属性，当这些虚拟DOM拥有唯一的类型。我们可以在这个例子中看到，我们拥有三个列表项——one，two，three。在第二个渲染框中，我们只有两个列表项，对于你和我这样的人类而言，我们只需要删除two，把第三项移上去。但虚拟DOM渲染器不知道这个，没有任何东西说明two就是第二项，它就是每次接受一个新的树，没有什么事可以矫正它。这整个过程就是，看看第一项，没变，然后啥事也没发生，然后看看第二项，它说，不，内容不一样啊，然后它就更改了内容。第三项直接被删除了。默认情况下，虚拟DOM中的元素列表，它只会push和pop，没法移动改变中间的项。与此相反，在有key的方法中，我们给每个元素一个唯一的key，所以在第一个框中，我们看到了1，2，3，在第二个框中，我们看到了1，3。很明显，key2被移除了，现在，我们告诉虚拟DOM应该做什么，所以它知道当它循环到key2时，它就会删除该项。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7obuoj1jj21fc0wsgtk.jpg" alt=""></p><p>DIFF的最后一步是attributes，这真的很简单，我们给我们自己老的属性和新的属性，从老的属性中找到不在新属性中的属性，然后把它们设置为undefined。对于新的属性，我们和老属性对比，然后设置新属性的值。我们解决了所有的问题，现在我们的app变得非常快！我们把所有问题都转移到了库中，这些库包括：react、preact、inferno等。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7occh61uj21gk0v8q7p.jpg" alt=""></p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>我想和大家讨论一些性能的话题。我编写Preact时，就想测试它的性能。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7qby6v8wj21hu0mggob.jpg" alt=""></p><p>这句话是你经常在推特上看见人说的。我们经常听到有人抱怨说DOM太慢了，DOM是性能差的根源所在。确实，DOM没有immediate mode drawing API那么快，它设计的目的不是这个，这是完全不同的事。DOM本质上提供了内建的accessibility。你可以使用title和字体注释DOM，还可以得到屏幕阅读器的支持。其他平台也可以这么做，但是DOM做这种事情更加简单。你根本不需要理解它是如何运作的，只需要编写语意化的标记即可。DOM也可以拓展，人们经常忘记这点。如果我在windows上使用推特，我想为推特添加emoji，我就安装浏览器拓展，然后就hook到了每一个在推特上的输入文本，接下来我不依赖推特的输入字段就可以使用emoji了。推特不知道这个，也不需要知道，也不在乎这个。这就是DOM的价值之一，这种基质巩固了所有的应用，它是一种超越我们知识范畴的拓展。这就跟那个“框架不可知论”不谋而合。你可以编写两个不同的插件在两个不同的框架中，只要它们可以渲染元素，你可以假设这些元素拥有相同的祖先元素，它们彼此之间不需要相互在乎。所以，Preact本质上来说就是个DOM渲染器，它是虚拟DOM渲染器，但它就是一种DOM库。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7r2tleloj218y0ic40u.jpg" alt=""></p><p>接下来，我想分享我在编写DOM库过程中的一些经验，第一个是使用文本节点来表示文本。这听起来很傻，我意识到了这个。但是很惊讶的是，我们经常曲解这句话。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7r3v1w7kj21ao0s8jtn.jpg" alt=""></p><p>DOM拥有API去和文本打交道，我们却经常忽略这些API。我们可以通过这些API去创建文本，插入文本，反转文本等。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7r8yo1wqj21gu0ty0xg.jpg" alt=""></p><p>这是个benchmark showing，展示了<code>textContent</code>和<code>Text.nodeValue</code>的速度，后者很明显更快。如果你正在编写一个有处理文本的DOM库或框架，那么选择前者会让你发疯。<code>textContent</code>做了更多工作，只说它慢貌似不太公平。但大多情况下，我们不需要处理“更多的工作”。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7rhq0ed9j217w0w2gq2.jpg" alt=""></p><p>下一个经验是，避免getters，完全的！别使用它们。Text的nodeType是undefined，但是它继承的Node的nodeType是个getter方法，性能不好。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7rrtjekbj21gy0jy7ac.jpg" alt=""></p><p>如图所示，splitText更快，因为这只是检查某个属性是否存在，而不是调用getter。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7rthnnovj21fk0vygpx.jpg" alt=""></p><p>这是一个性能测试，可以看到getters都很慢，而属性获取的速度却很快。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7rw7qmooj21jg0yatha.jpg" alt=""></p><p>最后一个经验是避免Live NodeLists，不要试图去用它们，它们特别耗性能。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7s0yww8aj21a20uk0uz.jpg" alt=""></p><p>这是一个例子，试图去移除父元素的children。第一个你写了一个倒置的循环去移除，之所以倒置是因为这是个live NodeList，它的项数不停的在变化。第二个就快多了，因为我们只是在获取一个属性，不需要回头去请求子节点。我们不需要去获取数组的位移，我们只是在用一个引用。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7s1eagrrj21ea0w20xj.jpg" alt=""></p><p>这是测试结果。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7s85x3i6j21i60wy0x7.jpg" alt=""></p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>我已经做性能优化很久了。Benchmark运行了五百万次循环，然后计算时间。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7sacjfgpj21ii0pm76d.jpg" alt=""></p><p>Chrome开发工具优化了这个，使其更加可视化。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7shbtvtuj21gk0y8k0g.jpg" alt=""></p><p>另一个工具是IRHydra。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7shuxscpj21ds0wih0c.jpg" alt=""></p><p>最后一个工具是ESBench。这个工具的目的是给你一个非常简单的用户界面去使用Babel和benchmark。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7sj2xdv0j21b00wutdi.jpg" alt=""></p><h2 id="其他经验"><a href="#其他经验" class="headerlink" title="其他经验"></a>其他经验</h2><p>第一个是尽量明确的。不要使用一些意外情况，如果你没有理由使用它们。这个例子中，我们检查一个对象的属性，它可能是0，空字符串，null，false等，第二种就清楚多了。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7srvrm9xj21ag0v4tbo.jpg" alt=""></p><p>下一个经验是行内帮助函数。函数可以更加通用。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7swa4vo9j21au0vujvc.jpg" alt=""></p><p>下一个是短路语法。最便宜的函数调用就是你不调用它。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7syosb7aj21cg0ue41l.jpg" alt=""></p><p>所有这一切都是在说一个道理：基于数据去做决定。</p><p><img src="https://ww1.sinaimg.cn/mw690/83900b4egy1fj7sz6p7llj21cw0moqv5.jpg" alt=""></p><hr><h2 id="教程示例代码及目录"><a href="#教程示例代码及目录" class="headerlink" title="教程示例代码及目录"></a>教程示例代码及目录</h2><p>示例代码：<a href="https://github.com/lewis617/react-redux-tutorial" target="_blank" rel="external">https://github.com/lewis617/react-redux-tutorial</a></p><p>目录：<a href="http://www.liuyiqi.cn/tags/React/">http://www.liuyiqi.cn/tags/React/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文整理自Jason Miller在JSConf上的talk。原视频地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=LY6y3HbDVmg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.youtube.com/watch?v=LY6y3HbDVmg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/mw690/83900b4egy1fj6o29y7yvj21gk0t8gp1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术讲座" scheme="http://www.liuyiqi.cn/tags/%E6%8A%80%E6%9C%AF%E8%AE%B2%E5%BA%A7/"/>
    
      <category term="Preact" scheme="http://www.liuyiqi.cn/tags/Preact/"/>
    
      <category term="JSX" scheme="http://www.liuyiqi.cn/tags/JSX/"/>
    
      <category term="虚拟DOM" scheme="http://www.liuyiqi.cn/tags/%E8%99%9A%E6%8B%9FDOM/"/>
    
      <category term="性能" scheme="http://www.liuyiqi.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>使用 superagent+cheerio 写爬虫</title>
    <link href="http://www.liuyiqi.cn/2017/04/24/node-spider/"/>
    <id>http://www.liuyiqi.cn/2017/04/24/node-spider/</id>
    <published>2017-04-24T11:57:00.000Z</published>
    <updated>2017-11-09T09:58:06.968Z</updated>
    
    <content type="html"><![CDATA[<p>本文将会讲解如何使用 superagent+cheerio 写爬虫。阅读本文，你会学习到这些知识点：</p><ul><li>如何使用 superagent 获取页面内容</li><li>如何使用 superagent 获取 JS 文件的内容</li><li>如何使用 superagent 下载文件</li><li>如何使用 cheerio 操作页面 DOM</li><li>如何正确设置字符编码来避免乱码</li><li>如何使用正则表达式去除字符串中的多余信息</li></ul><a id="more"></a><h2 id="使用-superagent-获取页面内容"><a href="#使用-superagent-获取页面内容" class="headerlink" title="使用 superagent 获取页面内容"></a>使用 superagent 获取页面内容</h2><p>superagent+cheerio 是 Node 爬虫的经典组合。superagent 是一个发起 Ajax 请求的工具。我们使用它来请求各种网络资源。比如，我们想批量爬取一些文件，我们就必须先找到文件的 URl，想找到 URL 就必须先获取记录这些 URL 的页面，想获取页面内容，那么首先就应该使用 superagent 把页面给请求下来。基本的请求代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">request</div><div class="line">  .get(<span class="string">'http://example.com/search'</span>)</div><div class="line">  .end(<span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>)</span>&#123;</div><div class="line">   <span class="comment">// 将会打印页面的 HTML 字符串</span></div><div class="line">      <span class="built_in">console</span>.log(res.text);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p>拿到了 HTMl 字符串，就可以使用 cheerio 进行解析了。关于 cheerio 我们等会介绍～ </p><h2 id="使用-superagent-获取-JS-文件的内容"><a href="#使用-superagent-获取-JS-文件的内容" class="headerlink" title="使用 superagent 获取 JS 文件的内容"></a>使用 superagent 获取 JS 文件的内容</h2><p>使用 superagent 获取页面内容非常简单，但是当我请求完页面后发现，音频和字幕的 URL 不在页面上，而是通过 JS 动态渲染到页面上的，我的爬虫无法和 JS 通信，这该怎么办呢？其实非常简单，既然 URL 信息在 JS 文件中，那么我们直接获取 JS 文件，并使用 eval 方法解析不就行了？所以，我们来使用 superagent 获取 JS 文件的内容。与获取页面内容的方法不同，获取 JS 文件，需要加个 <code>.buffer(true)</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">request.get(<span class="string">'https://raw.githubusercontent.com/sindresorhus/negative-zero/master/index.js'</span>)</div><div class="line">    .buffer(<span class="literal">true</span>)</div><div class="line">    .end(<span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</div><div class="line">      ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>为何要如此？具体原因可以看这个 Issue：</p><p> <a href="https://github.com/visionmedia/superagent/issues/523" target="_blank" rel="external">https://github.com/visionmedia/superagent/issues/523</a></p><h2 id="使用-superagent-下载文件"><a href="#使用-superagent-下载文件" class="headerlink" title="使用 superagent 下载文件"></a>使用 superagent 下载文件</h2><p>前面两节介绍了使用 superagent 获取页面和 JS 文件，那么如何使用 superagent 下载保存文件到硬盘上呢？这里需要配合使用 Node 的 <code>fs.createWriteStream</code> 方法，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">url, localPath, cb</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> stream = fs.createWriteStream(localPath);</div><div class="line">    stream.on(<span class="string">'finish'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'The download of '</span> + localPath + <span class="string">' is complete!'</span>);</div><div class="line">        cb();</div><div class="line">    &#125;);</div><div class="line">    request.get(url).pipe(stream);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>非常简单，不再赘述！</p><h2 id="使用-cheerio-操作页面-DOM"><a href="#使用-cheerio-操作页面-DOM" class="headerlink" title="使用 cheerio 操作页面 DOM"></a>使用 cheerio 操作页面 DOM</h2><p>在第一节，我们介绍了使用 superagent 获取页面内容，但是页面内容太多，我们想高效提取有用信息，该如何做呢？在浏览器中，我们通常使用 jQuery 来高效操作 DOM，在 Node 爬虫中，我们可以使用 cheerio 来模拟 jQuery 的操作方法。cheerio 的基本用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>)</div><div class="line"><span class="keyword">var</span> $ = cheerio.load(<span class="string">'&lt;h2 class="title"&gt;Hello world&lt;/h2&gt;'</span>)</div><div class="line"></div><div class="line">$(<span class="string">'h2.title'</span>).text(<span class="string">'Hello there!'</span>)</div><div class="line">$(<span class="string">'h2'</span>).addClass(<span class="string">'welcome'</span>)</div><div class="line"></div><div class="line"><span class="keyword">return</span> $.html()</div><div class="line"><span class="comment">//=&gt; &lt;h2 class="title welcome"&gt;Hello there!&lt;/h2&gt;</span></div></pre></td></tr></table></figure><p>通过 superagent 获取 html 字符串，然后使用 cheerio 解析，页面上的内容就尽在你的掌握中了！</p><p>更多 cheerio 的用法可以参考：</p><p><a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="external">https://github.com/cheeriojs/cheerio</a></p><h2 id="正确设置字符编码来避免乱码"><a href="#正确设置字符编码来避免乱码" class="headerlink" title="正确设置字符编码来避免乱码"></a>正确设置字符编码来避免乱码</h2><p>在获取页面内容，并提取里面的中文信息时，偶尔会遇到中文乱码。这是因为页面的 chartset 设置了<code>gb2312</code> 的原因，那么想要正确解析设置 <code>gb2312</code> 编码的页面，就必须使用这个编码来解析。值得高兴的是，superagent 为我们提供了相关的插件来实现：</p><p><a href="https://github.com/magicdawn/superagent-charset" target="_blank" rel="external">https://github.com/magicdawn/superagent-charset</a></p><p>基本用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">request.get(mainOrigin + mainPathname)</div><div class="line">    .charset(<span class="string">'gb2312'</span>)</div><div class="line">    .end(<span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><p>如何知道 <code>.charset()</code> 中填的是什么编码呢？你只需要看看页面的这行代码即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=gb2312"</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="使用正则表达式去除字符串中的多余信息"><a href="#使用正则表达式去除字符串中的多余信息" class="headerlink" title="使用正则表达式去除字符串中的多余信息"></a>使用正则表达式去除字符串中的多余信息</h2><p>最后，我们来讲一下如何使用使用正则表达式去除字符串中的多余信息。在下载文件时，可能需要处理一些中文名称作为将来的文件名或目录名。页面中的中文名称往往不是我们想要的，那么如何处理名称中的多余信息呢？使用正则表达式就可以做到！比如：</p><p>如果你想将 <code>&#39;听电影学英语之海上钢琴师&#39;</code>变为<code>&#39;海上钢琴师&#39;</code>，那么你可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// str 就是'海上钢琴师'</span></div><div class="line"><span class="keyword">var</span> str = <span class="string">'听电影学英语之海上钢琴师'</span>.replace(<span class="regexp">/听电影学英语之/g</span>, <span class="string">''</span>);</div></pre></td></tr></table></figure><p>如果你想将 <code>&#39;听电影MP3学英语之海上钢琴师&#39;</code> 或 <code>&#39;听电影学英语之海上钢琴师&#39;</code>变为<code>&#39;海上钢琴师&#39;</code>，那么你可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// str 就是'海上钢琴师'</span></div><div class="line"><span class="keyword">var</span> str = <span class="string">'听电影学英语之海上钢琴师'</span>.replace(<span class="regexp">/听电影(MP3)?学英语之/g</span>, <span class="string">''</span>);</div></pre></td></tr></table></figure><blockquote><p>注：小括号代表子表达式，问号代表前面的字符出现 0 或 1 次。</p></blockquote><p>如果你想将以下字符串：</p><ul><li><code>&#39;听电影学英语之海上钢琴师&#39;</code></li><li><code>&#39;听电影MP3学英语之海上钢琴师&#39;</code></li><li><code>&#39;听电影MP3学英语之海上钢琴师中英双语MP3+LRC&#39;</code></li><li><code>&#39;听电影MP3学英语之海上钢琴师 中英双语MP3+LRC&#39;</code></li><li><code>&#39;听电影MP3学英语之海上钢琴师 中英双语MP3+LRC+文本&#39;</code></li><li><code>&#39;听电影MP3学英语之海上钢琴师 中英双语MP3+LRC+文本 &#39;</code></li></ul><p>都变为 <code>&#39;海上钢琴师&#39;</code>，那么正则表达式应该这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/(听电影(MP3)?学英语之)|(\s?中英双语MP3\+LRC(\+文本)?)|(\s?$)/g</div></pre></td></tr></table></figure><p>把各种情况都考虑进去，然后用 <code>|</code> 隔开。其中，<code>\s</code> 匹配任何空白字符，包括空格、制表符、换页符等等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面介绍了 superagent+cheerio 写爬虫需要用到的各种技术，本文不打算对业务进行过多叙述。只要掌握了上述方法，就可以轻松读懂爬虫代码，如果你没写过爬虫，就赶快试试吧！</p><h2 id="教程示例代码及目录"><a href="#教程示例代码及目录" class="headerlink" title="教程示例代码及目录"></a>教程示例代码及目录</h2><p><a href="https://github.com/lewis617/practical-js" target="_blank" rel="external">https://github.com/lewis617/practical-js</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将会讲解如何使用 superagent+cheerio 写爬虫。阅读本文，你会学习到这些知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何使用 superagent 获取页面内容&lt;/li&gt;
&lt;li&gt;如何使用 superagent 获取 JS 文件的内容&lt;/li&gt;
&lt;li&gt;如何使用 superagent 下载文件&lt;/li&gt;
&lt;li&gt;如何使用 cheerio 操作页面 DOM&lt;/li&gt;
&lt;li&gt;如何正确设置字符编码来避免乱码&lt;/li&gt;
&lt;li&gt;如何使用正则表达式去除字符串中的多余信息&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="practical-js" scheme="http://www.liuyiqi.cn/tags/practical-js/"/>
    
      <category term="Node" scheme="http://www.liuyiqi.cn/tags/Node/"/>
    
      <category term="爬虫" scheme="http://www.liuyiqi.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="superagent" scheme="http://www.liuyiqi.cn/tags/superagent/"/>
    
      <category term="cheerio" scheme="http://www.liuyiqi.cn/tags/cheerio/"/>
    
      <category term="字符编码" scheme="http://www.liuyiqi.cn/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
      <category term="正则表达式" scheme="http://www.liuyiqi.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 版链表算法题：两个数相加</title>
    <link href="http://www.liuyiqi.cn/2017/03/12/add-two-numbers/"/>
    <id>http://www.liuyiqi.cn/2017/03/12/add-two-numbers/</id>
    <published>2017-03-12T03:41:00.000Z</published>
    <updated>2017-10-24T11:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是一道链表算法题：两个数相加。这道题有两个版本，它们都来自 LeetCode：</p><p><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="external">https://leetcode.com/problems/add-two-numbers/</a></p><p><a href="https://leetcode.com/problems/add-two-numbers-ii/" target="_blank" rel="external">https://leetcode.com/problems/add-two-numbers-ii/</a></p><p>本文将先回顾链表的基础知识，然后解决这两个问题，所用的语言依然是 JavaScript。</p><a id="more"></a><h2 id="链表基础"><a href="#链表基础" class="headerlink" title="链表基础"></a>链表基础</h2><p>在前面的博文<a href="https://lewis617.github.io/2017/02/15/linked-list/" target="_blank" rel="external">《JavaScript 版数据结构与算法（三）链表》</a>中，我们讲解了：</p><ul><li>什么是链表？</li><li>链表的作用？</li><li>链表的数据结构长啥样？</li><li>如何用 JavaScript 编写一个链表类，并实现 <code>append</code>、<code>toString</code>、<code>removeAt</code>、<code>insert</code>、<code>indexOf</code> 等多个链表方法。</li></ul><p>这些基础知识对做链表题非常有帮助，如果你之前没有阅读过这篇博文，那么我强烈建议你读一遍，然后自己写一个链表类。如果你对链表的基础知识比较熟悉，那么就继续往下读吧！</p><h2 id="两个数相加"><a href="#两个数相加" class="headerlink" title="两个数相加"></a>两个数相加</h2><p>让我们开始做题吧！首先，先来看下题目：</p><blockquote><p>给你两个非空的链表来表示两个非负整数。整数的每个数字倒序存储在链表的每个节点中。现在你需要写一个函数，将两个整数相加，并以链表的形式返回它们的和。</p><p>你可以假设两个整数没有任何前导零，除非是零本身。</p></blockquote><p>我们再通过测试用例来表达一下题意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</div><div class="line">Output: 7 -&gt; 0 -&gt; 8</div><div class="line"></div><div class="line">Input: (1 -&gt; 8) + (0)</div><div class="line">Output: 1 -&gt; 8</div><div class="line"></div><div class="line">Input: (9) + (1)</div><div class="line">Output: 0 -&gt; 1</div></pre></td></tr></table></figure><p>要实现的函数以及链表的结构是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * function ListNode(val) &#123;</span></div><div class="line"><span class="comment"> *     this.val = val;</span></div><div class="line"><span class="comment"> *     this.next = null;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * @param &#123;ListNode&#125; l1</span></div><div class="line"><span class="comment"> * @param &#123;ListNode&#125; l2</span></div><div class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>题目表述完了，那么如何做呢？其实两个数相加的逻辑非常简单，无非是：</p><ul><li>从个位开始相加，生成的数字的个位数就是新数字的个位数，十位数放到下个数中相加。</li><li>对其他位数执行上述操作。</li></ul><p>这个小学生都会，那么如何在链表中实现呢？这需要你了解链表几个常用操作：</p><ul><li>如何遍历链表？</li><li>如何生成新链表？</li></ul><p>如何遍历链表呢？非常简单，你需要一个 <code>current</code> 指针（其实就是个变量），然后在 while 循环中执行 <code>current = current.next</code> 即可。</p><p>如何生成新链表？这也非常简单，你只需要一个 <code>current</code> 指针指向链表最后一位，然后执行 <code>current.next = new Node(val)</code> 即可。</p><p>了解了链表的这两个操作，然后我们对前两个链表进行遍历相加，生成新链表即可。为此，我们需要设置几个变量：</p><ul><li>三个链表的 <code>current</code> 指针：<code>c1</code>、<code>c2</code>、<code>c3</code>。</li><li>新链表：<code>l3</code>。</li><li>放到下一位相加的数字：<code>carry</code>。</li></ul><p>完整代码就是：</p><p>LeetCode/002-addTwoNumbers.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> c1 = l1,</div><div class="line">    c2 = l2,</div><div class="line">    l3, c3,</div><div class="line">    carry = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (c1 || c2 || carry) &#123;</div><div class="line">    <span class="keyword">var</span> v1 = <span class="number">0</span>,</div><div class="line">      v2 = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 这么做是为了防止整数中当前位上没有数字</span></div><div class="line">    <span class="keyword">if</span> (c1) &#123;</div><div class="line">      v1 = c1.val;</div><div class="line">      c1 = c1.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c2) &#123;</div><div class="line">      v2 = c2.val;</div><div class="line">      c2 = c2.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> sum = v1 + v2 + carry;</div><div class="line">    carry = <span class="built_in">Math</span>.floor(sum / <span class="number">10</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!c3) &#123;</div><div class="line">      l3 = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</div><div class="line">      c3 = l3;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      c3.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</div><div class="line">      c3 = c3.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> l3;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="两个数相加第二版"><a href="#两个数相加第二版" class="headerlink" title="两个数相加第二版"></a>两个数相加第二版</h2><p>上面的题目相对来说还是比较简单的，因为两个数相加是从低位到高位，而链表遍历是从前面到后面，正好是一致的。那么如果我们将整数的每个数字正序存贮在链表中，如何实现这道题呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</div><div class="line">Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</div><div class="line"></div><div class="line">Input: (7) + (5)</div><div class="line">Output: 1 -&gt; 2</div></pre></td></tr></table></figure><p>虽然正序存储更符合我们的书写阅读整数的习惯，但在链表中执行相加操作时却很麻烦，我们需要从低位开始计算才行。那么如何解决这个问题呢？答案是使用栈！</p><ul><li>先遍历两个链表，将数字 push 到各自的栈中。</li><li>然后依次 pop 出数字进行相加操作，生成的新数字存储在第三个栈中。</li><li>最后将第三个栈的每个数字 pop 出来添加到新链表中。</li></ul><p>完整代码是：</p><p>LeetCode/445-addTwoNumbers2.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> c1 = l1,</div><div class="line">    c2 = l2,</div><div class="line">    l3, c3,</div><div class="line">    s1 = [],</div><div class="line">    s2 = [],</div><div class="line">    s3 = [],</div><div class="line">    carry = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (c1 || c2) &#123;</div><div class="line">    <span class="keyword">if</span> (c1) &#123;</div><div class="line">      s1.push(c1.val);</div><div class="line">      c1 = c1.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c2) &#123;</div><div class="line">      s2.push(c2.val);</div><div class="line">      c2 = c2.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (s1.length || s2.length || carry) &#123;</div><div class="line">    <span class="keyword">var</span> v1 = <span class="number">0</span>,</div><div class="line">      v2 = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (s1.length) &#123;</div><div class="line">      v1 = s1.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (s2.length) &#123;</div><div class="line">      v2 = s2.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> sum = v1 + v2 + carry;</div><div class="line">    carry = <span class="built_in">Math</span>.floor(sum / <span class="number">10</span>);</div><div class="line"></div><div class="line">    s3.push(sum % <span class="number">10</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (s3.length) &#123;</div><div class="line">    <span class="keyword">var</span> val = s3.pop();</div><div class="line">    <span class="keyword">if</span> (!c3) &#123;</div><div class="line">      l3 = <span class="keyword">new</span> ListNode(val);</div><div class="line">      c3 = l3;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      c3.next = <span class="keyword">new</span> ListNode(val);</div><div class="line">      c3 = c3.next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> l3;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>两个数相加这道题的本质是考察链表和栈的操作，所以如果你对链表和栈的数据结构和常用操作非常熟悉，那么做这道题就是小菜一碟！</p><h2 id="教程示例代码及目录"><a href="#教程示例代码及目录" class="headerlink" title="教程示例代码及目录"></a>教程示例代码及目录</h2><p>示例代码：<a href="https://github.com/lewis617/javascript-datastructures-algorithms" target="_blank" rel="external">https://github.com/lewis617/javascript-datastructures-algorithms</a></p><p>目录：<a href="http://www.liuyiqi.cn/tags/数据结构与算法/">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，我们要讲的是一道链表算法题：两个数相加。这道题有两个版本，它们都来自 LeetCode：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://leetcode.com/problems/add-two-numbers/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers-ii/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://leetcode.com/problems/add-two-numbers-ii/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文将先回顾链表的基础知识，然后解决这两个问题，所用的语言依然是 JavaScript。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.liuyiqi.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.liuyiqi.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 版贪心算法题：分饼干</title>
    <link href="http://www.liuyiqi.cn/2017/03/11/assign-cookies/"/>
    <id>http://www.liuyiqi.cn/2017/03/11/assign-cookies/</id>
    <published>2017-03-11T03:41:00.000Z</published>
    <updated>2017-10-24T11:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是一道贪心算法题：分饼干。这道题也来自 LeetCode：</p><p><a href="https://leetcode.com/problems/assign-cookies" target="_blank" rel="external">https://leetcode.com/problems/assign-cookies</a></p><p>本文将先介绍贪心算法的基础知识，然后使用贪心算法解决这个问题，所用的语言依然是 JavaScript。</p><a id="more"></a><h2 id="贪心算法简介"><a href="#贪心算法简介" class="headerlink" title="贪心算法简介"></a>贪心算法简介</h2><p>贪心法，又称贪心算法、贪婪算法、或称贪婪法，是一种在<strong>每一步选择中都采取在当前状态下最好或最优（即最有利）的选择</strong>，从而希望导致结果是最好或最优的算法。简单来说，贪心算法的核心思想就是<strong>今朝有酒今朝醉</strong>，<strong>活在当下</strong>。举几个贪心算法的例子吧！</p><p>1，一般人换零钱的时候会应用到贪心算法。把$36换散︰$20 &gt; $10 &gt; $5 &gt; $1。先换大面额再换小面额！</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Greedy_algorithm_36_cents.svg/600px-Greedy_algorithm_36_cents.svg.png" alt=""></p><p>2，但有时候贪心算法并不准确，比如上学时候，学渣使用贪心算法，坚持当下玩乐，但最后却没有好工作，当然前提是他也没有好爸爸。</p><p>3，在编程中，贪心算法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。</p><h2 id="分饼干"><a href="#分饼干" class="headerlink" title="分饼干"></a>分饼干</h2><p>了解了贪心算法，我们来使用它解决“分饼干问题”。“分饼干问题”的题目是这样的：</p><blockquote><p>假设你是一个好爸爸（妈妈），你想给你的孩子们分一些饼干。每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。你的目标就是尽量让更多的孩子满意。</p></blockquote><p>下面我们再用断言表示一下需求。编写一个方法 <code>findContentChildren</code> ，它接受一个表示饼干的数组作为参数，返回能满足的孩子的最大数量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果孩子的要求是 [1, 3, 5, 4, 2]，饼干是[1, 1]，最多能让1个孩子满足。</span></div><div class="line">expect(findContentChildren([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">1</span>])).toBe(<span class="number">1</span>);</div><div class="line"><span class="comment">// 如果孩子的要求是 [10, 9, 8, 7, 6]，饼干是[7, 6, 5]，最多能让2个孩子满足。</span></div><div class="line">expect(findContentChildren([<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>])).toBe(<span class="number">2</span>);</div></pre></td></tr></table></figure><p>题目分析完了，让我们使用贪心算法来解决它！贪心算法的核心思想是<strong>坚持当下的最好选择</strong>。那么在这道题中，<strong>当下的最好选择</strong>是什么？答案是，先将“较小的饼干”分给“对饼干尺寸要求最小”、“最好说话”的孩子，因为他们最容易满足，这样才能最大化满足孩子的数量。那么，整个分配流程就应该是这样的：</p><ul><li>首先，将孩子们按“对饼干尺寸要求最小”排序，将饼干按尺寸大小排序。</li><li>然后，判断第一块饼干是否能满足第一个孩子，能就分给他，否则就换个稍微大点的，直到满足这个孩子。</li><li>满足第一个孩子后，再对第二个、第三个以及后面的孩子重复上面一步，直到饼干分完为止。</li><li>最后统计满足了多少个孩子，并返回结果。</li></ul><p>那么用 JavaScript 实现就是：</p><p>LeetCode/455-assignCookies.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * @param &#123;number[]&#125; g</span></div><div class="line"><span class="comment"> * @param &#123;number[]&#125; s</span></div><div class="line"><span class="comment"> * @return &#123;number&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">var</span> findContentChildren = <span class="function"><span class="keyword">function</span> (<span class="params">g, s</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> sortFunc = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a - b;</div><div class="line">  &#125;;</div><div class="line">  g.sort(sortFunc);</div><div class="line">  s.sort(sortFunc);</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; i &lt; g.length &amp;&amp; j &lt; s.length; j++) &#123;</div><div class="line">    <span class="keyword">if</span> (g[i] &lt;= s[j]) &#123;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> i;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>至此，这道题就做完了！你理解贪心算法了吗？如果不理解，可以再做几道题练习一下：</p><p><a href="https://leetcode.com/tag/greedy/" target="_blank" rel="external">https://leetcode.com/tag/greedy/</a></p><p>上面的网址是 LeetCode 的所有贪心算法题目，从易到难均有，祝你刷题愉快！</p><h2 id="教程示例代码及目录"><a href="#教程示例代码及目录" class="headerlink" title="教程示例代码及目录"></a>教程示例代码及目录</h2><p>示例代码：<a href="https://github.com/lewis617/javascript-datastructures-algorithms" target="_blank" rel="external">https://github.com/lewis617/javascript-datastructures-algorithms</a></p><p>目录：<a href="http://www.liuyiqi.cn/tags/数据结构与算法/">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，我们要讲的是一道贪心算法题：分饼干。这道题也来自 LeetCode：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/assign-cookies&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://leetcode.com/problems/assign-cookies&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文将先介绍贪心算法的基础知识，然后使用贪心算法解决这个问题，所用的语言依然是 JavaScript。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.liuyiqi.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.liuyiqi.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 版动态规划算法题：打家劫舍</title>
    <link href="http://www.liuyiqi.cn/2017/03/10/house-robber/"/>
    <id>http://www.liuyiqi.cn/2017/03/10/house-robber/</id>
    <published>2017-03-10T08:45:00.000Z</published>
    <updated>2017-10-24T11:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是一道动态规划算法题：打家劫舍。这道题有三个版本，它们都来自 LeetCode：</p><p><a href="https://leetcode.com/problems/house-robber" target="_blank" rel="external">https://leetcode.com/problems/house-robber</a></p><p><a href="https://leetcode.com/problems/house-robber-ii" target="_blank" rel="external">https://leetcode.com/problems/house-robber-ii</a></p><p><a href="https://leetcode.com/problems/house-robber-iii" target="_blank" rel="external">https://leetcode.com/problems/house-robber-iii</a></p><p>本文将先介绍动态规划的基础知识，然后使用动态规划思想解决这个问题，所用的语言仍然是 JavaScript。</p><a id="more"></a><h2 id="动态规划简介"><a href="#动态规划简介" class="headerlink" title="动态规划简介"></a>动态规划简介</h2><p>动态规划是(Dynamic Programming，DP)是一种将复杂问题分解成更小的子问题来解决的优化技术。那么具体哪些算法用到了动态规划呢？使用动态规划的算法很多，先列举一些简单的吧！比如：</p><p>1，求斐波那契数列：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (num === <span class="number">1</span> || num === <span class="number">2</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> fibonacci(num - <span class="number">1</span>) + fibonacci(num - <span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述函数将 <code>fibonacci(num)</code> 分解成 <code>fibonacci(num - 1)</code> 和 <code>fibonacci(num - 2)</code>，然后继续分解直到 <code>num</code> 为1或2时终止。</p><p>2，深度优先遍历（DFS）：</p><ul><li>先访问一个顶点，然后对相邻顶点挨个进行深度优先遍历。</li></ul><p>上述做法将复杂的图遍历分解为“每个顶点的<strong>访问</strong>与<strong>相邻顶点的深度优先遍历</strong>”。有点类似于二叉树先序遍历。具体代码请参考前面的博文<a href="https://lewis617.github.io/2017/02/19/graph/" target="_blank" rel="external">《 JavaScript 版数据结构与算法（八）图 》</a>。</p><h2 id="动态规划和分而治之的区别"><a href="#动态规划和分而治之的区别" class="headerlink" title="动态规划和分而治之的区别"></a>动态规划和分而治之的区别</h2><p>了解了动态规划，我们来看另一种思想——分而治之。分而治之方法与软件设计的模块化方法非常相似。为了解决一个大的问题，可以： </p><ol><li>把它分成两个或多个更小的问题； </li><li>分别解决每个小问题； </li><li>把各小问题的解答组合起来，即可得到原问题的解答。</li></ol><p>小问题通常与原问题相似，可以递归地使用分而治之策略来解决。</p><p>动态规划和分而治之都是<strong>大问题分解成多个子问题</strong>，那么这两者有什么区别呢？动态规划和分而治之的区别在于<strong>子问题之间是否独立</strong>。分而治之是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则把问题分解成相互依赖的子问题。</p><p>常见的使用分而治之的算法有<strong>归并排序</strong>和<strong>快速排序</strong>。具体实现代码可以参考前面的博文<a href="https://lewis617.github.io/2017/02/20/sort-and-search/" target="_blank" rel="external">《JavaScript 版数据结构与算法（九）排序和搜索》</a>。</p><h2 id="用动态规划解决“打家劫舍问题”"><a href="#用动态规划解决“打家劫舍问题”" class="headerlink" title="用动态规划解决“打家劫舍问题”"></a>用动态规划解决“打家劫舍问题”</h2><p>通过前面的介绍，大家应该对动态规划有个大致的了解了，下面让我们用动态规划来解决“打家劫舍问题”。“打家劫舍问题”的题目是：</p><blockquote><p>假设你是一个专业的劫匪，你计划去打劫一条街上的家舍。每家有一定数量的钱财，但相邻两家有一个彼此连接的安全系统。一旦相邻两家在同一晚被打劫，那么这个安全系统就会自动报警。</p><p>给你一个由非负整数组成的数组，用来代表每家的钱财，在不让安全系统自动报警的前提下，求你能打劫到的钱财的最大数量。</p></blockquote><p>我们还是用单元测试来表达一下需求吧！毕竟好多程序员看机器语言要比自然语言还舒服：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对于 [2, 0, 0, 4, 5]，能打劫到的最大钱财是7</span></div><div class="line">expect(rob([<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>])).toBe(<span class="number">7</span>);</div></pre></td></tr></table></figure><p>我们要编写一个 <code>rob</code> 方法，可以返回内部数组的最大的不相邻数字之和。</p><p>那么如何实现这个算法呢？我们需要借助动态规划思想：</p><ul><li>如果数组长度为1，那么直接返回数组唯一项。</li><li>如果数组长度为2，那么返回“第1项”和“第2项”的较大者。</li><li>如果数组长度为3，那么返回“数组长度为1的结果+第3项”与“数组长度为2的结果”的较大者。</li><li>如果数组长度为4，那么返回“数组长度为2的结果+第4项”与“数组长度为3的结果”的较大者。</li><li>……</li><li>如果数组长度为n，那么返回“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”的较大者。</li></ul><p>为何会如此呢？因为题目要求不能打劫相邻两家，所以数组的当前项只能和上上次的结果相加。那么子问题就是“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”。用方程来表示就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f(0) = array[0]</div><div class="line">f(1) = max(array[0], array[1])</div><div class="line">f(n) = max( f(n-2) + array[n], f(n-1) )</div></pre></td></tr></table></figure><p>所以实现代码就是：</p><p>LeetCode/198-rob1.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></div><div class="line"><span class="comment"> * @return &#123;number&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> last = <span class="number">0</span>,</div><div class="line">    now = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> temp = last;</div><div class="line">    last = now;</div><div class="line">    now = <span class="built_in">Math</span>.max(temp + nums[i], now);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> now;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="圆圈版打家劫舍"><a href="#圆圈版打家劫舍" class="headerlink" title="圆圈版打家劫舍"></a>圆圈版打家劫舍</h2><p>“打家劫舍”问题还有另一个版本，它的题目是：</p><blockquote><p>在上次打劫后，作为专业劫匪的你意识到自己需要去一个新的地方打劫，这样才不会引起太多注意。这次，你去的地方的家舍是按圆圈形状来排列的。这意味着第一家和最后一家是挨着的，同时，安全系统和上个地方的一样。</p><p>给你一个由非负整数组成的数组，用来代表每家的钱财，在不让安全系统自动报警的前提下，求你能打劫到的钱财的最大数量。</p></blockquote><p>那么这道题该如何解答呢？因为家舍首尾相连，所以你不能在同一晚打劫第一家和最后一家，既然不能打劫，机智的你索性将计就计，先排除最后一家不管，或者先排除第一家不管，打劫剩余的家舍，然后比较那个更划算。所以这道题可以这么来解答：</p><ul><li>先求出第一家到倒数第二家的最大钱财数量</li><li>然后求出第二家到最后一家的最大钱财数量</li><li>最后求两者的较大值</li></ul><p>所以实现代码就是：</p><p>LeetCode/213-rob2.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></div><div class="line"><span class="comment"> * @return &#123;number&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> rob1 = <span class="built_in">require</span>(<span class="string">'./rob1'</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (nums.length === <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(rob1(nums.slice(<span class="number">1</span>)), rob1(nums.slice(<span class="number">0</span>, nums.length - <span class="number">1</span>)));</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上述代码中，<code>nums.slice(1)</code>代表排除了第一家，<code>nums.slice(0, array.length - 1)</code>代表排除了最后一家。然后运行测试，发现确实没有上次打劫的多：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expect(rob([<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>])).toBe(<span class="number">6</span>);</div></pre></td></tr></table></figure><h2 id="二叉树版打家劫舍"><a href="#二叉树版打家劫舍" class="headerlink" title="二叉树版打家劫舍"></a>二叉树版打家劫舍</h2><p>我们再看一道二叉树版打家劫舍吧！题目如下：</p><blockquote><p>作为专业劫匪的你又找到了一个新地方可以下手，这个地方的家舍是按二叉树形状排列的，安全系统和之前一样。在不让安全系统自动报警的前提下，求你能打劫到的钱财的最大数量。</p></blockquote><p>为了表述题意，我们来看个例子吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  3</div><div class="line"> / \</div><div class="line">2   3</div><div class="line"> \   \ </div><div class="line">  3   1</div></pre></td></tr></table></figure><p>那么最大钱财就是第一行的3和第三行的3、1，一共是7。</p><p>看完了题目，我们该如何编写代码呢？首先，按照动态规划，我们需要找到<strong>子问题</strong>！在第一版的打家劫舍问题中，子问题是“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”的较大者。那么这道题的子问题是什么呢？这道题的子问题是“打劫当前节点”和“不打劫当前节点”哪个更划算？那么如何比较哪个更划算呢？这得看“打劫子节点”和“不打劫子节点”的值各是多少。如果“打劫当前节点”，那么就不能打劫子节点，那么这时值就是“不打劫子节点”的值加上自己值。如果“不打劫当前节点”，那么就可以打劫子节点，也可以不打劫子节点，那么这时值就是“打劫子节点”和“不打劫子节点”的值的较大者。用代码表示就是：</p><p>LeetCode/337-rob3.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * function TreeNode(key) &#123;</span></div><div class="line"><span class="comment"> *     this.val = key;</span></div><div class="line"><span class="comment"> *     this.left = this.right = null;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></div><div class="line"><span class="comment"> * @return &#123;number&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> dfs = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> [<span class="literal">null</span>, <span class="literal">null</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> left = dfs(node.left);</div><div class="line">    <span class="keyword">var</span> right = dfs(node.right);</div><div class="line">    <span class="keyword">var</span> res = [];</div><div class="line">    res[<span class="number">0</span>] = left[<span class="number">1</span>] + right[<span class="number">1</span>] + node.key;</div><div class="line">    res[<span class="number">1</span>] = <span class="built_in">Math</span>.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">Math</span>.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> num = dfs(root);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(num[<span class="number">0</span>], num[<span class="number">1</span>]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>我们首先写一个 <code>dfs</code>来深度优先遍历节点，其实就是先序遍历。这个 <code>dfs</code> 方法返回了“打劫当前节点”和“不打劫当前节点”的值各是多少，这里用 <code>res</code> 数组来表示。由于深度优先遍历是对左右节点也进行 <code>dfs</code>，所以我们可以通过子节点的返回值（这里用 <code>left</code> 和 <code>right</code>来表示）得到当前节点的返回值，直到节点为空，就把递归终结掉！编写完了 <code>dfs</code>，我们对 <code>root</code> 入口进行 <code>dfs</code>，得到的数组就是“打劫根节点”和“不打劫根节点”的数值。最后，返回较大者即可得到答案。</p><p>测试代码如下：</p><p>LeetCode/__tests__/337-rob3.test.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> rob = <span class="built_in">require</span>(<span class="string">'../rob3'</span>);</div><div class="line"><span class="keyword">var</span> BinarySearchTree = <span class="built_in">require</span>(<span class="string">'../../Tree/BinarySearchTree'</span>);</div><div class="line"></div><div class="line">test(<span class="string">'rob3'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> binarySearchTree = <span class="keyword">new</span> BinarySearchTree();</div><div class="line"></div><div class="line">  binarySearchTree.insert(<span class="number">11</span>);</div><div class="line">  binarySearchTree.insert(<span class="number">7</span>);</div><div class="line">  binarySearchTree.insert(<span class="number">13</span>);</div><div class="line">  binarySearchTree.insert(<span class="number">5</span>);</div><div class="line">  binarySearchTree.insert(<span class="number">3</span>);</div><div class="line">  binarySearchTree.insert(<span class="number">9</span>);</div><div class="line"></div><div class="line">  expect(rob(binarySearchTree.getRoot())).toBe(<span class="number">27</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这里使用了前面编写的数据结构 <code>BinarySearchTree</code>，它的实现代码和具体讲解可以参考前面的博文<a href="https://lewis617.github.io/2017/02/18/tree/" target="_blank" rel="external">《JavaScript 版数据结构与算法（七）树》</a>。</p><p>至此，“打家劫舍问题”就讲完了！其实，“打家劫舍问题”的本质在于使用“动态规划”，而“动态规划”的本质在于将大问题分解为相互依赖的子问题。看清问题本质，才能练好算法！加油吧！</p><h2 id="教程示例代码及目录"><a href="#教程示例代码及目录" class="headerlink" title="教程示例代码及目录"></a>教程示例代码及目录</h2><p>示例代码：<a href="https://github.com/lewis617/javascript-datastructures-algorithms" target="_blank" rel="external">https://github.com/lewis617/javascript-datastructures-algorithms</a></p><p>目录：<a href="http://www.liuyiqi.cn/tags/数据结构与算法/">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，我们要讲的是一道动态规划算法题：打家劫舍。这道题有三个版本，它们都来自 LeetCode：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/house-robber&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://leetcode.com/problems/house-robber&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/house-robber-ii&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://leetcode.com/problems/house-robber-ii&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/house-robber-iii&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://leetcode.com/problems/house-robber-iii&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文将先介绍动态规划的基础知识，然后使用动态规划思想解决这个问题，所用的语言仍然是 JavaScript。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.liuyiqi.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.liuyiqi.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 版数组搜索算法题：求和为定值的多个数</title>
    <link href="http://www.liuyiqi.cn/2017/03/09/n-sum/"/>
    <id>http://www.liuyiqi.cn/2017/03/09/n-sum/</id>
    <published>2017-03-09T10:06:00.000Z</published>
    <updated>2017-10-24T11:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是<strong>求和为定值的多个数</strong>。这个算法题有很多版本，它们都来自于 LeetCode：</p><p><a href="https://leetcode.com/problems/two-sum" target="_blank" rel="external">https://leetcode.com/problems/two-sum</a></p><p><a href="https://leetcode.com/problems/3sum" target="_blank" rel="external">https://leetcode.com/problems/3sum</a></p><p><a href="https://leetcode.com/problems/4sum" target="_blank" rel="external">https://leetcode.com/problems/4sum</a></p><a id="more"></a><h2 id="和为定值的两个数"><a href="#和为定值的两个数" class="headerlink" title="和为定值的两个数"></a>和为定值的两个数</h2><p>在求和为定值的多个数之前，我们先来求和为定值的两个数。对于数组搜索算法而言，如果搜索一个数，那么方法就是前面讲的：</p><ul><li>顺序搜索</li><li>二分搜索</li></ul><p>这非常简单，那么如果搜索和为定值两个数呢？其实也可以是顺序搜索或二分搜索，只不过需要遍历数组，先拿到一个值，然后对另一个值进行顺序搜索或二分搜索，比如 <code>[1, 3, 5, 4, 2]</code>，求和为6的两个数，那么：</p><ul><li>第一轮取1，对 <code>[3, 5, 4, 2]</code> 进行顺序搜索或二分搜索</li><li>第二轮取3，对 <code>[5, 4, 2]</code>  进行顺序搜索或二分搜索</li><li>……</li></ul><p>使用顺序搜索查找两个数的时间复杂度为O(n^2)，空间复杂度为O(1)。使用二分搜索的时间复杂度为O(nlogn)，空间复杂度为O(1)。</p><p>那么除了顺序搜索和二分搜索，还有别的方法吗？答案是肯定的。其他方法列举如下：</p><p>1，<strong>借助散列表</strong>：先构建一个散列表，存储数组每个值。然后遍历数组，查看 <code>target</code> 与每项的差是否在散列表中，如果在就返回两个值。这个方法的时间复杂度和空间复杂度均为O(n)。代码示例如下：</p><p>LeetCode/001-twoSum.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * You may assume that each input would have exactly one solution, </span></div><div class="line"><span class="comment"> * and you may not use the same element twice.</span></div><div class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></div><div class="line"><span class="comment"> * @param &#123;number&#125; target</span></div><div class="line"><span class="comment"> * @return &#123;number[]&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> map = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (nums[i] <span class="keyword">in</span> map) &#123;</div><div class="line">      <span class="keyword">return</span> [map[nums[i]], i];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      map[target - nums[i]] = i;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expect(twoSum([<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], <span class="number">9</span>)).toEqual([<span class="number">0</span>, <span class="number">1</span>]);</div></pre></td></tr></table></figure><blockquote><p>注意， <code>twoSum</code> 输出的结果是数组项的索引，而后面的 <code>threeSum</code> 和 <code>fourSum</code> 输出的则是数组项的值。</p></blockquote><p>2，<strong>双指针两端扫描</strong>：若数组无序，就先排序后扫描。扫描方法是用两个指针 <code>i</code> 和 <code>j</code>，先放在数组首尾，如果指向的两个数之和大于 <code>target</code> ，就 <code>j--</code>，否则 <code>i++</code>，直到两个数之和为 <code>target</code>，然后返回这两个数。该方法的时间复杂度最后为：有序O(n)，无序O(nlogn + n)=O(nlogn)，空间复杂度都为O(1)。代码示例如下：</p><p>LeetCode/001-twoSum.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></div><div class="line"><span class="comment"> * @param &#123;number&#125; target</span></div><div class="line"><span class="comment"> * @return &#123;number[]&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">var</span> twoSum2 = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> l = <span class="number">0</span>,</div><div class="line">    r = nums.length - <span class="number">1</span>,</div><div class="line">    results = [];</div><div class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</div><div class="line">    <span class="keyword">var</span> s = nums[l] + nums[r];</div><div class="line">    <span class="keyword">if</span> (s === target) &#123;</div><div class="line">      results.push([l, r]);</div><div class="line">      <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] === nums[l + <span class="number">1</span>]) &#123;</div><div class="line">        l++;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">while</span> (r &gt; l &amp;&amp; nums[r] === nums[r - <span class="number">1</span>]) &#123;</div><div class="line">        r++;</div><div class="line">      &#125;</div><div class="line">      l++;</div><div class="line">      r--;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; target) &#123;</div><div class="line">      l++;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      r--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> results</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expect(twoSum2([<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>], <span class="number">0</span>)).toEqual([[<span class="number">1</span>, <span class="number">4</span>]]);</div></pre></td></tr></table></figure><h2 id="和为定值的三个数"><a href="#和为定值的三个数" class="headerlink" title="和为定值的三个数"></a>和为定值的三个数</h2><p>了解了和为定值的两个数的搜索方法，那么和为定值的三个数的搜索方法呢？这里需要用到<strong>遍历</strong>+<strong>求和为定值的两个数</strong>。先举个例子吧！比如数组为 <code>[1, 3, 5, 4, 2]</code> ，求和为7的三个数。那么整个流程如下：</p><ul><li>第一轮取1，对 <code>[3, 5, 4, 2]</code> 进行和为7-1的两个数搜索。</li><li>第二轮取3，对 <code>[5, 4, 2]</code> 进行和为7-3的两个数搜索。</li><li>……</li></ul><p>当问题变为两个数的搜索时，那么我们就可以用前面介绍的方法了！示例代码如下：</p><p>LeetCode/015-threeSum.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></div><div class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> res = [];</div><div class="line">  nums.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a - b;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> l = i + <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> r = nums.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</div><div class="line">      <span class="keyword">var</span> s = nums[i] + nums[l] + nums[r];</div><div class="line">      <span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</div><div class="line">        l++;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</div><div class="line">        r--;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        res.push([nums[i], nums[l], nums[r]]);</div><div class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] === nums[l + <span class="number">1</span>]) &#123;</div><div class="line">          l++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (r &gt; l &amp;&amp; nums[r] === nums[r - <span class="number">1</span>]) &#123;</div><div class="line">          r++;</div><div class="line">        &#125;</div><div class="line">        l++;</div><div class="line">        r--;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expect(threeSum([<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])).toEqual([[<span class="number">-2</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]]);</div></pre></td></tr></table></figure><h2 id="和为定值的四个数"><a href="#和为定值的四个数" class="headerlink" title="和为定值的四个数"></a>和为定值的四个数</h2><p>如果 <code>N</code>（<code>N</code> 代表和为定值的 <code>N</code> 个数） 为更大的值，那么就使用<strong>递归</strong>，一直到 <code>N</code> 为2时终结掉。这里我们来求一下和为定值的四个数，示例代码如下：</p><p>LeetCode/018-fourSum.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></div><div class="line"><span class="comment"> * @param &#123;number&#125; target</span></div><div class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">var</span> fourSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> findNSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target, N, result, results</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (nums.length &lt; N || target &lt; nums[<span class="number">0</span>] * N || target &gt; nums[<span class="number">-1</span>] * N) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (N === <span class="number">2</span>) &#123;</div><div class="line">      <span class="keyword">var</span> l = <span class="number">0</span>,</div><div class="line">        r = nums.length - <span class="number">1</span>;</div><div class="line">      <span class="keyword">while</span> (l &lt; r) &#123;</div><div class="line">        <span class="keyword">var</span> s = nums[l] + nums[r];</div><div class="line">        <span class="keyword">if</span> (s === target) &#123;</div><div class="line">          results.push(result.concat([nums[l], nums[r]]));</div><div class="line">          <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] === nums[l + <span class="number">1</span>]) &#123;</div><div class="line">            l++;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">while</span> (r &gt; l &amp;&amp; nums[r] === nums[r - <span class="number">1</span>]) &#123;</div><div class="line">            r++;</div><div class="line">          &#125;</div><div class="line">          l++;</div><div class="line">          r--;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; target) &#123;</div><div class="line">          l++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          r--;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length - N + <span class="number">1</span>; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (i === <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] !== nums[i])) &#123;</div><div class="line">          findNSum(nums.slice(i + <span class="number">1</span>), target - nums[i], N - <span class="number">1</span>, result.concat([nums[i]]), results);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">var</span> results = [];</div><div class="line">  nums.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a - b;</div><div class="line">  &#125;);</div><div class="line">  findNSum(nums, target, <span class="number">4</span>, [], results);</div><div class="line">  <span class="keyword">return</span> results;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expect(fourSum([<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], <span class="number">0</span>)).toEqual([[<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>]]);</div></pre></td></tr></table></figure><p>当 <code>N</code> 为更大的数，只需要更改 <code>findSum</code> 的第三个参数即可。练习算法光说不练可不行，赶快打开 LeetCode 进行练习吧！</p><h2 id="教程示例代码及目录"><a href="#教程示例代码及目录" class="headerlink" title="教程示例代码及目录"></a>教程示例代码及目录</h2><p>示例代码：<a href="https://github.com/lewis617/javascript-datastructures-algorithms" target="_blank" rel="external">https://github.com/lewis617/javascript-datastructures-algorithms</a></p><p>目录：<a href="http://www.liuyiqi.cn/tags/数据结构与算法/">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，我们要讲的是&lt;strong&gt;求和为定值的多个数&lt;/strong&gt;。这个算法题有很多版本，它们都来自于 LeetCode：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/two-sum&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://leetcode.com/problems/two-sum&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/3sum&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://leetcode.com/problems/3sum&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/4sum&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://leetcode.com/problems/4sum&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.liuyiqi.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.liuyiqi.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 版数据结构与算法（九）排序和搜索</title>
    <link href="http://www.liuyiqi.cn/2017/02/20/sort-and-search/"/>
    <id>http://www.liuyiqi.cn/2017/02/20/sort-and-search/</id>
    <published>2017-02-20T02:39:00.000Z</published>
    <updated>2017-10-24T11:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是一些基础的排序和搜索算法。</p><a id="more"></a><h2 id="编写-ArrayList-类"><a href="#编写-ArrayList-类" class="headerlink" title="编写 ArrayList 类"></a>编写 ArrayList 类</h2><p>在讲解排序和搜索算法前，我们先编写一个 <code>ArrayList</code> 类，使其包含私有变量 <code>array</code>，用于盛放数组，同时还包含 <code>insert</code> 和 <code>toString</code> 方法可以插入和转化为字符串。如此一来，当后面我们讲解各种排序和搜索算法时就可以很方便地设置输入输出来测试了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayList</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> array = [];</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</div><div class="line">    array.push(item);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> array.toString();</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是排序中最简单的一种，不过它的性能并不好（时间复杂度为O(n^2)）。面试官有时候为了缓解面试的紧张气氛，会让应聘者手写冒泡排序算法。</p><p>那么冒泡排序的思路是什么？其实就是每轮从头到尾比较相邻两个数并选择性交换（但是每次的最后一项在下一次就不用参与了，因为已经在正确的位置上了），然后执行 n-1 轮。比如对这个数组进行冒泡排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 3 5 4 2</div></pre></td></tr></table></figure><p>那么实现过程记录如下：</p><p>第一轮<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1 3 5 4 2  // 1&lt;3 不交换</div><div class="line">1 3 5 4 2  // 3&lt;5 不交换</div><div class="line">1 3 4 5 2  // 5&gt;4 交换</div><div class="line">1 3 4 2 5  // 5&gt;2 交换</div></pre></td></tr></table></figure></p><p>第二轮<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1 3 4 2 5  // 1&lt;3 不交换</div><div class="line">1 3 4 2 5  // 3&lt;4 不交换</div><div class="line">1 3 2 4 5  // 4&gt;2 不交换</div></pre></td></tr></table></figure></p><p>第三轮</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1 3 2 4 5  // 1&lt;3 不交换</div><div class="line">1 2 3 4 5  // 3&gt;2 交换</div></pre></td></tr></table></figure><p>第四轮</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 2 3 4 5  // 1&lt;2 不交换</div></pre></td></tr></table></figure><p>用代码实现就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> swap = <span class="function"><span class="keyword">function</span> (<span class="params">index1, index2</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> aux = array[index1];</div><div class="line">  array[index1] = array[index2];</div><div class="line">  array[index2] = aux;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">this</span>.bubbleSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;  <span class="comment">// 执行 n-1 轮</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;  <span class="comment">// 每轮（i）比较 n - i 个数 </span></div><div class="line">      <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</div><div class="line">        swap(j, j + <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>冒泡排序非常简单，唯一需要注意的就是边界的设置，你可以先使用5或3个数来假设一下，这样可以轻松算出边界。</p><p>测试代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNonSortedArray</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> array = <span class="keyword">new</span> ArrayList();</div><div class="line">  array.insert(<span class="number">1</span>);</div><div class="line">  array.insert(<span class="number">3</span>);</div><div class="line">  array.insert(<span class="number">5</span>);</div><div class="line">  array.insert(<span class="number">4</span>);</div><div class="line">  array.insert(<span class="number">2</span>);</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> array = createNonSortedArray();</div><div class="line">expect(array.toString()).toBe(<span class="string">'1,3,5,4,2'</span>);</div><div class="line">array.bubbleSort();</div><div class="line">expect(array.toString()).toBe(<span class="string">'1,2,3,4,5'</span>);</div></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序也是一种简单但性能（O(n^2)）一般的排序算法。在所有的<strong>完全依靠交换去移动元素</strong>的排序方法中，选择排序属于非常好的一种。选择排序的实现思路是：找到数据结构中的最小值，<strong>选</strong>中它并将其放置在第一位，接着找到第二小的值，<strong>选</strong>中它并将其放置在第二位，以此类推。</p><p>比如对一个这样的数组进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 3 5 4 2</div></pre></td></tr></table></figure><p>那么第一轮：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 3 5 4 2  // 找出最小值1和第一位的1交换，相同的话可以省去交换过程</div></pre></td></tr></table></figure><p>第二轮：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 2 5 4 3  // 找出第二小值2和第二位的3交换</div></pre></td></tr></table></figure><p>第三轮：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 2 3 4 5  // 找出第三小值3和第三位的5交换</div></pre></td></tr></table></figure><p>第四轮</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 2 3 4 5  // 找出第四小值4和第四位的4交换，相同的话可以省去交换过程</div></pre></td></tr></table></figure><p>那么代码的编写无法就是两个循环：</p><ul><li>循环得到最小值</li><li>循环将最小值交换到指定位置</li></ul><p>实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.selectionSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length,</div><div class="line">    indexMin;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;  <span class="comment">// 循环将最小值交换到指定位置</span></div><div class="line">    indexMin = i;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &lt; length; j++) &#123;  <span class="comment">// 循环得到最小值</span></div><div class="line">      <span class="keyword">if</span> (array[indexMin] &gt; array[j]) &#123;</div><div class="line">        indexMin = j;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i !== indexMin) &#123;</div><div class="line">      swap(i, indexMin);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>注意边界的设置！测试代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">array = createNonSortedArray();</div><div class="line">expect(array.toString()).toBe(<span class="string">'1,3,5,4,2'</span>);</div><div class="line">array.selectionSort();</div><div class="line">expect(array.toString()).toBe(<span class="string">'1,2,3,4,5'</span>);</div></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>虽然插入排序的复杂度也是O(n^2)，但排序<strong>小型数组</strong>时，此算法比选择排序和冒泡排序性能要好。插入排序的实现思路是：从第二个数开始往前比，比它大就往后排，依次进行到最后一个数。就好比是上学时排队，本来瞎胡排一队，然后老师说按个子高低排：</p><ul><li>第二个同学看看第一个同学，觉得比自己高，就说：“你个子高还站前面！后面去！”，然后<strong>插</strong>到他前面。</li><li>第三个同学，先后看了第二个、第一个同学，觉得都比自己高，就<strong>插</strong>到第一个了。</li><li>以此类推到最后一个同学。</li></ul><p>拿个数组做演示吧！比如对下面这个数组排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3 5 1 4 2</div></pre></td></tr></table></figure><p>第一轮：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3 5 1 4 2  // 5&gt;3，不插队</div></pre></td></tr></table></figure><p>第二轮：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 3 5 4 2  // 1&lt;5，插队，1&lt;3，再插队</div></pre></td></tr></table></figure><p>第三轮：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 3 4 5 2  // 4&lt;5，插队，4&gt;3，不插队</div></pre></td></tr></table></figure><p>第四轮：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 2 3 4 5  // 2&lt;5，插队，2&gt;4，插队，2&lt;3，不插队</div></pre></td></tr></table></figure><p>注意，只要第一次遇到较小的数，就不用再比较了，也就是说，如果第一次不插队，就不用再往前比了，因为前面都是更小的。所以代码实现是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.insertionSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length,</div><div class="line">    j, temp;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;  <span class="comment">// 从第二个开始比</span></div><div class="line">    temp = array[i];</div><div class="line">    j = i;</div><div class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt; temp) &#123; <span class="comment">// 比完或遇到较小数就不用比了</span></div><div class="line">      array[j] = array[j - <span class="number">1</span>];</div><div class="line">      j--;</div><div class="line">    &#125; </div><div class="line">    array[j] = temp;  <span class="comment">// 插队！！！</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">array = createNonSortedArray(<span class="number">5</span>);</div><div class="line">expect(array.toString()).toBe(<span class="string">'5,4,3,2,1'</span>);</div><div class="line">array.insertionSort();</div><div class="line">expect(array.toString()).toBe(<span class="string">'1,2,3,4,5'</span>);</div></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的性能比前三个排序算法都要好，时间复杂度为O( nlogn )，而且 Mozilla Firefox 使用了归并排序作为 <code>Array.prototype.sort</code> 的实现（但 Chrome 使用的是快速排序）。那么归并排序的思路是什么呢？简单来说，就是先分再合。</p><p>比如对这样的数组进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">13542</div></pre></td></tr></table></figure><p>分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">13 542</div></pre></td></tr></table></figure><p>再分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">13 5 42</div></pre></td></tr></table></figure><p>再分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 3 5 4 2</div></pre></td></tr></table></figure><p>合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">13 5 24</div></pre></td></tr></table></figure><p>再合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">13 245</div></pre></td></tr></table></figure><p>再合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">12345</div></pre></td></tr></table></figure><p><strong>分</strong> 这个过程需要用到递归，对原数组分割，再对子数组做同样的事，终止条件是数组只有一项了，然后对这些数组进行合并，<strong>合</strong>这个过程主要是将两个数组合并的同时进行排序。所以，实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mergeSortRec = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">left, right</span>) </span>&#123;  <span class="comment">// 合</span></div><div class="line">    <span class="keyword">var</span> final = [];</div><div class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length)</div><div class="line">      final.push(left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] ? left.shift() : right.shift());</div><div class="line">    <span class="keyword">return</span> final.concat(left.concat(right));</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> length = array.length;</div><div class="line">  <span class="keyword">if</span> (length === <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>),  <span class="comment">// 分</span></div><div class="line">    left = array.slice(<span class="number">0</span>, mid),</div><div class="line">    right = array.slice(mid, length);</div><div class="line">  <span class="keyword">return</span> merge(mergeSortRec(left), mergeSortRec(right));  <span class="comment">// 递归</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">this</span>.mergeSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  array = mergeSortRec(array);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">array = createNonSortedArray();</div><div class="line">expect(array.toString()).toBe(<span class="string">'1,3,5,4,2'</span>);</div><div class="line">array.insertionSort();</div><div class="line">expect(array.toString()).toBe(<span class="string">'1,2,3,4,5'</span>);</div></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序又称划分交换排序，是一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 Ο(n log n) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序的实现思路是：</p><ul><li>从数列中挑出一个元素，称为”基准”（pivot）。</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p>选择基准可以用第一项，也可以随机选择或选择中间一项。我们选择第一项！不过注意，研究表明选择第一项作为基准对几乎已经排序的数组并不适合，会导致性能最差。</p><p>比如对这样的数组进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">35142</div></pre></td></tr></table></figure><p>那么第一轮：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 对 35142 进行快排，left 为 21，基准是 3，right 为 45</div><div class="line">21 3 45</div></pre></td></tr></table></figure><p>第二轮：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 对 21 进行快排，left 为 1，基准是 2，right 为空</div><div class="line">1 2 3 45</div></pre></td></tr></table></figure><p>第三轮：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 对 45 进行快排，left 为空，基准是 4，right 为 5</div><div class="line">1 2 3 4 5</div></pre></td></tr></table></figure><p>所以代码实现的核心就是：</p><ul><li>找基准</li><li>找左右数组</li><li>将左右数组和基准合并</li><li>对左右子数组重复上述操作</li></ul><p>实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> quick = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = array.length;</div><div class="line">  <span class="keyword">if</span> (length &lt;= <span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> array.slice(<span class="number">0</span>);</div><div class="line">  <span class="keyword">var</span> left = [];</div><div class="line">  <span class="keyword">var</span> right = [];</div><div class="line">  <span class="keyword">var</span> mid = [array[<span class="number">0</span>]];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (array[i] &lt; mid[<span class="number">0</span>])</div><div class="line">      left.push(array[i]);</div><div class="line">    <span class="keyword">else</span></div><div class="line">      right.push(array[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> quick(left).concat(mid.concat(quick(right)));</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">this</span>.quickSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  array = quick(array);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="顺序搜索"><a href="#顺序搜索" class="headerlink" title="顺序搜索"></a>顺序搜索</h2><p>排序算法讲完了，我们来看搜索算法，最基本的搜索算法是顺序搜索：将每一个数据结构中的元素和我们要找的元素做比较。这种算法非常低效（时间复杂度为O(n)），不过比较简单，可以用来缓解面试紧张气氛。实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.sequentialSearch = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (array[i] === item) &#123;</div><div class="line">      <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是一种在<strong>有序数组</strong>中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。它的时间复杂度是 O(log(n))。</p><p>代码编写的要诀是：不断改变最小值、最大值和中间值，直到中间值为被查找的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.binarySearch = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.quickSort();</div><div class="line"></div><div class="line">  <span class="keyword">var</span> low = <span class="number">0</span>,</div><div class="line">    high = array.length - <span class="number">1</span>,</div><div class="line">    mid, element;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</div><div class="line">    mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>);</div><div class="line">    element = array[mid];</div><div class="line">    <span class="keyword">if</span> (element &lt; item) &#123;</div><div class="line">      low = mid + <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element &gt; item) &#123;</div><div class="line">      high = mid - <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> mid;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="教程示例代码及目录"><a href="#教程示例代码及目录" class="headerlink" title="教程示例代码及目录"></a>教程示例代码及目录</h2><p>示例代码：<a href="https://github.com/lewis617/javascript-datastructures-algorithms" target="_blank" rel="external">https://github.com/lewis617/javascript-datastructures-algorithms</a></p><p>目录：<a href="http://www.liuyiqi.cn/tags/数据结构与算法/">http://www.liuyiqi.cn/tags/数据结构与算法/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，我们要讲的是一些基础的排序和搜索算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.liuyiqi.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
