<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘一奇的个人博客</title>
  
  <subtitle>何以升华，唯有沉淀</subtitle>
  <link href="http://www.liuyiqi.cn/atom.xml" rel="self"/>
  
  <link href="http://www.liuyiqi.cn/"/>
  <updated>2022-09-07T03:52:16.607Z</updated>
  <id>http://www.liuyiqi.cn/</id>
  
  <author>
    <name>刘一奇</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>“真”前端知识图谱上线了</title>
    <link href="http://www.liuyiqi.cn/2021/03/18/fe-kg/"/>
    <id>http://www.liuyiqi.cn/2021/03/18/fe-kg/</id>
    <published>2021-03-18T02:20:00.000Z</published>
    <updated>2022-09-07T03:52:16.607Z</updated>
    
    <content type="html"><![CDATA[<p>网络上有不少所谓的“前端知识图谱”，其实只是一个前端“思维导图”，从数据结构上来说是“树”，而不是“图”。而今天笔者要介绍的是真正的“知识图谱”！图谱的样子如下：</p><iframe width="80%" height="300px" src="https://www.liuyiqi.cn/fe-kg/"></iframe><span id="more"></span><h2 id="前端知识图谱简介"><a href="#前端知识图谱简介" class="headerlink" title="前端知识图谱简介"></a>前端知识图谱简介</h2><p>它具备如下特性：</p><ul><li>它是一个简单的无向图</li><li>它只有一种“边”，代表“相关性”。</li><li>支持自动布局</li><li>支持拖动节点。</li><li>支持高亮相邻节点&#x2F;边。</li></ul><p>地址：<a href="https://www.liuyiqi.cn/fe-kg/">https://www.liuyiqi.cn/fe-kg/</a></p><h2 id="为何要做前端知识图谱？"><a href="#为何要做前端知识图谱？" class="headerlink" title="为何要做前端知识图谱？"></a>为何要做前端知识图谱？</h2><p>简单来说，是为了锻炼自己的联想能力。当然，如果能服务广大前端同学，就更好了。</p><p>目前网络的上前端思维导图，本质是一个树，每个节点的入度唯一，也就是它的父节点。这是不科学的！因为很多知识点具备相关性，用树是无法表达的。</p><p>比如：我们在学习网络-应用层-http-响应头（content-type、cache-control……）时候，只知道它是 http 的知识，但是不知道它有很多应用，比如实现一个静态文件服务器，需要用到 content-type 和 cache-control。</p><p>再比如：我们在学 async、defer 时候会接触非阻塞的优化方式。我们在学 HTTP2&#x2F;服务端推送时候，也会学到非阻塞。是不是应该将它们联系起来？</p><p>为了解决上述问题，图这个数据结构就能派上用场了！</p><h2 id="如何使用前端知识图谱"><a href="#如何使用前端知识图谱" class="headerlink" title="如何使用前端知识图谱"></a>如何使用前端知识图谱</h2><p>我们可以用广度优先遍历和深度优先遍历两种方式来学习这个知识图谱。</p><p>广度优先遍历，简单来说就是先广后深来遍历图中的顶点。比如一个这样的图：</p><p><img src="/css/images/1556699036556-1.jpg"></p><p>深度优先遍历，简单来说，深度优先遍历就是先深后广来遍历。如图：</p><p><img src="/css/images/1556699036557-2.jpg"></p><p>了解两种遍历方法，我们只需要随便选择一个节点，就可以开始学习了。当然也可以从根节点“前端”开始遍历。</p><h2 id="未来发展"><a href="#未来发展" class="headerlink" title="未来发展"></a>未来发展</h2><p>接下来，笔者会坚持从工作、博客、面试题等多个来源中提取节点和边，不断丰富这个知识图谱，争取打造一个全面、系统的前端知识图谱。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;网络上有不少所谓的“前端知识图谱”，其实只是一个前端“思维导图”，从数据结构上来说是“树”，而不是“图”。而今天笔者要介绍的是真正的“知识图谱”！图谱的样子如下：&lt;/p&gt;
&lt;iframe width=&quot;80%&quot; height=&quot;300px&quot; src=&quot;https://www.liuyiqi.cn/fe-kg/&quot;&gt;&lt;/iframe&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://www.liuyiqi.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="前端体系" scheme="http://www.liuyiqi.cn/tags/%E5%89%8D%E7%AB%AF%E4%BD%93%E7%B3%BB/"/>
    
    <category term="知识图谱" scheme="http://www.liuyiqi.cn/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 基础：异步</title>
    <link href="http://www.liuyiqi.cn/2019/06/02/js-async/"/>
    <id>http://www.liuyiqi.cn/2019/06/02/js-async/</id>
    <published>2019-06-02T12:51:00.000Z</published>
    <updated>2022-09-07T03:52:16.608Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是 JS 异步的知识，包括事件循环、执行栈、任务队列、宏任务、微任务。</p><p><img src="https://user-images.githubusercontent.com/11524612/58769995-a2ad2180-85de-11e9-9c4a-2dffefd08899.png" alt="事件循环"></p><span id="more"></span><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>一个记录函数调用的数据结构。当函数被调用时，会被 push 进栈顶；执行完返回时，从栈顶 pop 出。Javascript 主线程中只有一个执行栈，负责顺序执行主线程中代码。</p><p><img src="https://user-images.githubusercontent.com/11524612/58762165-b5443e00-857f-11e9-92be-76208ff985db.png" alt="image"></p><p>上图先调用 a（push a 到栈），a 再调用 b（push b 到栈），所以报错信息里的 error stack 是 b-&gt;a-&gt;主函数；</p><p>如果上图不报错，那么：b 执行完了被 pop 出，然后 a 执行完了被 pop 出。</p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>一个记录异步事件回调的队列数据结构。当有外部的异步事件 (setTimeout、ajax 等请求) 时，相应的回调函数会按照先后顺序存放在任务队列中。</p><h2 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h2><p>ES6 之前任务比较简单只有 setTimeout &#x2F; ajax 这类 web api 生成的异步事件，所有的这些内容都会被存放到事件队列中，我们称之为异步任务。后来 ES6 中引入了 Promise 之后，异步任务之间存在差异，执行的优先级也有区别。分为两类：微任务和宏任务。</p><blockquote><p>宏任务：整体代码 script 、setTimeout、setInterval、DOM 操作、ajax； 微任务：Promise、async &#x2F; await</p></blockquote><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ul><li>从宏任务队列的队头中拿出一个任务放到执行栈里执行；</li><li>中途遇到异步，就另外执行异步，并把回调函数放到宏任务或者微任务队列中；</li><li>执行完了，检查微任务队列，有就清空它（也就是放到执行栈里执行它）；</li><li>微任务清空了，回到第一步。</li></ul><p><img src="https://user-images.githubusercontent.com/11524612/58762110-ea9c5c00-857e-11e9-91d5-2caebb25b7d5.png" alt="image"></p><h2 id="面试题：promise-与-setTimeout"><a href="#面试题：promise-与-setTimeout" class="headerlink" title="面试题：promise 与 setTimeout"></a>面试题：promise 与 setTimeout</h2><p>下面代码的执行顺序是啥？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;console&#x27;</span>);</span><br></pre></td></tr></table></figure><p>答：promise console then setTimeout</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，我们要讲的是 JS 异步的知识，包括事件循环、执行栈、任务队列、宏任务、微任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/11524612/58769995-a2ad2180-85de-11e9-9c4a-2dffefd08899.png&quot; alt=&quot;事件循环&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript 基础" scheme="http://www.liuyiqi.cn/tags/JavaScript-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="事件循环" scheme="http://www.liuyiqi.cn/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
    <category term="执行栈" scheme="http://www.liuyiqi.cn/tags/%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
    
    <category term="任务队列" scheme="http://www.liuyiqi.cn/tags/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
    <category term="宏任务" scheme="http://www.liuyiqi.cn/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"/>
    
    <category term="微任务" scheme="http://www.liuyiqi.cn/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 基础：继承</title>
    <link href="http://www.liuyiqi.cn/2019/06/02/js-inherit/"/>
    <id>http://www.liuyiqi.cn/2019/06/02/js-inherit/</id>
    <published>2019-06-02T12:51:00.000Z</published>
    <updated>2022-09-07T03:52:16.609Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是 JS 继承的知识，包括 原型继承, 构造函数继承, 组合继承及其优化, 寄生式组合继承。</p><span id="more"></span><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>子类的原型对象设置为父类的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">C1</span> ()&#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C2</span> ()&#123;&#125;</span><br><span class="line"><span class="variable constant_">C2</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">C1</span>();</span><br><span class="line"><span class="variable constant_">C2</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="variable constant_">C2</span>;</span><br></pre></td></tr></table></figure><p>这样：每个子类实例就会继承父类实例的属性，但由于继承的属性在子类的原型上，所以继承的属性在不同实例之间都是共享的，没有隔离。</p><h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>子类的构造函数内部，执行了父类的构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">C1</span> ()&#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C2</span> (...args)&#123;</span><br><span class="line">    <span class="variable constant_">C1</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样：每个子类实例的继承属性就隔离了，但继承不到父类的原型方法；</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>结合以上两种</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">C1</span> ()&#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C2</span> (...args)&#123;</span><br><span class="line">    <span class="variable constant_">C1</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable constant_">C2</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">C1</span>();</span><br><span class="line"><span class="variable constant_">C2</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="variable constant_">C2</span>;</span><br></pre></td></tr></table></figure><p>这样：继承的私有属性隔离，继承的原型方法可以公用，但是执行了两次父类的构造函数，第二次是多余的。</p><h2 id="组合继承优化"><a href="#组合继承优化" class="headerlink" title="组合继承优化"></a>组合继承优化</h2><p>结合前两种方法，但把子类的原型对象指向父类的原型对象，而不是实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">C1</span> ()&#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C2</span> (...args)&#123;</span><br><span class="line">    <span class="variable constant_">C1</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable constant_">C2</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable constant_">C1</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="variable constant_">C2</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="variable constant_">C2</span>;</span><br></pre></td></tr></table></figure><p>这样：就避免执行了两次父类的构造函数，但破坏了父类的原型对象的 <code>constructor</code>：<code>C1.proptotype.constructor</code>，本来应该指向 C1 的，现在指向 C2 了。</p><h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><p>将子类的原型对象设置为一个新的对象，该对象的 <code>__proto__</code> 指向父类的原型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">C1</span> ()&#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C2</span> (...args)&#123;</span><br><span class="line">    <span class="variable constant_">C1</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable constant_">C2</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable constant_">C1</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="variable constant_">C2</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="variable constant_">C2</span>;</span><br></pre></td></tr></table></figure><p>这样就完美了！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，我们要讲的是 JS 继承的知识，包括 原型继承, 构造函数继承, 组合继承及其优化, 寄生式组合继承。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript 基础" scheme="http://www.liuyiqi.cn/tags/JavaScript-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="原型继承" scheme="http://www.liuyiqi.cn/tags/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/"/>
    
    <category term="构造函数继承" scheme="http://www.liuyiqi.cn/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF/"/>
    
    <category term="组合继承" scheme="http://www.liuyiqi.cn/tags/%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF/"/>
    
    <category term="寄生式组合继承" scheme="http://www.liuyiqi.cn/tags/%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 基础：防抖与节流</title>
    <link href="http://www.liuyiqi.cn/2019/06/02/js-debounce-throttle/"/>
    <id>http://www.liuyiqi.cn/2019/06/02/js-debounce-throttle/</id>
    <published>2019-06-02T12:14:00.000Z</published>
    <updated>2022-09-07T03:52:16.609Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是防抖与节流的知识。</p><span id="more"></span><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p><strong>防抖</strong>：当触发动作停够指定时间才触发事件</p><p><strong>节流</strong>：不管触发动作多么密集，事件之间的必须要有足够的间隔时间</p><h2 id="比喻"><a href="#比喻" class="headerlink" title="比喻"></a>比喻</h2><p><strong>防抖</strong>：假如你有一个善变的老婆，如果她一会要你给她买品牌A，一会说要你给她买品牌B，你很烦，就对她说，当你做完决定，<strong>一天</strong>内不变，我就给你买。</p><p><strong>节流</strong>：假如你有一个爱花钱的老婆，她一个月让你买 10 个包，你很烦，就对她说，<strong>每个月</strong>只能买 1 个包。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>防抖</strong>：一边在输入框里打字，一边发请求校验，可以用防抖技术，让用户停止输入足够时间后，再发请求。</p><p><strong>节流</strong>：监听滚动事件（比如图片懒加载）时候，可以用节流技术，减少触发事件的执行次数，减少性能消耗。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>防抖</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="variable language_">arguments</span>;   </span><br><span class="line">        <span class="keyword">var</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(func.<span class="title function_">bind</span>(context,args), wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用柯里化消化 <code>wait</code> 参数，使用 <code>setTimeout</code> 延迟执行函数，如果新的触发动作进来，就取消上次的 <code>setTimeout</code>。</p><p><strong>节流</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> pending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pending) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="variable language_">arguments</span>;   </span><br><span class="line">        <span class="keyword">var</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        pending = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">            pending = <span class="literal">false</span>;</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用柯里化消化 <code>wait</code> 参数，使用 <code>pending</code> 记录上次执行事件是否在等待中，如果是就返回，否则就开始新的等待。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，我们要讲的是防抖与节流的知识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript 基础" scheme="http://www.liuyiqi.cn/tags/JavaScript-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="debounce" scheme="http://www.liuyiqi.cn/tags/debounce/"/>
    
    <category term="throttle" scheme="http://www.liuyiqi.cn/tags/throttle/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 基础：偏移宽高距离、滚动宽高距离、可视宽高</title>
    <link href="http://www.liuyiqi.cn/2019/06/02/js-top-left-width-height/"/>
    <id>http://www.liuyiqi.cn/2019/06/02/js-top-left-width-height/</id>
    <published>2019-06-02T11:26:00.000Z</published>
    <updated>2022-09-07T03:52:16.610Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是偏移宽高距离、滚动宽高距离、可视宽高的含义。大概有这些属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scrollTop</span><br><span class="line">offsetTop</span><br><span class="line">scrollLeft</span><br><span class="line">offsetLeft</span><br><span class="line">clientWidth</span><br><span class="line">clientHeight</span><br><span class="line">offsetWidth</span><br><span class="line">offsetHeight</span><br><span class="line">scrollWidth</span><br><span class="line">scrollHeight</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="各个属性的含义"><a href="#各个属性的含义" class="headerlink" title="各个属性的含义"></a>各个属性的含义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">页可见区域宽： document.body.clientWidth;</span><br><span class="line">网页可见区域高： document.body.clientHeight;</span><br><span class="line">网页可见区域宽： document.body.offsetWidth (包括边线的宽);</span><br><span class="line">网页可见区域高： document.body.offsetHeight (包括边线的宽);</span><br><span class="line">网页正文全文宽： document.body.scrollWidth;</span><br><span class="line">网页正文全文高： document.body.scrollHeight;</span><br><span class="line">网页被卷去的高： document.body.scrollTop;</span><br><span class="line">网页被卷去的左： document.body.scrollLeft;</span><br><span class="line">浏览器距离屏幕上： window.screenTop;</span><br><span class="line">浏览器距离屏幕左： window.screenLeft;</span><br><span class="line">屏幕分辨率的高： window.screen.height;</span><br><span class="line">屏幕分辨率的宽： window.screen.width;</span><br><span class="line">屏幕可用工作区高度： window.screen.availHeight;</span><br></pre></td></tr></table></figure><p><img src="/css/images/offset.svg" alt="示意图"></p><h2 id="信息提取与总结"><a href="#信息提取与总结" class="headerlink" title="信息提取与总结"></a>信息提取与总结</h2><ul><li><strong>对于 height，width 而言</strong>，client（可见区域） &lt; offset（多个边框） &lt; scroll（多个滚动区域）</li><li><strong>对于 top，left 而言</strong>，offset 指的是相对于第一个 position 不为 static 的父元素（没有就是 document）的偏移距离，scroll 则是被卷去的长度。</li><li><strong>对于 screen 而言</strong>，说的是屏幕的距离和宽高。</li></ul><h2 id="面试题：实现图片懒加载"><a href="#面试题：实现图片懒加载" class="headerlink" title="面试题：实现图片懒加载"></a>面试题：实现图片懒加载</h2><p>思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始化状态：图片使用默认图片地址；</span><br><span class="line"></span><br><span class="line">当图片进入可见区域（图片的 offsetTop &lt; 整个文档的 clientHeight + scrollTop）：图片加载真实地址；</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;img&#x27;</span>).<span class="property">length</span>;</span><br><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>; <span class="comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">lazyload</span>(); <span class="comment">//页面载入完毕加载可是区域内的图片</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onscroll</span> = lazyload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lazyload</span>(<span class="params"></span>) &#123; <span class="comment">//监听页面滚动事件</span></span><br><span class="line">    <span class="keyword">var</span> seeHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>; <span class="comment">//可见区域高度</span></span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>; <span class="comment">//滚动条距离顶部高度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = n; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (img[i].<span class="property">offsetTop</span> &lt; seeHeight + scrollTop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (img[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;src&quot;</span>) == <span class="string">&quot;default.jpg&quot;</span>) &#123;</span><br><span class="line">                img[i].<span class="property">src</span> = img[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            n = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，我们要讲的是偏移宽高距离、滚动宽高距离、可视宽高的含义。大概有这些属性：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scrollTop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;offsetTop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scrollLeft&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;offsetLeft&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;clientWidth&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;clientHeight&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;offsetWidth&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;offsetHeight&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scrollWidth&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scrollHeight&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="JavaScript 基础" scheme="http://www.liuyiqi.cn/tags/JavaScript-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="偏移宽高距离" scheme="http://www.liuyiqi.cn/tags/%E5%81%8F%E7%A7%BB%E5%AE%BD%E9%AB%98%E8%B7%9D%E7%A6%BB/"/>
    
    <category term="滚动宽高距离" scheme="http://www.liuyiqi.cn/tags/%E6%BB%9A%E5%8A%A8%E5%AE%BD%E9%AB%98%E8%B7%9D%E7%A6%BB/"/>
    
    <category term="可视宽高" scheme="http://www.liuyiqi.cn/tags/%E5%8F%AF%E8%A7%86%E5%AE%BD%E9%AB%98/"/>
    
  </entry>
  
  <entry>
    <title>CSS 基础：单行与多行省略号</title>
    <link href="http://www.liuyiqi.cn/2019/06/02/css-ellipsis/"/>
    <id>http://www.liuyiqi.cn/2019/06/02/css-ellipsis/</id>
    <published>2019-06-02T05:45:00.000Z</published>
    <updated>2022-09-07T03:52:16.606Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是单行与多行省略号的 CSS 实现。</p><span id="more"></span><h2 id="单行省略号"><a href="#单行省略号" class="headerlink" title="单行省略号"></a>单行省略号</h2><p>主要是用 <code>text-overflow</code> 属性，但为了截断也要用 <code>overflow</code> 和 <code>width</code> 属性。</p><iframe height="265" style="width: 100%;" scrolling="no" title="单行多行省略号" src="//codepen.io/liuyiqi/embed/vwvbGz/?height=265&theme-id=0&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/liuyiqi/pen/vwvbGz/'>单行多行省略号</a> by liuyiqi  (<a href='https://codepen.io/liuyiqi'>@liuyiqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><h2 id="多行省略号"><a href="#多行省略号" class="headerlink" title="多行省略号"></a>多行省略号</h2><p>首先，用 <code>flex: -webkit-box;</code>，将容器设置为弹性盒子模块，这是老版本的 flex，然后，设置 <code>-webkit-box-orient: vertical;</code> 和 <code>-webkit-line-clamp: 3;</code> 让其向下布局，并截断三行显示省略号，demo 同上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，我们要讲的是单行与多行省略号的 CSS 实现。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CSS 基础" scheme="http://www.liuyiqi.cn/tags/CSS-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="省略号" scheme="http://www.liuyiqi.cn/tags/%E7%9C%81%E7%95%A5%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>CSS 基础：BFC</title>
    <link href="http://www.liuyiqi.cn/2019/06/02/css-bfc/"/>
    <id>http://www.liuyiqi.cn/2019/06/02/css-bfc/</id>
    <published>2019-06-02T03:23:00.000Z</published>
    <updated>2022-09-07T03:52:16.605Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是 BFC 的相关知识。</p><span id="more"></span><h2 id="什么是-BFC？"><a href="#什么是-BFC？" class="headerlink" title="什么是 BFC？"></a>什么是 BFC？</h2><blockquote><p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p></blockquote><h2 id="创建-BFC"><a href="#创建-BFC" class="headerlink" title="创建 BFC"></a>创建 BFC</h2><ol><li>根元素或包含根元素的元素</li><li>浮动元素 float ＝ left | right 或 inherit（≠ none）</li><li>绝对定位元素 position ＝ absolute 或 fixed</li><li>display ＝ inline-block | flex | inline-flex | table-cell 或 table-caption</li><li>overflow ＝ hidden | auto 或 scroll (≠ visible)</li></ol><h2 id="BFC-特性"><a href="#BFC-特性" class="headerlink" title="BFC 特性"></a>BFC 特性</h2><ol><li>BFC 是一个独立的容器，容器内子元素不会影响容器外的元素。反之亦如此。</li><li>盒子从顶端开始垂直地一个接一个地排列，盒子之间垂直的间距是由 margin 决定的。</li><li>在同一个 BFC 中，两个相邻的块级盒子的垂直外边距会发生重叠。</li><li>BFC 区域不会和 float box 发生重叠。</li><li>BFC 能够识别并包含浮动元素，当计算其区域的高度时，浮动元素也可以参与计算了。</li></ol><h2 id="Demo-展示"><a href="#Demo-展示" class="headerlink" title="Demo 展示"></a>Demo 展示</h2><p>BFC 区域不会和 float box 发生重叠：</p><iframe height="265" style="width: 100%;" scrolling="no" title="BFC 不会和 float 重叠" src="//codepen.io/liuyiqi/embed/QRzzmo/?height=265&theme-id=0&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/liuyiqi/pen/QRzzmo/'>BFC 不会和 float 重叠</a> by liuyiqi  (<a href='https://codepen.io/liuyiqi'>@liuyiqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>BFC 能够识别并包含浮动元素，当计算其区域的高度时，浮动元素也可以参与计算了（<strong>清除浮动</strong>）：</p><iframe height="265" style="width: 100%;" scrolling="no" title="BFC 把 float 元素高度计算在内" src="//codepen.io/liuyiqi/embed/eabbLN/?height=265&theme-id=0&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/liuyiqi/pen/eabbLN/'>BFC 把 float 元素高度计算在内</a> by liuyiqi  (<a href='https://codepen.io/liuyiqi'>@liuyiqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>在同一个 BFC 中，两个相邻的块级盒子的垂直外边距会发生重叠：</p><iframe height="429" style="width: 100%;" scrolling="no" title="BFC内部会外边距塌陷，外部不会" src="//codepen.io/liuyiqi/embed/OYrrBB/?height=429&theme-id=0&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/liuyiqi/pen/OYrrBB/'>BFC内部会外边距塌陷，外部不会</a> by liuyiqi  (<a href='https://codepen.io/liuyiqi'>@liuyiqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，我们要讲的是 BFC 的相关知识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CSS 基础" scheme="http://www.liuyiqi.cn/tags/CSS-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="BFC" scheme="http://www.liuyiqi.cn/tags/BFC/"/>
    
  </entry>
  
  <entry>
    <title>CSS 基础：块级元素、行内元素、替换元素、非替换元素</title>
    <link href="http://www.liuyiqi.cn/2019/06/02/css-inline-block/"/>
    <id>http://www.liuyiqi.cn/2019/06/02/css-inline-block/</id>
    <published>2019-06-02T03:23:00.000Z</published>
    <updated>2022-09-07T03:52:16.606Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是块级元素、行内元素、替换元素、非替换元素的区分和特点。</p><span id="more"></span><h2 id="元素的分类"><a href="#元素的分类" class="headerlink" title="元素的分类"></a>元素的分类</h2><p><strong>1 替换和不可替换元素</strong> </p><p>从元素本身的特点来讲，可以分为替换和不可替换元素。</p><p><strong>1.1 替换元素</strong></p><p>替换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容。</p><p>例如：浏览器会根据 <code>&lt;img&gt;</code> 标签的src属性的值来读取图片信息并显示出来，而如果查看(X)HTML代码，则看不到图片的实际内容；</p><p>又例如：根据<code>&lt;input&gt;</code>标签的type属性来决定是显示输入框，还是单选按钮等。</p><p>(X)HTML中的<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;object&gt;</code>都是替换元素。这些元素往往没有实际的内容，即是一个空元素，浏览器会根据元素的标签类型和属性来显示这些元素。可替换元素也在其显示中生成了框。</p><p><strong>1.2 不可替换元素</strong></p><p>(X)HTML 的大多数元素是不可替换元素，即其内容直接表现给用户端（例如浏览器）。段落<code>&lt;p&gt;</code>是一个不可替换元素，文字“段落的内容”全被显示。</p><p><strong>2 显示元素</strong></p><p>除了可替换元素和不可替换元素的分类方式外，CSS 2.1中元素还有另外的分类方式：块级元素（block-level）和行内元素（inline-level，也译作“内联”元素）。</p><p><strong>2.1 块级元素</strong></p><p>在视觉上被格式化为块的元素，最明显的特征就是它默认在横向充满其父元素的内容区域，而且在其左右两边没有其他元素，即<strong>块级元素默认是独占一行的</strong>。</p><p><strong>举例</strong>：典型的块级元素有：<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>，等等。</p><p><strong>产生方式</strong>：通过CSS设定了浮动（float属性，可向左浮动或向右浮动）以及设定显示（display）属性为“block”或“list-item”的元素都是块级元素。但是浮动元素比较特殊，由于浮动，其旁边可能会有其他元素的存在。而“list-item”（列表项<code>&lt;li&gt;</code>），会在其前面生成圆点符号，或者数字序号。</p><p><strong>2.2 行内元素</strong></p><p>行内元素不形成新内容块，即在其左右可以有其他元素，例如<code>&lt;a&gt;</code>、<code>&lt;span&gt;</code>、<code>&lt;strong&gt;</code>等，都是典型的行内级元素。</p><p><strong>产生方式</strong>：display属性等于“inline”的元素都是行内元素。几乎所有的可替换元素都是行内元素，例如<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>等等。不过元素的类型也不是固定的，通过设定CSS 的display属性，可以使行内元素变为块级元素，也可以让块级元素变为行内元素。</p><p>MDN 对行内元素这么定义：</p><blockquote><p>一个行内元素只占据它对应标签的边框所包含的空间。</p></blockquote><iframe height="265" style="width: 100%;" scrolling="no" title="行内元素只占据边框" src="//codepen.io/liuyiqi/embed/OYrrjZ/?height=265&theme-id=0&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/liuyiqi/pen/OYrrjZ/'>行内元素只占据边框</a> by liuyiqi  (<a href='https://codepen.io/liuyiqi'>@liuyiqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><h2 id="各种元素的width-height-margin-padding-特性"><a href="#各种元素的width-height-margin-padding-特性" class="headerlink" title="各种元素的width height margin padding 特性"></a>各种元素的width height margin padding 特性</h2><p><strong>1 块级元素</strong></p><p>width、 height、 margin的四个方向、 padding的四个方向都正常显示，遵循标准的css盒模型。例如：div</p><p><strong>2 行内替换元素</strong></p><p>width、 height、 margin的四个方向、 padding的四个方向都正常显示，遵循标准的css盒模型。 例如：img</p><p><strong>3 行内非替换元素（重点）</strong><br>width、 height不起作用，用line-height来控制高度。</p><p>padding左右起作用，上下不会影响行高，但是对于有背景色和内边距的行内非替换元素，背景可以向元素上下延伸，但是行高没有改变。因此视觉效果就是与前面的行重叠。(《css权威指南》 P249)</p><p>margin左右作用起作用，上下不起作用，原因在于：行内非替换元素的外边距不会改变一个元素的行高（《css权威指南》 P227）。</p><iframe height="265" style="width: 100%;" scrolling="no" title="行内元素特点" src="//codepen.io/liuyiqi/embed/gJZZwX/?height=265&theme-id=0&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/liuyiqi/pen/gJZZwX/'>行内元素特点</a> by liuyiqi  (<a href='https://codepen.io/liuyiqi'>@liuyiqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，我们要讲的是块级元素、行内元素、替换元素、非替换元素的区分和特点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CSS 基础" scheme="http://www.liuyiqi.cn/tags/CSS-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="块级元素" scheme="http://www.liuyiqi.cn/tags/%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0/"/>
    
    <category term="行内元素" scheme="http://www.liuyiqi.cn/tags/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/"/>
    
    <category term="替换元素" scheme="http://www.liuyiqi.cn/tags/%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0/"/>
    
    <category term="非替换元素" scheme="http://www.liuyiqi.cn/tags/%E9%9D%9E%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 基础：原型链</title>
    <link href="http://www.liuyiqi.cn/2019/06/01/js-prototype/"/>
    <id>http://www.liuyiqi.cn/2019/06/01/js-prototype/</id>
    <published>2019-06-01T13:42:00.000Z</published>
    <updated>2022-09-07T03:52:16.609Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是原型链以及相关几道面试题。</p><span id="more"></span><h2 id="原型链是啥？"><a href="#原型链是啥？" class="headerlink" title="原型链是啥？"></a>原型链是啥？</h2><blockquote><p>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 <code>__proto__</code> ）指向它的构造函数的原型对象（<code>prototype</code> ）。该原型对象也有一个自己的原型对象( <code>__proto__</code> ) ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个原型链中的最后一个环节。</p></blockquote><p>以上是 MDN 的定义，简单来说就是一个链表，不过这个链表有点奇葩，就像这样：</p><p>如果 <code>const a = new A();</code> 那么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                    A                    Object</span><br><span class="line">                    .                       .   </span><br><span class="line">a.__proto__ --&gt; prototype.__proto__ --&gt; prototype.__proto__ --&gt; null</span><br></pre></td></tr></table></figure><p>来张完整版本的图：</p><p><img src="https://user-images.githubusercontent.com/11524612/58749311-1b18c300-84b7-11e9-969a-44578d9da420.png" alt="image"></p><p>完整版本的信息提取：</p><ol><li>每个对象（包括函数）都有 <code>__proto__</code> , 但 <code>null</code> 没有。</li><li>每个对象的 <code>__proto__</code> 只会指向它的构造函数的 <code>prototype</code> 对象，<code>Object.__proto__</code> 除外，它指向 <code>null</code>。</li><li>构造函数的 <code>prototype</code> 对象的 <code>constructor</code> 属性指回构造函数。</li></ol><p>看似复杂，也就三条信息。</p><h2 id="面试题一：instanceof-的实现原理是啥？"><a href="#面试题一：instanceof-的实现原理是啥？" class="headerlink" title="面试题一：instanceof 的实现原理是啥？"></a>面试题一：instanceof 的实现原理是啥？</h2><p>如果 <code>left instanceof right</code> ，那么会沿着 <code>left</code> 的原型链一直往上找，如果找到 <code>right.prototype</code>，就 return true，否则就 return false。说白了就是一个链表的的遍历。</p><h2 id="面试题二：描述-new-一个对象的过程"><a href="#面试题二：描述-new-一个对象的过程" class="headerlink" title="面试题二：描述 new 一个对象的过程"></a>面试题二：描述 new 一个对象的过程</h2><ol><li>创建空对象； <code>var obj = &#123;&#125;;</code></li><li>设置新对象的 <code>constructor</code> 属性为构造函数的名称，设置新对象的 <code>__proto__</code>属性指向构造函数的 <code>prototype</code> 对象；<code>obj._proto_ = ClassA.prototype;</code></li><li>使用新对象调用函数，函数中的 this 被指向新实例对象，<code>ClassA.call(obj);</code></li><li>将创建的新对象（如果构造函数返回对象，这里会将构造函数返回的对象保存在等号左边的变量中），保存到等号左边的变量中。</li></ol><h2 id="面试题三：如何准确判断一个变量是数组类型？"><a href="#面试题三：如何准确判断一个变量是数组类型？" class="headerlink" title="面试题三：如何准确判断一个变量是数组类型？"></a>面试题三：如何准确判断一个变量是数组类型？</h2><ol><li><code>arr instanceof Array</code></li><li><code>Array.isArray(arr)</code></li><li><code>Object.prototype.toString.call(arr) === &#39;[object Array]&#39;</code></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，我们要讲的是原型链以及相关几道面试题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端面试" scheme="http://www.liuyiqi.cn/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    <category term="原型链" scheme="http://www.liuyiqi.cn/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 基础：柯里化</title>
    <link href="http://www.liuyiqi.cn/2019/06/01/js-currying/"/>
    <id>http://www.liuyiqi.cn/2019/06/01/js-currying/</id>
    <published>2019-06-01T13:22:00.000Z</published>
    <updated>2022-09-07T03:52:16.608Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是柯里化以及相关几道面试题。</p><span id="more"></span><h2 id="什么是柯里化？"><a href="#什么是柯里化？" class="headerlink" title="什么是柯里化？"></a>什么是柯里化？</h2><blockquote><p>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p></blockquote><p>这是 wiki 百科的解释。简单来说，柯里化就是帮你消化一部分参数的函数。来张图吧～</p><p><img src="https://user-images.githubusercontent.com/11524612/58748306-1e0cb700-84a9-11e9-881f-bee95cc41dcb.png" alt="image"></p><p>本来计算 a + b + c，需要三个参数，结果柯里化函数帮你消化了一部分，每次只需要传递一个参数。</p><h2 id="柯里化和高阶函数有啥区别？"><a href="#柯里化和高阶函数有啥区别？" class="headerlink" title="柯里化和高阶函数有啥区别？"></a>柯里化和高阶函数有啥区别？</h2><p>有的同学看到上面的嵌套函数，会想这不就是高阶函数吗？没错，柯里化一定是高阶函数，但高阶函数不一定是柯里化。因为高阶函数的定义是：</p><blockquote><p>在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数： 接受一个或多个函数作为输入 输出一个函数。</p></blockquote><p>比如，ES6 的 map、reduce 都是高阶函数（函数作为参数），但它们不是柯里化。</p><h2 id="面试题一：用-apply-实现-bind"><a href="#面试题一：用-apply-实现-bind" class="headerlink" title="面试题一：用 apply 实现 bind"></a>面试题一：用 apply 实现 bind</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">const</span> ctx = args.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    fn.<span class="title function_">apply</span>(ctx, args.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bind 先消化一部分参数，apply 再消化一部分参数。</p><h2 id="面试题二：实现-sum-函数"><a href="#面试题二：实现-sum-函数" class="headerlink" title="面试题二：实现 sum 函数"></a>面试题二：实现 sum 函数</h2><p>满足：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>)(<span class="number">2</span>).<span class="title function_">valueOf</span>() <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>).<span class="title function_">valueOf</span>() <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>)(<span class="number">2</span>)....(n).<span class="title function_">valueOf</span>() <span class="comment">// 所有参数的和</span></span><br></pre></td></tr></table></figure><p>sum 就是一个柯里化函数，因为它执行一次就消化了一部分参数，并返回了一个函数继续消化剩余的参数，最终还能把所有消化的参数计算出来。</p><p>先实现两个参数的版本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">a</span>) =&gt; <span class="function">(<span class="params">b</span>) =&gt;</span> (&#123;<span class="attr">valueOf</span>: <span class="function">() =&gt;</span> a+b&#125;)  </span><br></pre></td></tr></table></figure><p>那么无限参数的版本难道是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">a</span>) =&gt; <span class="function">(<span class="params">b</span>) =&gt;</span> <span class="function">(<span class="params">c</span>) =&gt;</span> ... =&gt; <span class="function">(<span class="params">n</span>) =&gt;</span> (&#123;<span class="attr">valueOf</span>: <span class="function">() =&gt;</span> a+b+...+n&#125;) </span><br></pre></td></tr></table></figure><p>显然不行，所以用递归：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">n</span>) =&gt; &#123; </span><br><span class="line">  <span class="keyword">let</span> val = a;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">tmp</span> = (<span class="params">n</span>) =&gt; &#123;</span><br><span class="line">    val += n;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  tmp.<span class="property">valueOf</span> = <span class="function">() =&gt;</span> val;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，我们要讲的是柯里化以及相关几道面试题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript 基础" scheme="http://www.liuyiqi.cn/tags/JavaScript-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="柯里化" scheme="http://www.liuyiqi.cn/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JS 死循环的手动终止以及代码熔断方法</title>
    <link href="http://www.liuyiqi.cn/2019/01/25/js-infinite-loop-breaker/"/>
    <id>http://www.liuyiqi.cn/2019/01/25/js-infinite-loop-breaker/</id>
    <published>2019-01-25T06:35:00.000Z</published>
    <updated>2022-09-07T03:52:16.609Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作中遇到了一些死循环导致的页面卡死问题，经过 trouble shooting 和代码修复解决了问题，在此也顺便整理了一下 JS 死循环的手动终止以及代码熔断方法。</p><span id="more"></span><h2 id="被死循环卡死的页面"><a href="#被死循环卡死的页面" class="headerlink" title="被死循环卡死的页面"></a>被死循环卡死的页面</h2><p>你是否遇到这样的场景，在你执行了页面上某个动作后，一些怪异的事情发生了：</p><ul><li>页面卡死了，点击页面上任何按钮，或者是尝试滚动页面都没有任何反应。</li><li>过了几秒后，电脑的风扇开始加速转动，声音变大。</li><li>然后，你尝试关闭页面，发现连页面都关不了（刚卡死不太久时候其实还能关闭）。</li><li>接着，你尝试关闭浏览器，但也没有任何反应。随着风扇转动地更快，你也开始焦急了。</li><li>无奈，你打开任务管理器关闭了浏览器的进程。</li><li>当你想再试试触发这一切的那个“动作”时候，上述事情还是如期而至。</li><li>……<br><a href="https://imgchr.com/i/kmNDsJ"><img src="https://s2.ax1x.com/2019/01/25/kmNDsJ.png" alt="kmNDsJ.png"></a></li></ul><p>那么这时候很有可能，你的 JS 代码里出现了死循环（Infinite Loop）。</p><p>死循环出现的原因很多：</p><ul><li>组件更新回调里再次调用了更新方法。</li><li>表单项 A 和 B 相互联动。</li><li>递归函数里忘记写了终止逻辑，或是终止逻辑有问题。</li><li>……</li></ul><p>死循环严重影响用户体验，甚至伤机器，我们要尽力避免，但完全规避是不可能的，毕竟程序员也是人，也会犯错。所以，今天我们要介绍如何手动终止死循环，以及如何用代码熔断死循环。</p><h2 id="手动终止死循环"><a href="#手动终止死循环" class="headerlink" title="手动终止死循环"></a>手动终止死循环</h2><p>如果你尝试调用任务管理器，关闭浏览器进程，这样的操作成本较高，你还要重新打开浏览器，打开页面。但是不这么做，页面就会卡死，你“什么也做不了”。其实，在 Chrome 67及以上版本中，还是有方法可以在不杀死浏览器进程的前提下终止死循环的。方法如下：</p><ul><li>打开开发者工具 DevTools（F12）。</li><li>点开 <strong>Sources</strong> 面板，点击 “Pause script execution” 按钮，发现代码就暂停了。</li><li>然后长按“Pause script execution” 按钮，并选择 “Stop” 图标，就终止死循环了。</li></ul><p><img src="https://i.stack.imgur.com/iYiF1.png" alt="手动终止"></p><h2 id="代码熔断"><a href="#代码熔断" class="headerlink" title="代码熔断"></a>代码熔断</h2><p>手动终止只是减少杀死浏览器进程重启的成本，我们最好还能用代码来熔断一些死循环。下面是熔断函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loopBreaker = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> startTime;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    startTime = startTime || (startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>());</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 更改阈值为你想要的，这里是 10000</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">10000</span> &amp;&amp; (<span class="title class_">Date</span>.<span class="title function_">now</span>() - startTime &gt; <span class="number">1000</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Loop Broken!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一秒后清空</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; count = <span class="number">0</span>; startTime = <span class="literal">null</span>; &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>上述函数中 <code>count</code> 是循环执行次数，<code>startTime</code> 是首次执行函数的时间。如果循环超过 10000 次，且循环时间超过 1000 毫秒，那么就熔断。</p><p>使用方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i--) &#123;</span><br><span class="line">  <span class="title function_">loopBreaker</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以改写这个函数以支持更多的功能，如：日志格式、熔断阈值等，快去试试吧！</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文介绍了 JS 死循环的手动终止以及代码熔断方法。但解决问题的方法肯定不止于此，比如一些 Babel 插件可以转换所有循环代码，但就不再赘述了。最后，希望可以本文给遇到死循环的读者一些参考。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近工作中遇到了一些死循环导致的页面卡死问题，经过 trouble shooting 和代码修复解决了问题，在此也顺便整理了一下 JS 死循环的手动终止以及代码熔断方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JS 调试" scheme="http://www.liuyiqi.cn/tags/JS-%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>深度优先搜索和链表指针在 JSON 操作中的应用</title>
    <link href="http://www.liuyiqi.cn/2019/01/23/dfs-linked-list-in-json/"/>
    <id>http://www.liuyiqi.cn/2019/01/23/dfs-linked-list-in-json/</id>
    <published>2019-01-23T08:25:00.000Z</published>
    <updated>2022-09-07T03:52:16.606Z</updated>
    
    <content type="html"><![CDATA[<p>最近的工作涉及了大量 JSON 操作，用到了一些之前做过的算法题中的知识，深刻感觉到，传统数据结构与算法在前端开发中的应用也挺多的。所以，想借此文记录总结一番。</p><span id="more"></span><h2 id="深度优先搜索简介"><a href="#深度优先搜索简介" class="headerlink" title="深度优先搜索简介"></a>深度优先搜索简介</h2><p>深度优先搜索（Depth-First-Search，DFS）是一种用于遍历或搜索树或者图的算法。顾名思义，它的搜索的规则是深度优先：先访问根结点，如果有孩子节点（或者邻居节点）就优先访问孩子节点，并对孩子节点也进行上述递归访问。</p><p><img src="/css/images/1556699036557-2.jpg" alt="dfs"></p><p>DFS 可谓是 LeetCode 中考察最多的知识点了，另外由于动态规划算法可以和 DFS 算法相互转换（就像是所有的递归都可以用“栈”来改写一样），所以 DFS 的题目简直不能更多。</p><h2 id="使用深度优先搜索打印-JSON"><a href="#使用深度优先搜索打印-JSON" class="headerlink" title="使用深度优先搜索打印 JSON"></a>使用深度优先搜索打印 JSON</h2><p>那么 DFS 在 JSON 操作中有什么用处呢？假如你想在网页上渲染一个 JSON，甚至想渲染出一个表单来编辑这个 JSON，那么就要用到 DFS 了。思路也很简单，先访问一个 JSON 的根结点，然后访问它的所有 key（也就是孩子节点），并对 key 也进行上述递归。</p><p>示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> json = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;hello&#x27;</span> &#125;, <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>] &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">n</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">String</span>(n) === <span class="string">&#x27;[object Object]&#x27;</span> || <span class="title class_">Array</span>.<span class="title function_">isArray</span>(n))&#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(n).<span class="title function_">forEach</span>(<span class="function"><span class="params">k</span> =&gt;</span> &#123; <span class="title function_">dfs</span>(n[k]); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="title function_">dfs</span>(json);</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://s2.ax1x.com/2019/01/23/kECv8A.png" alt="打印 JSON"></p><p>可以发现 JSON 中每个节点都被遍历到了。</p><h2 id="DFS-用于构建无限递归表单"><a href="#DFS-用于构建无限递归表单" class="headerlink" title="DFS 用于构建无限递归表单"></a>DFS 用于构建无限递归表单</h2><p>只需要更改上述 <code>dfs</code> 函数的参数，就可以渲染 JSON 树中的任意一项了，也可以渲染表单项来编辑它们。比如之前做的递归表单组件：</p><p><img src="/css/images/1662520255066-3.png" alt="递归表单"></p><h2 id="链表指针简介"><a href="#链表指针简介" class="headerlink" title="链表指针简介"></a>链表指针简介</h2><p><strong>链表</strong>（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针。</p><p>链表遍历及操作也是 LeetCode 考察非常多的题目。通常我们会定义一个变量作为指针，然后在循环里让它遍历链表的多个 <code>next</code>。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = linkedList;</span><br><span class="line"><span class="comment">// 某个循环中</span></span><br><span class="line">p = p.<span class="property">next</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用链表指针获取-JSON-中的叶子节点的值"><a href="#使用链表指针获取-JSON-中的叶子节点的值" class="headerlink" title="使用链表指针获取 JSON 中的叶子节点的值"></a>使用链表指针获取 JSON 中的叶子节点的值</h2><p>那么链表指针在 JSON 操作中有什么用呢？我们可以把 JS 中 Object 的 key 当作链表中的 <code>next</code>。那么如果知道一个叶子节点的路径，我们就可以用指针像遍历链表那样遍历到 JSON 的叶子节点处。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> json = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;hello&#x27;</span> &#125;, <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>] &#125;;</span><br><span class="line"><span class="keyword">const</span> path = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> point = json;</span><br><span class="line">path.<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123; point = point[key] &#125;);</span><br><span class="line"><span class="comment">// point 为 &#x27;hello&#x27;，即 json.a.b 的值。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(point);</span><br></pre></td></tr></table></figure><p>上述代码中，<code>json</code> 是我们要查找的 JSON 对象，<code>path</code> 是叶子节点的路径，<code>point</code> 是指针，通过遍历，<code>point</code> 最后指向了指定的叶子节点的值。</p><h2 id="使用链表指针构造-immutibility-helper-所需要的数据结构"><a href="#使用链表指针构造-immutibility-helper-所需要的数据结构" class="headerlink" title="使用链表指针构造 immutibility-helper 所需要的数据结构"></a>使用链表指针构造 immutibility-helper 所需要的数据结构</h2><p>另外，由于 React Redux 的风行，不可变数据结构在前端用的非常多，有个不可变数据工具包叫 immutibility-helper ，它经常用到这样的结构来“不可变”地改变数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">update</span>(obj, &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: &#123;<span class="attr">c</span>: &#123;<span class="attr">$set</span>: <span class="number">1</span>&#125;&#125;&#125;&#125;);</span><br></pre></td></tr></table></figure><p>所以，还可以通过指针来将路径与它所需要的结构进行互转。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文讲述的算法都非常简单，在 LeetCode 上应该属于 Easy 中的 Easy 级别的，但是将算法应用到实际工作中也是一件有趣的事情，故记录下来，作为总结，也抛砖引玉，分享给大家。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近的工作涉及了大量 JSON 操作，用到了一些之前做过的算法题中的知识，深刻感觉到，传统数据结构与算法在前端开发中的应用也挺多的。所以，想借此文记录总结一番。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://www.liuyiqi.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://www.liuyiqi.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>搭建 Appium 自动化测试环境（IOS 篇）</title>
    <link href="http://www.liuyiqi.cn/2018/08/10/appium-ios-get-started/"/>
    <id>http://www.liuyiqi.cn/2018/08/10/appium-ios-get-started/</id>
    <published>2018-08-10T09:51:00.000Z</published>
    <updated>2022-09-07T03:52:16.605Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 IOS 系统的 App 进行自动化测试。</p><blockquote><p>本文仅讲解在 Mac 上的环境配置方法。</p></blockquote><span id="more"></span><h2 id="配置-IOS-的自动化驱动环境"><a href="#配置-IOS-的自动化驱动环境" class="headerlink" title="配置 IOS 的自动化驱动环境"></a>配置 IOS 的自动化驱动环境</h2><p>Appium 进行自动化的原理是：发送命令到各自系统对应的自动化驱动，来对相应的系统上的 App 进行自动化。这篇文章讲的是 IOS 自动化，对应驱动的名字叫 XCUITest。为了让驱动正常工作，我们要配置 XCUITest 的环境：</p><h3 id="安装-XCode7-或更高版本"><a href="#安装-XCode7-或更高版本" class="headerlink" title="安装 XCode7 或更高版本"></a>安装 XCode7 或更高版本</h3><p>如果你的 Mac 已经安装 XCode，请忽略，否则去 App Store 里安装。</p><h3 id="添加-udid-到-IOS-开发者账号上"><a href="#添加-udid-到-IOS-开发者账号上" class="headerlink" title="添加 udid 到 IOS 开发者账号上"></a>添加 udid 到 IOS 开发者账号上</h3><p>让有 IOS 开发者账号的人（可能是你或着你的 IOS 开发同事）把被测试的 iPhone 的 udid （udid 的获取办法请 Google）添加到开发者账户上。IOS 开发者都知道，如果你不是 IOS 开发就找他们做这一步，这里就不再赘述。</p><h3 id="安装开发者证书"><a href="#安装开发者证书" class="headerlink" title="安装开发者证书"></a>安装开发者证书</h3><p>让有 IOS 开发者账号的人（可能是你或着你的 IOS 开发同事）把证书文件给你，你把它们装在 Mac 上。</p><p>文件清单：</p><ul><li>xxx.cer</li><li>xxx.p12</li><li>xxx.mobileprovision</li></ul><p>三个文件都是双击安装，一路默认。</p><p>注意：</p><ul><li>安装 xxx.p12 文件时候，可能有密码，还是找有 IOS 开发者账号的人要密码。</li><li>双击 xxx.mobileprovision 文件时候，没有什么界面，但是只要你的电脑上有 XCode，就已经安装好了。</li></ul><h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h3><p>如果你的 Mac 已经有 Homebrew ，请忽略，否则执行此命令安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="安装-Carthage"><a href="#安装-Carthage" class="headerlink" title="安装 Carthage"></a>安装 Carthage</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install carthage</span><br></pre></td></tr></table></figure><h3 id="安装-libimobiledevice"><a href="#安装-libimobiledevice" class="headerlink" title="安装 libimobiledevice"></a>安装 libimobiledevice</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install libimobiledevice --HEAD</span><br></pre></td></tr></table></figure><h3 id="安装-ios-deploy"><a href="#安装-ios-deploy" class="headerlink" title="安装 ios-deploy"></a>安装 ios-deploy</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g ios-deploy</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ios-deploy</span><br></pre></td></tr></table></figure><p>至此，驱动环境就搭建好了！</p><h2 id="安装-Appium"><a href="#安装-Appium" class="headerlink" title="安装 Appium"></a>安装 Appium</h2><p>安装 Appium 有两种方式，NPM 和 桌面程序安装包，我们这次先选择前者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g appium</span><br></pre></td></tr></table></figure><h2 id="配置-WebDriverAgent"><a href="#配置-WebDriverAgent" class="headerlink" title="配置 WebDriverAgent"></a>配置 WebDriverAgent</h2><p>打开 WebDriverAgent.xcodeproj：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open $(npm root -g)/appium/node_modules/appium-xcuitest-driver/WebDriverAgent/WebDriverAgent.xcodeproj</span><br></pre></td></tr></table></figure><p>选择 WebDriverAgentRunner，并在下面两个 Signing 面板上选择之前安装的 provisioning 文件。</p><p><img src="/css/images/1662520255065-2.png" alt="image.png"></p><h2 id="编写简单测试脚本"><a href="#编写简单测试脚本" class="headerlink" title="编写简单测试脚本"></a>编写简单测试脚本</h2><p>把 iPhone 插到 Mac 上。然后： </p><h3 id="准备被测试的-App-的安装包"><a href="#准备被测试的-App-的安装包" class="headerlink" title="准备被测试的 App 的安装包"></a>准备被测试的 App 的安装包</h3><p>准备一份被测试 IOS App 文件，就是 ipa 结尾的安装包。</p><h3 id="新建测试项目"><a href="#新建测试项目" class="headerlink" title="新建测试项目"></a>新建测试项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir appium-test</span><br><span class="line"></span><br><span class="line">cd appium-test</span><br><span class="line"></span><br><span class="line">npm i webdriverio</span><br></pre></td></tr></table></figure><p>添加 test.js 文件，并填写以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wdio = <span class="built_in">require</span>(<span class="string">&quot;webdriverio&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> opts = &#123;</span><br><span class="line">  <span class="attr">port</span>: <span class="number">4723</span>,</span><br><span class="line">  <span class="attr">desiredCapabilities</span>: &#123;</span><br><span class="line">    <span class="attr">platformName</span>: <span class="string">&quot;IOS&quot;</span>,</span><br><span class="line">    <span class="attr">deviceName</span>: <span class="string">&quot;iPhone的设备名称（Settings -&gt; General -&gt; About -&gt; Name ）&quot;</span>,</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&quot;填写 xxx.ipa 的本地路径&quot;</span>,</span><br><span class="line">    <span class="attr">automationName</span>: <span class="string">&quot;XCUITest&quot;</span>,</span><br><span class="line">    <span class="attr">udid</span>: <span class="string">&quot;iPhone 的 udid&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = wdio.<span class="title function_">remote</span>(opts);</span><br><span class="line"></span><br><span class="line">client</span><br><span class="line">  .<span class="title function_">init</span>()</span><br><span class="line">  .<span class="title function_">end</span>();</span><br></pre></td></tr></table></figure><p>在一个命令行中启动 appium：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appium</span><br></pre></td></tr></table></figure><p>在另一个命令行中执行测试脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node test.js</span><br></pre></td></tr></table></figure><p>然后就会发现手机被安装了 xxx.ipa ，并打开了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 IOS 系统的 App 进行自动化测试。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文仅讲解在 Mac 上的环境配置方法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="测试" scheme="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="自动化测试" scheme="http://www.liuyiqi.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Appium" scheme="http://www.liuyiqi.cn/tags/Appium/"/>
    
    <category term="IOS" scheme="http://www.liuyiqi.cn/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title>搭建 Appium 自动化测试环境（Android 篇）</title>
    <link href="http://www.liuyiqi.cn/2018/08/08/appium-android-get-started/"/>
    <id>http://www.liuyiqi.cn/2018/08/08/appium-android-get-started/</id>
    <published>2018-08-08T06:23:00.000Z</published>
    <updated>2022-09-07T03:52:16.605Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 Android 系统的 App 进行自动化测试。</p><blockquote><p>本文仅讲解在 Mac 上的环境配置方法。</p></blockquote><span id="more"></span><h2 id="配置-Android-的自动化驱动环境"><a href="#配置-Android-的自动化驱动环境" class="headerlink" title="配置 Android 的自动化驱动环境"></a>配置 Android 的自动化驱动环境</h2><p>Appium 进行自动化的原理是：发送命令到各自系统对应的自动化驱动，来对相应的系统上的 App 进行自动化。这篇文章讲的是 Android 自动化，对应驱动的名字叫 UiAutomator2。为了让驱动正常工作，我们要配置 UiAutomator2 的环境：</p><h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h3><p>如果你的 Mac 已经有 Homebrew ，请忽略，否则执行此命令安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="安装-Java"><a href="#安装-Java" class="headerlink" title="安装 Java"></a>安装 Java</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap caskroom/versions</span><br><span class="line">brew cask install java8</span><br></pre></td></tr></table></figure><h3 id="设置-JAVA-HOME-环境变量"><a href="#设置-JAVA-HOME-环境变量" class="headerlink" title="设置 JAVA_HOME 环境变量"></a>设置 JAVA_HOME 环境变量</h3><p>编辑登陆脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br></pre></td></tr></table></figure><p>添加这两行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="string">&quot;<span class="subst">$(/usr/libexec/java_home)</span>&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>使其生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><h3 id="安装-Android-SDK"><a href="#安装-Android-SDK" class="headerlink" title="安装 Android SDK"></a>安装 Android SDK</h3><p>Android SDK 最好的安装方法是安装 <a href="https://developer.android.com/studio/index.html">Android Studio</a>。安装过程一路默认就好。</p><p>安装完成后，点击这里查看 SDK 目录：</p><p><img src="/css/images/1662520255050-0.png" alt="image.png"></p><p><img src="/css/images/1662520255064-1.png" alt="image.png"></p><h3 id="设置-ADNROID-HOME-环境变量"><a href="#设置-ADNROID-HOME-环境变量" class="headerlink" title="设置 ADNROID_HOME 环境变量"></a>设置 ADNROID_HOME 环境变量</h3><p>将 ANDROID_HOME 环境变量设置为上步的 SDK 目录地址：</p><p>编辑登陆脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br></pre></td></tr></table></figure><p>添加这两行（注意把 username 改为自己的）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_HOME=<span class="string">&quot;/Users/username/Library/Android/sdk&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ANDROID_HOME</span>/platform-tools:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>使其生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>至此，驱动环境就搭建好了！</p><h2 id="安装-Appium"><a href="#安装-Appium" class="headerlink" title="安装 Appium"></a>安装 Appium</h2><p>安装 Appium 有两种方式，NPM 和 桌面程序安装包，我们这次先选择前者：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g appium</span><br></pre></td></tr></table></figure><h2 id="编写简单测试脚本"><a href="#编写简单测试脚本" class="headerlink" title="编写简单测试脚本"></a>编写简单测试脚本</h2><h3 id="查看设备名称"><a href="#查看设备名称" class="headerlink" title="查看设备名称"></a>查看设备名称</h3><p>打开手机开发者模式插到 Mac 上，输入此命令查看设备名称：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><h3 id="下载被测试的-App"><a href="#下载被测试的-App" class="headerlink" title="下载被测试的 App"></a>下载被测试的 App</h3><p><a href="https://github.com/appium/appium/raw/master/sample-code/apps/ApiDemos-debug.apk">ApiDemos-debug.apk</a></p><h3 id="新建测试项目"><a href="#新建测试项目" class="headerlink" title="新建测试项目"></a>新建测试项目</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> appium-test</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> appium-test</span><br><span class="line"></span><br><span class="line">npm i webdriverio</span><br></pre></td></tr></table></figure><p>添加 test.js 文件，并填写以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wdio = <span class="built_in">require</span>(<span class="string">&quot;webdriverio&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> opts = &#123;</span><br><span class="line">  <span class="attr">port</span>: <span class="number">4723</span>,</span><br><span class="line">  <span class="attr">desiredCapabilities</span>: &#123;</span><br><span class="line">    <span class="attr">platformName</span>: <span class="string">&quot;Android&quot;</span>,</span><br><span class="line">    <span class="attr">deviceName</span>: <span class="string">&quot;填写 adb devices 中的名称&quot;</span>,</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&quot;填写 ApiDemos-debug.apk 的本地路径&quot;</span>,</span><br><span class="line">    <span class="attr">automationName</span>: <span class="string">&quot;UiAutomator2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = wdio.<span class="title function_">remote</span>(opts);</span><br><span class="line"></span><br><span class="line">client</span><br><span class="line">  .<span class="title function_">init</span>()</span><br><span class="line">  .<span class="title function_">click</span>(<span class="string">&quot;~App&quot;</span>)</span><br><span class="line">  .<span class="title function_">back</span>()</span><br><span class="line">  .<span class="title function_">end</span>();</span><br></pre></td></tr></table></figure><p>在一个命令行中启动 appium：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appium</span><br></pre></td></tr></table></figure><p>在另一个命令行中执行测试脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node test.js</span><br></pre></td></tr></table></figure><p>然后就会发现手机被安装了 ApiDemos.apk ，并模拟点击了脚本中的命令。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天我们要讲的如何搭建一个 Appium 自动化测试环境，可以对 Android 系统的 App 进行自动化测试。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文仅讲解在 Mac 上的环境配置方法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="测试" scheme="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="自动化测试" scheme="http://www.liuyiqi.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Appium" scheme="http://www.liuyiqi.cn/tags/Appium/"/>
    
    <category term="Android" scheme="http://www.liuyiqi.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>利用机器学习进行整张设计稿多组件识别的探索</title>
    <link href="http://www.liuyiqi.cn/2018/07/25/ml-component-recognition/"/>
    <id>http://www.liuyiqi.cn/2018/07/25/ml-component-recognition/</id>
    <published>2018-07-25T07:00:00.000Z</published>
    <updated>2022-09-07T03:52:16.611Z</updated>
    
    <content type="html"><![CDATA[<p>前不久，在集团内部做了一个 CR 系统，可以从设计稿上截图识别某个组件并给出代码。</p><p><img src="/css/images/1662520255066-4.gif"></p><p>但是，我不想只是识别单个组件，最好能识别整张设计稿的多个组件。于是，花了两三天进行了这项技术的探索调研，并将过程记录下来。</p><span id="more"></span><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="二值化处理"><a href="#二值化处理" class="headerlink" title="二值化处理"></a>二值化处理</h3><p>识别多个组件的本质是定位，我首先想到的是像车牌定位，或者跳一跳外挂那样的利用颜色，进行二值化等处理进行识别，但设计稿中的组件并没有非常明显的边界，这种方法显然是不可行的。</p><p><img src="/css/images/1662520255066-5.png" alt="image.png"></p><p><img src="/css/images/1662520255067-6.png" alt="image.png"></p><h3 id="TensorFlow-Object-Detection-API"><a href="#TensorFlow-Object-Detection-API" class="headerlink" title="TensorFlow Object Detection API"></a>TensorFlow Object Detection API</h3><p>后来发现了谷歌开放的 TensorFlow Object Detection API，顿时看到了希望。TensorFlow Object Detection API 可以创建一个精确的机器学习模型，该模型能够在单张图片中对多个物体进行定位、分类。看了几张效果图，认为应该有戏：</p><p><img src="/css/images/1662520255067-7.png" alt="image.png"></p><p><img src="/css/images/1662520255067-8.png" alt="image.png"></p><h2 id="机器选择"><a href="#机器选择" class="headerlink" title="机器选择"></a>机器选择</h2><p>TensorFlow 可以在各个系统上跑，甚至可以在浏览器里运行和 retrain。但是如果要有更好的速度，最好选择可以用 GPU 的系统，由于 OSX 系统的在显卡方面的封闭性，TensorFlow 不支持在 OSX 上跑 GPU 版本，所以剩下的选择是：</p><ul><li>WIndows 或者 Linux 系统的电脑</li><li>谷歌云</li><li>集团的 PAI 平台</li><li>其他云平台</li></ul><p>由于云平台对我来说会增加一些熟悉成本，而我目前又只是急于知道多组件识别的可行性，所以就借了部门实习生的台式机来训练，正好这位实习生不习惯用 Windows 系统，自己带了 Macbook，所以就很爽快地借给我了。不过，不得不说集团给实习同学配置的电脑配置确实很基础，8g内存，Nvidia GeForce GT 730 的显卡，再差一点就跑不动 GPU 版本的 Tensorflow 了。</p><h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><p>TensorFlow Object Detection API 提供了一些<a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/detection_model_zoo.md">现成的模型</a>来让你直接用或者重新训练，它们的区别在速度和精确度上。因为我的台式机配置较低，所以选择了速度较快，精度较低的模型（ssd_mobilenet_v1_coco）来重新训练。</p><h2 id="训练图片选择"><a href="#训练图片选择" class="headerlink" title="训练图片选择"></a>训练图片选择</h2><p>我们要进行的是整张设计稿的识别，所以最初我用的训练图片是整张设计稿，但训练下来，发现根本识别不出来什么。</p><p><img src="/css/images/1662520255068-9.png" alt="image.png"></p><p>思考了一下，发现是因为：</p><ul><li>图片尺寸太大</li><li>而上步选择的模型只支持小尺寸的图片（毕竟那个模型是给移动端用的）</li></ul><p>于是我打算缩小图片尺寸，换成了表单项的识别，即在一个表单上识别出输入框、下拉框、文本框等。将尺寸缩小后，我在那台低配的台式机上训练了半个小时（没跑完），最终识别效果图如下：</p><p><img src="/css/images/1662520255068-10.png" alt="image.png"></p><p>至少证明是可行的了。但是还有一些表单项没有识别出来，所以我继续缩小训练图片的尺寸，将七个表单项的识别换成三个，训练了一个小时（也是没跑完），测试了一下，可以全部识别出来了：</p><p><img src="/css/images/1662520255068-11.png" alt="image.png"></p><h2 id="最终结论"><a href="#最终结论" class="headerlink" title="最终结论"></a>最终结论</h2><p>首先，整张设计稿的多组件识别是可行的，但是需要几个前提条件：</p><ul><li><p>有充足的 GPU 资源：如果你像我一样只有一台低配机器，那么精度高的模型，你跑都跑不动，显卡内存直接占满，程序崩溃。</p></li><li><p>有充足的设计稿素材：由于只是验证可行性，所以我只训练了十张图片，但是要达到很好的效果，至少得有一百张图片来训练，所以你得有足够多的设计稿素材。</p></li><li><p>有充足的人手和时间：训练 Object Detection 模型不像 Image Classification 那样简单，需要你手动标注位置，生成 xml 文件来给机器学习，这个工作非常无聊繁琐，所以如果要做，必须有足够多的人和时间。</p></li></ul><p>暂时就写这么多了，笔者研究较浅，请多多批评！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前不久，在集团内部做了一个 CR 系统，可以从设计稿上截图识别某个组件并给出代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/css/images/1662520255066-4.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是，我不想只是识别单个组件，最好能识别整张设计稿的多个组件。于是，花了两三天进行了这项技术的探索调研，并将过程记录下来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="机器学习" scheme="http://www.liuyiqi.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="TensorFlow" scheme="http://www.liuyiqi.cn/tags/TensorFlow/"/>
    
    <category term="Object Detection API" scheme="http://www.liuyiqi.cn/tags/Object-Detection-API/"/>
    
    <category term="二值化" scheme="http://www.liuyiqi.cn/tags/%E4%BA%8C%E5%80%BC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>使用 render-react-components 来单独渲染每个 React 组件</title>
    <link href="http://www.liuyiqi.cn/2018/04/13/render-react-components/"/>
    <id>http://www.liuyiqi.cn/2018/04/13/render-react-components/</id>
    <published>2018-04-13T09:56:00.000Z</published>
    <updated>2022-09-07T03:52:16.618Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是如何使用 render-react-components 来单独渲染每个 React 组件。</p><span id="more"></span><h2 id="为何要单独渲染每个-React-组件？"><a href="#为何要单独渲染每个-React-组件？" class="headerlink" title="为何要单独渲染每个 React 组件？"></a>为何要单独渲染每个 React 组件？</h2><p>我之前参与了一位阿里前端专家架构的项目，这个项目的技术栈是 Angular1 ，经过几天的开发，我发现这是我来阿里后参与的开发体验最好的几个前端项目之一了。为何这么说呢？主要原因是这个项目使用了 Angular1 的指令（Angular1 的指令就是 Angular2 的组件，也等同于 React 的组件）将页面组件化，并且为每个单独的指令创建了一个 demo 页面，可以单独渲染展示每个指令。相当于一个复杂的项目被分为很多小项目，每个小项目都可以独立调试，这样的开发体验太好了！不仅如此，这么做还有很多好处：</p><ul><li>每个组件的 demo 页面也可以成为该组件的文档，方便别的前端同学快速掌握每个组件是干嘛的，这比在混杂在项目中清晰多了。</li><li>每个组件按道理都应该写单元测试的，如果我们能单独渲染每个 React 组件，相当于给每个组件进行了一次“看得见摸得着”的单元测试。</li><li>如果你喜欢写端对端测试，那么你可以对每个组件的 demo 页面进行完全模拟用户的端对端测试。</li><li>假如你编写的组件的父组件还没写出来，放到过去，你完全没招，只能等待，但现在每个组件都是可以单独开发调试的，再也不用受制于人，受制于环境了。</li><li>假如的项目特别庞大，运行一次，需要编译很久，那么你还可以使用 demo 页面来提升你的开发效率。</li><li>假如你的组件有很多种环境，但在项目中，只能模拟有限的环境，那么你可以在 demo 页面里自由的模拟各种环境，进行各种逻辑的开发。</li><li>……</li></ul><p>既然有这么多好处，然后我就想，在 React 项目中能不能也将项目中的每个小组件，单独渲染出来呢？答案是可以的，不过稍微麻烦一点，因为 React 组件不像 Angular1 那样可以直接在浏览器里面运行，需要编译一下，所以我就开发了一个名为 render-react-components 的命令行工具，帮我做这件事。</p><h2 id="render-react-components-是什么？"><a href="#render-react-components-是什么？" class="headerlink" title="render-react-components 是什么？"></a>render-react-components 是什么？</h2><p>render-react-components（简称 rrc） 是一个命令行工具，可以递归找出当前项目中所有的 React 组件（仅限于 src 目录下的所有组件），并为它们创建相互隔离的 demo 页面。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>使用 rrc 非常简单，只需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 本地或者全局安装</span></span><br><span class="line">$ npm i render-react-components -g</span><br><span class="line"></span><br><span class="line"><span class="comment">## 为项目中所有的 React 组件，创建 demo 页面</span></span><br><span class="line">$ rrc init</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果你只想给部分组件创建 demo 页面，可以使用 filter 参数，输入组件路径的关键词即可</span></span><br><span class="line">$ rrc init --filter=Component1</span><br><span class="line"><span class="comment">## 或者简写</span></span><br><span class="line">$ rrc init -f=Component1</span><br><span class="line"></span><br><span class="line"><span class="comment">## 本地开发，支持代码热加载</span></span><br><span class="line">$ rrc dev</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除了 rrc init 创建的所有文件</span></span><br><span class="line">$ rrc clean</span><br></pre></td></tr></table></figure><p>以下动图，演示了如何使用这个工具，先后做了这几件事：</p><ul><li>运行 <code>find . -name *.js</code> （<code>find</code> 命令和本工具无关，只是为了对比展示文件的变化）列出原始项目中的 js。</li><li>运行 <code>rrc init</code>，为项目中所有的 React 组件创建 demo 页面。再次运行 <code>find . -name *.js</code> 发现多了一些文件，不过放心，这只是一些 js、html 文件，不会给你添加多余的依赖，非常干净、非常隔离。</li><li>运行 <code>rrc dev</code> ，自动弹出一个页面，我们发现每个组件都可以展示了。并且，修改代码，页面会自动更新，非常方便。</li></ul><p><img src="https://img.alicdn.com/tfs/TB1VPzQnHGYBuNjy0FoXXciBFXa-894-444.gif"></p><h2 id="修改组件的-demo-页面"><a href="#修改组件的-demo-页面" class="headerlink" title="修改组件的 demo 页面"></a>修改组件的 demo 页面</h2><p>每个 React 组件的 props 都不同，需要我们单独编写。如果你想修改某个组件的 props ，只需要去项目根目录的 rrc 文件夹中找到组件对应的 demo 页面的入口文件即可。那么组件的对应的入口文件如何寻找呢？非常简单明了：</p><ul><li>假如一个组件的路径是 src&#x2F;Component1.js，那么这个组件的入口文件的路径就是：rrc&#x2F;Component1.js。</li><li>假如一个组件的路径是 src&#x2F;Component2&#x2F;index.js，那么这个组件的入口文件的路径就是：rrc&#x2F;Component2.js。</li><li>假如一个组件的路径是 src&#x2F;Component2&#x2F;Component3&#x2F;index.js，那么这个组件的入口文件的路径就是：rrc&#x2F;Component2_Component3.js。</li></ul><h2 id="修改渲染组件的-webpack-配置"><a href="#修改渲染组件的-webpack-配置" class="headerlink" title="修改渲染组件的 webpack 配置"></a>修改渲染组件的 webpack 配置</h2><p>虽然在大多数情况下，你都不用操心 webpack 配置，但如果你实在想修改渲染组件的 webpack 配置，那么你可以直接在根目录下的 <code>.rrc.js</code> 中修改，具体配置可以在<a href="https://github.com/lewis617/render-react-components/blob/master/README_zh-cn.md#%E9%85%8D%E7%BD%AE">这里</a>参考。</p><h2 id="真实小例子"><a href="#真实小例子" class="headerlink" title="真实小例子"></a>真实小例子</h2><p>上面动图中真实小例子可以在<a href="https://github.com/lewis617/render-react-components/tree/master/examples/dead-simple">这里</a>找到。</p><p>本工具的 Github 地址： <a href="https://github.com/lewis617/render-react-components">https://github.com/lewis617/render-react-components</a>，欢迎 star、提 issue 和 pull request。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，我们要讲的是如何使用 render-react-components 来单独渲染每个 React 组件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="测试" scheme="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="单元测试" scheme="http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="React" scheme="http://www.liuyiqi.cn/tags/React/"/>
    
    <category term="render-react-components" scheme="http://www.liuyiqi.cn/tags/render-react-components/"/>
    
  </entry>
  
  <entry>
    <title>如何在端对端测试中模拟 HTTP 请求</title>
    <link href="http://www.liuyiqi.cn/2017/12/18/how-to-mock-http-in-e2e-testing/"/>
    <id>http://www.liuyiqi.cn/2017/12/18/how-to-mock-http-in-e2e-testing/</id>
    <published>2017-12-18T11:15:00.000Z</published>
    <updated>2022-09-07T03:52:16.608Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们要讲的是如何在端对端测试中模拟 HTTP 请求。这个技术在复杂系统中非常实用，让我们一睹为快。</p><blockquote><p>注意，本文是给有一定端对端测试经验的测试工程师或前端工程师看的，如果你对端对端测试一无所知，请先阅读我之前写的<a href="http://www.liuyiqi.cn/tags/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95/">关于端对端测试的文章</a>。</p></blockquote><span id="more"></span><h2 id="复杂系统中的端对端测试的问题"><a href="#复杂系统中的端对端测试的问题" class="headerlink" title="复杂系统中的端对端测试的问题"></a>复杂系统中的端对端测试的问题</h2><p>最近想在公司内部一个非常复杂的后台系统中添加端对端测试。这个系统拥有很多页面，每个页面都有很多功能，在这些功能中，不仅涉及许多数据库操作，还包含一些对用户来说不可控的外部数据来源。给这样的系统添加端对端测试，我的内心是崩溃的，因为如果完全模拟用户操作，我会面临很多问题：</p><ul><li>把数据库搞得一团糟：添加很多乱数据，不小心删除一些关键数据（试想这些数据万一是巨额钱款呢？！）</li><li>因为一些不可控的外部数据，我的测试脚本面对的场景可能每次都不一样，可我的脚本却只有一份，也许今天脚本能跑，明天脚本就出错了。</li><li>在真实场景下，一些边界情况的逻辑往往测试不到，比如空数据，错误数据的处理等。</li></ul><h2 id="是否应该简化或放弃端对端测试？"><a href="#是否应该简化或放弃端对端测试？" class="headerlink" title="是否应该简化或放弃端对端测试？"></a>是否应该简化或放弃端对端测试？</h2><p>面对这些问题，我当时冒出了放弃的想法，我咨询了一些同事，他们有的人让我评估可行性、必要性，有的人说让端对端测试测一些简单的跨页功能即可，把复杂逻辑留给人工或单元测试。他们说的都很 reasonable。但我认为端对端测试还是有必要的，一些国外的大公司的端对端测试真的是测试了软件中用户所可能用到的每个功能。这确实是可行，而且有意义的，我们不应该偷懒或者放弃。</p><h2 id="面向前端集成的端对端测试"><a href="#面向前端集成的端对端测试" class="headerlink" title="面向前端集成的端对端测试"></a>面向前端集成的端对端测试</h2><p>我第一次接触端对端测试是在 Angular 中，于是我看了很多 Angular 中端对端测试的例子，发现很多人面对和我一样问题时，所采取的办法是模拟 HTTP 请求。有人会说，这还算端对端测试吗？这已经不是在完全模拟真实的用户场景了！这种做法只有在后端没有任何 bug 的前提下才是有效的……这些说法都是对的，模拟 HTTP 请求确实是一种 trade off。但作为前端工程师，这样的做法至少能保证我负责的前端系统被测试到了，而且是集成测试，这就够了！后端完全可以另写针对后端的集成测试。当然，模拟 HTTP 请求是在那种迫不得已的情况下才做的，如果你的系统比较简单，比如这些类型：</p><ul><li>纯展示型的页面，只是“查找”数据，比较安全。</li><li>通过用户操作或在你控制范围内的操作下，可以让数据形成闭环，比如你操作完后，所有的数据恢复如初，就像在沙盒里跑一样</li></ul><p>那么就无需模拟 HTTP 了，毕竟我们还是希望能尽量还原真实场景。</p><h2 id="端对端测试中模拟-HTTP-请求的几种方法"><a href="#端对端测试中模拟-HTTP-请求的几种方法" class="headerlink" title="端对端测试中模拟 HTTP 请求的几种方法"></a>端对端测试中模拟 HTTP 请求的几种方法</h2><p>好了，回归正题。那么如何在端对端测试中模拟 HTTP 请求？有几种方法：</p><ul><li>使用代理工具，比如 Charles 代理一些请求，进行模拟。这种方法太麻烦了，不仅要在浏览器上设置代理，还要在 Charles 中配置一堆东西。不推荐！</li><li>如果使用 Puppeteer 的话，使用 <code>request.continue</code> 重写一些请求的 url，指向别的链接。你可以自己搭建一个测试服务器进行重写。简单好用，推荐！</li><li>如果使用 Puppeteer 的话，使用 <code>request.respond</code> 拦截请求，并直接返回响应结果。简单好用，推荐！</li></ul><p>以上三种方法都是可行的，但是后两种更简单。其中，第二种适合那种拥有测试服务器的场景，你只需要对请求链接进行重定向即可。比如原来是 <code>a.com</code>，你将其改为 <code>b.com</code>。但这种方法还是不能非常灵活的模拟每个 case，这时候，第三种方法就更加推荐，你想返回什么都可以直接在函数中写出来。让我们快看看代码实现吧！</p><h2 id="真实例子"><a href="#真实例子" class="headerlink" title="真实例子"></a>真实例子</h2><p>介绍了背景和方法，我们来看下真实的例子！例子代码在这里：</p><p><a href="https://github.com/lewis617/fe-test/tree/master/puppeteer-demo/mock-demo">https://github.com/lewis617/fe-test/tree/master/puppeteer-demo/mock-demo</a></p><p>先说下运行方法：将整个项目 clone 下来后在根目录（不是 mock-demo 这个目录哦）执行以下命令开启服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server -p 8081</span><br></pre></td></tr></table></figure><p>然后就可以在 <code>http://localhost:8081/puppeteer-demo/mock-demo</code>，看到程序了。</p><p><img src="/css/images/5.jpg"></p><p>这个程序的功能是这样的：</p><p>1，在一个简单的 HTML 页面中进行 <code>data1.json</code> 这个文件的请求，并将 JSON 文件中的 <code>name</code> 字段的值显示在 <code>h1</code> 标签中。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">fetch</span>(<span class="string">&#x27;http://localhost:8081/puppeteer-demo/mock-demo/data1.json&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span></span><br><span class="line"><span class="language-javascript">    .<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`&lt;h1&gt;<span class="subst">$&#123;json.name&#125;</span>&lt;/h1&gt;`</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2，我们要做的是，运行 puppeteer，打开页面，并进行请求劫持，将 data1.json 的数据换成 data2.json 的数据。</p><p>另开一个终端，执行这些命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br><span class="line"></span><br><span class="line">npm <span class="built_in">test</span> -- mock-demo</span><br></pre></td></tr></table></figure><p>然后就会发现 Puppeteer 中显示的数据是 <code>data2</code>。</p><p><img src="/css/images/6.jpg"></p><p>我们看下测试脚本是如何进行拦截重写的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">setRequestInterception</span>(<span class="literal">true</span>);</span><br><span class="line">page.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="params">request</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.<span class="property">url</span>.<span class="title function_">endsWith</span>(<span class="string">&#x27;data1.json&#x27;</span>)) &#123;</span><br><span class="line">    request.<span class="title function_">continue</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;http://localhost:8081/puppeteer-demo/mock-demo/data2.json&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    request.<span class="title function_">continue</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码，先设置可以进行请求拦截：<code>await page.setRequestInterception(true);</code>。然后在 <code>request</code> 事件中进行 url 改写。另外，还可以换成 <code>request.respond</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">setRequestInterception</span>(<span class="literal">true</span>);</span><br><span class="line">page.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="params">request</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.<span class="property">url</span>.<span class="title function_">endsWith</span>(<span class="string">&#x27;data1.json&#x27;</span>)) &#123;</span><br><span class="line">    request.<span class="title function_">respond</span>(&#123;</span><br><span class="line">      <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;data2&#x27;</span> &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    request.<span class="title function_">continue</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>就是这么简单。这太好用了！我们甚至可以在日常开发中也使用 Puppeteer 来模拟请求，不需要等待后端的工作。</p><h2 id="测试金字塔"><a href="#测试金字塔" class="headerlink" title="测试金字塔"></a>测试金字塔</h2><p>最后再聊一下端对端测试和单元测试的比例问题。谷歌的测试团队曾经提出过一个<a href="https://docs.google.com/presentation/d/15gNk21rjer3xo-b1ZqyQVGebOp_aPvHU3YH7YnOMxtE/edit#slide=id.g437663ce1_53_98">测试金字塔的概念</a>。大概就是单元测试应该最多，然后是集成测试（部分单元之间的集成，不像端对端那样完全黑盒），最少的应该是端对端测试：</p><p><img src="/css/images/7.jpg"></p><p>为何会这样呢？因为他们认为端对端测试不能像单元测试那样快速的定位问题所在，端对端测试所发现的问题，可能存在系统中的任何位置，但单元测试的反馈定位就更加直接准确。另外，单元测试写起来更加简单快速，而端对端测试则需要整个系统部署好之后才能测试，这样比较慢，毕竟有时候开发周期还是很长的，人家开发一周前写完的代码，你现在才开始测试，有点拖后腿。以上说法非常有道理，我也认为单元测试非常好，但是端对端测试也是有意义的，它可以检测出所有单元连接后的问题，这些问题只能通过端对端测试才能测出来。所以，两者都要写，不要怕麻烦，后期的收益是很大的！</p><h2 id="更多测试文章："><a href="#更多测试文章：" class="headerlink" title="更多测试文章："></a>更多测试文章：</h2><p><a href="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，我们要讲的是如何在端对端测试中模拟 HTTP 请求。这个技术在复杂系统中非常实用，让我们一睹为快。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，本文是给有一定端对端测试经验的测试工程师或前端工程师看的，如果你对端对端测试一无所知，请先阅读我之前写的&lt;a href=&quot;http://www.liuyiqi.cn/tags/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95/&quot;&gt;关于端对端测试的文章&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="测试" scheme="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Puppeteer" scheme="http://www.liuyiqi.cn/tags/Puppeteer/"/>
    
    <category term="端对端测试" scheme="http://www.liuyiqi.cn/tags/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95/"/>
    
    <category term="e2e" scheme="http://www.liuyiqi.cn/tags/e2e/"/>
    
  </entry>
  
  <entry>
    <title>端对端测试中常用的 Puppeteer 操作总结</title>
    <link href="http://www.liuyiqi.cn/2017/12/05/common-puppeteer-api-collection/"/>
    <id>http://www.liuyiqi.cn/2017/12/05/common-puppeteer-api-collection/</id>
    <published>2017-12-05T06:51:00.000Z</published>
    <updated>2022-09-07T03:52:16.605Z</updated>
    
    <content type="html"><![CDATA[<p>上篇博客我们讲解了<a href="http://www.liuyiqi.cn/2017/12/05/e2e-testing-with-jest-and-puppeteer/">《使用 Jest 与 Puppeteer 来进行端对端测试》</a>，但内容偏向于“快速开始”这种风格，并不涉及一些具体的、实用的操作，所以本篇博客将会补充这一点，即，总结一下端对端测试中常用的 Puppeteer 操作，比如模拟用户输入、执行 JavaScript 脚本、获取某个 DOM 节点中的文本等。</p><span id="more"></span><h2 id="让所有操作可见"><a href="#让所有操作可见" class="headerlink" title="让所有操作可见"></a>让所有操作可见</h2><p>还记得上篇博客中的端对端测试的动图演示吗？</p><p><img src="/css/images/3.gif"></p><p>想实现这个效果，就需要将 Puppeteer 的 <code>headless</code> 选项设为 <code>false</code>，并将 <code>slowMo</code> 设为 20-100 中的某个值，前者使得所有浏览器自动化操作可见，后者控制了动作之间的间隔，使其变慢，从而通过人眼可以看清每步操作。示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>(&#123;</span><br><span class="line">    <span class="attr">headless</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">slowMo</span>: <span class="number">20</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="导航到某个页面"><a href="#导航到某个页面" class="headerlink" title="导航到某个页面"></a>导航到某个页面</h2><p>这个操作太常用了！第一步是启动浏览器，那么第二步就是导航到某个页面，代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line"><span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://baidu.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上述代码会开启一个新页面，并将其导航到 <code>https://baidu.com</code>。</p><h2 id="等待某个-DOM-节点出现"><a href="#等待某个-DOM-节点出现" class="headerlink" title="等待某个 DOM 节点出现"></a>等待某个 DOM 节点出现</h2><p>在进行某些页面操作前，我们必须要等待指定的 DOM 加载完成后才能操作，比如，一个 Input 没有加载出来时，你是无法在里面输入字符的等等。在 Puppeteer 中，你可以使用 <code>page.waitForSelector</code> 和选择器来等待某个 DOM 节点出现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">waitForSelector</span>(<span class="string">&#x27;#loginForm&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上述代码会等待 ID 为 <code>loginForm</code> 的节点出现。</p><h2 id="等待几毫秒"><a href="#等待几毫秒" class="headerlink" title="等待几毫秒"></a>等待几毫秒</h2><p>有时候，你找不到某个特定的时刻，只能通过时间间隔来确定，那么此时你可以使用 <code>page.waitFor(number)</code> 来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">waitFor</span>(<span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>上述代码会等待 500 毫秒。</p><h2 id="等待某个-JavaScript-函数返回-true"><a href="#等待某个-JavaScript-函数返回-true" class="headerlink" title="等待某个 JavaScript 函数返回 true"></a>等待某个 JavaScript 函数返回 true</h2><p>有时候，你需要等待某个复杂的时刻，这个时刻只能通过一些复杂的 JavaScript 函数来判断，那么此时你可以使用 <code>page.waitFor(Function)</code> 来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">waitFor</span>(<span class="function">() =&gt;</span> !<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.ant-spin.ant-spin-spinning&#x27;</span>));</span><br></pre></td></tr></table></figure><p>上述代码会等待 Antd 中的旋转图标消失。</p><h2 id="向某个-Input-中输入字符"><a href="#向某个-Input-中输入字符" class="headerlink" title="向某个 Input 中输入字符"></a>向某个 Input 中输入字符</h2><p>为了模拟用户登陆或仅仅就是输入某个表单，我们经常会向某个 Input 中输入字符，那么我们可以使用这个方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">type</span>(<span class="string">&#x27;#username&#x27;</span>, <span class="string">&#x27;lewis&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上述代码向 ID 为 <code>username</code> 的 Input 中输入了 <code>lewis</code>。值得一提的是，该方法还会触发 Input 的 <code>keydown</code>、<code>keypress</code>, 和 <code>keyup</code> 事件，所以如果你有该事件的相关功能，也会被测试到哦，是不是很强大？</p><h2 id="点击某个节点"><a href="#点击某个节点" class="headerlink" title="点击某个节点"></a>点击某个节点</h2><p>在 Puppeteer 中模拟点击某个节点，非常简单，只需要：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">click</span>(<span class="string">&#x27;#btn-submit&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上述代码点击了 ID 为 <code>btn-submit</code> 的节点。</p><h2 id="在浏览器中执行一段-JavaScript-代码"><a href="#在浏览器中执行一段-JavaScript-代码" class="headerlink" title="在浏览器中执行一段 JavaScript 代码"></a>在浏览器中执行一段 JavaScript 代码</h2><p>有时候我们需要在浏览器中执行一段 JavaScript 代码，此时你可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.evaluate(<span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&#x27;1&#x27;</span>));</span><br></pre></td></tr></table></figure><p>上述代码会在浏览器执行 <code>alert(&#39;1&#39;)</code>。</p><h2 id="获取某一个节点的某个属性"><a href="#获取某一个节点的某个属性" class="headerlink" title="获取某一个节点的某个属性"></a>获取某一个节点的某个属性</h2><p>有时候我们需要获取某个 Input 的 <code>value</code>，某个链接的 <code>href</code>，某个节点的文本 <code>textContent</code>，或者 <code>outerHTML</code>，那么你可以使用这个方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> searchValue = <span class="keyword">await</span> page.$eval(<span class="string">&#x27;#search&#x27;</span>, <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="property">value</span>);</span><br><span class="line"><span class="keyword">const</span> preloadHref = <span class="keyword">await</span> page.$eval(<span class="string">&#x27;link[rel=preload]&#x27;</span>, <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="property">href</span>);</span><br><span class="line"><span class="keyword">const</span> text = <span class="keyword">await</span> page.$eval(<span class="string">&#x27;.text&#x27;</span>, <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="property">textContent</span>);</span><br><span class="line"><span class="keyword">const</span> html = <span class="keyword">await</span> page.$eval(<span class="string">&#x27;.main-container&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> e.<span class="property">outerHTML</span>);</span><br></pre></td></tr></table></figure><h2 id="获取某一类节点的某个属性集合"><a href="#获取某一类节点的某个属性集合" class="headerlink" title="获取某一类节点的某个属性集合"></a>获取某一类节点的某个属性集合</h2><p>有时候我们需要获取某一类节点的某个属性集合，那么你可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textArray = <span class="keyword">await</span> page.$$eval(<span class="string">&#x27;.text&#x27;</span>, <span class="function"><span class="params">els</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(els).<span class="title function_">map</span>(<span class="function"><span class="params">el</span> =&gt;</span> el.<span class="property">textContent</span>));</span><br></pre></td></tr></table></figure><p>上述代码将页面中所有类为 <code>text</code> 的节点中的文本拼装为数组放到了 <code>textArray</code> 中。</p><p>以上就是 Puppeteer 的一些常用操作，当然仅仅掌握这些是不够的，更多的操作请参考 Puppeteer 的 API 文档：</p><p><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md">https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md</a></p><h2 id="综合应用小例子"><a href="#综合应用小例子" class="headerlink" title="综合应用小例子"></a>综合应用小例子</h2><p>单个操作讲了这么多，我们来进行一次综合应用吧！我们依次让浏览器进行以下自动化操作：</p><ul><li>打开百度首页</li><li>输入<code>刘一奇的个人博客</code></li><li>点击搜索按钮</li><li>点击第一个搜索项</li><li>进入<code>刘一奇的个人博客</code></li><li>断言新页面的 <code>logo</code> 为<code>刘一奇的个人博客</code></li><li>断言新页面的导航栏包括：<code>主页,归档,关于我</code> 三项</li></ul><p>示例代码： </p><p><a href="https://github.com/lewis617/fe-test/blob/master/puppeteer-demo/liuyiqi-blog.test.js">https://github.com/lewis617/fe-test/blob/master/puppeteer-demo/liuyiqi-blog.test.js</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> browser, page;</span><br><span class="line"></span><br><span class="line"><span class="title function_">beforeAll</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>(&#123;</span><br><span class="line">    <span class="attr">headless</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">slowMo</span>: <span class="number">80</span></span><br><span class="line">  &#125;);</span><br><span class="line">  page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">afterAll</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  browser.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;open baidu page&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://baidu.com&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;search liuiqi\&#x27;s blog&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">waitForSelector</span>(<span class="string">&#x27;#kw&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">type</span>(<span class="string">&#x27;#kw&#x27;</span>, <span class="string">&#x27;刘一奇的个人博客&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">click</span>(<span class="string">&#x27;#su&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;goto liuyiqi\&#x27;s blog&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">waitForSelector</span>(<span class="string">&#x27;h3.t &gt; a&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">click</span>(<span class="string">&#x27;h3.t:nth-of-type(1) &gt; a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> pages = <span class="keyword">await</span> browser.<span class="title function_">pages</span>();</span><br><span class="line">  page = pages.<span class="title function_">pop</span>();</span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">bringToFront</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;expect logo is 刘一奇的个人博客&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">waitForSelector</span>(<span class="string">&#x27;#logo&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> text = <span class="keyword">await</span> page.$eval(<span class="string">&#x27;#logo&#x27;</span>, <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="property">textContent</span>)</span><br><span class="line">  <span class="title function_">expect</span>(text).<span class="title function_">toBe</span>(<span class="string">&#x27;刘一奇的个人博客&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;expect main-nav-link is 主页,归档,关于我&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> textArray = <span class="keyword">await</span> page.$$eval(<span class="string">&#x27;.main-nav-link&#x27;</span>, <span class="function"><span class="params">els</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(els).<span class="title function_">map</span>(<span class="function"><span class="params">el</span> =&gt;</span> el.<span class="property">textContent</span>));</span><br><span class="line">  <span class="title function_">expect</span>(textArray).<span class="title function_">toEqual</span>([<span class="string">&#x27;主页&#x27;</span>, <span class="string">&#x27;归档&#x27;</span>, <span class="string">&#x27;关于我&#x27;</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="/css/images/1.gif"></p><p>至此，端对端测试中常用的 Puppeteer 操作总结就讲完了。有更多操作请查阅官网文档，或给我发邮件，或在本文下方评论。</p><h2 id="更多测试文章："><a href="#更多测试文章：" class="headerlink" title="更多测试文章："></a>更多测试文章：</h2><p><a href="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上篇博客我们讲解了&lt;a href=&quot;http://www.liuyiqi.cn/2017/12/05/e2e-testing-with-jest-and-puppeteer/&quot;&gt;《使用 Jest 与 Puppeteer 来进行端对端测试》&lt;/a&gt;，但内容偏向于“快速开始”这种风格，并不涉及一些具体的、实用的操作，所以本篇博客将会补充这一点，即，总结一下端对端测试中常用的 Puppeteer 操作，比如模拟用户输入、执行 JavaScript 脚本、获取某个 DOM 节点中的文本等。&lt;/p&gt;</summary>
    
    
    
    
    <category term="测试" scheme="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Puppeteer" scheme="http://www.liuyiqi.cn/tags/Puppeteer/"/>
    
    <category term="端对端测试" scheme="http://www.liuyiqi.cn/tags/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95/"/>
    
    <category term="e2e" scheme="http://www.liuyiqi.cn/tags/e2e/"/>
    
  </entry>
  
  <entry>
    <title>使用 Jest 与 Puppeteer 来进行端对端测试</title>
    <link href="http://www.liuyiqi.cn/2017/12/05/e2e-testing-with-jest-and-puppeteer/"/>
    <id>http://www.liuyiqi.cn/2017/12/05/e2e-testing-with-jest-and-puppeteer/</id>
    <published>2017-12-05T02:07:00.000Z</published>
    <updated>2022-09-07T03:52:16.607Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们要讲的是如何使用 Jest 与 Puppeteer 来进行端对端测试（e2e testing）。</p><span id="more"></span><h2 id="端对端测试-vs-单元测试"><a href="#端对端测试-vs-单元测试" class="headerlink" title="端对端测试 vs. 单元测试"></a>端对端测试 vs. 单元测试</h2><p>在前面<a href="http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">很多文章</a>中，我们都介绍了单元测试。如果你了解单元测试，或者读过我之前写的单元测试的文章，那么你一定知道，单元测试的测试对象是单独的、隔离的小代码片段或者代码单元。与单元测试不同，端对端测试的测试对象则是页面上的用户交互，我们对底层实现一无所知，也就是说我们的测试是黑盒的。另外，一些跨页测试，比如链接检查，登陆跳转等功能必须使用端对端测试才能检查出来，单元测试是无法测这些功能的。以前我只写单元测试，不写端对端测试，结果有一次所负责的页面上有个链接不能点了，还好及时修复，但还是让我感受到了端对端测试，或者说是自动化端对端测试的重要性。这是我在物流服务中做的端对端测试演示：</p><p><img src="/css/images/3.gif"></p><p>话不多说，让我们开始学习端对端测试吧！</p><blockquote><p>Puppeteer 默认情况下，所有操作是不可见的，如果你想像我这样监视发生的一切，需要将 Puppeteer 的 <code>headless</code> 选项设为 <code>false</code>，具体操作将会在<a href="http://www.liuyiqi.cn/2017/12/05/common-puppeteer-api-collection/">下篇博文</a>中介绍。</p></blockquote><h2 id="使用-Puppeteer-进行浏览器自动化"><a href="#使用-Puppeteer-进行浏览器自动化" class="headerlink" title="使用 Puppeteer 进行浏览器自动化"></a>使用 Puppeteer 进行浏览器自动化</h2><p>我使用过很多端对端测试的轮子，比如 Selenium、Appium、Protractor、Zombie.js、Cypress、Nightmare、Puppeteer 等。但最终还是选择了 Puppeteer，因为 Selenium 和 Appium 太难用了，Protractor 则像是专门给 Angular 设计的，Zombie.js 太简单了，而且使用的浏览器内核不是市面上流行的任何一个，而是自定义的。Cypress 有平台依赖，我只是想要个本地运行的工具而已。只剩 Nightmare 和 Puppeteer 了，其实这两个都是好选择，但是我是个 star 控，Puppeteer 的 star 比 Nightmare 多，所以我选择了 Puppeteer。但事实上 Nightmare 更流行，因为我发现蚂蚁最新的那个 Antd Pro 就是用的 Nightmare，阿里一些其他端对端测试的工具也有基于 Nightmare 来做的。所以如果你想使用 Nightmare 来进行自动化端对端测试也是完全没有问题的。</p><p>使用 Puppeteer 非常简单，首先安装它：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add puppeteer</span><br><span class="line"><span class="comment"># or &quot;npm i puppeteer&quot;</span></span><br></pre></td></tr></table></figure><p>然后就可以在 Node 脚本中使用它了！来个简单的导航并截屏例子吧！这个例子先启动浏览器，导航到 <code>https://baidu.com</code> 页面，然后截屏并保存为 <code>baidu.png</code>，最后关闭浏览器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://baidu.com&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">screenshot</span>(&#123;<span class="attr">path</span>: <span class="string">&#x27;baidu.png&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> browser.<span class="title function_">close</span>();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>将上述代码写进 Node 脚本中，并运行就可以了！看下生成的截图：</p><p><img src="/css/images/4.jpg" alt="image"></p><p>是不是很简单？短短几行代码就做了这么多事。如果你对 <code>async</code>、<code>await</code> 这种语法不熟悉，那么我强烈建议你去学习一下，这种语法在 Puppeteer 中使用率简直不要太高。不过也不要担心学习成本， <code>async</code>、<code>await</code> 语法非常简单，就是 Promise 的一种新写法而已，让你的异步代码看起来就像是同步的一样。</p><h2 id="使用-Jest-来进行测试"><a href="#使用-Jest-来进行测试" class="headerlink" title="使用 Jest 来进行测试"></a>使用 Jest 来进行测试</h2><p>要知道，Puppeteer 是一个浏览器自动化工具，它只能进行浏览器的自动化，本身并不具有测试功能。我说的测试功能指的是，断言啊，生成测试报告啊这些功能。如果你不熟悉这些概念，那么请移步：<a href="http://www.liuyiqi.cn/2017/02/15/start-jest/">《Jest 单元测试入门》</a>。所以，除了 Puppeteer 外，我们还需要使用一个测试工具，我选择了 Jest，理由在<a href="http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">之前的博文中</a>已经说过很多遍了，这里不再赘述。使用 Jest 非常简单，只需要</p><ul><li>安装 Jest</li><li>编写测试脚本 *.test.js</li><li>最后在终端中输入 jest 命令运行测试</li></ul><p>具体用法看之前的博文：<a href="http://www.liuyiqi.cn/2017/02/15/start-jest/">《Jest 单元测试入门》</a>。</p><h2 id="将-Jest-与-Puppeteer-结合使用"><a href="#将-Jest-与-Puppeteer-结合使用" class="headerlink" title="将 Jest 与 Puppeteer 结合使用"></a>将 Jest 与 Puppeteer 结合使用</h2><p>讲完了 Puppeteer 和 Jest 的基本用法，我们来看一下，如何将两者结合起来使用。其实将 Jest 与 Puppeteer 结合使用非常简单，因为 Puppeteer 的本质就是个 NPM 模块而已，所以我们只需要在 Jest 测试脚本中引入它即可使用了。为何如此呢？因为测试脚本的本质其实也是 Node 脚本，既然是 Node 脚本那么当然可以直接引入 NPM 模块来用了！</p><blockquote><p>需要注意的是，因为 Puppeteer 通常需要使用 <code>async</code>、<code>await</code> 这种语法，如果你的 Node 版本在7.6及以上，那么恭喜你，直接大胆使用，否则需要在 Jest 中配置 Babel，来使其支持这种新语法。在 Jest 中配置 Babel 非常简单，你可以在<a href="http://facebook.github.io/jest/docs/en/getting-started#using-babel">这里</a>找到具体方法。</p></blockquote><p>让我们来个小例子吧！首先，我们打开百度页面，并断言百度页面的 <code>title</code> 是 <code>百度一下，你就知道</code>。那么测试脚本应该这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;baidu title is correct&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&#x27;https://baidu.com&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> title = <span class="keyword">await</span> page.<span class="title function_">title</span>();</span><br><span class="line">  <span class="title function_">expect</span>(title).<span class="title function_">toBe</span>(<span class="string">&#x27;百度一下，你就知道&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> browser.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看到 <code>test</code> 和 <code>expect</code> 两个全局函数了吗？这就是 Jest 所赋予的能力，让你可以编写测试用例和断言。最后在命令行输入 <code>npm test</code>，即 <code>jest</code>（这是在 package.json 中配置好的命令），即可看到生成的测试报告：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">&gt; fe-test@1.0.0 <span class="built_in">test</span> /Users/liuyiqi/code/fe-test</span><br><span class="line">&gt; jest</span><br><span class="line"></span><br><span class="line"> PASS  puppeteer-demo/baidu-title.test.js</span><br><span class="line"> PASS  puppeteer-demo/screenshot.test.js</span><br><span class="line"></span><br><span class="line">Test Suites: 2 passed, 2 total</span><br><span class="line">Tests:       2 passed, 2 total</span><br><span class="line">Snapshots:   0 total</span><br><span class="line">Time:        3.241s</span><br><span class="line">Ran all <span class="built_in">test</span> suites.</span><br></pre></td></tr></table></figure><p>其中 <code>screenshot.test.js</code> 是截屏的那个例子，<code>baidu-title.test.js</code> 是断言百度首页 title 的例子。你可以在这里找到源码：</p><p><a href="https://github.com/lewis617/fe-test/tree/master/puppeteer-demo">https://github.com/lewis617/fe-test/tree/master/puppeteer-demo</a></p><p>至此，使用 Jest 与 Puppeteer 来进行端对端测试的基本用法就讲完了。下篇博文我们将会集中讲解常用 Puppeteer 功能，比如模拟用户输入、执行 JavaScript 脚本、获取某个 DOM 节点中的文本等。</p><h2 id="更多测试文章："><a href="#更多测试文章：" class="headerlink" title="更多测试文章："></a>更多测试文章：</h2><p><a href="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/">http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天我们要讲的是如何使用 Jest 与 Puppeteer 来进行端对端测试（e2e testing）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="测试" scheme="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Puppeteer" scheme="http://www.liuyiqi.cn/tags/Puppeteer/"/>
    
    <category term="端对端测试" scheme="http://www.liuyiqi.cn/tags/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95/"/>
    
    <category term="e2e" scheme="http://www.liuyiqi.cn/tags/e2e/"/>
    
    <category term="Jest" scheme="http://www.liuyiqi.cn/tags/Jest/"/>
    
    <category term="黑盒测试" scheme="http://www.liuyiqi.cn/tags/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何测试 DOM 操作类的 JS 代码</title>
    <link href="http://www.liuyiqi.cn/2017/11/09/how-to-test-dom-manipulation/"/>
    <id>http://www.liuyiqi.cn/2017/11/09/how-to-test-dom-manipulation/</id>
    <published>2017-11-09T03:05:00.000Z</published>
    <updated>2022-09-07T03:52:16.608Z</updated>
    
    <content type="html"><![CDATA[<p>前几天写了一篇博客：<a href="http://www.liuyiqi.cn/2017/11/03/use-js-to-get-weibo-comments/">《使用 JavaScript 批量获取微博评论》</a>。今天我们来学习如何测试我们之前编写的代码。从本质上来说，我们今天要学习的是如何测试 DOM 操作类的 JS 代码。你可以在这里获取测试代码：</p><p><a href="https://github.com/lewis617/practical-js/blob/master/src/weiboBackup.test.js">https://github.com/lewis617/practical-js/blob/master/src/weiboBackup.test.js</a></p><span id="more"></span><h2 id="选择测试框架"><a href="#选择测试框架" class="headerlink" title="选择测试框架"></a>选择测试框架</h2><p>我使用过很多测试框架，比如 Karma、Mocha、Jest 等，但因为对 Facebook 开源项目的偏爱，我选择了 Jest 来测试，事实证明，Jest 确实最为简单，无需进行繁琐的浏览器环境模拟，就可以直接使用浏览器环境的各种 API，让我们一睹为快！不过先安装 Jest：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev jest</span><br></pre></td></tr></table></figure><h2 id="处理被测试文件"><a href="#处理被测试文件" class="headerlink" title="处理被测试文件"></a>处理被测试文件</h2><p>被测试文件原来是这样的：</p><p>weiboBackup.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取微博以及评论文字</span></span><br><span class="line"><span class="comment"> * 先打开微博页面，</span></span><br><span class="line"><span class="comment"> * 然后将下面的js拷贝到浏览器的console面板中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nodeArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.list_con .WB_text&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textArray = nodeArray.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(node.<span class="property">childNodes</span>).<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">childNode</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="comment">// 文字的情况</span></span><br><span class="line">    <span class="keyword">if</span> (childNode.<span class="property">nodeName</span> === <span class="string">&#x27;#text&#x27;</span>) value = childNode.<span class="property">nodeValue</span>;</span><br><span class="line">    <span class="comment">// 图片表情的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (childNode.<span class="property">nodeName</span> === <span class="string">&#x27;IMG&#x27;</span>) value = childNode.<span class="property">alt</span>;</span><br><span class="line">    <span class="comment">// 链接的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (childNode.<span class="property">nodeName</span> === <span class="string">&#x27;A&#x27;</span>) value = childNode.<span class="property">lastChild</span>.<span class="property">nodeValue</span>;</span><br><span class="line">    <span class="keyword">return</span> value.<span class="title function_">replace</span>(<span class="regexp">/(\s+$)|(^\s+)/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(textArray.<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br></pre></td></tr></table></figure><p>为了方便测试，我们在底部添加一行代码，将其导出，方便测试。另外，为了让测试报告更纯净，我们把 console 注释掉：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(textArray.join(&#x27;\n&#x27;));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本行代码用于单元测试，请不要拷贝到浏览器的console中运行</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = textArray;</span><br></pre></td></tr></table></figure><h2 id="编写测试文件"><a href="#编写测试文件" class="headerlink" title="编写测试文件"></a>编写测试文件</h2><p>前面说了 Jest 自带浏览器模拟环境，无需手动配置。所以我们直接添加用于测试的 html 即可：</p><blockquote><p>这段 html 字符串相当于模拟数据，即假数据。在这里，相当于模拟一个微博评论。模拟数据你可以随意编写，但是通常需要和真实数据保持结构和规律上的一致，而且需要覆盖所有的情况，这样才能测试到所有的边界。</p></blockquote><p>weiboBackup.test.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;\</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;list_con&quot;&gt;\</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;WB_text&quot;&gt;\</span></span><br><span class="line"><span class="string">      &lt;a target=&quot;_blank&quot; href=&quot;//weibo.com/2809324184&quot; usercard=&quot;id=2809324184&quot;&gt;Geo橙子&lt;/a&gt;：在过一阵子是不是要翻成英文，走出国门了\</span></span><br><span class="line"><span class="string">    &lt;/div&gt;\</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;WB_text&quot;&gt;\</span></span><br><span class="line"><span class="string">      &lt;a target=&quot;_blank&quot; href=&quot;//weibo.com/2497287343&quot; usercard=&quot;id=2497287343&quot;&gt;dev_zk&lt;/a&gt;\</span></span><br><span class="line"><span class="string">      &lt;a target=&quot;_blank&quot; suda-data=&quot;key=pc_apply_entry&amp;amp;value=feed_icon&quot; href=&quot;http://club.weibo.com/intro&quot;&gt;\</span></span><br><span class="line"><span class="string">        &lt;i title=&quot;微博达人&quot; class=&quot;W_icon icon_club&quot; node-type=&quot;daren&quot;&gt;&lt;/i&gt;\</span></span><br><span class="line"><span class="string">      &lt;/a&gt;\</span></span><br><span class="line"><span class="string">      ：现在好了\</span></span><br><span class="line"><span class="string">      &lt;img render=&quot;ext&quot; src=&quot;//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif&quot; title=&quot;[太开心]&quot; alt=&quot;[太开心]&quot; type=&quot;face&quot;&gt;\</span></span><br><span class="line"><span class="string">      &lt;img render=&quot;ext&quot; src=&quot;//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif&quot; title=&quot;[太开心]&quot; alt=&quot;[太开心]&quot; type=&quot;face&quot;&gt;\</span></span><br><span class="line"><span class="string">    &lt;/div&gt;\</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;WB_text&quot;&gt;\</span></span><br><span class="line"><span class="string">      &lt;a target=&quot;_blank&quot; href=&quot;//weibo.com/2497287343&quot; usercard=&quot;id=2497287343&quot;&gt;dev_zk&lt;/a&gt;\</span></span><br><span class="line"><span class="string">      &lt;a target=&quot;_blank&quot; suda-data=&quot;key=pc_apply_entry&amp;amp;value=feed_icon&quot; href=&quot;http://club.weibo.com/intro&quot;&gt;\</span></span><br><span class="line"><span class="string">      &lt;i title=&quot;微博达人&quot; class=&quot;W_icon icon_club&quot; node-type=&quot;daren&quot;&gt;&lt;/i&gt;\</span></span><br><span class="line"><span class="string">      &lt;/a&gt;\</span></span><br><span class="line"><span class="string">      ：哈哈\</span></span><br><span class="line"><span class="string">    &lt;/div&gt;\</span></span><br><span class="line"><span class="string">  &lt;/div&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后直接调用被测试文件 weiboBackup.js，相当于运行了它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textArray = <span class="built_in">require</span>(<span class="string">&#x27;./weiboBackup&#x27;</span>);</span><br></pre></td></tr></table></figure><p>现在评论文本已经被保存到数组 <code>textArray</code> 中了，然后我们直接编写断言即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">expect</span>(textArray).<span class="title function_">toEqual</span>([</span><br><span class="line">    <span class="string">&quot;Geo橙子：在过一阵子是不是要翻成英文，走出国门了&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dev_zk：现在好了[太开心][太开心]&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dev_zk：哈哈&quot;</span>,</span><br><span class="line">  ]);</span><br></pre></td></tr></table></figure><blockquote><p>关于断言等测试的基础知识，如果你不了解，请看我之前写的 <a href="http://www.liuyiqi.cn/2017/02/15/start-jest/">《Jest 单元测试入门》</a>。</p></blockquote><p>最后我们将上述代码包在 <code>test</code> 函数中，这个函数用于打包一个测试用例，并附带测试用例说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;getweiboBackup&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;\</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;list_con&quot;&gt;\</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;WB_text&quot;&gt;\</span></span><br><span class="line"><span class="string">      &lt;a target=&quot;_blank&quot; href=&quot;//weibo.com/2809324184&quot; usercard=&quot;id=2809324184&quot;&gt;Geo橙子&lt;/a&gt;：在过一阵子是不是要翻成英文，走出国门了\</span></span><br><span class="line"><span class="string">    &lt;/div&gt;\</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;WB_text&quot;&gt;\</span></span><br><span class="line"><span class="string">      &lt;a target=&quot;_blank&quot; href=&quot;//weibo.com/2497287343&quot; usercard=&quot;id=2497287343&quot;&gt;dev_zk&lt;/a&gt;\</span></span><br><span class="line"><span class="string">      &lt;a target=&quot;_blank&quot; suda-data=&quot;key=pc_apply_entry&amp;amp;value=feed_icon&quot; href=&quot;http://club.weibo.com/intro&quot;&gt;\</span></span><br><span class="line"><span class="string">        &lt;i title=&quot;微博达人&quot; class=&quot;W_icon icon_club&quot; node-type=&quot;daren&quot;&gt;&lt;/i&gt;\</span></span><br><span class="line"><span class="string">      &lt;/a&gt;\</span></span><br><span class="line"><span class="string">      ：现在好了\</span></span><br><span class="line"><span class="string">      &lt;img render=&quot;ext&quot; src=&quot;//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif&quot; title=&quot;[太开心]&quot; alt=&quot;[太开心]&quot; type=&quot;face&quot;&gt;\</span></span><br><span class="line"><span class="string">      &lt;img render=&quot;ext&quot; src=&quot;//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/58/mb_org.gif&quot; title=&quot;[太开心]&quot; alt=&quot;[太开心]&quot; type=&quot;face&quot;&gt;\</span></span><br><span class="line"><span class="string">    &lt;/div&gt;\</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;WB_text&quot;&gt;\</span></span><br><span class="line"><span class="string">      &lt;a target=&quot;_blank&quot; href=&quot;//weibo.com/2497287343&quot; usercard=&quot;id=2497287343&quot;&gt;dev_zk&lt;/a&gt;\</span></span><br><span class="line"><span class="string">      &lt;a target=&quot;_blank&quot; suda-data=&quot;key=pc_apply_entry&amp;amp;value=feed_icon&quot; href=&quot;http://club.weibo.com/intro&quot;&gt;\</span></span><br><span class="line"><span class="string">      &lt;i title=&quot;微博达人&quot; class=&quot;W_icon icon_club&quot; node-type=&quot;daren&quot;&gt;&lt;/i&gt;\</span></span><br><span class="line"><span class="string">      &lt;/a&gt;\</span></span><br><span class="line"><span class="string">      ：哈哈\</span></span><br><span class="line"><span class="string">    &lt;/div&gt;\</span></span><br><span class="line"><span class="string">  &lt;/div&gt;&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> textArray = <span class="built_in">require</span>(<span class="string">&#x27;./weiboBackup&#x27;</span>);</span><br><span class="line">  <span class="title function_">expect</span>(textArray).<span class="title function_">toEqual</span>([</span><br><span class="line">    <span class="string">&quot;Geo橙子：在过一阵子是不是要翻成英文，走出国门了&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dev_zk：现在好了[太开心][太开心]&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dev_zk：哈哈&quot;</span>,</span><br><span class="line">  ]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>测试文件写好了，我们需要运行它，首先在 package.json 中添加：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jest&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后在命令行中运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>最后就会看测试报告了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> PASS  ./weiboBackup.test.js</span><br><span class="line">  ✓ getweiboBackup (27ms)</span><br><span class="line"></span><br><span class="line">Test Suites: 1 passed, 1 total</span><br><span class="line">Tests:       1 passed, 1 total</span><br><span class="line">Snapshots:   0 total</span><br><span class="line">Time:        0.907s, estimated 1s</span><br></pre></td></tr></table></figure><p>尝试改变 html 中的测试文本，或断言中的预期文本，看看预期与结果不一致的情况。比如，将断言改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">expect</span>(textArray).<span class="title function_">toEqual</span>([]);</span><br></pre></td></tr></table></figure><p>结果测试报告变为这样：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> FAIL  ./weiboBackup.test.js</span><br><span class="line">  ✕ getweiboBackup (310ms)</span><br><span class="line"></span><br><span class="line">  ● getweiboBackup</span><br><span class="line"></span><br><span class="line">    expect(received).toEqual(expected)</span><br><span class="line"></span><br><span class="line">    Expected value to equal:</span><br><span class="line">      []</span><br><span class="line">    Received:</span><br><span class="line">      [<span class="string">&quot;Geo橙子：在过一阵子是不是要翻成英文，走出国门了&quot;</span>, <span class="string">&quot;dev_zk：现在好了[太开心][太开心]&quot;</span>, <span class="string">&quot;dev_zk：哈哈&quot;</span>]</span><br><span class="line"></span><br><span class="line">    Difference:</span><br><span class="line"></span><br><span class="line">    - Expected</span><br><span class="line">    + Received</span><br><span class="line"></span><br><span class="line">    - Array []</span><br><span class="line">    + Array [</span><br><span class="line">    +   <span class="string">&quot;Geo橙子：在过一阵子是不是要翻成英文，走出国门了&quot;</span>,</span><br><span class="line">    +   <span class="string">&quot;dev_zk：现在好了[太开心][太开心]&quot;</span>,</span><br><span class="line">    +   <span class="string">&quot;dev_zk：哈哈&quot;</span>,</span><br><span class="line">    + ]</span><br><span class="line"></span><br><span class="line">      at Object.&lt;anonymous&gt;.<span class="built_in">test</span> (weiboBackup.test.js:25:21)</span><br><span class="line">          at new Promise (&lt;anonymous&gt;)</span><br><span class="line">          at &lt;anonymous&gt;</span><br><span class="line">      at process._tickCallback (internal/process/next_tick.js:188:7)</span><br><span class="line"></span><br><span class="line">Test Suites: 1 failed, 1 total</span><br><span class="line">Tests:       1 failed, 1 total</span><br><span class="line">Snapshots:   0 total</span><br><span class="line">Time:        0.897s, estimated 1s</span><br><span class="line">Ran all <span class="built_in">test</span> suites.</span><br><span class="line">npm ERR! Test failed.  See above <span class="keyword">for</span> more details.</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>编写测试还是很重要的，可以保证你的代码质量，而你的代码质量关系到你的 KPI，所以我建议大家还是养成编写测试的好习惯。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前几天写了一篇博客：&lt;a href=&quot;http://www.liuyiqi.cn/2017/11/03/use-js-to-get-weibo-comments/&quot;&gt;《使用 JavaScript 批量获取微博评论》&lt;/a&gt;。今天我们来学习如何测试我们之前编写的代码。从本质上来说，我们今天要学习的是如何测试 DOM 操作类的 JS 代码。你可以在这里获取测试代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lewis617/practical-js/blob/master/src/weiboBackup.test.js&quot;&gt;https://github.com/lewis617/practical-js/blob/master/src/weiboBackup.test.js&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="测试" scheme="http://www.liuyiqi.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="DOM" scheme="http://www.liuyiqi.cn/tags/DOM/"/>
    
    <category term="单元测试" scheme="http://www.liuyiqi.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
